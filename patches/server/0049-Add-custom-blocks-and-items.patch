From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Mon, 27 Jun 2022 01:04:35 +0200
Subject: [PATCH] Add custom blocks and items


diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
index bd86dc2ad2f87969da4add06de2a629f69d4b5de..60bed5928b91ede650f140e61aaa9fca318c5c64 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockController.java
@@ -13,7 +13,7 @@ import net.minecraft.world.level.chunk.LevelChunk;
 
 public class ChunkPacketBlockController {
 
-    public static final ChunkPacketBlockController NO_OPERATION_INSTANCE = new ChunkPacketBlockController();
+    //public static final ChunkPacketBlockController NO_OPERATION_INSTANCE = new ChunkPacketBlockController(); // Suki - custom blocks and items
 
     protected ChunkPacketBlockController() {
 
@@ -27,7 +27,7 @@ public class ChunkPacketBlockController {
         return false;
     }
 
-    public ChunkPacketInfo<BlockState> getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
+    public ChunkPacketInfo<BlockState> getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, boolean doesPlayerHaveResourcePack) { // Suki - custom blocks and items
         return null;
     }
 
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
index dabd93c35bdbac6a8b668a82d5f3d4173a1baa4a..062b630e2b517042bf1560c9dc2298398eb09ea2 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketBlockControllerAntiXray.java
@@ -20,6 +20,8 @@ import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.EntityBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.*;
+import org.sucraft.suki.antixray.ChunkPacketBlockControllerModifier;
+import org.sucraft.suki.antixray.ChunkPacketBlockControllerModifierBase;
 import org.bukkit.Bukkit;
 
 import java.util.*;
@@ -27,11 +29,9 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadLocalRandom;
 import java.util.function.IntSupplier;
 
-public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockController {
+// Suki start - custom blocks and items
+public class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockControllerModifierBase { // Suki - custom blocks and items
 
-    private static final Palette<BlockState> GLOBAL_BLOCKSTATE_PALETTE = new GlobalPalette<>(Block.BLOCK_STATE_REGISTRY);
-    private static final LevelChunkSection EMPTY_SECTION = null;
-    private final Executor executor;
     private final EngineMode engineMode;
     private final int maxBlockHeight;
     private final int updateRadius;
@@ -53,7 +53,7 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
     private final int maxBlockHeightUpdatePosition;
 
     public ChunkPacketBlockControllerAntiXray(Level level, Executor executor) {
-        this.executor = executor;
+        super(level, executor);
         WorldConfiguration.Anticheat.AntiXray paperWorldConfig = level.paperConfig().anticheat.antiXray;
         engineMode = paperWorldConfig.engineMode;
         maxBlockHeight = paperWorldConfig.maxBlockHeight >> 4 << 4;
@@ -165,44 +165,24 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
         return !usePermission || !player.getBukkitEntity().hasPermission("paper.antixray.bypass");
     }
 
-    @Override
-    public ChunkPacketInfoAntiXray getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
-        // Return a new instance to collect data and objects in the right state while creating the chunk packet for thread safe access later
-        return new ChunkPacketInfoAntiXray(chunkPacket, chunk, this);
-    }
-
-    @Override
-    public void modifyBlocks(ClientboundLevelChunkWithLightPacket chunkPacket, ChunkPacketInfo<BlockState> chunkPacketInfo) {
-        if (!(chunkPacketInfo instanceof ChunkPacketInfoAntiXray)) {
-            chunkPacket.setReady(true);
-            return;
-        }
-
-        if (!Bukkit.isPrimaryThread()) {
-            // Plugins?
-            MinecraftServer.getServer().scheduleOnMain(() -> modifyBlocks(chunkPacket, chunkPacketInfo));
-            return;
-        }
-
-        LevelChunk chunk = chunkPacketInfo.getChunk();
-        int x = chunk.getPos().x;
-        int z = chunk.getPos().z;
-        Level level = chunk.getLevel();
-        ((ChunkPacketInfoAntiXray) chunkPacketInfo).setNearbyChunks(level.getChunkIfLoaded(x - 1, z), level.getChunkIfLoaded(x + 1, z), level.getChunkIfLoaded(x, z - 1), level.getChunkIfLoaded(x, z + 1));
-        executor.execute((Runnable) chunkPacketInfo);
-    }
-
     // Actually these fields should be variables inside the obfuscate method but in sync mode or with SingleThreadExecutor in async mode it's okay (even without ThreadLocal)
     // If an ExecutorService with multiple threads is used, ThreadLocal must be used here
     private final ThreadLocal<int[]> presetBlockStateBits = ThreadLocal.withInitial(() -> new int[getPresetBlockStatesFullLength()]);
-    private static final ThreadLocal<boolean[]> SOLID = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
-    private static final ThreadLocal<boolean[]> OBFUSCATE = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
+    protected static final ThreadLocal<boolean[]> SOLID = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
+    protected static final ThreadLocal<boolean[]> OBFUSCATE = ThreadLocal.withInitial(() -> new boolean[Block.BLOCK_STATE_REGISTRY.size()]);
     // These boolean arrays represent chunk layers, true means don't obfuscate, false means obfuscate
-    private static final ThreadLocal<boolean[][]> CURRENT = ThreadLocal.withInitial(() -> new boolean[16][16]);
-    private static final ThreadLocal<boolean[][]> NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
-    private static final ThreadLocal<boolean[][]> NEXT_NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> CURRENT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
+    protected static final ThreadLocal<boolean[][]> NEXT_NEXT = ThreadLocal.withInitial(() -> new boolean[16][16]);
 
-    public void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+    // Martijn start- custom blocks and items
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        this.obfuscateXray(chunkPacketInfoAntiXray);
+    }
+
+    public void obfuscateXray(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        // Suki end - custom blocks and items
         int[] presetBlockStateBits = this.presetBlockStateBits.get();
         boolean[] solid = SOLID.get();
         boolean[] obfuscate = OBFUSCATE.get();
@@ -346,8 +326,6 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
                 bitStorageWriter.flush();
             }
         }
-
-        chunkPacketInfoAntiXray.getChunkPacket().setReady(true);
     }
 
     private void obfuscateLayer(int y, BitStorageReader bitStorageReader, BitStorageWriter bitStorageWriter, boolean[] solid, boolean[] obfuscate, int[] presetBlockStateBits, boolean[][] current, boolean[][] next, boolean[][] nextNext, LevelChunkSection[] nearbyChunkSections, IntSupplier random) {
@@ -633,3 +611,4 @@ public final class ChunkPacketBlockControllerAntiXray extends ChunkPacketBlockCo
         }
     }
 }
+// Suki end - custom blocks and items
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java
index d98a3f5c54c67a673eb7dc456dd039cd78f9c34d..3bd0ffc0234c57d01b28e4f68dfdad711fd58c5d 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfo.java
@@ -13,6 +13,7 @@ public class ChunkPacketInfo<T> {
     private final int[] indexes;
     private final Object[][] presetValues;
     private byte[] buffer;
+    private final int[] paletteIndexes; // Suki - custom blocks and items
 
     public ChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk) {
         this.chunkPacket = chunkPacket;
@@ -22,6 +23,7 @@ public class ChunkPacketInfo<T> {
         palettes = new Object[sections];
         indexes = new int[sections];
         presetValues = new Object[sections][];
+        paletteIndexes = new int[sections]; // Suki - custom blocks and items
     }
 
     public ClientboundLevelChunkWithLightPacket getChunkPacket() {
@@ -74,6 +76,18 @@ public class ChunkPacketInfo<T> {
         this.presetValues[chunkSectionIndex] = presetValues;
     }
 
+    // Suki start - custom blocks and items
+
+    public int getPaletteIndex(int chunkSectionIndex) {
+        return paletteIndexes[chunkSectionIndex];
+    }
+
+    public void setPaletteIndex(int chunkSectionIndex, int paletteIndex) {
+        paletteIndexes[chunkSectionIndex] = paletteIndex;
+    }
+
+    // Suki end - custom blocks and items
+
     public boolean isWritten(int chunkSectionIndex) {
         return bits[chunkSectionIndex] != 0;
     }
diff --git a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
index 80a2dfb266ae1221680a7b24fee2f7e2a8330b7d..ff840c1f92e7562766c5fbea8baa30f24e9d4a16 100644
--- a/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
+++ b/src/main/java/com/destroystokyo/paper/antixray/ChunkPacketInfoAntiXray.java
@@ -3,15 +3,21 @@ package com.destroystokyo.paper.antixray;
 import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunk;
+import org.sucraft.suki.antixray.ChunkPacketBlockControllerAntiXrayCustom;
+import org.sucraft.suki.antixray.ChunkPacketBlockControllerModifier;
 
 public final class ChunkPacketInfoAntiXray extends ChunkPacketInfo<BlockState> implements Runnable {
 
-    private final ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray;
+    // Suki start - custom blocks and items
+    private final ChunkPacketBlockControllerModifier chunkPacketBlockControllerAntiXray;
+    public final boolean doesPlayerHaveResourcePack;
+    // Suki end - custom blocks and items
     private LevelChunk[] nearbyChunks;
 
-    public ChunkPacketInfoAntiXray(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, ChunkPacketBlockControllerAntiXray chunkPacketBlockControllerAntiXray) {
+    public ChunkPacketInfoAntiXray(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, ChunkPacketBlockControllerModifier chunkPacketBlockControllerAntiXray, boolean doesPlayerHaveResourcePack) { // Suki - custom blocks and items
         super(chunkPacket, chunk);
         this.chunkPacketBlockControllerAntiXray = chunkPacketBlockControllerAntiXray;
+        this.doesPlayerHaveResourcePack = doesPlayerHaveResourcePack;
     }
 
     public LevelChunk[] getNearbyChunks() {
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 6be8c28bfdeca098d0c785c2cf121b5a6c9a91be..58b6dbc841d2cafa8fc704e9acbfbdda1e62ddf6 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -925,7 +925,7 @@ public final class PlayerChunkLoader {
         protected final TreeSet<ChunkPriorityHolder> sendQueueForTracking = createSendQueue();
         protected final TreeSet<ChunkPriorityHolder> sendQueueForSeeing = createSendQueue();
 
-        protected LongOpenHashSet getSentChunks(final boolean concernsTracking) {
+        public LongOpenHashSet getSentChunks(final boolean concernsTracking) { // Suki - custom blocks and items
             return concernsTracking ? this.sentChunksForTracking : this.sentChunksForSeeing;
         }
         protected LongOpenHashSet getChunksToBeSent(final boolean concernsTracking) {
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 7c7ad9828d2bd1b17cdf5f69d2a3de465895ef18..84db940123aba6ea78bfe02e36a11eaef208af63 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -36,6 +36,18 @@ public class GlobalConfiguration extends ConfigurationPart {
     @Setting(Configuration.VERSION_FIELD)
     public int version = CURRENT_VERSION;
 
+    // Suki start - custom blocks and items
+
+    public CustomBlocksAndItems customBlocksAndItems;
+
+    public class CustomBlocksAndItems extends ConfigurationPart {
+
+        public int maxPingThatCountsAsLowForCustomBlocks = 300;
+
+    }
+
+    // Suki end - custom blocks and items
+
     // Suki start - custom strongholds
 
     public CustomStrongholds customStrongholds;
diff --git a/src/main/java/net/minecraft/commands/arguments/item/ItemParser.java b/src/main/java/net/minecraft/commands/arguments/item/ItemParser.java
index d36518504d6524e551abb2ee424b7133508934b2..18ea75c648773bc8f0efe3e37435cb96cf83a7b3 100644
--- a/src/main/java/net/minecraft/commands/arguments/item/ItemParser.java
+++ b/src/main/java/net/minecraft/commands/arguments/item/ItemParser.java
@@ -26,7 +26,7 @@ import net.minecraft.world.item.Item;
 
 public class ItemParser {
     private static final SimpleCommandExceptionType ERROR_NO_TAGS_ALLOWED = new SimpleCommandExceptionType(Component.translatable("argument.item.tag.disallowed"));
-    private static final DynamicCommandExceptionType ERROR_UNKNOWN_ITEM = new DynamicCommandExceptionType((id) -> {
+    public static final DynamicCommandExceptionType ERROR_UNKNOWN_ITEM = new DynamicCommandExceptionType((id) -> { // Suki - custom blocks and items
         return Component.translatable("argument.item.id.invalid", id);
     });
     private static final DynamicCommandExceptionType ERROR_UNKNOWN_TAG = new DynamicCommandExceptionType((tag) -> {
diff --git a/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java b/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
index 442b42e80ee9001f9610003c3eaeb7f75f782f73..92b561078eea25b0389509c7d72ba403f0a5e641 100644
--- a/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
+++ b/src/main/java/net/minecraft/commands/synchronization/ArgumentTypeInfos.java
@@ -60,6 +60,7 @@ import net.minecraft.commands.synchronization.brigadier.StringArgumentSerializer
 import net.minecraft.core.Registry;
 import net.minecraft.gametest.framework.TestClassNameArgument;
 import net.minecraft.gametest.framework.TestFunctionArgument;
+import org.sucraft.suki.command.CustomItemArgument;
 
 public class ArgumentTypeInfos {
     private static final Map<Class<?>, ArgumentTypeInfo<?, ?>> BY_CLASS = Maps.newHashMap();
diff --git a/src/main/java/net/minecraft/core/MappedRegistry.java b/src/main/java/net/minecraft/core/MappedRegistry.java
index 0b7bfb95fbe8d9dbf1079d01b7d517df9f106d6a..cdafe225722ada50fd84bb92b796e7da445119a8 100644
--- a/src/main/java/net/minecraft/core/MappedRegistry.java
+++ b/src/main/java/net/minecraft/core/MappedRegistry.java
@@ -33,12 +33,17 @@ import net.minecraft.server.MinecraftServer;
 import net.minecraft.tags.StructureTags;
 import net.minecraft.tags.TagKey;
 import net.minecraft.util.RandomSource;
+import net.minecraft.world.item.Item;
 import net.minecraft.world.level.biome.Biome;
 import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import org.sucraft.suki.biome.SuCraftBiomeTags;
 import org.sucraft.suki.biome.SuCraftBiomeTagsProvider;
+import org.sucraft.suki.block.SuCraftBlockTagsProvider;
+import org.sucraft.suki.block.SuCraftObservableBlockTagsSpreader;
 import org.sucraft.suki.data.SuCraftTagsProvider;
+import org.sucraft.suki.item.SuCraftItemTagsProvider;
 import org.sucraft.suki.structure.SuCraftBuiltinStructures;
 import org.sucraft.suki.structure.SuCraftStructureTagsProvider;
 import org.apache.commons.lang3.Validate;
@@ -396,6 +401,12 @@ public class MappedRegistry<T> extends WritableRegistry<T> {
             tagEntries = ((SuCraftTagsProvider<T>) new SuCraftStructureTagsProvider((Registry<Structure>) this)).run(tagEntries);
         } else if (this.key().equals(BIOME_REGISTRY)) {
             tagEntries = ((SuCraftTagsProvider<T>) new SuCraftBiomeTagsProvider((Registry<Biome>) this)).run(tagEntries);
+        } else if (this.key().equals(BLOCK_REGISTRY)) {
+            tagEntries = ((SuCraftTagsProvider<T>) new SuCraftBlockTagsProvider((Registry<Block>) this)).run(tagEntries);
+            var spreader = (SuCraftTagsProvider<T>) new SuCraftObservableBlockTagsSpreader((Registry<Block>) this);
+            tagEntries = spreader.run(tagEntries);
+        } else if (this.key().equals(ITEM_REGISTRY)) {
+            tagEntries = ((SuCraftTagsProvider<T>) new SuCraftItemTagsProvider((Registry<Item>) this)).run(tagEntries);
         }
         // Suki end - custom resource
         tagEntries.forEach((tag, entries) -> {
diff --git a/src/main/java/net/minecraft/core/Rotations.java b/src/main/java/net/minecraft/core/Rotations.java
index 152b1a2cb88c6456282b537611c18975d6da5f57..967652c9fe7f43f78deb49edd37dceca4ce928c7 100644
--- a/src/main/java/net/minecraft/core/Rotations.java
+++ b/src/main/java/net/minecraft/core/Rotations.java
@@ -3,12 +3,15 @@ package net.minecraft.core;
 import net.minecraft.nbt.FloatTag;
 import net.minecraft.nbt.ListTag;
 import net.minecraft.util.Mth;
+import org.jetbrains.annotations.NotNull;
 
 public class Rotations {
     protected final float x;
     protected final float y;
     protected final float z;
 
+    public static final @NotNull Rotations ZERO = new Rotations(0, 0, 0); // Suki - custom blocks and items
+
     public Rotations(float pitch, float yaw, float roll) {
         this.x = !Float.isInfinite(pitch) && !Float.isNaN(pitch) ? pitch % 360.0F : 0.0F;
         this.y = !Float.isInfinite(yaw) && !Float.isNaN(yaw) ? yaw % 360.0F : 0.0F;
diff --git a/src/main/java/net/minecraft/data/loot/BlockLoot.java b/src/main/java/net/minecraft/data/loot/BlockLoot.java
index b2ee7ebf6d960437da1387d4f051995629d15e56..8208c306ebb5a47cffffe75474316ff81bd686c1 100644
--- a/src/main/java/net/minecraft/data/loot/BlockLoot.java
+++ b/src/main/java/net/minecraft/data/loot/BlockLoot.java
@@ -97,7 +97,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
     private static final LootItemCondition.Builder HAS_SHEARS_OR_SILK_TOUCH = HAS_SHEARS.or(HAS_SILK_TOUCH);
     private static final LootItemCondition.Builder HAS_NO_SHEARS_OR_SILK_TOUCH = HAS_SHEARS_OR_SILK_TOUCH.invert();
     private static final Set<Item> EXPLOSION_RESISTANT = Stream.of(Blocks.DRAGON_EGG, Blocks.BEACON, Blocks.CONDUIT, Blocks.SKELETON_SKULL, Blocks.WITHER_SKELETON_SKULL, Blocks.PLAYER_HEAD, Blocks.ZOMBIE_HEAD, Blocks.CREEPER_HEAD, Blocks.DRAGON_HEAD, Blocks.SHULKER_BOX, Blocks.BLACK_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.LIGHT_GRAY_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.WHITE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX).map(ItemLike::asItem).collect(ImmutableSet.toImmutableSet());
-    private static final float[] NORMAL_LEAVES_SAPLING_CHANCES = new float[]{0.05F, 0.0625F, 0.083333336F, 0.1F};
+    public static final float[] NORMAL_LEAVES_SAPLING_CHANCES = new float[]{0.05F, 0.0625F, 0.083333336F, 0.1F}; // Suki - custom blocks and items
     private static final float[] JUNGLE_LEAVES_SAPLING_CHANGES = new float[]{0.025F, 0.027777778F, 0.03125F, 0.041666668F, 0.1F};
     private static final float[] NORMAL_LEAVES_STICK_CHANCES = new float[]{0.02F, 0.022222223F, 0.025F, 0.033333335F, 0.1F};
     private final Map<ResourceLocation, LootTable.Builder> map = Maps.newHashMap();
@@ -110,7 +110,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         return (T)(!EXPLOSION_RESISTANT.contains(drop.asItem()) ? builder.when(ExplosionCondition.survivesExplosion()) : builder.unwrap());
     }
 
-    private static LootTable.Builder createSingleItemTable(ItemLike drop) {
+    public static LootTable.Builder createSingleItemTable(ItemLike drop) { // Suki - custom blocks and items
         return LootTable.lootTable().withPool(applyExplosionCondition(drop, LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).add(LootItem.lootTableItem(drop))));
     }
 
@@ -130,7 +130,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         return createSelfDropDispatchTable(drop, HAS_SHEARS_OR_SILK_TOUCH, child);
     }
 
-    private static LootTable.Builder createSingleItemTableWithSilkTouch(Block dropWithSilkTouch, ItemLike drop) {
+    public static LootTable.Builder createSingleItemTableWithSilkTouch(Block dropWithSilkTouch, ItemLike drop) { // Suki - custom blocks and items
         return createSilkTouchDispatchTable(dropWithSilkTouch, applyExplosionCondition(dropWithSilkTouch, LootItem.lootTableItem(drop)));
     }
 
@@ -138,11 +138,11 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         return LootTable.lootTable().withPool(LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).add(applyExplosionDecay(drop, LootItem.lootTableItem(drop).apply(SetItemCountFunction.setCount(count)))));
     }
 
-    private static LootTable.Builder createSingleItemTableWithSilkTouch(Block dropWithSilkTouch, ItemLike drop, NumberProvider count) {
+    public static LootTable.Builder createSingleItemTableWithSilkTouch(Block dropWithSilkTouch, ItemLike drop, NumberProvider count) { // Suki - custom blocks and items
         return createSilkTouchDispatchTable(dropWithSilkTouch, applyExplosionDecay(dropWithSilkTouch, LootItem.lootTableItem(drop).apply(SetItemCountFunction.setCount(count))));
     }
 
-    private static LootTable.Builder createSilkTouchOnlyTable(ItemLike drop) {
+    public static LootTable.Builder createSilkTouchOnlyTable(ItemLike drop) { // Suki - custom blocks and items
         return LootTable.lootTable().withPool(LootPool.lootPool().when(HAS_SILK_TOUCH).setRolls(ConstantValue.exactly(1.0F)).add(LootItem.lootTableItem(drop)));
     }
 
@@ -150,7 +150,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         return LootTable.lootTable().withPool(applyExplosionCondition(Blocks.FLOWER_POT, LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).add(LootItem.lootTableItem(Blocks.FLOWER_POT)))).withPool(applyExplosionCondition(plant, LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).add(LootItem.lootTableItem(plant))));
     }
 
-    private static LootTable.Builder createSlabItemTable(Block drop) {
+    public static LootTable.Builder createSlabItemTable(Block drop) { // Suki - custom blocks and items
         return LootTable.lootTable().withPool(LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).add(applyExplosionDecay(drop, LootItem.lootTableItem(drop).apply(SetItemCountFunction.setCount(ConstantValue.exactly(2.0F)).when(LootItemBlockStatePropertyCondition.hasBlockStateProperties(drop).setProperties(StatePropertiesPredicate.Builder.properties().hasProperty(SlabBlock.TYPE, SlabType.DOUBLE)))))));
     }
 
@@ -226,7 +226,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         }).apply(SetItemCountFunction.setCount(ConstantValue.exactly(-1.0F), true)))));
     }
 
-    private static LootTable.Builder createLeavesDrops(Block leaves, Block drop, float... chance) {
+    public static LootTable.Builder createLeavesDrops(Block leaves, Block drop, float... chance) { // Suki - custom blocks and items
         return createSilkTouchOrShearsDispatchTable(leaves, applyExplosionCondition(leaves, LootItem.lootTableItem(drop)).when(BonusLevelTableCondition.bonusLevelFlatChance(Enchantments.BLOCK_FORTUNE, chance))).withPool(LootPool.lootPool().setRolls(ConstantValue.exactly(1.0F)).when(HAS_NO_SHEARS_OR_SILK_TOUCH).add(applyExplosionDecay(leaves, LootItem.lootTableItem(Items.STICK).apply(SetItemCountFunction.setCount(UniformGenerator.between(1.0F, 2.0F)))).when(BonusLevelTableCondition.bonusLevelFlatChance(Enchantments.BLOCK_FORTUNE, NORMAL_LEAVES_STICK_CHANCES))));
     }
 
@@ -1313,6 +1313,7 @@ public class BlockLoot implements Consumer<BiConsumer<ResourceLocation, LootTabl
         this.add(Blocks.POWDER_SNOW, noDrop());
         this.add(Blocks.FROGSPAWN, noDrop());
         this.add(Blocks.REINFORCED_DEEPSLATE, noDrop());
+
         Set<ResourceLocation> set = Sets.newHashSet();
 
         for(Block block : Registry.BLOCK) {
diff --git a/src/main/java/net/minecraft/data/worldgen/biome/Biomes.java b/src/main/java/net/minecraft/data/worldgen/biome/Biomes.java
index aa8d3566a6979f2d61ebee409f98e2b9af0a6933..bc6088503ecd80aee22dd788a9a6f7a93fb9d396 100644
--- a/src/main/java/net/minecraft/data/worldgen/biome/Biomes.java
+++ b/src/main/java/net/minecraft/data/worldgen/biome/Biomes.java
@@ -4,6 +4,7 @@ import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.data.BuiltinRegistries;
 import net.minecraft.world.level.biome.Biome;
+import org.sucraft.suki.biome.SuCraftBiomes;
 
 public abstract class Biomes {
     public static Holder<Biome> bootstrap(Registry<Biome> registry) {
@@ -69,6 +70,9 @@ public abstract class Biomes {
         BuiltinRegistries.register(registry, net.minecraft.world.level.biome.Biomes.END_HIGHLANDS, EndBiomes.endHighlands());
         BuiltinRegistries.register(registry, net.minecraft.world.level.biome.Biomes.END_MIDLANDS, EndBiomes.endMidlands());
         BuiltinRegistries.register(registry, net.minecraft.world.level.biome.Biomes.SMALL_END_ISLANDS, EndBiomes.smallEndIslands());
-        return BuiltinRegistries.register(registry, net.minecraft.world.level.biome.Biomes.END_BARRENS, EndBiomes.endBarrens());
+        // Suki start - custom blocks and items
+        BuiltinRegistries.register(registry, net.minecraft.world.level.biome.Biomes.END_BARRENS, EndBiomes.endBarrens());
+        return SuCraftBiomes.bootstrap(registry);
+        // Suki end - custom blocks and items
     }
 }
diff --git a/src/main/java/net/minecraft/data/worldgen/biome/OverworldBiomes.java b/src/main/java/net/minecraft/data/worldgen/biome/OverworldBiomes.java
index e589653c227abfba7b1497b75045e88ef84c9331..e24ddf91520617343c147f90963a97185d43a96b 100644
--- a/src/main/java/net/minecraft/data/worldgen/biome/OverworldBiomes.java
+++ b/src/main/java/net/minecraft/data/worldgen/biome/OverworldBiomes.java
@@ -18,6 +18,7 @@ import net.minecraft.world.level.biome.BiomeGenerationSettings;
 import net.minecraft.world.level.biome.BiomeSpecialEffects;
 import net.minecraft.world.level.biome.MobSpawnSettings;
 import net.minecraft.world.level.levelgen.GenerationStep;
+import org.sucraft.suki.biome.features.SuCraftBiomeDefaultFeatures;
 
 public class OverworldBiomes {
     protected static final int NORMAL_WATER_COLOR = 4159204;
@@ -361,6 +362,12 @@ public class OverworldBiomes {
     }
 
     public static Biome forest(boolean birch, boolean oldGrowth, boolean flower) {
+        // Suki start - custom blocks and items
+        return forest(birch, oldGrowth, flower, false);
+    }
+
+    public static Biome forest(boolean birch, boolean oldGrowth, boolean flower, boolean orange) {
+        // Suki end - custom blocks and items
         BiomeGenerationSettings.Builder builder = new BiomeGenerationSettings.Builder();
         globalOverworldGeneration(builder);
         if (flower) {
@@ -382,6 +389,10 @@ public class OverworldBiomes {
                 } else {
                     BiomeDefaultFeatures.addBirchTrees(builder);
                 }
+                // Suki start - custom blocks and items
+            } else if (orange) {
+                SuCraftBiomeDefaultFeatures.addOrangeTintedOtherBirchTrees(builder);
+                // Suki end - custom blocks and items
             } else {
                 BiomeDefaultFeatures.addOtherBirchTrees(builder);
             }
@@ -401,9 +412,9 @@ public class OverworldBiomes {
             builder2.addSpawn(MobCategory.CREATURE, new MobSpawnSettings.SpawnerData(EntityType.WOLF, 5, 4, 4));
         }
 
-        float f = birch ? 0.6F : 0.7F;
+        float f = birch ? 0.6F : orange ? 0.8F : 0.7F; // Suki - custom blocks and items
         Music music = Musics.createGameMusic(SoundEvents.MUSIC_BIOME_JUNGLE_AND_FOREST);
-        return biome(Biome.Precipitation.RAIN, f, birch ? 0.6F : 0.8F, builder2, builder, music);
+        return biome(Biome.Precipitation.RAIN, f, birch ? 0.6F : orange ? 0.9F : 0.8F, builder2, builder, music); // Suki - custom blocks and items
     }
 
     public static Biome taiga(boolean cold) {
diff --git a/src/main/java/net/minecraft/nbt/NbtUtils.java b/src/main/java/net/minecraft/nbt/NbtUtils.java
index 46681f3fa63516aa750de11cf1dee17cb3734fcd..6788cf46df539dfe9973088c9376619d27f05750 100644
--- a/src/main/java/net/minecraft/nbt/NbtUtils.java
+++ b/src/main/java/net/minecraft/nbt/NbtUtils.java
@@ -37,6 +37,7 @@ import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.StateHolder;
 import net.minecraft.world.level.block.state.properties.Property;
 import net.minecraft.world.level.material.FluidState;
+import org.sucraft.suki.block.replacementrule.BlockReplacementRule;
 import org.slf4j.Logger;
 
 public final class NbtUtils {
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 4069ef0030d66e1186afe5066030cb7b3f19a002..c0b8b7402a77acb1ef37fe0f4c2a68f6aa854584 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -2,6 +2,7 @@ package net.minecraft.network;
 
 import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
 import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
@@ -69,6 +70,7 @@ import it.unimi.dsi.fastutil.longs.LongSet;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
+import net.minecraft.core.Rotations;
 import net.minecraft.core.SectionPos;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
@@ -85,7 +87,10 @@ import net.minecraft.network.protocol.game.ClientboundRemoveEntitiesPacket;
 import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSetEntityDataPacket;
 import net.minecraft.network.protocol.game.ClientboundSetEquipmentPacket;
+import net.minecraft.network.protocol.game.ServerboundResourcePackPacket;
 import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
+import net.minecraft.network.syncher.SynchedEntityData;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.RunningOnDifferentThreadException;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.tags.BlockTags;
@@ -101,6 +106,14 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.phys.Vec3;
+import org.sucraft.suki.blockanditemdata.model.BaseBlockEntityModelVisualProperties;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelPosition;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelProximity;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelVisualProperties;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelVisualPropertiesUniverse;
+import org.sucraft.suki.blockanditemdata.model.TypicalBlockEntityModelVisualProperties;
+import org.sucraft.suki.resourcepack.asset.model.ResourcePackModel;
 import org.apache.commons.lang3.Validate;
 import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
@@ -160,6 +173,563 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private float averageSentPackets;
     private int tickCount;
     private boolean handlingFault;
+
+    // Suki start - custom blocks and items
+
+    // Keeping track of the Entity.getEntityId() of the fake entities that are sent to this connection's player as block entities
+
+    /**
+     * Stores the entity id (@{link org.bukkit.entity.Entity#getEntityId}) of the block entity (sent or to send) at the given block position (represented by a block key ({@link CoordinateUtils#getBlockKey}))
+     */
+    private final @NotNull Long2IntMap blockEntityEntityIdByBlockPosKey = new Long2IntOpenHashMap();
+
+    /**
+     * Stores the information of the block entity that was last sent at the given block position (represented by a block key ({@link CoordinateUtils#getBlockKey}))
+     */
+    private final @NotNull Long2ObjectMap<SentBlockEntityInformation> sentBlockEntityInformationByBlockPosKey = new Long2ObjectOpenHashMap<>(0);
+
+    private record SentBlockEntityInformation(@NotNull BlockState blockState, @NotNull BlockEntityModelVisualProperties properties) {}
+
+    /**
+     * Stores the block positions (represented by a block key ({@link CoordinateUtils#getBlockKey})) at the given chunk section position (represented by a chunk section key ({@link CoordinateUtils#getChunkSectionKey}))
+     */
+    private final @NotNull Long2ObjectMap<LongSet> blockEntityBlockPosKeysPerChunkSectionKey = new Long2ObjectOpenHashMap<>(0);
+
+    public @Nullable LongSet getBlockEntityBlockPosKeysForChunkSectionKey(long chunkSectionKey) {
+        return this.blockEntityBlockPosKeysPerChunkSectionKey.get(chunkSectionKey);
+    }
+
+    /**
+     * Utility function used in {@link #spawnBlockEntity}
+     */
+    private static void writeMetadataSharedFlags(@NotNull FriendlyByteBuf buf, int index, int byteValue) {
+        buf.writeByte(index);
+        buf.writeVarInt(0);
+        buf.writeByte(byteValue);
+    }
+
+    private static void writeMetadataRotation(@NotNull FriendlyByteBuf buf, int index, float x, float y, float z) {
+        buf.writeByte(index);
+        buf.writeVarInt(8);
+        buf.writeFloat(x);
+        buf.writeFloat(y);
+        buf.writeFloat(z);
+    }
+
+    /**
+     * Utility function used in {@link #spawnBlockEntity}
+     */
+    private static int bitsetToInt(@NotNull BitSet bitset) {
+        long[] longArray = bitset.toLongArray();
+        if (longArray.length == 0) {
+            return 0;
+        }
+        return (int) longArray[0];
+    }
+
+    private void sendBlockEntityAddEntityPacket(int entityId, @NotNull UUID entityUUID, double x, double y, double z, @NotNull SentBlockEntityInformation blockEntityInformationToSend) {
+        this.send(new ClientboundAddEntityPacket(
+            entityId,
+            entityUUID,
+            x + (blockEntityInformationToSend.properties instanceof TypicalBlockEntityModelVisualProperties typicalProperties ? typicalProperties.getPosition().armorStandPhysicalTranslationX : 0),
+            y + ResourcePackModel.BLOCK_ENTITY_ARMOR_STAND_DY,
+            z + (blockEntityInformationToSend.properties instanceof TypicalBlockEntityModelVisualProperties typicalProperties ? typicalProperties.getPosition().armorStandPhysicalTranslationZ : 0),
+            0F,
+            0F,
+            EntityType.ARMOR_STAND,
+            0,
+            Vec3.ZERO,
+            0
+        ));
+    }
+
+    private void sendBlockEntitySetEquipmentPacket(int entityId, @NotNull SentBlockEntityInformation blockEntityInformationToSend) {
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Sending " + entityId + " equipment: " + blockEntityInformationToSend.blockState + " , " + blockEntityInformationToSend.properties.position() + " , " + blockEntityInformationToSend.properties.proximity() + " = " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemStack(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.properties).getTag().getInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT) + " ( " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemModel(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.properties).getKeyWithIntention() + " using custom model data " + blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemCustomModelData(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.properties) + " )");
+        this.send(new ClientboundSetEquipmentPacket(
+            entityId,
+            Collections.singletonList(
+                new Pair<>(EquipmentSlot.HEAD, blockEntityInformationToSend.blockState().getBlock().replacementRule.getBlockEntityItemStack(blockEntityInformationToSend.blockState(), blockEntityInformationToSend.properties))
+            )
+        ));
+    }
+
+    private void sendBlockEntitySetEntityDataPacket(int entityId, boolean noGravity) {
+        @NotNull ClientboundSetEntityDataPacket setEntityDataPacket = new ClientboundSetEntityDataPacket(entityId);
+        var setEntityDataUnpackedData = setEntityDataPacket.getUnpackedData();
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_SHARED_FLAGS_ID, (byte) (1 << Entity.FLAG_INVISIBLE)));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_NO_GRAVITY, noGravity));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_SILENT, true));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(Entity.DATA_AIR_SUPPLY_ID, Integer.MAX_VALUE));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_CLIENT_FLAGS, (byte) (ArmorStand.CLIENT_FLAG_NO_BASEPLATE | ArmorStand.CLIENT_FLAG_MARKER)));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_HEAD_POSE, Rotations.ZERO));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_BODY_POSE, Rotations.ZERO));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_LEFT_ARM_POSE, Rotations.ZERO));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_RIGHT_ARM_POSE, Rotations.ZERO));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_LEFT_LEG_POSE, Rotations.ZERO));
+        setEntityDataUnpackedData.add(new SynchedEntityData.DataItem<>(ArmorStand.DATA_RIGHT_LEG_POSE, Rotations.ZERO));
+        this.send(setEntityDataPacket);
+    }
+
+    private void spawnBlockEntityForFallingBlock(int entityId, @NotNull UUID entityUUID, @NotNull BlockState blockState, @NotNull Vec3 pos) {
+
+        @NotNull SentBlockEntityInformation blockEntityInformationToSend = new SentBlockEntityInformation(blockState, new BaseBlockEntityModelVisualProperties(BlockEntityModelPosition.CENTER, BlockEntityModelProximity.NOT_EXPANDED));
+
+        // Send the add entity packet
+        this.sendBlockEntityAddEntityPacket(entityId, entityUUID, pos.x, pos.y, pos.z, blockEntityInformationToSend);
+
+        // Send the set equipment packet
+        this.sendBlockEntitySetEquipmentPacket(entityId, blockEntityInformationToSend);
+
+        // Send the set entity data packet
+        this.sendBlockEntitySetEntityDataPacket(entityId, false);
+
+    }
+
+    private void spawnBlockEntity(@NotNull BlockPos blockPos, @NotNull SentBlockEntityInformation blockEntityInformationToSend) {
+
+        long blockKey = blockPos.asLong();
+        int entityId = this.blockEntityEntityIdByBlockPosKey.computeIfAbsent(blockKey, $ -> Entity.ENTITY_COUNTER.incrementAndGet());
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Spawning " + entityId + " at " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ());
+        this.sentBlockEntityInformationByBlockPosKey.put(blockKey, blockEntityInformationToSend);
+        long chunkSectionKey = SectionPos.of(blockPos).asLong();
+        this.blockEntityBlockPosKeysPerChunkSectionKey.computeIfAbsent(chunkSectionKey, $ -> new LongOpenHashSet(1)).add(blockKey);
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Added block key " + BlockPos.of(blockKey).getX() + ", " + BlockPos.of(blockKey).getY() + ", " + BlockPos.of(blockKey).getZ());
+        UUID entityUUID = UUID.randomUUID();
+
+        // Send the add entity packet
+        this.sendBlockEntityAddEntityPacket(entityId, entityUUID, blockPos.getX() + 0.5, blockPos.getY(), blockPos.getZ() + 0.5, blockEntityInformationToSend);
+
+        // Send the set equipment packet
+        this.sendBlockEntitySetEquipmentPacket(entityId, blockEntityInformationToSend);
+
+        // Send the set entity data packet
+        this.sendBlockEntitySetEntityDataPacket(entityId, true);
+
+    }
+
+    private void despawnBlockEntity(@NotNull BlockPos blockPos, boolean needToRemoveFromPerChunkSectionKey) {
+        long blockKey = blockPos.asLong();
+        if (!this.blockEntityEntityIdByBlockPosKey.containsKey(blockKey)) {
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - Tried to despawn at " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ() + " but is no longer there?");
+            return;
+        }
+        int entityId = this.blockEntityEntityIdByBlockPosKey.remove(blockKey);
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Despawning " + entityId + " at " + blockPos.getX() + ", " + blockPos.getY() + ", " + blockPos.getZ());
+        this.sentBlockEntityInformationByBlockPosKey.remove(blockKey);
+        if (needToRemoveFromPerChunkSectionKey) {
+            long chunkSectionKey = SectionPos.of(blockPos).asLong();
+            this.blockEntityBlockPosKeysPerChunkSectionKey.computeIfPresent(chunkSectionKey, ($, blockPosKeys) -> {
+                blockPosKeys.remove(blockKey);
+                if (blockPosKeys.isEmpty()) {
+                    return null;
+                }
+                return blockPosKeys;
+            });
+        }
+        this.send(new ClientboundRemoveEntitiesPacket(entityId));
+    }
+
+    /**
+     * Updates any existing sent block entity at the position that had different information,
+     * and spawns a new block entity if no such existing sent block entity exists
+     */
+    private void updateBlockEntityOrSpawnIfNotSent(@NotNull BlockPos blockPos, @NotNull SentBlockEntityInformation blockEntityInformationToSend) {
+        long blockKey = blockPos.asLong();
+        @Nullable SentBlockEntityInformation existingSentBlockEntityInformation = this.sentBlockEntityInformationByBlockPosKey.get(blockKey);
+        tryUpdateExistingBlockEntity: if (existingSentBlockEntityInformation != null) {
+            if (blockEntityInformationToSend.properties instanceof TypicalBlockEntityModelVisualProperties && ((TypicalBlockEntityModelVisualProperties) existingSentBlockEntityInformation.properties).getPosition() != ((TypicalBlockEntityModelVisualProperties) blockEntityInformationToSend.properties).getPosition()) {
+                this.despawnBlockEntity(blockPos, true);
+                break tryUpdateExistingBlockEntity;
+            }
+            boolean updated = false;
+            if (!existingSentBlockEntityInformation.blockState.equals(blockEntityInformationToSend.blockState) || !existingSentBlockEntityInformation.properties.equals(blockEntityInformationToSend.properties)) {
+                int entityId = this.blockEntityEntityIdByBlockPosKey.get(blockKey);
+                // Send a set equipment packet to change the observed block state
+                sendBlockEntitySetEquipmentPacket(entityId, blockEntityInformationToSend);
+                updated = true;
+            }
+            if (updated) {
+                sentBlockEntityInformationByBlockPosKey.put(blockKey, blockEntityInformationToSend);
+            }
+            return;
+        }
+        this.spawnBlockEntity(blockPos, blockEntityInformationToSend);
+    }
+
+    /**
+     * Completely updates this player correctly as per the current potential block entity at the given position
+     * <br>
+     * To be called when a block update for the block is sent to the player
+     *
+     * @param sentBlockEntityBlockPosKeys Will be used to determine if a block entity at the given block position (represented by the block key) was sent to the player before - if null, will be assumed to be an empty set
+     */
+    public void updatePotentialBlockEntityAtPosition(@NotNull BlockPos blockPos, boolean useGivenSentBlockEntityBlockPosKeys, @Nullable LongSet sentBlockEntityBlockPosKeys, boolean doDespawns) {
+        long blockKey = blockPos.asLong();
+        var player = this.getPlayer();
+        var level = player.getLevel();
+        @NotNull BlockState state = level.getBlockState(blockPos);
+        @Nullable var replacementRule = state.getBlock().replacementRule;
+        if (replacementRule == null || !replacementRule.hasAsReal(state.getBlock()) || !replacementRule.rendersAsEntity(state)) {
+            if (doDespawns && (useGivenSentBlockEntityBlockPosKeys ? (sentBlockEntityBlockPosKeys != null && sentBlockEntityBlockPosKeys.contains(blockKey)) : this.blockEntityEntityIdByBlockPosKey.containsKey(blockKey))) {
+                this.despawnBlockEntity(blockPos, true);
+            }
+            return;
+        }
+        @NotNull BlockEntityModelPosition position;
+        // Check if one of the block, the block above and the block below is transparent: because then we can just use the center
+        BlockEntityModelVisualPropertiesUniverse<?> universe = replacementRule.getEntityRenderModelVisualPropertiesUniverse(state);
+        if (!universe.caresAboutPosition() || !state.isOpaque() || !level.getBlockState(blockPos.above()).isOpaque() || !level.getBlockState(blockPos.below()).isOpaque()) {
+            position = BlockEntityModelPosition.CENTER;
+        } else {
+            // If all three vertical blocks on the positive X, positive Z and positive XZ side are opaque, only then do we assume the negative XZ is a better position
+            BlockPos positiveXRelative = blockPos.relative(Direction.Axis.X, 1);
+            BlockPos positiveZRelative = blockPos.relative(Direction.Axis.Z, 1);
+            BlockPos positiveXZRelative = positiveXRelative.relative(Direction.Axis.Z, 1);
+            if (level.getBlockState(positiveXRelative).isOpaque() && level.getBlockState(positiveXRelative.above()).isOpaque() && level.getBlockState(positiveXRelative.below()).isOpaque() && level.getBlockState(positiveZRelative).isOpaque() && level.getBlockState(positiveZRelative.above()).isOpaque() && level.getBlockState(positiveZRelative.below()).isOpaque() && level.getBlockState(positiveXZRelative).isOpaque() && level.getBlockState(positiveXZRelative.above()).isOpaque() && level.getBlockState(positiveXZRelative.below()).isOpaque()) {
+                position = BlockEntityModelPosition.NEGATIVE_XZ;
+            } else {
+                position = BlockEntityModelPosition.POSITIVE_XZ;
+            }
+        }
+        @NotNull BlockEntityModelProximity proximity = universe.caresAboutProximity() ? this.computeNewProximity(blockKey, SectionPos.of(player), player.blockPosition) : BlockEntityModelProximity.NOT_EXPANDED;
+        this.updateBlockEntityOrSpawnIfNotSent(blockPos, new SentBlockEntityInformation(state, new BaseBlockEntityModelVisualProperties(position, proximity)));
+    }
+
+    private ReentrantLock scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock = new ReentrantLock();
+    private boolean executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = false;
+
+    private final @NotNull Long2ObjectMap<Boolean> sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds = new Long2ObjectOpenHashMap<>(1);
+    private final @NotNull LongArrayFIFOQueue sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList= new LongArrayFIFOQueue(64);
+    private @Nullable Long lastChunkInitializationPacketInTransitKeepaliveIdWhenLastUpdatingPotentialBlockEntitiesInSection = null;
+
+    /**
+     * If we cross this limit, we will wait some time to attempt this again.
+     */
+    public static final long maxNanosUpdatingPotentialBlockEntitiesInSectionPerTick = 5_000_000L; // 5 milliseconds
+
+    private @Nullable Long nextMinNanoTimeToUpdatePotentialBlockEntitiesInSection = null;
+
+    private void tickUpdatePotentialBlockEntitiesInSectionSpawnNew() {
+
+        if (nextMinNanoTimeToUpdatePotentialBlockEntitiesInSection != null) {
+            if (System.nanoTime() < nextMinNanoTimeToUpdatePotentialBlockEntitiesInSection) {
+                return;
+            }
+            nextMinNanoTimeToUpdatePotentialBlockEntitiesInSection = null;
+        }
+
+        var player = getPlayer();
+
+        // Skip this tick if we are still waiting for chunks in transit
+        if (lastChunkInitializationPacketInTransitKeepaliveIdWhenLastUpdatingPotentialBlockEntitiesInSection != null) {
+            if (player.isChunkInitializationPacketWithKeepaliveIdInTransit(lastChunkInitializationPacketInTransitKeepaliveIdWhenLastUpdatingPotentialBlockEntitiesInSection)) {
+                return;
+            }
+        }
+
+        long sectionKey;
+        boolean updateOutsideSectionBounds;
+        boolean needToUnlock = true;
+        try {
+            scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.lock();
+            if (sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds.isEmpty()) {
+                executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = false;
+                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+                needToUnlock = false;
+                return;
+            }
+            executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = true;
+            sectionKey = sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList.dequeueLong();
+            updateOutsideSectionBounds = sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds.remove(sectionKey);
+        } finally {
+            if (needToUnlock) {
+                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+            }
+        }
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Section update new during tick: " + SectionPos.of(sectionKey).x() + ", " + SectionPos.of(sectionKey).y() + ", " + SectionPos.of(sectionKey).z());
+        // Measure the absolute time this takes to decide how many next ticks we should skip this action
+        long startTime = System.nanoTime();
+        this.updatePotentialBlockEntitiesInSectionSpawnNew(SectionPos.of(sectionKey), updateOutsideSectionBounds, null);
+        long endTime = System.nanoTime();
+        long extraTicksWorthOfUpdatesDone = (endTime - startTime) / maxNanosUpdatingPotentialBlockEntitiesInSectionPerTick;
+        if (extraTicksWorthOfUpdatesDone > 0) {
+            nextMinNanoTimeToUpdatePotentialBlockEntitiesInSection = System.nanoTime() + extraTicksWorthOfUpdatesDone * 50_000_000; // 50 milliseconds = 1 tick
+        }
+
+        // Update when we performed this tick update, to prevent doing this too often before chunks are sent
+        lastChunkInitializationPacketInTransitKeepaliveIdWhenLastUpdatingPotentialBlockEntitiesInSection = player.getLastChunkInitializationPacketInTransitKeepaliveId();
+
+    }
+
+    private void scheduleUpdatePotentialBlockEntitiesInSectionSpawnNew(@NotNull SectionPos sectionPos, boolean updateOutsideSectionBounds, @Nullable LevelChunk precomputedChunk) {
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Schedule section update new: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+        boolean needToUnlock = true;
+        try {
+            scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.lock();
+//            boolean executeRightNow = !executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick && sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList.isEmpty();
+//            if (executeRightNow) {
+//                executedUpdatePotentialBlockEntitiesInSectionSpawnNewThisTick = true;
+//                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+//                needToUnlock = false;
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update new right now: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+//                this.updatePotentialBlockEntitiesInSectionSpawnNew(sectionPos, updateOutsideSectionBounds, precomputedChunk);
+//                return;
+//            }
+            long sectionKey = sectionPos.asLong();
+            sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds.compute(sectionKey, ($, existingUpdateOutsideSectionBounds) -> {
+                if (existingUpdateOutsideSectionBounds == null) {
+                    sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewList.enqueue(sectionKey);
+                    return updateOutsideSectionBounds;
+                }
+                return existingUpdateOutsideSectionBounds || updateOutsideSectionBounds;
+            });
+        } finally {
+            if (needToUnlock) {
+                scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+            }
+        }
+    }
+
+    /**
+     * The part of {@link #updatePotentialBlockEntitiesInSection} that spawns new block entities
+     */
+    private void updatePotentialBlockEntitiesInSectionSpawnNew(@NotNull SectionPos sectionPos, boolean updateOutsideSectionBounds, @Nullable LevelChunk precomputedChunk) {
+        var player = this.getPlayer();
+        var level = player.getLevel();
+        @Nullable LevelChunk chunk = precomputedChunk != null ? precomputedChunk : level.getChunkIfLoaded(sectionPos.x(), sectionPos.z());
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Section update new: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+        if (chunk != null) {
+            var section = chunk.getSection(chunk.getSectionIndexFromSectionY(sectionPos.y()));
+            if (section.potentiallyContainsBlockEntity()) {
+                int minYInSection;
+                int maxYInSection;
+                int minXInSection;
+                int minZInSection;
+                int maxXInSection;
+                int maxZInSection;
+                if (updateOutsideSectionBounds) {
+                    boolean isBottomSection = sectionPos.y() == level.getMinSection();
+                    boolean isTopSection = sectionPos.y() == level.getMaxSection();
+                    boolean isMinXChunkLoaded = chunk.isNeighbourLoaded(-1, 0);
+                    boolean isMinXZChunkLoaded = chunk.isNeighbourLoaded(-1, -1);
+                    boolean isMinZChunkLoaded = chunk.isNeighbourLoaded(0, -1);
+                    boolean isPlusXChunkLoaded = chunk.isNeighbourLoaded(1, 0);
+                    boolean isPlusXZChunkLoaded = chunk.isNeighbourLoaded(1, 1);
+                    boolean isPlusZChunkLoaded = chunk.isNeighbourLoaded(0, 1);
+                    boolean isMinXPlusZChunkLoaded = chunk.isNeighbourLoaded(-1, 1);
+                    boolean isPlusXMinZChunkLoaded = chunk.isNeighbourLoaded(1, -1);
+                    minYInSection = isBottomSection ? 0 : -1;
+                    maxYInSection = isTopSection ? 15 : 16;
+                    minXInSection = isMinXChunkLoaded && isMinXZChunkLoaded && isMinXPlusZChunkLoaded ? -1 : 0;
+                    minZInSection = isMinZChunkLoaded && isMinXZChunkLoaded && isPlusXMinZChunkLoaded ? -1 : 0;
+                    maxXInSection = isPlusXChunkLoaded && isPlusXZChunkLoaded && isPlusXMinZChunkLoaded ? 16 : 15;
+                    maxZInSection = isPlusZChunkLoaded && isPlusXZChunkLoaded && isMinXPlusZChunkLoaded ? 16 : 15;
+                } else {
+                    minYInSection = 0;
+                    maxYInSection = 15;
+                    minXInSection = 0;
+                    minZInSection = 0;
+                    maxXInSection = 15;
+                    maxZInSection = 15;
+                }
+                //                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update loop: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+                for (int xInSection = minXInSection; xInSection <= maxXInSection; xInSection++) {
+                    for (int yInSection = minYInSection; yInSection <= maxYInSection; yInSection++) {
+                        for (int zInSection = minZInSection; zInSection <= maxZInSection; zInSection++) {
+                            int blockX = sectionPos.minBlockX() + xInSection;
+                            int blockY = sectionPos.minBlockY() + yInSection;
+                            int blockZ = sectionPos.minBlockZ() + zInSection;
+                            this.updatePotentialBlockEntityAtPosition(new BlockPos(blockX, blockY, blockZ), true, null, false);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public void updatePotentialBlockEntitiesInSection(@NotNull SectionPos sectionPos, boolean updateOutsideSectionBounds, @Nullable LevelChunk precomputedChunk) {
+        updatePotentialBlockEntitiesInSection(sectionPos, updateOutsideSectionBounds, precomputedChunk, null, null);
+    }
+
+    public void updatePotentialBlockEntitiesInSection(@NotNull SectionPos sectionPos, boolean updateOutsideSectionBounds, @Nullable LevelChunk precomputedChunk, short @org.jetbrains.annotations.Nullable [] positions, @NotNull BlockState @org.jetbrains.annotations.Nullable [] states) {
+
+        var sectionKey = sectionPos.asLong();
+
+        @Nullable Boolean existingUpdateOutsideSectionBounds;
+        try {
+            scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.lock();
+            existingUpdateOutsideSectionBounds = sectionsToUpdatePotentialBlockEntitiesInSectionSpawnNewAndWhetherToUpdateOutsideSectionBounds.get(sectionKey);
+        } finally {
+            scheduleUpdatePotentialBlockEntitiesInSectionSpawnNewLock.unlock();
+        }
+        if (existingUpdateOutsideSectionBounds != null) {
+            if (existingUpdateOutsideSectionBounds || !updateOutsideSectionBounds) {
+                // We are already planning to update the potential block entities in this section, do not process the chunk again here
+                return;
+            }
+        }
+
+        @org.jetbrains.annotations.Nullable Long2ObjectMap<BlockState> sentStates = null;
+        if (positions != null) {
+            sentStates = new Long2ObjectOpenHashMap<>(positions.length * 2);
+            for (int i = 0; i < positions.length; i++) {
+                short shortRelativePosition = positions[i];
+                int x = sectionPos.relativeToBlockX(shortRelativePosition);
+                int y = sectionPos.relativeToBlockY(shortRelativePosition);
+                int z = sectionPos.relativeToBlockZ(shortRelativePosition);
+                long blockKey = BlockPos.asLong(x, y, z);
+                sentStates.put(blockKey, states[i]);
+            }
+        }
+
+        var player = this.getPlayer();
+        var level = player.getLevel();
+        @Nullable LevelChunk chunk = precomputedChunk != null ? precomputedChunk : level.getChunkIfLoaded(sectionPos.x(), sectionPos.z());
+        if (chunk != null) {
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - Section update start: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+            // Attempt to despawn any sent block entities where one no longer exists
+            @Nullable LongSet sectionSentBlockKeys = this.getBlockEntityBlockPosKeysForChunkSectionKey(sectionKey);
+            if (sectionSentBlockKeys != null && !sectionSentBlockKeys.isEmpty()) {
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update old: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+                @Nullable LongList toRemoveBlockKeys = null;
+                try {
+                    LongIterator sectionSentBlockKeyIterator = sectionSentBlockKeys.longIterator();
+                    while (sectionSentBlockKeyIterator.hasNext()) {
+                        long sentBlockKey = sectionSentBlockKeyIterator.nextLong();
+                        //                    BlockState sentState = sentStates == null ? null : sentStates.get(sentBlockKey);
+                        //                    if (sentStates == null || sentState != null) {
+                        if (sentStates == null || sentStates.containsKey(sentBlockKey)) {
+                            @NotNull BlockPos blockPos = BlockPos.of(sentBlockKey);
+                            //                        @NotNull BlockState state = sentState != null ? sentState : level.getBlockState(blockPos);
+                            @NotNull BlockState state = level.getBlockState(blockPos);
+                            @Nullable var replacementRule = state.getBlock().replacementRule;
+                            if (replacementRule == null || !replacementRule.hasAsReal(state.getBlock()) || !replacementRule.rendersAsEntity(state)) {
+                                if (toRemoveBlockKeys == null) {
+                                    toRemoveBlockKeys = new LongArrayList(1);
+                                }
+                                toRemoveBlockKeys.add(sentBlockKey);
+                                despawnBlockEntity(blockPos, false);
+                            }
+                        }
+                    }
+                } catch (Exception ignored) {}
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update old to remove size is " + (toRemoveBlockKeys == null ? 0 : toRemoveBlockKeys.size()));
+                if (toRemoveBlockKeys != null) {
+                    for (long sentBlockKey : toRemoveBlockKeys) {
+                        sectionSentBlockKeys.remove(sentBlockKey);
+                        if (sectionSentBlockKeys.isEmpty()) {
+                            this.blockEntityBlockPosKeysPerChunkSectionKey.remove(sectionKey);
+                        }
+                    }
+                }
+            }
+            // Attempt to update any block entities derived from the actual world block states
+            var section = chunk.getSection(chunk.getSectionIndexFromSectionY(sectionPos.y()));
+            if (section.potentiallyContainsBlockEntity(positions, states)) {
+                this.scheduleUpdatePotentialBlockEntitiesInSectionSpawnNew(sectionPos, updateOutsideSectionBounds, chunk);
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Section update done: " + sectionPos.x() + ", " + sectionPos.y() + ", " + sectionPos.z());
+            }
+        }
+
+    }
+
+    /**
+     * To be called for every chunk section of a chunk when it is being unloaded from the player
+     */
+    public void despawnBlockEntitiesInChunkSection(long chunkSectionKey) {
+        this.blockEntityBlockPosKeysPerChunkSectionKey.computeIfPresent(chunkSectionKey, ($, blockPosKeys) -> {
+            blockPosKeys.forEach(blockPosKey -> this.despawnBlockEntity(BlockPos.of(blockPosKey), false));
+            return null;
+        });
+    }
+
+    public boolean hasUpdatedBlockEntitiesClosebyModelForSections = false;
+
+    private static @NotNull BlockEntityModelProximity getProximityForSections(@NotNull SectionPos sectionPos, @NotNull SectionPos playerSectionPos) {
+        int sectionDX = sectionPos.x() - playerSectionPos.x();
+        int sectionDY = sectionPos.y() - playerSectionPos.y();
+        int sectionDZ = sectionPos.z() - playerSectionPos.z();
+        if (sectionDX == 0 && sectionDY == 0 && sectionDZ == 0) {
+            return BlockEntityModelProximity.SAME_CHUNK;
+        } else if (sectionDX >= -BlockEntityModelProximity.maxSectionDistanceForNeighbors && sectionDX <= BlockEntityModelProximity.maxSectionDistanceForNeighbors && sectionDY >= -BlockEntityModelProximity.maxSectionDistanceForNeighbors && sectionDY <= BlockEntityModelProximity.maxSectionDistanceForNeighbors && sectionDZ >= -BlockEntityModelProximity.maxSectionDistanceForNeighbors && sectionDZ <= BlockEntityModelProximity.maxSectionDistanceForNeighbors) {
+            return BlockEntityModelProximity.NEIGHBOR_CHUNK;
+        } else {
+            return BlockEntityModelProximity.FAR;
+        }
+    }
+
+    private static @Nullable BlockEntityModelProximity getProximityForBlocks(@NotNull BlockPos blockPos, @NotNull BlockPos playerBlockPos, @Nullable BlockEntityModelProximity defaultValue) {
+        int dx = blockPos.getX() - playerBlockPos.getX();
+        if (dx >= -BlockEntityModelProximity.maxBlockDistanceForNeighbors && dx <= BlockEntityModelProximity.maxBlockDistanceForNeighbors) {
+            int dy = blockPos.getY() - playerBlockPos.getY();
+            if (dy >= -BlockEntityModelProximity.maxBlockDistanceForNeighbors && dy <= BlockEntityModelProximity.maxBlockDistanceForNeighbors) {
+                int dz = blockPos.getZ() - playerBlockPos.getZ();
+                if (dz >= -BlockEntityModelProximity.maxBlockDistanceForNeighbors && dz <= BlockEntityModelProximity.maxBlockDistanceForNeighbors) {
+                    return BlockEntityModelProximity.NEIGHBOR_BLOCK;
+                }
+            }
+        }
+        return defaultValue;
+    }
+
+    private @NotNull SentBlockEntityInformation sendUpdateBlockEntityClosebyModelIfNeeded(long blockKey, @NotNull SentBlockEntityInformation existingSentBlockEntityInformation, @NotNull BlockEntityModelProximity newProximity) {
+        if (!(existingSentBlockEntityInformation.properties instanceof TypicalBlockEntityModelVisualProperties) || ((TypicalBlockEntityModelVisualProperties) existingSentBlockEntityInformation.properties).getProximity() == newProximity) {
+            return existingSentBlockEntityInformation;
+        }
+        int entityId = this.blockEntityEntityIdByBlockPosKey.get(blockKey);
+        var newBlockEntityInformation = new SentBlockEntityInformation(existingSentBlockEntityInformation.blockState, ((TypicalBlockEntityModelVisualProperties) existingSentBlockEntityInformation.properties).cloneWithProximity(newProximity));
+        this.sendBlockEntitySetEquipmentPacket(entityId, newBlockEntityInformation);
+        return newBlockEntityInformation;
+    }
+
+    /**
+     * To be called for every chunk section that the player enters or leaves, or any chunk section right next to a chunk section (at most chunk section chessboard distance 1) the player enters or leaves
+     */
+    public void updateBlockEntitiesClosebyModelInChunkSection(long chunkSectionKey, @NotNull SectionPos upToDatePlayerSectionPos, @NotNull BlockPos upToDatePlayerBlockPos) {
+        LongSet blockKeys = this.blockEntityBlockPosKeysPerChunkSectionKey.get(chunkSectionKey);
+        if (blockKeys == null) {
+            return;
+        }
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Updating closeby model for all in section " + SectionPos.x(chunkSectionKey) + ", " + SectionPos.y(chunkSectionKey) + ", " + SectionPos.z(chunkSectionKey));
+        SectionPos sectionPos = SectionPos.of(chunkSectionKey);
+        @NotNull BlockEntityModelProximity globalSectionProximity = getProximityForSections(sectionPos, upToDatePlayerSectionPos);
+        boolean needToCheckForBlockProximity;
+        if (upToDatePlayerSectionPos.asLong() == chunkSectionKey) {
+            needToCheckForBlockProximity = true;
+        } else {
+            needToCheckForBlockProximity = upToDatePlayerBlockPos.getX() >= sectionPos.minBlockX() - 1 && upToDatePlayerBlockPos.getX() <= sectionPos.maxBlockX() + 1 && upToDatePlayerBlockPos.getY() >= sectionPos.minBlockY() - 1 && upToDatePlayerBlockPos.getY() <= sectionPos.maxBlockY() + 1 && upToDatePlayerBlockPos.getZ() >= sectionPos.minBlockZ() - 1 && upToDatePlayerBlockPos.getZ() <= sectionPos.maxBlockZ() + 1;
+        }
+        for (long blockKey : blockKeys) {
+            this.sentBlockEntityInformationByBlockPosKey.computeIfPresent(blockKey, ($, existingSentBlockEntityInformation) -> {
+                @NotNull BlockEntityModelProximity newProximity = globalSectionProximity;
+                if (needToCheckForBlockProximity) {
+                    BlockPos blockPos = BlockPos.of(blockKey);
+                    newProximity = getProximityForBlocks(blockPos, upToDatePlayerBlockPos, newProximity);
+                }
+                return sendUpdateBlockEntityClosebyModelIfNeeded(blockKey, existingSentBlockEntityInformation, newProximity);
+            });
+        }
+    }
+
+    private @NotNull BlockEntityModelProximity computeNewProximity(long blockKey, @NotNull SectionPos upToDatePlayerSectionPos, @NotNull BlockPos upToDatePlayerBlockPos) {
+        BlockPos blockPos = BlockPos.of(blockKey);
+        @Nullable BlockEntityModelProximity newProximity = getProximityForBlocks(blockPos, upToDatePlayerBlockPos, null);
+        if (newProximity == null) {
+            SectionPos sectionPos = SectionPos.of(blockPos);
+            newProximity = getProximityForSections(sectionPos, upToDatePlayerSectionPos);
+        }
+        return newProximity;
+    }
+
+    public void updateBlockEntitiesClosebyModelForBlock(long blockKey, @NotNull SectionPos upToDatePlayerSectionPos, @NotNull BlockPos upToDatePlayerBlockPos) {
+        this.sentBlockEntityInformationByBlockPosKey.computeIfPresent(blockKey, ($, existingSentBlockEntityInformation) -> {
+            @Nullable BlockEntityModelProximity newProximity = computeNewProximity(blockKey, upToDatePlayerSectionPos, upToDatePlayerBlockPos);
+            return sendUpdateBlockEntityClosebyModelIfNeeded(blockKey, existingSentBlockEntityInformation, newProximity);
+        });
+    }
+
+    // Suki end - custom blocks and items
+
     // Paper start - NetworkClient implementation
     public int protocolVersion;
     public java.net.InetSocketAddress virtualHost;
@@ -391,6 +961,21 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             return null;
         }
     }
+
+    // Suki start - custom blocks and items
+
+    public boolean doesPlayerHaveSuCraftResourcePack() {
+        var player = getPlayer();
+        return player != null ? player.hasSuCraftResourcePack() : false;
+    }
+
+    public boolean doesPlayerHaveHighPingForCustomBlocks() {
+        var player = getPlayer();
+        return player != null ? player.hasHighPingForCustomBlocks() : false;
+    }
+
+    // Suki end - custom blocks and items
+
     private static class InnerUtil { // Attempt to hide these methods from ProtocolLib so it doesn't accidently pick them up.
         private static java.util.List<Packet> buildExtraPackets(Packet packet) {
             java.util.List<Packet> extra = packet.getExtraPackets();
@@ -427,7 +1012,15 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
                 packet instanceof net.minecraft.network.protocol.game.ClientboundClearTitlesPacket ||
                 packet instanceof net.minecraft.network.protocol.game.ClientboundBossEventPacket ||
                 packet instanceof net.minecraft.network.protocol.game.ClientboundPlayerInfoPacket ||
-                packet instanceof net.minecraft.network.protocol.game.ClientboundMapItemDataPacket;
+                // Suki start - custom blocks and items - even more packets that can be sent immediately
+                packet instanceof net.minecraft.network.protocol.game.ClientboundMapItemDataPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundUpdateAdvancementsPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundUpdateRecipesPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundResourcePackPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundInitializeBorderPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundLoginPacket ||
+                packet instanceof net.minecraft.network.protocol.game.ClientboundServerDataPacket;
+                // Suki end - custom blocks and items - even more packets that can be sent immediately
             // Suki end - more packets that can be sent immediately
         }
         // Paper end
@@ -1208,6 +1801,11 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         if (!connected && !preparing) {
             return; // Do nothing
         }
+        // Suki start - custom blocks and items
+        if (this.doesPlayerHaveSuCraftResourcePack()) {
+            callbacks = packet.updateCallbackWithBlockEntityPacketSends(callbacks, this);
+        }
+        // Suki end - custom blocks and items
         packet.onPacketDispatch(getPlayer());
         if (connected && (InnerUtil.canSendImmediate(this, packet) || (
             net.minecraft.server.MCUtil.isMainThread() && packet.isReady() && this.queue.isEmpty() &&
@@ -1270,6 +1868,65 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 //        }
         // Suki end - limit packets per tick
         this.packetWrites.getAndIncrement(); // must be befeore using canFlush
+        // Suki start - custom blocks and items
+        // Replace the packet in case of custom falling blocks
+        if (packet instanceof ClientboundSetEntityDataPacket setEntityDataPacket) {
+            var player = this.getPlayer();
+            if (player != null) {
+                var level = player.getLevel();
+                if (level != null) {
+                    Entity entity = level.getEntity(setEntityDataPacket.getId());
+                    if (entity instanceof FallingBlockEntity fallingBlockEntity) {
+                        BlockState blockState = fallingBlockEntity.getBlockState();
+                        Block block = blockState.getBlock();
+                        var replacementRule = block.replacementRule;
+                        if (replacementRule != null) {
+                            var unpackedData = setEntityDataPacket.getUnpackedData();
+                            // Check that the data packet is not for an armor stand (even though the entity is a falling block), because if it is for an armor stand, it is a valid block entity sent instead of the falling block and we should let it pass
+                            if (unpackedData == null || unpackedData.stream().noneMatch(dataItem -> dataItem.getAccessor().equals(ArmorStand.DATA_CLIENT_FLAGS))) {
+                                if (replacementRule.rendersSomeStatesAsEntity() && !replacementRule.rendersAsEntity(blockState)) {
+                                    // No need to do anything since we will actually be using the falling block entity packets
+                                } else {
+                                    // Cancel the packets sent for the original falling block entity
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        } else if (packet instanceof ClientboundAddEntityPacket addEntityPacket) {
+            if (addEntityPacket.getType().equals(EntityType.FALLING_BLOCK)) {
+                var player = this.getPlayer();
+                if (player != null) {
+                    var level = player.getLevel();
+                    if (level != null) {
+                        Entity entity = level.getEntity(addEntityPacket.getId());
+                        if (entity instanceof FallingBlockEntity fallingBlockEntity) {
+                            BlockState blockState = fallingBlockEntity.getBlockState();
+                            Block block = blockState.getBlock();
+                            var replacementRule = block.replacementRule;
+                            if (replacementRule != null) {
+                                if (replacementRule.rendersAsEntity(blockState)) {
+                                    MinecraftServer.LOGGER.info("Spawning block entity for " + blockState.getBlock() + " with id " + addEntityPacket.getId());
+                                    // Spawn a block entity for a falling block instead
+                                    this.spawnBlockEntityForFallingBlock(fallingBlockEntity.getId(), fallingBlockEntity.getUUID(), blockState, fallingBlockEntity.position());
+                                    return;
+                                } else if (replacementRule.rendersSomeStatesAsEntity()) {
+                                    // We can replace the state of the falling block with the used host (such as the full block host for a slab)
+                                    // Based on FallingBlockEntity.getAddEntityPacket
+                                    packet = new ClientboundAddEntityPacket(entity, Block.getId(replacementRule.getHost(blockState)));
+                                } else {
+                                    // We don't have a replacement entity to send ready - so we cancel this packet entirely
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        // Suki end - custom blocks and items
         boolean effectiveFlush = flushConditional == null ? this.canFlush : flushConditional.booleanValue();
         // Suki start - more packets without delay
         final boolean flush = effectiveFlush || packet instanceof net.minecraft.network.protocol.game.ClientboundKeepAlivePacket || packet instanceof ClientboundDisconnectPacket
@@ -1277,6 +1934,14 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             || packet instanceof net.minecraft.network.protocol.game.ClientboundForgetLevelChunkPacket
             || packet instanceof net.minecraft.network.protocol.game.ClientboundPlayerInfoPacket
             || packet instanceof net.minecraft.network.protocol.game.ClientboundMapItemDataPacket
+            // Suki start - custom blocks and items - even more packets without delay
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundUpdateAdvancementsPacket
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundUpdateRecipesPacket
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundResourcePackPacket
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundInitializeBorderPacket
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundLoginPacket
+            || packet instanceof net.minecraft.network.protocol.game.ClientboundServerDataPacket
+            // Suki end - custom blocks and items - even more packets without delay
             ; // no delay for certain packets
         // Suki end - more packets without delay
         // Paper end - add flush parameter
@@ -1289,20 +1954,22 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
             this.channel.config().setAutoRead(false);
         }
 
+        Packet<?> modifiedPacket = packet.replaceCustomContent(this.doesPlayerHaveSuCraftResourcePack(), this.doesPlayerHaveHighPingForCustomBlocks()); // Suki - custom blocks and items
+
         if (this.channel.eventLoop().inEventLoop()) {
-            this.doSendPacket(packet, callbacks, enumprotocol, enumprotocol1, flush); // Paper
+            this.doSendPacket(modifiedPacket, callbacks, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Suki - custom blocks and items
         } else {
             // Paper start - optimise packets that are not flushed
             // note: since the type is not dynamic here, we need to actually copy the old executor code
             // into two branches. On conflict, just re-copy - no changes were made inside the executor code.
             if (!flush) {
                 AbstractEventExecutor.LazyRunnable run = () -> {
-                    this.doSendPacket(packet, callbacks, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter
+                    this.doSendPacket(modifiedPacket, callbacks, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Suki - custom blocks and items
                 };
                 this.channel.eventLoop().execute(run);
             } else { // Paper end - optimise packets that are not flushed
             this.channel.eventLoop().execute(() -> {
-                this.doSendPacket(packet, callbacks, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Paper - diff on change
+                this.doSendPacket(modifiedPacket, callbacks, enumprotocol, enumprotocol1, flush); // Paper - add flush parameter // Paper - diff on change // Suki - custom blocks and items
             });
             } // Paper
         }
@@ -1426,8 +2093,35 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static final int MAX_PER_TICK = io.papermc.paper.configuration.GlobalConfiguration.get().misc.maxJoinsPerTick; // Paper
     private static int joinAttemptsThisTick; // Paper
     private static int currTick; // Paper
+    // Suki start - custom blocks and items
+    private static final int repeatResourcePackEveryTicks = 100; // 5 seconds
+    private static final int forceResourcePackFailureAfterTicks = 2400; // 2 minutes
+    private int firstResourcePackSendTick = tickCount;
+    private int lastResourcePackSendTick = tickCount;
+    // Suki end - custom blocks and items
     public void tick() {
         this.tickQueuedPackets(); // Suki - limit packets per tick
+        // Suki start - custom blocks and items
+        this.tickUpdatePotentialBlockEntitiesInSectionSpawnNew();
+        // Re-send the resource pack packet if no response has been received
+        {
+            var player = this.getPlayer();
+            if (player != null) {
+                if (player.getBukkitEntity().getResourcePackStatus() == null) {
+                    if (!player.canAcceptServerResourcePack()) {
+                        player.connection.handleResourcePackResponse(new ServerboundResourcePackPacket(ServerboundResourcePackPacket.Action.FAILED_DOWNLOAD));
+                    } else if (this.tickCount >= this.lastResourcePackSendTick + repeatResourcePackEveryTicks) {
+                        player.server.getServerResourcePack().ifPresent((minecraftserver_serverresourcepackinfo) -> {
+                            player.sendTexturePack(minecraftserver_serverresourcepackinfo.url(), minecraftserver_serverresourcepackinfo.hash(), minecraftserver_serverresourcepackinfo.isRequired(), minecraftserver_serverresourcepackinfo.prompt());
+                        });
+                        this.updateLastResourcePackSendTick(); // Redundant but just in case, to avoid rapid packet sends in case something fails above
+                    } else if (this.tickCount >= this.firstResourcePackSendTick + forceResourcePackFailureAfterTicks) {
+                        player.connection.handleResourcePackResponse(new ServerboundResourcePackPacket(ServerboundResourcePackPacket.Action.FAILED_DOWNLOAD));
+                    }
+                }
+            }
+        }
+        // Suki end - custom blocks and items
         this.flushQueue();
         // Paper start
         if (currTick != net.minecraft.server.MinecraftServer.currentTick) {
@@ -1469,6 +2163,18 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
 
     }
 
+    // Suki start - custom blocks and items
+
+    public void updateLastResourcePackSendTick() {
+        this.lastResourcePackSendTick = this.tickCount;
+    }
+
+    public void updateFirstResourcePackSendTick() {
+        this.firstResourcePackSendTick = this.tickCount;
+    }
+
+    // Suki end - custom blocks and items
+
     protected void tickSecond() {
         this.averageSentPackets = Mth.lerp(0.75F, (float) this.sentPackets, this.averageSentPackets);
         this.averageReceivedPackets = Mth.lerp(0.75F, (float) this.receivedPackets, this.averageReceivedPackets);
diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index 8747a55d8818d4526939070fa29a12ab643f0798..a8ed21a70da0d7412c0d7a73481f6562ce6db235 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -60,6 +60,7 @@ import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.Crypt;
 import net.minecraft.util.CryptException;
 import net.minecraft.world.item.Item;
@@ -68,7 +69,10 @@ import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
+import org.sucraft.suki.item.ItemReplacementRule;
+import org.sucraft.suki.item.SuCraftItems;
 import org.bukkit.craftbukkit.inventory.CraftItemStack; // CraftBukkit
+import org.jetbrains.annotations.NotNull;
 
 public class FriendlyByteBuf extends ByteBuf {
 
@@ -92,6 +96,11 @@ public class FriendlyByteBuf extends ByteBuf {
     }
     // Mirai end
 
+    // Suki start - custom blocks and items
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    public @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Suki end - custom blocks and items
+
     public FriendlyByteBuf(ByteBuf parent) {
         this.source = parent;
     }
@@ -532,6 +541,28 @@ public class FriendlyByteBuf extends ByteBuf {
         return this;
     }
 
+    // Suki start - custom blocks and items
+
+    /**
+     * We may want to change the palette of chunk packets on the fly, but we can't do that if the palette values are already written to the buffer with a VarInt type (since then, if they are no longer the same length in bytes as a VarInt, we would have to move up all following data in the buffer)
+     * <br>
+     * Therefore, we introduce this method: it will write exactly 3 bytes (which is the minimum needed to encode all possible block states using a VarInt), but still in the VarInt format so that the client can read it properly
+     *
+     * @see #writeVarInt
+     */
+    public FriendlyByteBuf writeVarIntThreeBytes(int value) {
+        // First write two bytes
+        this.writeByte(value & 127 | 128);
+        value >>>= 7;
+        this.writeByte(value & 127 | 128);
+        value >>>= 7;
+        // Then write the last byte
+        this.writeByte(value);
+        return this;
+    }
+
+    // Suki end - custom blocks and items
+
     public FriendlyByteBuf writeVarLong(long value) {
         while ((value & -128L) != 0L) {
             this.writeByte((int) (value & 127L) | 128);
@@ -585,12 +616,37 @@ public class FriendlyByteBuf extends ByteBuf {
     }
 
     public FriendlyByteBuf writeItem(ItemStack stack) {
+        // Suki start - custom blocks and items
+        return this.writeItem(stack, false);
+    }
+
+    public FriendlyByteBuf writeItem(ItemStack stack, boolean isStonecutterRecipeResult) {
+        // Suki end - custom blocks and items
         if (stack.isEmpty() || stack.getItem() == null) { // CraftBukkit - NPE fix itemstack.getItem()
             this.writeBoolean(false);
         } else {
             this.writeBoolean(true);
             Item item = stack.getItem();
 
+            // Suki start - custom blocks and items
+            boolean tryRename = true;
+            if (item.replacementRule != null) {
+                @Nullable ItemStack replacedStack = item.replacementRule.replace(stack, doesNetworkTargetHaveResourcePack != null ? doesNetworkTargetHaveResourcePack : false, doesNetworkTargetHaveHighPing != null ? doesNetworkTargetHaveHighPing : false, isStonecutterRecipeResult);
+                if (replacedStack != null) {
+                    tryRename = false;
+                    stack = replacedStack;
+                    item = replacedStack.getItem();
+                }
+            }
+            if (tryRename && item.customDisplayName != null) {
+                @NotNull ItemStack replacedStack = stack.copy();
+                CompoundTag tag = replacedStack.getOrCreateTag();
+                ItemReplacementRule.SimpleItemReplacementRule.replaceItemStackDisplayName(replacedStack, tag, null, item.customDisplayNameJSON, item.customDisplayNameInLoreJSON, false, false);
+                ItemReplacementRule.storeOriginalItemInfoInItemStackNBT(replacedStack, tag, stack);
+                stack = replacedStack;
+            }
+            // Suki end - custom blocks and items
+
             this.writeId(Registry.ITEM, item);
             this.writeByte(stack.getCount());
             CompoundTag nbttagcompound = null;
diff --git a/src/main/java/net/minecraft/network/PacketEncoder.java b/src/main/java/net/minecraft/network/PacketEncoder.java
index 5fce1177e7198d791d4ab1c64b394c5b1c145782..de8782009f77612407ba5dc8ddfbb271d750cb29 100644
--- a/src/main/java/net/minecraft/network/PacketEncoder.java
+++ b/src/main/java/net/minecraft/network/PacketEncoder.java
@@ -8,6 +8,7 @@ import io.papermc.paper.adventure.PaperAdventure; // Paper
 import java.io.IOException;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundUpdateRecipesPacket;
 import net.minecraft.util.profiling.jfr.JvmProfiler;
 import org.slf4j.Logger;
 
@@ -38,6 +39,10 @@ public class PacketEncoder extends MessageToByteEncoder<Packet<?>> {
 
                 try {
                     int i = friendlyByteBuf.writerIndex();
+                    // Suki start - custom blocks and items
+                    friendlyByteBuf.doesNetworkTargetHaveResourcePack = packet.doesNetworkTargetHaveResourcePack();
+                    friendlyByteBuf.doesNetworkTargetHaveHighPing = packet.doesNetworkTargetHaveHighPing();
+                    // Suki end - custom blocks and items
                     packet.write(friendlyByteBuf);
                     int j = friendlyByteBuf.writerIndex() - i;
                     if (j > 8388608) {
@@ -57,7 +62,7 @@ public class PacketEncoder extends MessageToByteEncoder<Packet<?>> {
 
                 // Paper start
                 int packetLength = friendlyByteBuf.readableBytes();
-                if (packetLength > MAX_PACKET_SIZE) {
+                if (packetLength > MAX_PACKET_SIZE && !(packet instanceof ClientboundUpdateRecipesPacket)) { // Suki - custom blocks and items
                     throw new PacketTooLargeException(packet, packetLength);
                 }
                 // Paper end
diff --git a/src/main/java/net/minecraft/network/protocol/Packet.java b/src/main/java/net/minecraft/network/protocol/Packet.java
index e8fcd56906d26f6dc87959e32c4c7c78cfea9658..b224cfa2adf30b5c5a9108b70d9026c6ef43cb97 100644
--- a/src/main/java/net/minecraft/network/protocol/Packet.java
+++ b/src/main/java/net/minecraft/network/protocol/Packet.java
@@ -1,7 +1,14 @@
 package net.minecraft.network.protocol;
 
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.PacketListener;
+import net.minecraft.network.PacketSendListener;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public interface Packet<T extends PacketListener> {
     void write(FriendlyByteBuf buf);
@@ -30,4 +37,33 @@ public interface Packet<T extends PacketListener> {
     default boolean isSkippable() {
         return false;
     }
+
+    // Suki start - custom blocks and items
+
+    /**
+     * Replaces any custom blocks or items in this packet will their intended replacement, based
+     * on whether a player has accepted the resource pack.
+     *
+     * This will usually replace the custom content in-place, returning this instance itself. However, when there is
+     * a real risk of a single packet instance with custom content to be replaced being sent to multiple players with
+     * differing resource pack statuses, this method may return a different instance.
+     */
+    default @NotNull Packet<T> replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        return this;
+    }
+
+    default @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return null;
+    }
+
+    default @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return null;
+    }
+
+    default @Nullable PacketSendListener updateCallbackWithBlockEntityPacketSends(@Nullable PacketSendListener callback, @NotNull Connection connection) {
+        return callback;
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
index 7b4947aa2cdd7f359184689bf348560bde1016dd..f81962c46027062d7f552e489158142cac26a24c 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundBlockUpdatePacket.java
@@ -1,15 +1,25 @@
 package net.minecraft.network.protocol.game;
 
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
 import net.minecraft.core.BlockPos;
+import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.PacketSendListener;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
+import org.sucraft.suki.protocol.CachableCustomContentReplaceable;
+import org.sucraft.suki.protocol.ReplacedCustomContentCache;
+import org.jetbrains.annotations.NotNull;
 
-public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketListener> {
+import javax.annotation.Nullable;
+import java.util.Arrays;
+
+public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketListener>, CachableCustomContentReplaceable<ClientboundBlockUpdatePacket> { // Suki - custom blocks and items
     private final BlockPos pos;
-    public final BlockState blockState;
+    public BlockState blockState; // Suki - custom blocks and items
 
     public ClientboundBlockUpdatePacket(BlockPos pos, BlockState state) {
         this.pos = pos;
@@ -43,4 +53,76 @@ public class ClientboundBlockUpdatePacket implements Packet<ClientGamePacketList
     public BlockPos getPos() {
         return this.pos;
     }
+
+    // Suki start - custom blocks and items
+
+    private final ReplacedCustomContentCache<ClientboundBlockUpdatePacket> replacedCustomContentCache = new ReplacedCustomContentCache<>(this);
+
+    @Override
+    public @NotNull ClientboundBlockUpdatePacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        return this.replacedCustomContentCache.get(hasResourcePack);
+    }
+
+    @Override
+    public @NotNull ClientboundBlockUpdatePacket copy() {
+        return new ClientboundBlockUpdatePacket(
+            this.pos,
+            this.blockState
+        );
+    }
+
+    @Override
+    public void replaceCustomContentInPlace(boolean hasResourcePack) {
+        var stateIdReplacementArray = hasResourcePack ? Block.stateIdReplacementArrayWithResourcePack : Block.stateIdReplacementArrayWithoutResourcePack;
+        int oldId = Block.BLOCK_STATE_REGISTRY.getId(this.blockState);
+        int newId = stateIdReplacementArray[oldId];
+        if (oldId != newId) {
+            this.blockState = Block.BLOCK_STATE_REGISTRY.byId(newId);
+        }
+    }
+
+    @Override
+    public @Nullable PacketSendListener updateCallbackWithBlockEntityPacketSends(@Nullable PacketSendListener callback, @NotNull Connection connection) {
+        return new PacketSendListener() {
+
+            @Override
+            public void onSuccess() {
+
+                if (callback != null) {
+                    callback.onSuccess();
+                }
+                if (connection.isConnected()) {
+                    var level = connection.getPlayer().getLevel();
+                    if (level != null) {
+                        for (int dx = -1; dx <= 1; dx++) {
+                            for (int dy = -1; dy <= 1; dy++) {
+                                for (int dz = -1; dz <= 1; dz++) {
+                                    int nx = ClientboundBlockUpdatePacket.this.pos.getX() + dx;
+                                    int ny = ClientboundBlockUpdatePacket.this.pos.getY() + dy;
+                                    int nz = ClientboundBlockUpdatePacket.this.pos.getZ() + dz;
+                                    BlockPos npos = new BlockPos(nx, ny, nz);
+                                    if (level.isLoadedAndInBounds(npos)) {
+                                        connection.updatePotentialBlockEntityAtPosition(npos, false, null, true);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+            }
+
+            @Override
+            public @Nullable Packet<?> onFailure() {
+                if (callback != null) {
+                    return callback.onFailure();
+                }
+                return null;
+            }
+
+        };
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java
index dbd8b9b09b82c1b75e8be9dc7416d9f0863c8c87..8436fa475901deb77b5411dab86468eebfee9048 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetContentPacket.java
@@ -5,12 +5,19 @@ import net.minecraft.core.NonNullList;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundContainerSetContentPacket implements Packet<ClientGamePacketListener> {
     private final int containerId;
     private final int stateId;
     private final List<ItemStack> items;
     private final ItemStack carriedItem;
+    // Suki start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Suki end - custom blocks and items
 
     public ClientboundContainerSetContentPacket(int syncId, int revision, NonNullList<ItemStack> contents, ItemStack cursorStack) {
         this.containerId = syncId;
@@ -69,4 +76,26 @@ public class ClientboundContainerSetContentPacket implements Packet<ClientGamePa
     public int getStateId() {
         return this.stateId;
     }
+
+    // Suki start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundContainerSetContentPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java
index 13ee7ad9c9415cd785b5487de7131c932c2198a0..794eacce858887db110a4fecccec9e3d9da5a2c0 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundContainerSetSlotPacket.java
@@ -3,6 +3,9 @@ package net.minecraft.network.protocol.game;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundContainerSetSlotPacket implements Packet<ClientGamePacketListener> {
     public static final int CARRIED_ITEM = -1;
@@ -11,6 +14,10 @@ public class ClientboundContainerSetSlotPacket implements Packet<ClientGamePacke
     private final int stateId;
     private final int slot;
     private final ItemStack itemStack;
+    // Suki start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Suki end - custom blocks and items
 
     public ClientboundContainerSetSlotPacket(int syncId, int revision, int slot, ItemStack stack) {
         this.containerId = syncId;
@@ -54,4 +61,26 @@ public class ClientboundContainerSetSlotPacket implements Packet<ClientGamePacke
     public int getStateId() {
         return this.stateId;
     }
+
+    // Suki start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundContainerSetSlotPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
index 578600a56f9461fbf3a6c1abf1d5aad614a93eb6..2034e1a2dac0ffd20bbc1b589ca0a1ec045d7e40 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundForgetLevelChunkPacket.java
@@ -1,7 +1,16 @@
 package net.minecraft.network.protocol.game;
 
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import io.papermc.paper.util.CoordinateUtils;
+import net.minecraft.core.SectionPos;
+import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.PacketSendListener;
+import net.minecraft.world.level.ChunkPos;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 public class ClientboundForgetLevelChunkPacket implements Packet<ClientGamePacketListener> {
     private final int x;
@@ -35,4 +44,39 @@ public class ClientboundForgetLevelChunkPacket implements Packet<ClientGamePacke
     public int getZ() {
         return this.z;
     }
+
+    // Suki start - custom blocks and items
+
+    @Override
+    public @Nullable PacketSendListener updateCallbackWithBlockEntityPacketSends(@Nullable PacketSendListener callback, @NotNull Connection connection) {
+        return new PacketSendListener() {
+
+            @Override
+            public void onSuccess() {
+
+                if (callback != null) {
+                    callback.onSuccess();
+                }
+                if (connection.isConnected()) {
+                    ChunkPos chunkPos = new ChunkPos(ClientboundForgetLevelChunkPacket.this.x, ClientboundForgetLevelChunkPacket.this.z);
+                    for (int y = connection.getPlayer().getLevel().getMinSection(); y <= connection.getPlayer().getLevel().getMaxSection(); y++) {
+                        connection.despawnBlockEntitiesInChunkSection(SectionPos.of(chunkPos, y).asLong());
+                    }
+                }
+
+            }
+
+            @Override
+            public @Nullable Packet<?> onFailure() {
+                if (callback != null) {
+                    return callback.onFailure();
+                }
+                return null;
+            }
+
+        };
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
index 76b6437a1d807c7e1b673f8feeed1f171ee9a803..0334e48b1674971b13f6397e3391262d7437dc12 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
@@ -192,4 +192,19 @@ public class ClientboundLevelChunkPacketData {
     public interface BlockEntityTagOutput {
         void accept(BlockPos pos, BlockEntityType<?> type, @Nullable CompoundTag nbt);
     }
+
+    // Suki start - custom blocks and items
+
+//    /**
+//     * Replaces any custom blocks or items in this packet will their intended replacement, based
+//     * on whether a player has accepted the resource pack.
+//     *
+//     * The replacement is performed in-place.
+//     */
+//    default void replaceCustomContent(boolean hasResourcePack) {
+//
+//    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
index 000853110c7a89f2d0403a7a2737025a5ac28240..a4b89a9b47a098ce02d3206ccdad645897205818 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
@@ -2,11 +2,22 @@ package net.minecraft.network.protocol.game;
 
 import java.util.BitSet;
 import javax.annotation.Nullable;
+
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import io.papermc.paper.util.CoordinateUtils;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.SectionPos;
+import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.PacketSendListener;
 import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.lighting.LevelLightEngine;
+import org.jetbrains.annotations.NotNull;
 
 public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePacketListener> {
     private final int x;
@@ -27,12 +38,14 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
     // Paper end
 
     // Paper start - Anti-Xray - Add chunk packet info
-    @Deprecated @io.papermc.paper.annotation.DoNotUse public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge) { this(chunk, lightProvider, skyBits, blockBits, nonEdge, true); }
-    public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge, boolean modifyBlocks) {
+    // Suki start - custom blocks and items
+    @Deprecated public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge, boolean doesPlayerHaveResourcePack) { this(chunk, lightProvider, skyBits, blockBits, nonEdge, true, doesPlayerHaveResourcePack); } // Notice for updates: Please make sure this constructor isn't used anywhere
+    public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge, boolean modifyBlocks, boolean doesPlayerHaveResourcePack) {
+        com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo = modifyBlocks ? chunk.getLevel().chunkPacketBlockController.getChunkPacketInfo(this, chunk, doesPlayerHaveResourcePack) : null;
+        // Suki end - custom blocks and items
         ChunkPos chunkPos = chunk.getPos();
         this.x = chunkPos.x;
         this.z = chunkPos.z;
-        com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo = modifyBlocks ? chunk.getLevel().chunkPacketBlockController.getChunkPacketInfo(this, chunk) : null;
         this.chunkData = new ClientboundLevelChunkPacketData(chunk, chunkPacketInfo);
         // Paper end
         this.lightData = new ClientboundLightUpdatePacketData(chunkPos, lightProvider, skyBits, blockBits, nonEdge);
@@ -81,4 +94,52 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
         return this.chunkData.getExtraPackets();
     }
     // Paper end
+
+    // Suki start - custom blocks and items
+
+//    @Override
+//    public @NotNull ClientboundLevelChunkWithLightPacket replaceCustomContent(boolean hasResourcePack) {
+//        chunkData.replaceCustomContent(hasResourcePack);
+//        return this;
+//    }
+
+    @Override
+    public @Nullable PacketSendListener updateCallbackWithBlockEntityPacketSends(@Nullable PacketSendListener callback, @NotNull Connection connection) {
+        return new PacketSendListener() {
+
+            @Override
+            public void onSuccess() {
+
+                if (callback != null) {
+                    callback.onSuccess();
+                }
+                if (connection.isConnected()) {
+                    try {
+                        @Nullable LevelChunk chunk = connection.getPlayer().getLevel().getChunkIfLoaded(ClientboundLevelChunkWithLightPacket.this.x, ClientboundLevelChunkWithLightPacket.this.z);
+                        if (chunk != null) {
+                            int sectionsCount = chunk.getSectionsCount();
+                            for (int sectionYIndex = 0; sectionYIndex < sectionsCount; sectionYIndex++) {
+                                SectionPos sectionPos = SectionPos.of(ClientboundLevelChunkWithLightPacket.this.x, chunk.getSectionYFromSectionIndex(sectionYIndex), ClientboundLevelChunkWithLightPacket.this.z);
+                                connection.updatePotentialBlockEntitiesInSection(sectionPos, false, chunk);
+                            }
+                        }
+                    } catch (Exception ignored) {
+                    }
+                }
+
+            }
+
+            @Override
+            public @Nullable Packet<?> onFailure() {
+                if (callback != null) {
+                    return callback.onFailure();
+                }
+                return null;
+            }
+
+        };
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java
index dc31aa80ead5765e0b8cc63aa890966ab0bf94a4..89cfc647eb9ab623e8ac92a8469ea09be26e9d0a 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundMerchantOffersPacket.java
@@ -3,6 +3,9 @@ package net.minecraft.network.protocol.game;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.item.trading.MerchantOffers;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundMerchantOffersPacket implements Packet<ClientGamePacketListener> {
     private final int containerId;
@@ -11,6 +14,10 @@ public class ClientboundMerchantOffersPacket implements Packet<ClientGamePacketL
     private final int villagerXp;
     private final boolean showProgress;
     private final boolean canRestock;
+    // Suki start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Suki end - custom blocks and items
 
     public ClientboundMerchantOffersPacket(int syncId, MerchantOffers recipes, int levelProgress, int experience, boolean leveled, boolean refreshable) {
         this.containerId = syncId;
@@ -68,4 +75,26 @@ public class ClientboundMerchantOffersPacket implements Packet<ClientGamePacketL
     public boolean canRestock() {
         return this.canRestock;
     }
+
+    // Suki start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundMerchantOffersPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
index 70ca28f06d0e8541c1130ff7b1b0bce21872b649..a85784a3644f55bc860f3568d656166e94984682 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSectionBlocksUpdatePacket.java
@@ -1,17 +1,33 @@
 package net.minecraft.network.protocol.game;
 
+import io.netty.util.concurrent.Future;
+import io.netty.util.concurrent.GenericFutureListener;
+import io.papermc.paper.util.CoordinateUtils;
+import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortIterator;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
+
+import java.util.Arrays;
 import java.util.function.BiConsumer;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
+import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.PacketSendListener;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.LevelChunkSection;
+import org.sucraft.suki.protocol.CachableCustomContentReplaceable;
+import org.sucraft.suki.protocol.ReplacedCustomContentCache;
+import org.bukkit.Chunk;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
-public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePacketListener> {
+public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePacketListener>, CachableCustomContentReplaceable<ClientboundSectionBlocksUpdatePacket> { // Suki - custom blocks and items
 
     private static final int POS_IN_SECTION_BITS = 12;
     // Suki start - limit packets per tick
@@ -21,6 +37,17 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
     // Suki end - limit packets per tick
     private final boolean suppressLightUpdates;
 
+    // Suki start - custom blocks and items
+
+    public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, short[] positions, BlockState[] states, boolean suppressLightUpdates) {
+        this.sectionPos = sectionPos;
+        this.positions = positions;
+        this.states = states;
+        this.suppressLightUpdates = suppressLightUpdates;
+    }
+
+    // Suki end - custom blocks and items
+
     public ClientboundSectionBlocksUpdatePacket(SectionPos sectionPos, ShortSet positions, LevelChunkSection section, boolean noLightingUpdates) {
         this.sectionPos = sectionPos;
         this.suppressLightUpdates = noLightingUpdates;
@@ -97,4 +124,64 @@ public class ClientboundSectionBlocksUpdatePacket implements Packet<ClientGamePa
         return this.suppressLightUpdates;
     }
 
+    // Suki start - custom blocks and items
+
+    private final ReplacedCustomContentCache<ClientboundSectionBlocksUpdatePacket> replacedCustomContentCache = new ReplacedCustomContentCache<>(this);
+
+    @Override
+    public @NotNull ClientboundSectionBlocksUpdatePacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        return this.replacedCustomContentCache.get(hasResourcePack);
+    }
+
+    @Override
+    public @NotNull ClientboundSectionBlocksUpdatePacket copy() {
+        return new ClientboundSectionBlocksUpdatePacket(
+            this.sectionPos,
+            this.positions,
+            Arrays.copyOf(this.states, this.states.length),
+            this.suppressLightUpdates
+        );
+    }
+
+    @Override
+    public void replaceCustomContentInPlace(boolean hasResourcePack) {
+        var stateIdReplacementArray = hasResourcePack ? Block.stateIdReplacementArrayWithResourcePack : Block.stateIdReplacementArrayWithoutResourcePack;
+        for (int i = 0; i < this.states.length; i++) {
+            int oldId = Block.BLOCK_STATE_REGISTRY.getId(states[i]);
+            int newId = stateIdReplacementArray[oldId];
+            if (oldId != newId) {
+                this.states[i] = Block.BLOCK_STATE_REGISTRY.byId(newId);
+            }
+        }
+    }
+
+    @Override
+    public @Nullable PacketSendListener updateCallbackWithBlockEntityPacketSends(@Nullable PacketSendListener callback, @NotNull Connection connection) {
+        return new PacketSendListener() {
+
+            @Override
+            public void onSuccess() {
+
+                if (callback != null) {
+                    callback.onSuccess();
+                }
+                if (connection.isConnected()) {
+                    connection.updatePotentialBlockEntitiesInSection(ClientboundSectionBlocksUpdatePacket.this.sectionPos, true, null, positions, states);
+                }
+
+            }
+
+            @Override
+            public @Nullable Packet<?> onFailure() {
+                if (callback != null) {
+                    return callback.onFailure();
+                }
+                return null;
+            }
+
+        };
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
index 3e17f6131bf590d7c4a16b79c1c145cb4f565bc9..7968d60a5ab0f3023fc79cd49bbf8a65ccc0c850 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEntityDataPacket.java
@@ -1,15 +1,21 @@
 package net.minecraft.network.protocol.game;
 
+import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Nullable;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.syncher.SynchedEntityData;
+import org.jetbrains.annotations.NotNull;
 
 public class ClientboundSetEntityDataPacket implements Packet<ClientGamePacketListener> {
     private final int id;
     @Nullable
     private final List<SynchedEntityData.DataItem<?>> packedItems;
+    // Suki start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Suki end - custom blocks and items
 
     public ClientboundSetEntityDataPacket(int id, SynchedEntityData tracker, boolean forceUpdateAll) {
         this.id = id;
@@ -22,6 +28,15 @@ public class ClientboundSetEntityDataPacket implements Packet<ClientGamePacketLi
 
     }
 
+    // Suki start - custom blocks and items
+
+    public ClientboundSetEntityDataPacket(int id) {
+        this.id = id;
+        this.packedItems = new ArrayList<>();
+    }
+
+    // Suki end - custom blocks and items
+
     public ClientboundSetEntityDataPacket(FriendlyByteBuf buf) {
         this.id = buf.readVarInt();
         this.packedItems = SynchedEntityData.unpack(buf);
@@ -46,4 +61,26 @@ public class ClientboundSetEntityDataPacket implements Packet<ClientGamePacketLi
     public int getId() {
         return this.id;
     }
+
+    // Suki start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundSetEntityDataPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
index 5a8f850b447fc3a4bd0eb0c505bbdfc8be7115e8..5d7c1595e75bb5f066115e3caf18c02dfed750be 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundSetEquipmentPacket.java
@@ -7,11 +7,18 @@ import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.entity.EquipmentSlot;
 import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketListener> {
     private static final byte CONTINUE_MASK = -128;
     private final int entity;
     private final List<Pair<EquipmentSlot, ItemStack>> slots;
+    // Suki start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Suki end - custom blocks and items
 
     public ClientboundSetEquipmentPacket(int id, List<Pair<EquipmentSlot, ItemStack>> equipmentList) {
         this.entity = id;
@@ -44,7 +51,11 @@ public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketLis
             boolean bl = j != i - 1;
             int k = equipmentSlot.ordinal();
             buf.writeByte(bl ? k | -128 : k);
-            buf.writeItem(pair.getSecond());
+            // Suki start - custom blocks and items
+            @org.jetbrains.annotations.Nullable ItemStack itemStack = pair.getSecond();
+            // This fixes a bug when this is called with a null itemStack, which happens because the null was already present in slots after a call to the ClientboundSetEquipmentPacket constructor from Connection.sendBlockEntitySetEquipmentPacket, which is caused by BlockReplacementRule.getBlockEntityItemStack returning null, which should not happen for blocks with block entities, but apparently in this case it accidentally does - should check later
+            buf.writeItem(itemStack == null ? ItemStack.EMPTY : itemStack);
+            // Suki end - custom blocks and items
         }
 
     }
@@ -61,4 +72,26 @@ public class ClientboundSetEquipmentPacket implements Packet<ClientGamePacketLis
     public List<Pair<EquipmentSlot, ItemStack>> getSlots() {
         return this.slots;
     }
+
+    // Suki start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundSetEquipmentPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java
index 053a66d714168f5e8a7cc5ff532190e80de887ca..31c957ed797fc52117875e5b737a784f8a61775a 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateAdvancementsPacket.java
@@ -11,12 +11,19 @@ import net.minecraft.advancements.AdvancementProgress;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
 
 public class ClientboundUpdateAdvancementsPacket implements Packet<ClientGamePacketListener> {
     private final boolean reset;
     private final Map<ResourceLocation, Advancement.Builder> added;
     private final Set<ResourceLocation> removed;
     private final Map<ResourceLocation, AdvancementProgress> progress;
+    // Suki start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Suki end - custom blocks and items
 
     public ClientboundUpdateAdvancementsPacket(boolean clearCurrent, Collection<Advancement> toEarn, Set<ResourceLocation> toRemove, Map<ResourceLocation, AdvancementProgress> toSetProgress) {
         this.reset = clearCurrent;
@@ -70,4 +77,26 @@ public class ClientboundUpdateAdvancementsPacket implements Packet<ClientGamePac
     public boolean shouldReset() {
         return this.reset;
     }
+
+    // Suki start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundUpdateAdvancementsPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
index e562a768ad400a6dca0f1546fb0dddbe72324eea..185cea6f1139ac776d141cadeecd535818afed9f 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundUpdateRecipesPacket.java
@@ -9,9 +9,15 @@ import net.minecraft.network.protocol.Packet;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.world.item.crafting.Recipe;
 import net.minecraft.world.item.crafting.RecipeSerializer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 public class ClientboundUpdateRecipesPacket implements Packet<ClientGamePacketListener> {
     private final List<Recipe<?>> recipes;
+    // Suki start - custom blocks and items
+    private @Nullable Boolean doesNetworkTargetHaveResourcePack = null;
+    private @Nullable Boolean doesNetworkTargetHaveHighPing = null;
+    // Suki end - custom blocks and items
 
     public ClientboundUpdateRecipesPacket(Collection<Recipe<?>> recipes) {
         this.recipes = Lists.newArrayList(recipes);
@@ -48,4 +54,26 @@ public class ClientboundUpdateRecipesPacket implements Packet<ClientGamePacketLi
         buf.writeResourceLocation(recipe.getId());
         ((RecipeSerializer<T>) recipe.getSerializer()).toNetwork(buf, recipe);
     }
+
+    // Suki start - custom blocks and items
+
+    @Override
+    public @NotNull ClientboundUpdateRecipesPacket replaceCustomContent(boolean hasResourcePack, boolean hasHighPing) {
+        this.doesNetworkTargetHaveResourcePack = hasResourcePack;
+        this.doesNetworkTargetHaveHighPing = hasHighPing;
+        return this;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveResourcePack() {
+        return this.doesNetworkTargetHaveResourcePack;
+    }
+
+    @Override
+    public @Nullable Boolean doesNetworkTargetHaveHighPing() {
+        return this.doesNetworkTargetHaveHighPing;
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/resources/ResourceKey.java b/src/main/java/net/minecraft/resources/ResourceKey.java
index b8cd7177d82c08604bc3654cc2098e78484551d2..95dd60f95d0b720eeff756326a6cfed45c986774 100644
--- a/src/main/java/net/minecraft/resources/ResourceKey.java
+++ b/src/main/java/net/minecraft/resources/ResourceKey.java
@@ -6,6 +6,8 @@ import java.util.Collections;
 import java.util.Map;
 import java.util.Optional;
 import net.minecraft.core.Registry;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
 
 public class ResourceKey<T> {
 
@@ -56,6 +58,14 @@ public class ResourceKey<T> {
         return this.location;
     }
 
+    // Suki start - custom resources
+
+    public @NotNull NamespacedKey asBukkit() {
+        return location().asBukkit();
+    }
+
+    // Suki end - custom resources
+
     public ResourceLocation registry() {
         return this.registryName;
     }
diff --git a/src/main/java/net/minecraft/resources/ResourceLocation.java b/src/main/java/net/minecraft/resources/ResourceLocation.java
index 50c284854aa2404cc821ba9cec66347c5d642c5e..97ca06ff241e0a83b30def2d5cd84926ef088a9d 100644
--- a/src/main/java/net/minecraft/resources/ResourceLocation.java
+++ b/src/main/java/net/minecraft/resources/ResourceLocation.java
@@ -17,7 +17,10 @@ import javax.annotation.Nullable;
 import net.minecraft.ResourceLocationException;
 import net.minecraft.network.chat.Component;
 import net.minecraft.util.GsonHelper;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
 import org.apache.commons.lang3.StringUtils;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
 
 public class ResourceLocation implements Comparable<ResourceLocation> {
     public static final Codec<ResourceLocation> CODEC = Codec.STRING.comapFlatMap(ResourceLocation::read, ResourceLocation::toString).stable();
@@ -50,10 +53,26 @@ public class ResourceLocation implements Comparable<ResourceLocation> {
 
     // Suki start - custom resources
 
+    public static ResourceLocation minecraft(String id) {
+        return new ResourceLocation(DEFAULT_NAMESPACE, id);
+    }
+
     public static ResourceLocation sucraft(String id) {
         return new ResourceLocation(SUCRAFT_NAMESPACE, id);
     }
 
+    public @NotNull NamespacedKey asBukkit() {
+        return new NamespacedKey(this.namespace, this.path);
+    }
+
+    public @NotNull ResourceLocation withPathSuffix(@NotNull String suffix) {
+        return new ResourceLocation(namespace, this.path + suffix);
+    }
+
+    public @NotNull ResourceLocation withPathPrefix(@NotNull String prefix) {
+        return new ResourceLocation(namespace, prefix + this.path);
+    }
+
     // Suki end - custom resources
 
     public static ResourceLocation of(String id, char delimiter) {
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index ae4acf8c3d5d05ebf34ca39921e1b78fa3e89a42..28a5ba62401cb808f5b8c52d4345a68eec9c0572 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -59,6 +59,7 @@ import net.minecraft.world.level.storage.LevelStorageSource;
 import net.minecraft.world.level.storage.LevelSummary;
 import org.sucraft.suki.biome.SuCraftBiomeTagsProvider;
 import org.sucraft.suki.data.BlackHoleCachedOutput;
+import org.sucraft.suki.resourcepack.httpserver.ResourcePackHTTPServer;
 import org.sucraft.suki.structure.SuCraftStructureTagsProvider;
 import org.slf4j.Logger;
 
@@ -304,6 +305,7 @@ public class Main {
 
                 return dedicatedserver1;
             });
+
             /* CraftBukkit start
             Thread thread = new Thread("Server Shutdown Thread") {
                 public void run() {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index cf3389f045e4b6cc0f48888be75c509e74a3f94b..c1e29b095a07b73559825be77c4f21cedb5547ec 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -153,6 +153,7 @@ import net.minecraft.world.level.storage.loot.LootTables;
 import net.minecraft.world.level.storage.loot.PredicateManager;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
+import org.sucraft.suki.resourcepack.httpserver.ResourcePackHTTPServer;
 import org.apache.commons.lang3.Validate;
 import org.slf4j.Logger;
 
@@ -1141,6 +1142,13 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<Runnab
             this.status.setEnforcesSecureChat(this.enforceSecureProfile());
             this.updateStatusIcon(this.status);
 
+            // Suki start - custom blocks and items
+
+            // Update the server properties in memory to match the resource pack and HTTP server
+            ResourcePackHTTPServer.getInstance().updateServerPropertiesInMemory(false);
+
+            // Suki end - custom blocks and items
+
             // Spigot start
             // Paper start - move done tracking
             LOGGER.info("Running delayed init tasks");
diff --git a/src/main/java/net/minecraft/server/PlayerAdvancements.java b/src/main/java/net/minecraft/server/PlayerAdvancements.java
index 90173d7c0e8fc41ecd70ffce81eaa624045eac70..22a9e365b7dec75d0f8613cc2f5106a05cd10189 100644
--- a/src/main/java/net/minecraft/server/PlayerAdvancements.java
+++ b/src/main/java/net/minecraft/server/PlayerAdvancements.java
@@ -61,7 +61,7 @@ public class PlayerAdvancements {
     private final File file;
     public final Map<Advancement, AdvancementProgress> advancements = Maps.newLinkedHashMap();
     private final Set<Advancement> visible = Sets.newLinkedHashSet();
-    private final Set<Advancement> visibilityChanged = Sets.newLinkedHashSet();
+    public final Set<Advancement> visibilityChanged = Sets.newLinkedHashSet(); // Suki - custom blocks and items // We use this to mark advancements as dirty to resend them when the resource pack status changes
     private final Set<Advancement> progressChanged = Sets.newLinkedHashSet();
     private ServerPlayer player;
     @Nullable
diff --git a/src/main/java/net/minecraft/server/commands/GiveCommand.java b/src/main/java/net/minecraft/server/commands/GiveCommand.java
index 00c481ebf012efa5424e32521e7aecf4b36f24c0..1809ec50f252d325095b59c18a2a2ee60e741f4d 100644
--- a/src/main/java/net/minecraft/server/commands/GiveCommand.java
+++ b/src/main/java/net/minecraft/server/commands/GiveCommand.java
@@ -2,6 +2,7 @@ package net.minecraft.server.commands;
 
 import com.mojang.brigadier.CommandDispatcher;
 import com.mojang.brigadier.arguments.IntegerArgumentType;
+import com.mojang.brigadier.builder.ArgumentBuilder;
 import com.mojang.brigadier.builder.LiteralArgumentBuilder;
 import com.mojang.brigadier.builder.RequiredArgumentBuilder;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
@@ -10,6 +11,7 @@ import java.util.Iterator;
 import net.minecraft.commands.CommandBuildContext;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.commands.arguments.ResourceLocationArgument;
 import net.minecraft.commands.arguments.item.ItemArgument;
 import net.minecraft.commands.arguments.item.ItemInput;
 import net.minecraft.network.chat.Component;
@@ -19,6 +21,7 @@ import net.minecraft.sounds.SoundSource;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
+import org.sucraft.suki.command.CustomItemArgument;
 
 public class GiveCommand {
 
@@ -26,16 +29,31 @@ public class GiveCommand {
 
     public GiveCommand() {}
 
+    // Suki start - custom blocks and items
+
+    @SuppressWarnings("unchecked")
     public static void register(CommandDispatcher<CommandSourceStack> dispatcher, CommandBuildContext commandRegistryAccess) {
-        dispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) net.minecraft.commands.Commands.literal("give").requires((commandlistenerwrapper) -> {
+        // This is not working, stopped working on this while in progress
+        var targetsArgument =
+            net.minecraft.commands.Commands.argument("targets", EntityArgument.players())
+                .then(((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("item", ItemArgument.item(commandRegistryAccess)).executes((commandcontext) -> {
+                    return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), ItemArgument.getItem(commandcontext, "item"), EntityArgument.getPlayers(commandcontext, "targets"), 1);
+                })).then(net.minecraft.commands.Commands.argument("count", IntegerArgumentType.integer(1)).executes((commandcontext) -> {
+                    return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), ItemArgument.getItem(commandcontext, "item"), EntityArgument.getPlayers(commandcontext, "targets"), IntegerArgumentType.getInteger(commandcontext, "count"));
+                })))
+                .then(((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("sucraft item", ResourceLocationArgument.id())).executes((commandcontext) -> {
+                    return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), CustomItemArgument.getItem(commandcontext, "sucraft item"), EntityArgument.getPlayers(commandcontext, "targets"), 1);
+                }).then(net.minecraft.commands.Commands.argument("count", IntegerArgumentType.integer(1)).executes((commandcontext) -> {
+                    return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), CustomItemArgument.getItem(commandcontext, "sucraft item"), EntityArgument.getPlayers(commandcontext, "targets"), IntegerArgumentType.getInteger(commandcontext, "count"));
+                })));
+        var giveCommand = (LiteralArgumentBuilder) net.minecraft.commands.Commands.literal("give").requires((commandlistenerwrapper) -> {
             return commandlistenerwrapper.hasPermission(2);
-        })).then(net.minecraft.commands.Commands.argument("targets", EntityArgument.players()).then(((RequiredArgumentBuilder) net.minecraft.commands.Commands.argument("item", ItemArgument.item(commandRegistryAccess)).executes((commandcontext) -> {
-            return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), ItemArgument.getItem(commandcontext, "item"), EntityArgument.getPlayers(commandcontext, "targets"), 1);
-        })).then(net.minecraft.commands.Commands.argument("count", IntegerArgumentType.integer(1)).executes((commandcontext) -> {
-            return GiveCommand.giveItem((CommandSourceStack) commandcontext.getSource(), ItemArgument.getItem(commandcontext, "item"), EntityArgument.getPlayers(commandcontext, "targets"), IntegerArgumentType.getInteger(commandcontext, "count"));
-        })))));
+        }).then(targetsArgument);
+        dispatcher.register(giveCommand);
     }
 
+    // Suki end - custom blocks and items
+
     private static int giveItem(CommandSourceStack source, ItemInput item, Collection<ServerPlayer> targets, int count) throws CommandSyntaxException {
         int j = item.getItem().getMaxStackSize();
         int k = j * 100;
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 60ba00eb6daeeb9b97281f9380d373af3cc29402..28392b0e65258ec791817bcf6a861a0ac83c496f 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -13,11 +13,16 @@ import java.net.Proxy;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Comparator;
+import java.util.IdentityHashMap;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 import java.util.Optional;
 import java.util.function.BooleanSupplier;
+import java.util.stream.StreamSupport;
 import javax.annotation.Nullable;
 import net.minecraft.DefaultUncaughtExceptionHandler;
 import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
@@ -27,6 +32,7 @@ import net.minecraft.Util;
 import net.minecraft.commands.CommandSourceStack;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.NonNullList;
+import net.minecraft.core.Registry;
 import net.minecraft.nbt.Tag;
 import net.minecraft.server.ConsoleInput;
 import net.minecraft.server.MinecraftServer;
@@ -49,12 +55,19 @@ import net.minecraft.util.Mth;
 import net.minecraft.util.monitoring.jmx.MinecraftServerStatistics;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.CreativeModeTab;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
+import net.minecraft.world.item.crafting.RecipeType;
 import net.minecraft.world.level.DataPackConfig;
 import net.minecraft.world.level.GameRules;
 import net.minecraft.world.level.GameType;
 import net.minecraft.world.level.block.entity.SkullBlockEntity;
 import net.minecraft.world.level.storage.LevelStorageSource;
+import org.sucraft.suki.item.ItemReplacementRule;
+import org.sucraft.suki.item.SuCraftCraftingRecipeProvider;
+import org.sucraft.suki.resourcepack.httpserver.ResourcePackHTTPServer;
+import org.sucraft.suki.resourcepack.sucraft.CreateSuCraftResourcePack;
 import org.slf4j.Logger;
 
 // CraftBukkit start
@@ -277,6 +290,63 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             return false;
         }
 
+        // Suki start - custom blocks and items
+
+        SuCraftCraftingRecipeProvider.run();
+
+        // Now that we have all the recipes added, we should set some stonecutter hosts for those items that require it
+        { // Create a scope to make sure we don't use any of these variables later - we want them to be garbage collected
+            Map<Item, List<Item>> ingredientToResult = new IdentityHashMap<>();
+            Map<Item, List<Item>> resultToIngredient = new IdentityHashMap<>();
+            MinecraftServer.getServer().getRecipeManager().getAllRecipesFor(RecipeType.STONECUTTING).forEach(recipe -> {
+                recipe.getIngredients().forEach(ingredient -> {
+                    if (ingredient.getItems() != null) {
+                        for (ItemStack itemStack : ingredient.getItems()) {
+                            ingredientToResult.computeIfAbsent(itemStack.getItem(), $ -> new ArrayList<>(1)).add(recipe.getResultItem().getItem());
+                            resultToIngredient.computeIfAbsent(recipe.getResultItem().getItem(), $ -> new ArrayList<>(1)).add(itemStack.getItem());
+                        }
+                    }
+                });
+            });
+//            System.out.println("TEMP DEBUG - Ingredient to result: " + ingredientToResult);
+//            System.out.println("TEMP DEBUG - Result to ingredient: " + resultToIngredient);
+            Map<Item, Integer> ingredientToIngredientGroupIndex = new IdentityHashMap<>();
+            int nextGroupIndex = 0;
+            for (Item resultToIngredientKey : resultToIngredient.keySet().stream().sorted(Comparator.comparing(item -> item.id.toString())).toList()) {
+                List<Item> resultToIngredientValue = resultToIngredient.get(resultToIngredientKey);
+                final int finalNextGroupIndex = nextGroupIndex;
+                for (Item ingredient : resultToIngredientValue) {
+                    Integer existingGroupIndex = ingredientToIngredientGroupIndex.get(ingredient);
+                    if (existingGroupIndex != null) {
+                        ingredientToIngredientGroupIndex.replaceAll((item, index) -> index.equals(existingGroupIndex) ? finalNextGroupIndex : index);
+                    } else {
+                        ingredientToIngredientGroupIndex.put(ingredient, nextGroupIndex);
+                    }
+                }
+                nextGroupIndex++;
+            }
+//            System.out.println("TEMP DEBUG - Ingredient to ingredient group index: " + ingredientToIngredientGroupIndex);
+            ingredientToIngredientGroupIndex.values().stream().toList().stream().distinct().sorted().map(index -> ingredientToIngredientGroupIndex.entrySet().stream().filter(entry -> entry.getValue().equals(index)).map(entry -> entry.getKey()).toList()).forEach(groupIngredients -> {
+                groupIngredients = groupIngredients.stream().sorted(Comparator.comparing(item -> item.id.toString())).toList();
+//                System.out.println("TEMP DEBUG - Doing group ingredients: " + groupIngredients);
+                var groupResults = groupIngredients.stream().flatMap(ingredient -> ingredientToResult.get(ingredient).stream().sorted(Comparator.comparing(item -> item.id.toString()))).distinct().sorted(Comparator.comparing(item -> ((Item) item).id.toString())).toList();
+//                System.out.println("TEMP DEBUG - group results: " + groupResults);
+                List<Item> potentialHosts = StreamSupport.stream(Registry.ITEM.spliterator(), false).filter(item -> item.isVanilla && Registry.BLOCK.containsKey(item.id) && !groupResults.contains(item)).sorted(Comparator.comparing(item -> item.getDescriptionId())).toList();
+                var customGroupResults = groupResults.stream().filter(result -> !result.isVanilla).toList();
+                for (int i = 0; i < customGroupResults.size(); i++) {
+                    var replacementRule = customGroupResults.get(i).replacementRule;
+                    var host = potentialHosts.get(potentialHosts.size() - customGroupResults.size() + i);
+//                    System.out.println("TEMP DEBUG - for group result " + customGroupResults.get(i) + " using host " + host);
+                    replacementRule.setStonecutterRecipeHost(host);
+                }
+            });
+        }
+
+        // This is a reasonable time to create the resource pack
+        CreateSuCraftResourcePack.createAndWrite();
+
+        // Suki end - custom blocks and items
+
         // CraftBukkit start
         // this.setPlayerList(new DedicatedPlayerList(this, this.registryHolder, this.playerDataStorage)); // Spigot - moved up
         server.loadPlugins();
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 907e6ee49a703021a3af7ecc53c70f518eea181e..0539661e026d9cc4058856ebf35094e04845d158 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -64,6 +64,7 @@ import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
 import net.minecraft.Util;
+import net.minecraft.core.BlockPos;
 import net.minecraft.core.Registry;
 import net.minecraft.core.SectionPos;
 import net.minecraft.nbt.CompoundTag;
@@ -112,8 +113,10 @@ import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import net.minecraft.world.phys.Vec3;
 import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet; // Paper
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelProximity;
 import org.apache.commons.lang3.mutable.MutableBoolean;
 import org.apache.commons.lang3.mutable.MutableObject;
+import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.slf4j.Logger;
 import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
 import org.bukkit.entity.Player;
@@ -1712,7 +1715,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     // Paper end - replace player loader system
 
-    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Suki - per-player track and see view distance
+    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<ImmutablePair<Boolean, Boolean>, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Suki - per-player track and see view distance // Suki - custom blocks and items
         if (player.level == this.level) {
             if (newWithinViewDistance && !oldWithinViewDistance) {
                 ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
@@ -2020,6 +2023,66 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
         SectionPos sectionposition = player.getLastSectionPos();
         SectionPos sectionposition1 = SectionPos.of((EntityAccess) player);
+        // Suki start - custom blocks and items
+        BlockPos newBlockPos = player.blockPosition;
+        var connection = player.connection;
+        if (connection != null) {
+            if (!connection.isDisconnected()) {
+                var connection2 = connection.connection;
+                if (connection2 != null && connection2.isConnected()) {
+                    if (!sectionposition.equals(sectionposition1) || !connection2.hasUpdatedBlockEntitiesClosebyModelForSections) {
+                        connection2.hasUpdatedBlockEntitiesClosebyModelForSections = true;
+                        LongSet fromAndToSectionsAndChessboardNeighbors = new LongOpenHashSet((BlockEntityModelProximity.maxSectionDistanceForNeighbors * 2 + 1) * (BlockEntityModelProximity.maxSectionDistanceForNeighbors * 2 + 1) * (BlockEntityModelProximity.maxSectionDistanceForNeighbors * 2 + 1) * 2 * 2);
+                        for (SectionPos oldOrNewSectionPos : new SectionPos[]{sectionposition, sectionposition1}) {
+                            for (int dx = -BlockEntityModelProximity.maxSectionDistanceForNeighbors; dx <= BlockEntityModelProximity.maxSectionDistanceForNeighbors; dx++) {
+                                for (int dy = -BlockEntityModelProximity.maxSectionDistanceForNeighbors; dy <= BlockEntityModelProximity.maxSectionDistanceForNeighbors; dy++) {
+                                    for (int dz = -BlockEntityModelProximity.maxSectionDistanceForNeighbors; dz <= BlockEntityModelProximity.maxSectionDistanceForNeighbors; dz++) {
+                                        int nx = oldOrNewSectionPos.x() + dx;
+                                        int ny = oldOrNewSectionPos.y() + dy;
+                                        int nz = oldOrNewSectionPos.z() + dz;
+                                        if (ny >= level.getMinSection() && ny <= level.getMaxSection()) {
+                                            SectionPos neighbor = SectionPos.of(nx, ny, nz);
+                                            if (level.isLoadedAndInBounds(new BlockPos(neighbor.minBlockX(), neighbor.minBlockY(), neighbor.minBlockZ()))) {
+                                                long neighborKey = neighbor.asLong();
+                                                if (fromAndToSectionsAndChessboardNeighbors.add(neighborKey)) {
+                                                    connection2.updateBlockEntitiesClosebyModelInChunkSection(neighborKey, sectionposition1, newBlockPos);
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    } else if (player.lastBlockPos == null || !player.lastBlockPos.equals(newBlockPos)) {
+                        LongSet fromAndToBlocksAndChessboardNeighbors = new LongOpenHashSet((BlockEntityModelProximity.maxBlockDistanceForNeighbors * 2 + 1) * (BlockEntityModelProximity.maxBlockDistanceForNeighbors * 2 + 1) * (BlockEntityModelProximity.maxBlockDistanceForNeighbors * 2 + 1) * 2 * 2);
+                        for (BlockPos oldOrNewBlockPos : new BlockPos[]{player.lastBlockPos, newBlockPos}) {
+                            if (oldOrNewBlockPos != null) {
+                                for (int dx = -BlockEntityModelProximity.maxBlockDistanceForNeighbors; dx <= BlockEntityModelProximity.maxBlockDistanceForNeighbors; dx++) {
+                                    for (int dy = -BlockEntityModelProximity.maxBlockDistanceForNeighbors; dy <= BlockEntityModelProximity.maxBlockDistanceForNeighbors; dy++) {
+                                        for (int dz = -BlockEntityModelProximity.maxBlockDistanceForNeighbors; dz <= BlockEntityModelProximity.maxBlockDistanceForNeighbors; dz++) {
+                                            int nx = oldOrNewBlockPos.getX() + dx;
+                                            int ny = oldOrNewBlockPos.getY() + dy;
+                                            int nz = oldOrNewBlockPos.getZ() + dz;
+                                            if (ny >= level.getMinBuildHeight() && ny <= level.getMaxBuildHeight()) {
+                                                BlockPos neighbor = new BlockPos(nx, ny, nz);
+                                                if (level.isLoadedAndInBounds(neighbor)) {
+                                                    long neighborKey = neighbor.asLong();
+                                                    if (fromAndToBlocksAndChessboardNeighbors.add(neighborKey)) {
+                                                        connection2.updateBlockEntitiesClosebyModelForBlock(neighborKey, sectionposition1, newBlockPos);
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        player.lastBlockPos = newBlockPos;
+        // Suki end - custom blocks and items
         long k = sectionposition.chunk().toLong();
         long l = sectionposition1.chunk().toLong();
         boolean flag = this.playerMap.ignored(player);
@@ -2330,13 +2393,16 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - Fix MC-162253
 
     // Paper start - Anti-Xray - Bypass
-    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Suki - per-player track and see view distance
+    public void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<ImmutablePair<Boolean, Boolean>, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Suki - per-player track and see view distance // Suki - custom blocks and items
         if (cachedDataPackets.getValue() == null) {
             cachedDataPackets.setValue(new java.util.HashMap<>());
         }
 
         Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-        player.trackChunk(chunk.getPos(), (Packet) cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
+        // Suki start - custom blocks and items
+        boolean hasResourcePack = player.hasSuCraftResourcePack();
+        player.trackChunk(chunk.getPos(), cachedDataPackets.getValue().computeIfAbsent(new ImmutablePair<>(shouldModify, hasResourcePack), (s) -> {
+            // Suki end - custom blocks and items
             // Paper start - Fix MC-162253
             final int viewDistance = getVanillaWorldViewDistance(); // Suki - per-player view distance
             final int playerChunkX = player.getBlockX() >> 4;
@@ -2376,7 +2442,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 }
             }
             // Paper end - Fix MC-162253
-            return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
+            return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, s.left, s.right); // Suki - custom blocks and items
         }), concernsTracking);
         // Paper end
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
diff --git a/src/main/java/net/minecraft/server/level/ServerEntity.java b/src/main/java/net/minecraft/server/level/ServerEntity.java
index 09be313aefd5dda15bd4db6ee0324b2aec879744..0d1640a07ee883e47537d475b4f35591b15fdcf4 100644
--- a/src/main/java/net/minecraft/server/level/ServerEntity.java
+++ b/src/main/java/net/minecraft/server/level/ServerEntity.java
@@ -31,6 +31,7 @@ import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.Mob;
 import net.minecraft.world.entity.ai.attributes.AttributeInstance;
 import net.minecraft.world.entity.decoration.ItemFrame;
+import net.minecraft.world.entity.item.FallingBlockEntity;
 import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.MapItem;
@@ -75,7 +76,16 @@ public class ServerEntity {
         this.level = worldserver;
         this.broadcast = consumer;
         this.entity = entity;
-        this.updateInterval = i;
+        // Suki start - custom blocks and items
+        boolean useSmallerUpdateIntervalForCustomFallingBlocks = false;
+        if (entity instanceof FallingBlockEntity fallingBlockEntity) {
+            var replacementRule = fallingBlockEntity.getBlockState().getBlock().replacementRule;
+            if (replacementRule != null && replacementRule.hasAsReal(fallingBlockEntity.getBlockState().getBlock()) && replacementRule.rendersAsEntity(fallingBlockEntity.getBlockState())) {
+                useSmallerUpdateIntervalForCustomFallingBlocks = true;
+            }
+        }
+        this.updateInterval = useSmallerUpdateIntervalForCustomFallingBlocks ? 1 : i;
+        // Suki end - custom blocks and items
         this.trackDelta = flag;
         this.positionCodec.setBase(entity.trackingPosition());
         this.yRotp = Mth.floor(entity.getYRot() * 256.0F / 360.0F);
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 63479e24d2d28f275d05485e15c798c0b1a4cca7..b4ded6c14bf8b6c2a169565f7913c59fe887701e 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -9,8 +9,10 @@ import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 
 import java.util.ArrayDeque;
+import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
@@ -18,7 +20,10 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.Random;
+import java.util.Set;
 import java.util.UUID;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 
@@ -96,6 +101,7 @@ import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.ClientboundSystemChatPacket;
 import net.minecraft.network.protocol.game.ClientboundUpdateMobEffectPacket;
+import net.minecraft.network.protocol.game.ClientboundUpdateRecipesPacket;
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
 import net.minecraft.network.protocol.status.ServerStatus;
@@ -140,6 +146,7 @@ import net.minecraft.world.inventory.ContainerSynchronizer;
 import net.minecraft.world.inventory.HorseInventoryMenu;
 import net.minecraft.world.inventory.ResultSlot;
 import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.inventory.StonecutterMenu;
 import net.minecraft.world.item.ComplexItem;
 import net.minecraft.world.item.ItemCooldowns;
 import net.minecraft.world.item.ItemStack;
@@ -169,6 +176,7 @@ import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.portal.PortalInfo;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
+import org.apache.commons.lang3.mutable.MutableObject;
 import org.slf4j.Logger;
 import net.minecraft.world.Container;
 import net.minecraft.world.InteractionHand;
@@ -517,6 +525,7 @@ public class ServerPlayer extends Player {
     @Nullable
     private Vec3 enteredLavaOnVehiclePosition;
     private SectionPos lastSectionPos;
+    public @Nullable BlockPos lastBlockPos; // Suki - custom blocks and items
     private ResourceKey<Level> respawnDimension;
     @Nullable
     private BlockPos respawnPosition;
@@ -561,7 +570,7 @@ public class ServerPlayer extends Player {
 
     private int maxNumberOfChunkPacketsInTransitBasedOnConnection = GlobalConfiguration.get().networkConstrainedChunkSending.maxChunkPacketsInTransit.initial;
     // Keep track of chunk packets in transit
-    private final ArrayDeque<ChunkPacketInTransit> chunkInitializationPacketsInTransitKeepaliveIds = new ArrayDeque<>();
+    public final ArrayDeque<ChunkPacketInTransit> chunkInitializationPacketsInTransitKeepaliveIds = new ArrayDeque<>(); // Suki - custom blocks and items
 
     public int getMaxNumberOfChunkPacketsInTransitBasedOnConnection() {
         synchronized (this.networkConstrainedSendingLock) {
@@ -617,6 +626,11 @@ public class ServerPlayer extends Player {
     }
 
     public boolean canSendChunkInitializationPacketNow(ChunkPos chunk) {
+        // Suki start - custom blocks and items
+        if (getBukkitEntity().getResourcePackStatus() == null) {
+            return false;
+        }
+        // Suki end - custom blocks and items
         if (getChessboardDistanceToChunk(chunk) <= GlobalConfiguration.get().networkConstrainedChunkSending.ignoreNetworkConditionsForChunksWithinChessboardDistance) return true;
         synchronized (this.networkConstrainedSendingLock) {
             return this.chunkInitializationPacketsInTransitKeepaliveIds.size() < this.maxNumberOfChunkPacketsInTransitBasedOnConnection;
@@ -2408,7 +2422,12 @@ public class ServerPlayer extends Player {
     }
 
     public void sendTexturePack(String url, String hash, boolean required, @Nullable Component resourcePackPrompt) {
-        this.connection.send(new ClientboundResourcePackPacket(url, hash, required, resourcePackPrompt));
+        // Suki start - custom blocks and items
+        if (this.canAcceptServerResourcePack()) {
+            this.connection.send(new ClientboundResourcePackPacket(url, hash, required, resourcePackPrompt));
+        }
+        this.connection.connection.updateLastResourcePackSendTick();
+        // Suki end - custom blocks and items
     }
 
     public void sendServerStatus(ServerStatus metadata) {
@@ -2946,4 +2965,163 @@ public class ServerPlayer extends Player {
     // CraftBukkit end
 
     public final int getViewDistance() { throw new UnsupportedOperationException("Use PlayerChunkLoader"); } // Paper - placeholder
+
+    // Suki start - custom blocks and items
+
+    public boolean hasSuCraftResourcePack() {
+        var bukkitPlayer = this.getBukkitEntity();
+        if (bukkitPlayer == null) {
+            return false;
+        }
+        return bukkitPlayer.hasSuCraftResourcePack();
+    }
+
+    public boolean hasHighPingForCustomBlocks() {
+        var bukkitPlayer = this.getBukkitEntity();
+        if (bukkitPlayer == null) {
+            return false;
+        }
+        return bukkitPlayer.hasHighPingForCustomBlocks();
+    }
+
+    public boolean canAcceptLargePackets() {
+        for (Predicate<org.bukkit.entity.Player> disjunct : this.getServer().getPlayerList().canAcceptLargePacketsDisjuncts) {
+            if (disjunct.test(this.getBukkitEntity())) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean canAcceptServerResourcePack() {
+        for (Predicate<org.bukkit.entity.Player> disjunct : this.getServer().getPlayerList().canAcceptServerResourcePackDisjuncts) {
+            if (disjunct.test(this.getBukkitEntity())) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public void resendInventory() {
+        this.getBukkitEntity().updateInventory();
+    }
+
+    private @Nullable Set<ResourceLocation> lastSentSpecificRecipeIds = null;
+
+    public final @NotNull Comparator<Recipe<?>> RECIPE_ORDER = (recipe1, recipe2) -> {
+        // Suki start - custom blocks and items
+        var descriptionId1 = recipe1.getReplacedResultItemDescriptionId(this);
+        var descriptionId2 = recipe2.getReplacedResultItemDescriptionId(this);
+        int descriptionIdCompare = descriptionId1.compareTo(descriptionId2);
+        if (descriptionIdCompare != 0) {
+            return descriptionIdCompare;
+        }
+        return Integer.compare(descriptionId1.hashCode(), descriptionId2.hashCode());
+        // Suki end - custom blocks and items
+    };
+
+    public void resendCraftingRecipes(@Nullable ItemStack stonecutterInput, int iteration) {
+
+        Collection<Recipe<?>> allRecipes = this.server.getRecipeManager().getRecipes();
+        boolean canPlayerAcceptLargePackets = this.canAcceptLargePackets();
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - stonecutter custom is: " + MinecraftServer.getServer().getRecipeManager().stonecutterRecipesThatAreCustom.stream().map(Object::toString).sorted().toList());
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Too large would include: " + MinecraftServer.getServer().getRecipeManager().recipesSkippableForPlayersThatCannotAcceptLargePackets.stream().map(Object::toString).sorted().toList());
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Can accept large packets: " + canPlayerAcceptLargePackets);
+
+        if (!this.hasSuCraftResourcePack()) {
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - No resource pack");
+            if (this.lastSentSpecificRecipeIds != null && lastSentSpecificRecipeIds.isEmpty()) {
+                return;
+            }
+            var recipesToSend = allRecipes.stream().filter(recipe -> recipe.shouldAlwaysSend(canPlayerAcceptLargePackets)).toList();
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - Number of recipes to send: " + recipesToSend.size());
+            this.lastSentSpecificRecipeIds = Collections.emptySet();
+            this.connection.send(new ClientboundUpdateRecipesPacket(recipesToSend));
+            this.getRecipeBook().sendInitialRecipeBook(this);
+            return;
+        }
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Yes resource pack");
+
+        if (stonecutterInput == null) {
+            if (this.containerMenu instanceof StonecutterMenu stonecutterMenu) {
+                stonecutterInput = stonecutterMenu.container.getItem(StonecutterMenu.INPUT_SLOT);
+            }
+        }
+
+        final @Nullable ItemStack finalStonecutterInput = stonecutterInput;
+        List<Recipe<?>> alwaysRecipesToSend = new ArrayList<>(allRecipes.size());
+        List<Recipe<?>> specificRecipesToSend = new ArrayList<>(4);
+        List<Recipe<?>> allRecipesToSend = new ArrayList<>(allRecipes.size());
+        allRecipes.forEach(recipe -> {
+            if (recipe.shouldAlwaysSend(canPlayerAcceptLargePackets)) {
+                alwaysRecipesToSend.add(recipe);
+                allRecipesToSend.add(recipe);
+            } else if (recipe.shouldSpecificallySend(this, finalStonecutterInput)) {
+                specificRecipesToSend.add(recipe);
+                allRecipesToSend.add(recipe);
+            }
+        });
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Number of always recipes to send: " + alwaysRecipesToSend.size());
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Number of specific recipes to send: " + specificRecipesToSend.size());
+//        MinecraftServer.LOGGER.info("TEMP DEBUG - Number of total recipes to send: " + allRecipesToSend.size());
+        Set<ResourceLocation> willSendSpecificRecipeIds = specificRecipesToSend.stream().map(recipe -> recipe.getId()).collect(Collectors.toSet());
+
+        if (this.lastSentSpecificRecipeIds == null || !this.lastSentSpecificRecipeIds.equals(willSendSpecificRecipeIds)) {
+            allRecipesToSend.sort(RECIPE_ORDER);
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - all: " + allRecipesToSend.stream().map(recipe -> recipe.getResultItem().getItem()).toList());
+//            Collections.shuffle(allRecipesToSend);
+            this.lastSentSpecificRecipeIds = willSendSpecificRecipeIds;
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - Sending the following: " + allRecipesToSend.stream().map(recipe -> recipe.getId().toString()).sorted().toList());
+            this.connection.send(new ClientboundUpdateRecipesPacket(allRecipesToSend));
+            this.getRecipeBook().sendInitialRecipeBook(this);
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - specific: " + specificRecipesToSend.stream().sorted(RECIPE_ORDER).map(recipe -> recipe.getResultItem().getItem()).toList());
+        }
+
+        if (iteration < 3 && iteration >= 0) {
+            if (this.containerMenu instanceof StonecutterMenu stonecutterMenu) {
+                this.connection.send(new ClientboundContainerSetSlotPacket(containerMenu.containerId, containerMenu.getStateId(), StonecutterMenu.INPUT_SLOT, new ItemStack(Items.AIR, 0)));
+            }
+            this.resendInventory();
+            Bukkit.getScheduler().runTaskLater(Bukkit.getPluginManager().getPlugins()[0], () -> this.resendCraftingRecipes(null, iteration + 1), 1);
+        }
+
+    }
+
+    public void resendAdvancements() {
+        this.advancements.visibilityChanged.addAll(this.advancements.advancements.keySet());
+        this.advancements.flushDirty(this);
+    }
+
+    public void resendAllSentChunks() {
+        if (!this.isAlive()) {
+            // Chunks cannot be untracked or tracked while dead
+            return;
+        }
+        net.minecraft.server.level.ChunkMap chunkMap = this.getLevel().getChunkSource().chunkMap;
+        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this);
+        if (data != null) {
+            LongSet sentTrackChunks = data.getSentChunks(true);
+            LongSet sentSeeChunks = data.getSentChunks(false);
+            // For all chunk keys, we will naively untrack and track the chunks all at once (bypassing the entire network-constrained chunk sending system, which would normally also call the untrackand track methods at the right times)
+            for (long chunkKey : sentSeeChunks) {
+                ChunkPos chunkPos = new ChunkPos(chunkKey);
+                int chunkX = chunkPos.x;
+                int chunkZ = chunkPos.z;
+                boolean concernsTracking = sentTrackChunks.contains(chunkKey);
+                // Untrack the chunk
+                this.untrackChunk(chunkPos, concernsTracking);
+                // Track the chunk (note that this will send a network-constrained chunk sending fake keep-alive packet too, and thereby increase the number of packets in transit according to that system, which should cause the network-constrained chunk sending system to wait appropriately for enough of these packets to arrive before sending any more)
+                // ChunkMap.playerLoadedChunk is basically ServerPlayer.trackChunk in this scenario, but it re-computes the chunk data to send based on the resource pack status
+                LevelChunk chunk = chunkMap.level.getChunkIfLoaded(chunkX, chunkZ);
+                // We don't want to suddenly load a chunk here, so we simply ignore this chunk if it is somehow not loaded anymore - too bad, but this should never happen or be so rare it is not significant
+                if (chunk == null) {
+                    continue;
+                }
+                chunkMap.playerLoadedChunk(this, new MutableObject<>(), chunk, concernsTracking);
+            }
+        }
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
index 615ae506972ee0f7df842d18b3060577cb5272e1..d946e44c0c85b09441209a15ae5a73c5fc801da7 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -59,6 +59,7 @@ public class ServerPlayerGameMode {
     private boolean isDestroyingBlock;
     private int destroyProgressStart;
     private BlockPos destroyPos;
+    private int destroySequence; // Suki - custom blocks and items
     private int gameTicks;
     private boolean hasDelayedDestroy;
     private BlockPos delayedDestroyPos;
@@ -153,7 +154,16 @@ public class ServerPlayerGameMode {
                 this.lastSentState = -1;
                 this.isDestroyingBlock = false;
             } else {
-                this.incrementDestroyProgress(iblockdata, this.destroyPos, this.destroyProgressStart);
+                // Suki start - custom blocks and items
+                float f = this.incrementDestroyProgress(iblockdata, this.destroyPos, this.destroyProgressStart);
+                // Arbitrary choices: 1.5f is about double the usual check amount when a player sends a block break finish packet (0.7f), and it seems to work very well
+                // The minimum ticks of 7 is because otherwise it seems that for good tools, it breaks way too quickly
+                if (iblockdata.getBlock().breakBeforeClientKnowsToBreak && f >= 1.5f && this.gameTicks - this.destroyProgressStart >= 7) {
+                    this.isDestroyingBlock = false;
+                    this.level.destroyBlockProgress(this.player.getId(), this.destroyPos, -1);
+                    this.destroyAndAck(this.destroyPos, this.destroySequence, "destroyed");
+                }
+                // Suki end - custom blocks and items
             }
         }
 
@@ -304,6 +314,7 @@ public class ServerPlayerGameMode {
 
                     this.isDestroyingBlock = true;
                     this.destroyPos = pos.immutable();
+                    this.destroySequence = sequence; // Suki - custom blocks and items
                     int k = (int) (f * 10.0F);
 
                     this.level.destroyBlockProgress(this.player.getId(), pos, k);
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 7bc0f0ec1fb6ed7cc21e02eb0e93a965173a767b..972855ebd3fce6afdefa3cd6056f7aed86e91149 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -159,6 +159,7 @@ import net.minecraft.world.entity.player.Inventory;
 import net.minecraft.world.entity.player.ProfilePublicKey;
 import net.minecraft.world.entity.projectile.AbstractArrow;
 import net.minecraft.world.entity.vehicle.Boat;
+import net.minecraft.world.inventory.StonecutterMenu;
 import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.BucketItem;
 import net.minecraft.world.item.Item;
@@ -187,6 +188,7 @@ import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import org.sucraft.suki.item.ItemReplacementRule;
 import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
 
@@ -2105,7 +2107,31 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
         }
         // Paper start
         PlayerResourcePackStatusEvent.Status packStatus = PlayerResourcePackStatusEvent.Status.values()[packet.action.ordinal()];
+
+        // Suki start - custom blocks and items
+
+        @Nullable PlayerResourcePackStatusEvent.Status oldPackStatus = this.player.getBukkitEntity().getResourcePackStatus();
+
+        // Update the player's packet status before resending anything, so that it can be used by for example ChunkMap.playerLoadedChunk to correctly compute the chunk data to send
         player.getBukkitEntity().setResourcePackStatus(packStatus);
+
+        if ((oldPackStatus == PlayerResourcePackStatusEvent.Status.ACCEPTED || oldPackStatus == PlayerResourcePackStatusEvent.Status.SUCCESSFULLY_LOADED) && (packStatus == PlayerResourcePackStatusEvent.Status.DECLINED || packStatus == PlayerResourcePackStatusEvent.Status.FAILED_DOWNLOAD)) {
+            // Resend most of the potentially already sent data if we previously thought the player had accepted the resource pack, but now they no longer do
+            this.player.resendInventory();
+            this.player.resendAllSentChunks();
+            this.player.resendCraftingRecipes(null, -1);
+            this.player.resendAdvancements();
+            this.player.chunkInitializationPacketsInTransitKeepaliveIds.clear(); // Don't delay starting sending chunks even if some are already in transit
+        } else if (oldPackStatus == null && (packStatus == PlayerResourcePackStatusEvent.Status.ACCEPTED || packStatus == PlayerResourcePackStatusEvent.Status.SUCCESSFULLY_LOADED)) {
+            // Resend their inventory (we have not sent any chunks yet if this is true, so we do not need to resend any)
+            this.player.resendInventory();
+            this.player.resendCraftingRecipes(null, -1);
+            this.player.resendAdvancements();
+            this.player.chunkInitializationPacketsInTransitKeepaliveIds.clear(); // Don't delay starting sending chunks even if some are already in transit
+        }
+
+        // Suki end - custom blocks and items
+
         this.cserver.getPluginManager().callEvent(new PlayerResourcePackStatusEvent(this.getCraftPlayer(), packStatus)); // CraftBukkit
         // Paper end
     }
@@ -3361,6 +3387,17 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
                             return;
                         }
 
+                        // Suki start - custom blocks and items
+
+                        if (this.player.containerMenu instanceof StonecutterMenu stonecutterMenu) {
+                            ItemStack intoInputStack = ItemReplacementRule.reverseReplacement(packet.getChangedSlots().get(StonecutterMenu.INPUT_SLOT));
+                            if (intoInputStack != null) {
+                                this.player.resendCraftingRecipes(intoInputStack, 0);
+                            }
+                        }
+
+                        // Suki end - custom blocks and items
+
                         switch (event.getResult()) {
                             case ALLOW:
                             case DEFAULT:
@@ -3428,10 +3465,10 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
                     while (objectiterator.hasNext()) {
                         Entry<ItemStack> entry = (Entry) objectiterator.next();
 
-                        this.player.containerMenu.setRemoteSlotNoCopy(entry.getIntKey(), (ItemStack) entry.getValue());
+                        this.player.containerMenu.setRemoteSlotNoCopy(entry.getIntKey(), ItemReplacementRule.reverseReplacement((ItemStack) entry.getValue())); // Suki - custom blocks and items
                     }
 
-                    this.player.containerMenu.setRemoteCarried(packet.getCarriedItem());
+                    this.player.containerMenu.setRemoteCarried(ItemReplacementRule.reverseReplacement(packet.getCarriedItem())); // Suki - custom blocks and items
                     this.player.containerMenu.resumeRemoteUpdates();
                     if (flag) {
                         this.player.containerMenu.broadcastFullState();
@@ -3497,7 +3534,10 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
         if (this.player.gameMode.isCreative()) {
             boolean flag = packet.getSlotNum() < 0;
-            ItemStack itemstack = packet.getItem();
+            // Suki start - custom blocks and items
+            ItemStack requestedItemStack = ItemReplacementRule.reverseReplacement(packet.getItem());
+            ItemStack itemstack = requestedItemStack;
+            // Suki end - custom blocks and items
             CompoundTag nbttagcompound = BlockItem.getBlockEntityData(itemstack);
 
             if (!itemstack.isEmpty() && nbttagcompound != null && nbttagcompound.contains("x") && nbttagcompound.contains("y") && nbttagcompound.contains("z") && this.player.getBukkitEntity().hasPermission("minecraft.nbt.copy")) { // Spigot
@@ -3519,10 +3559,10 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
 
             boolean flag1 = packet.getSlotNum() >= 1 && packet.getSlotNum() <= 45;
             boolean flag2 = itemstack.isEmpty() || itemstack.getDamageValue() >= 0 && itemstack.getCount() <= 64 && !itemstack.isEmpty();
-            if (flag || (flag1 && !ItemStack.matches(this.player.inventoryMenu.getSlot(packet.getSlotNum()).getItem(), packet.getItem()))) { // Insist on valid slot
+            if (flag || (flag1 && !ItemStack.matches(this.player.inventoryMenu.getSlot(packet.getSlotNum()).getItem(), requestedItemStack))) { // Insist on valid slot // Suki - custom blocks and items
                 // CraftBukkit start - Call click event
                 InventoryView inventory = this.player.inventoryMenu.getBukkitView();
-                org.bukkit.inventory.ItemStack item = CraftItemStack.asBukkitCopy(packet.getItem());
+                org.bukkit.inventory.ItemStack item = CraftItemStack.asBukkitCopy(requestedItemStack); // Suki - custom blocks and items
 
                 SlotType type = SlotType.QUICKBAR;
                 if (flag) {
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index c3355db1f57310d2e6b85d84a76f93390dab1f0f..0f91bf646f76bae5ae747377180b69bb0bebf48c 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -15,6 +15,7 @@ import java.net.SocketAddress;
 import java.nio.file.Path;
 import java.text.SimpleDateFormat;
 import java.time.Instant;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -162,6 +163,17 @@ public abstract class PlayerList {
     private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
     public @Nullable String collideRuleTeamName; // Paper - Team name used for collideRule
 
+    // Suki start - custom blocks and items
+    public final List<java.util.function.Predicate<org.bukkit.entity.Player>> canAcceptLargePacketsDisjuncts = new ArrayList<>(2);
+    public final List<java.util.function.Predicate<org.bukkit.entity.Player>> canAcceptServerResourcePackDisjuncts = new ArrayList<>(2);
+    {
+        if (new File("paper_test_server").exists()) {
+            canAcceptLargePacketsDisjuncts.add($ -> true);
+            canAcceptServerResourcePackDisjuncts.add($ -> true);
+        }
+    }
+    // Suki end - custom blocks and items
+
     public PlayerList(MinecraftServer server, RegistryAccess.Frozen registryManager, PlayerDataStorage saveHandler, int maxPlayers) {
         this.cserver = server.server = new CraftServer((DedicatedServer) server, this);
         server.console = new com.destroystokyo.paper.console.TerminalConsoleCommandSender(); // Paper
@@ -283,14 +295,22 @@ public abstract class PlayerList {
 
         player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.send(new ClientboundCustomPayloadPacket(ClientboundCustomPayloadPacket.BRAND, (new FriendlyByteBuf(Unpooled.buffer())).writeUtf(this.getServer().getServerModName())));
+
+        // Suki start - custom blocks and items
+        this.server.getServerResourcePack().ifPresent((minecraftserver_serverresourcepackinfo) -> {
+            player.sendTexturePack(minecraftserver_serverresourcepackinfo.url(), minecraftserver_serverresourcepackinfo.hash(), minecraftserver_serverresourcepackinfo.isRequired(), minecraftserver_serverresourcepackinfo.prompt());
+        });
+        player.connection.connection.updateFirstResourcePackSendTick();
+        // Suki end - custom blocks and items
+
         playerconnection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
         playerconnection.send(new ClientboundPlayerAbilitiesPacket(player.getAbilities()));
         playerconnection.send(new ClientboundSetCarriedItemPacket(player.getInventory().selected));
-        playerconnection.send(new ClientboundUpdateRecipesPacket(this.server.getRecipeManager().getRecipes()));
+//        playerconnection.send(new ClientboundUpdateRecipesPacket(this.server.getRecipeManager().getRecipes())); // Suki - custom blocks and items
         playerconnection.send(new ClientboundUpdateTagsPacket(TagNetworkSerialization.serializeTagsToNetwork(this.registryHolder)));
         this.sendPlayerPermissionLevel(player);
         player.getStats().markAllDirty();
-        player.getRecipeBook().sendInitialRecipeBook(player);
+//        player.getRecipeBook().sendInitialRecipeBook(player); // Suki - custom blocks and items
         this.updateEntireScoreboard(worldserver1.getScoreboard(), player);
         this.server.invalidateStatus();
         // Paper start - async load spawn in chunk
@@ -419,9 +439,11 @@ public abstract class PlayerList {
         worldserver1 = player.getLevel(); // CraftBukkit - Update in case join event changed it
         // CraftBukkit end
         this.sendLevelInfo(player, worldserver1);
-        this.server.getServerResourcePack().ifPresent((minecraftserver_serverresourcepackinfo) -> {
-            player.sendTexturePack(minecraftserver_serverresourcepackinfo.url(), minecraftserver_serverresourcepackinfo.hash(), minecraftserver_serverresourcepackinfo.isRequired(), minecraftserver_serverresourcepackinfo.prompt());
-        });
+        // Suki start - custom blocks and items
+//        this.server.getServerResourcePack().ifPresent((minecraftserver_serverresourcepackinfo) -> {
+//            player.sendTexturePack(minecraftserver_serverresourcepackinfo.url(), minecraftserver_serverresourcepackinfo.hash(), minecraftserver_serverresourcepackinfo.isRequired(), minecraftserver_serverresourcepackinfo.prompt());
+//        });
+        // Suki end - custom blocks and items
         player.sendServerStatus(this.server.getStatus());
         Iterator iterator = player.getActiveEffects().iterator();
 
@@ -439,7 +461,7 @@ public abstract class PlayerList {
                 .getHolderOrThrow(net.minecraft.world.level.biome.Biomes.PLAINS);
             player.connection.send(new net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket(
                 new net.minecraft.world.level.chunk.EmptyLevelChunk(worldserver1, player.chunkPosition(), plains),
-                worldserver1.getLightEngine(), null, null, true, false)
+                worldserver1.getLightEngine(), null, null, true, false, player.hasSuCraftResourcePack()) // Suki - custom blocks and items
             );
         }
         // Paper end
@@ -1619,13 +1641,16 @@ public abstract class PlayerList {
         // CraftBukkit end
 
         this.broadcastAll(new ClientboundUpdateTagsPacket(TagNetworkSerialization.serializeTagsToNetwork(this.registryHolder)));
-        ClientboundUpdateRecipesPacket packetplayoutrecipeupdate = new ClientboundUpdateRecipesPacket(this.server.getRecipeManager().getRecipes());
+        //ClientboundUpdateRecipesPacket packetplayoutrecipeupdate = new ClientboundUpdateRecipesPacket(this.server.getRecipeManager().getRecipes()); // Suki - custom blocks and items
         Iterator iterator1 = this.players.iterator();
 
         while (iterator1.hasNext()) {
             ServerPlayer entityplayer = (ServerPlayer) iterator1.next();
 
-            entityplayer.connection.send(packetplayoutrecipeupdate);
+            // Suki start - custom blocks and items
+            //entityplayer.connection.send(packetplayoutrecipeupdate);
+            entityplayer.resendCraftingRecipes(null, -1);
+            // Suki end - custom blocks and items
             entityplayer.getRecipeBook().sendInitialRecipeBook(entityplayer);
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 436f6f860c7cb6dfad2e3176e527dd23591f0e0b..76d0e905e6e8f43aeb046192fb7aa82453122fe2 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -265,7 +265,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final String ID_TAG = "id";
     public static final String PASSENGERS_TAG = "Passengers";
-    private static final AtomicInteger ENTITY_COUNTER = new AtomicInteger();
+    public static final AtomicInteger ENTITY_COUNTER = new AtomicInteger(); // Suki - custom blocks and items
     private static final List<ItemStack> EMPTY_LIST = Collections.emptyList();
     public static final int BOARDING_COOLDOWN = 60;
     public static final int TOTAL_AIR_SUPPLY = 300;
@@ -333,21 +333,23 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public int invulnerableTime;
     protected boolean firstTick;
     protected final SynchedEntityData entityData;
-    protected static final EntityDataAccessor<Byte> DATA_SHARED_FLAGS_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BYTE);
-    protected static final int FLAG_ONFIRE = 0;
+    // Suki start - custom blocks and items
+    public static final EntityDataAccessor<Byte> DATA_SHARED_FLAGS_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BYTE);
+    private static final int FLAG_ONFIRE = 0;
     private static final int FLAG_SHIFT_KEY_DOWN = 1;
     private static final int FLAG_SPRINTING = 3;
     private static final int FLAG_SWIMMING = 4;
-    private static final int FLAG_INVISIBLE = 5;
+    public static final int FLAG_INVISIBLE = 5;
     protected static final int FLAG_GLOWING = 6;
     protected static final int FLAG_FALL_FLYING = 7;
-    private static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    public static final EntityDataAccessor<Integer> DATA_AIR_SUPPLY_ID = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
     private static final EntityDataAccessor<Optional<Component>> DATA_CUSTOM_NAME = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.OPTIONAL_COMPONENT);
     private static final EntityDataAccessor<Boolean> DATA_CUSTOM_NAME_VISIBLE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    private static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
-    private static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Boolean> DATA_SILENT = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
+    public static final EntityDataAccessor<Boolean> DATA_NO_GRAVITY = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.BOOLEAN);
     protected static final EntityDataAccessor<net.minecraft.world.entity.Pose> DATA_POSE = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.POSE);
     private static final EntityDataAccessor<Integer> DATA_TICKS_FROZEN = SynchedEntityData.defineId(Entity.class, EntityDataSerializers.INT);
+    // Suki end - custom blocks and items
     private EntityInLevelCallback levelCallback;
     private final VecDeltaCodec packetPositionCodec;
     public boolean noCulling;
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 5bb9325aa1b8ec0779c191582e877a455dfbb463..856f9604b26d47f8f3549f57c63b16ed7ce7d2ee 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -512,7 +512,7 @@ public abstract class LivingEntity extends Entity {
     }
 
     protected boolean onSoulSpeedBlock() {
-        return this.level.getBlockState(this.getBlockPosBelowThatAffectsMyMovement()).is(BlockTags.SOUL_SPEED_BLOCKS);
+        return this.level.getBlockState(this.getBlockPosBelowThatAffectsMyMovement()).is(BlockTags.SOUL_SPEED_BLOCKS) || this.level.getBlockState(new BlockPos(this.getX(), this.getBoundingBox().minY - 0.25, this.getZ())).is(BlockTags.SOUL_SPEED_BLOCKS); // Suki - custom blocks and items
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
index ef07967b64180c54338b8fb2ba1780adec87f333..b34b8d72d581d68be003568c5cdccb6030ea2214 100644
--- a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -40,6 +40,7 @@ import net.minecraft.world.level.block.FallingBlock;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.SlabType;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.HitResult;
@@ -89,7 +90,18 @@ public class FallingBlockEntity extends Entity {
 
     public static FallingBlockEntity fall(Level world, BlockPos blockposition, BlockState iblockdata, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason) {
         // CraftBukkit end
-        FallingBlockEntity entityfallingblock = new FallingBlockEntity(world, (double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D, iblockdata.hasProperty(BlockStateProperties.WATERLOGGED) ? (BlockState) iblockdata.setValue(BlockStateProperties.WATERLOGGED, false) : iblockdata);
+        // Suki start - custom blocks and items
+        BlockState fallingBlockState = iblockdata;
+        double fallingBlockEntityY = (double) blockposition.getY();
+        if (iblockdata.hasProperty(BlockStateProperties.WATERLOGGED)) {
+            fallingBlockState = (BlockState) iblockdata.setValue(BlockStateProperties.WATERLOGGED, false);
+        }
+        if (iblockdata.hasProperty(BlockStateProperties.SLAB_TYPE) && iblockdata.getValue(BlockStateProperties.SLAB_TYPE) == SlabType.TOP) {
+            fallingBlockState = (BlockState) iblockdata.setValue(BlockStateProperties.SLAB_TYPE, SlabType.BOTTOM);
+            fallingBlockEntityY += 0.5;
+        }
+        FallingBlockEntity entityfallingblock = new FallingBlockEntity(world, (double) blockposition.getX() + 0.5D, fallingBlockEntityY, (double) blockposition.getZ() + 0.5D, fallingBlockState);
+        // Suki end - custom blocks and items
         if (CraftEventFactory.callEntityChangeBlockEvent(entityfallingblock, blockposition, iblockdata.getFluidState().createLegacyBlock()).isCancelled()) return entityfallingblock; // CraftBukkit
 
         world.setBlock(blockposition, iblockdata.getFluidState().createLegacyBlock(), 3);
diff --git a/src/main/java/net/minecraft/world/entity/monster/Silverfish.java b/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
index 2dcda3b03796655da443e1b3dd68c6f6bca20d21..75f071fbeea888d2f37e3fa9f8801d6faa2e2951 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Silverfish.java
@@ -4,6 +4,7 @@ import java.util.EnumSet;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.util.RandomSource;
diff --git a/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java b/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java
index 2c1c6b1c352161eb98ead4518f74a0c64bc9fef4..b9c7f2d6c181e82ae39384e7770ce3709e226801 100644
--- a/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java
+++ b/src/main/java/net/minecraft/world/entity/npc/VillagerTrades.java
@@ -5,6 +5,8 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+
+import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.stream.Collectors;
@@ -44,6 +46,8 @@ import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import net.minecraft.world.level.saveddata.maps.MapDecoration;
 import net.minecraft.world.level.saveddata.maps.MapItemSavedData;
+import org.sucraft.suki.block.SuCraftBlockTags;
+import org.sucraft.suki.block.SuCraftBlocks;
 import org.sucraft.suki.enchantments.EnchantmentSource;
 
 public class VillagerTrades {
@@ -66,7 +70,36 @@ public class VillagerTrades {
         map.put(VillagerProfession.FISHERMAN, toIntMap(ImmutableMap.of(1, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.STRING, 20, 16, 2), new VillagerTrades.EmeraldForItems(Items.COAL, 10, 16, 2), new VillagerTrades.ItemsAndEmeraldsToItems(Items.COD, 6, Items.COOKED_COD, 6, 16, 1), new VillagerTrades.ItemsForEmeralds(Items.COD_BUCKET, 3, 1, 16, 1)}, 2, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.COD, 15, 16, 10), new VillagerTrades.ItemsAndEmeraldsToItems(Items.SALMON, 6, Items.COOKED_SALMON, 6, 16, 5), new VillagerTrades.ItemsForEmeralds(Items.CAMPFIRE, 2, 1, 5)}, 3, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.SALMON, 13, 16, 20), new VillagerTrades.EnchantedItemForEmeralds(Items.FISHING_ROD, 3, 3, 10, 0.2F)}, 4, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.TROPICAL_FISH, 6, 12, 30)}, 5, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.PUFFERFISH, 4, 12, 30), new VillagerTrades.EmeraldsForVillagerTypeItem(1, 12, 30, ImmutableMap.<VillagerType, Item>builder().put(VillagerType.PLAINS, Items.OAK_BOAT).put(VillagerType.TAIGA, Items.SPRUCE_BOAT).put(VillagerType.SNOW, Items.SPRUCE_BOAT).put(VillagerType.DESERT, Items.JUNGLE_BOAT).put(VillagerType.JUNGLE, Items.JUNGLE_BOAT).put(VillagerType.SAVANNA, Items.ACACIA_BOAT).put(VillagerType.SWAMP, Items.DARK_OAK_BOAT).build())})));
         map.put(VillagerProfession.SHEPHERD, toIntMap(ImmutableMap.of(1, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Blocks.WHITE_WOOL, 18, 16, 2), new VillagerTrades.EmeraldForItems(Blocks.BROWN_WOOL, 18, 16, 2), new VillagerTrades.EmeraldForItems(Blocks.BLACK_WOOL, 18, 16, 2), new VillagerTrades.EmeraldForItems(Blocks.GRAY_WOOL, 18, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.SHEARS, 2, 1, 1)}, 2, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.WHITE_DYE, 12, 16, 10), new VillagerTrades.EmeraldForItems(Items.GRAY_DYE, 12, 16, 10), new VillagerTrades.EmeraldForItems(Items.BLACK_DYE, 12, 16, 10), new VillagerTrades.EmeraldForItems(Items.LIGHT_BLUE_DYE, 12, 16, 10), new VillagerTrades.EmeraldForItems(Items.LIME_DYE, 12, 16, 10), new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.LIME_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.PINK_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.RED_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_WOOL, 1, 1, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.LIME_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.PINK_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.RED_CARPET, 1, 4, 16, 5), new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_CARPET, 1, 4, 16, 5)}, 3, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.YELLOW_DYE, 12, 16, 20), new VillagerTrades.EmeraldForItems(Items.LIGHT_GRAY_DYE, 12, 16, 20), new VillagerTrades.EmeraldForItems(Items.ORANGE_DYE, 12, 16, 20), new VillagerTrades.EmeraldForItems(Items.RED_DYE, 12, 16, 20), new VillagerTrades.EmeraldForItems(Items.PINK_DYE, 12, 16, 20), new VillagerTrades.ItemsForEmeralds(Blocks.WHITE_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.YELLOW_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.RED_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.BLACK_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.BLUE_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.BROWN_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.CYAN_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.GRAY_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.GREEN_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_BLUE_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.LIGHT_GRAY_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.LIME_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.MAGENTA_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.ORANGE_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.PINK_BED, 3, 1, 12, 10), new VillagerTrades.ItemsForEmeralds(Blocks.PURPLE_BED, 3, 1, 12, 10)}, 4, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.BROWN_DYE, 12, 16, 30), new VillagerTrades.EmeraldForItems(Items.PURPLE_DYE, 12, 16, 30), new VillagerTrades.EmeraldForItems(Items.BLUE_DYE, 12, 16, 30), new VillagerTrades.EmeraldForItems(Items.GREEN_DYE, 12, 16, 30), new VillagerTrades.EmeraldForItems(Items.MAGENTA_DYE, 12, 16, 30), new VillagerTrades.EmeraldForItems(Items.CYAN_DYE, 12, 16, 30), new VillagerTrades.ItemsForEmeralds(Items.WHITE_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.BLUE_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.RED_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.PINK_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.GREEN_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.LIME_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.GRAY_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.BLACK_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.PURPLE_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.CYAN_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.BROWN_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.YELLOW_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.ORANGE_BANNER, 3, 1, 12, 15), new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_BANNER, 3, 1, 12, 15)}, 5, new VillagerTrades.ItemListing[]{new VillagerTrades.ItemsForEmeralds(Items.PAINTING, 2, 3, 30)})));
         map.put(VillagerProfession.FLETCHER, toIntMap(ImmutableMap.of(1, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.STICK, 32, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.ARROW, 1, 16, 1), new VillagerTrades.ItemsAndEmeraldsToItems(Blocks.GRAVEL, 10, Items.FLINT, 10, 12, 1)}, 2, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.FLINT, 26, 12, 10), new VillagerTrades.ItemsForEmeralds(Items.BOW, 2, 1, 5)}, 3, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.STRING, 14, 16, 20), new VillagerTrades.ItemsForEmeralds(Items.CROSSBOW, 3, 1, 10)}, 4, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.FEATHER, 24, 16, 30), new VillagerTrades.EnchantedItemForEmeralds(Items.BOW, 2, 3, 15)}, 5, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.TRIPWIRE_HOOK, 8, 12, 30), new VillagerTrades.EnchantedItemForEmeralds(Items.CROSSBOW, 3, 3, 15), new VillagerTrades.TippedArrowForItemsAndEmeralds(Items.ARROW, 5, Items.TIPPED_ARROW, 5, 2, 12, 30)})));
-        map.put(VillagerProfession.LIBRARIAN, toIntMap(ImmutableMap.<Integer, VillagerTrades.ItemListing[]>builder().put(1, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.PAPER, 24, 16, 2), new VillagerTrades.EnchantBookForEmeralds(1), new VillagerTrades.ItemsForEmeralds(Blocks.BOOKSHELF, 9, 1, 12, 1)}).put(2, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.BOOK, 4, 12, 10), new VillagerTrades.EnchantBookForEmeralds(5), new VillagerTrades.ItemsForEmeralds(Items.LANTERN, 1, 1, 5)}).put(3, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.INK_SAC, 5, 12, 20), new VillagerTrades.EnchantBookForEmeralds(10), new VillagerTrades.ItemsForEmeralds(Items.GLASS, 1, 4, 10)}).put(4, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.WRITABLE_BOOK, 2, 12, 30), new VillagerTrades.EnchantBookForEmeralds(15), new VillagerTrades.ItemsForEmeralds(Items.CLOCK, 5, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.COMPASS, 4, 1, 15)}).put(5, new VillagerTrades.ItemListing[]{new VillagerTrades.ItemsForEmeralds(Items.NAME_TAG, 20, 1, 30)}).build()));
+        // Suki start - custom blocks and items
+        map.put(VillagerProfession.LIBRARIAN, toIntMap(ImmutableMap.<Integer, VillagerTrades.ItemListing[]>builder()
+            .put(1, new VillagerTrades.ItemListing[]{
+                new VillagerTrades.EmeraldForItems(Items.PAPER, 24, 16, 2),
+                // Replaced bookshelf by any of the types of bookshelves
+                new VillagerTrades.EnchantBookForEmeralds(1), new VillagerTrades.ItemsChoiceForEmeralds(new Block[] {
+                    Blocks.BOOKSHELF,
+                    SuCraftBlocks.SPRUCE_BOOKSHELF,
+                    SuCraftBlocks.BIRCH_BOOKSHELF,
+                    SuCraftBlocks.JUNGLE_BOOKSHELF,
+                    SuCraftBlocks.ACACIA_BOOKSHELF,
+                    SuCraftBlocks.DARK_OAK_BOOKSHELF,
+                    SuCraftBlocks.WARPED_BOOKSHELF,
+                    SuCraftBlocks.CRIMSON_BOOKSHELF,
+                    SuCraftBlocks.MANGROVE_BOOKSHELF
+            }, 9, 1, 12, 1)})
+            .put(2, new VillagerTrades.ItemListing[]{
+                new VillagerTrades.EmeraldForItems(Items.BOOK, 4, 12, 10),
+                new VillagerTrades.EnchantBookForEmeralds(5), new VillagerTrades.ItemsForEmeralds(Items.LANTERN, 1, 1, 5)})
+            .put(3, new VillagerTrades.ItemListing[]{
+                new VillagerTrades.EmeraldForItems(Items.INK_SAC, 5, 12, 20),
+                new VillagerTrades.EnchantBookForEmeralds(10), new VillagerTrades.ItemsForEmeralds(Items.GLASS, 1, 4, 10)})
+            .put(4, new VillagerTrades.ItemListing[]{
+                new VillagerTrades.EmeraldForItems(Items.WRITABLE_BOOK, 2, 12, 30),
+                new VillagerTrades.EnchantBookForEmeralds(15), new VillagerTrades.ItemsForEmeralds(Items.CLOCK, 5, 1, 15),
+                new VillagerTrades.ItemsForEmeralds(Items.COMPASS, 4, 1, 15)})
+            .put(5, new VillagerTrades.ItemListing[]{
+                new VillagerTrades.ItemsForEmeralds(Items.NAME_TAG, 20, 1, 30)})
+            .build()));
+        // Suki end - custom blocks and items
         map.put(VillagerProfession.CARTOGRAPHER, toIntMap(ImmutableMap.of(1, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.PAPER, 24, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.MAP, 7, 1, 1)}, 2, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.GLASS_PANE, 11, 16, 10), new VillagerTrades.TreasureMapForEmeralds(13, StructureTags.ON_OCEAN_EXPLORER_MAPS, "filled_map.monument", MapDecoration.Type.MONUMENT, 12, 5)}, 3, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.COMPASS, 1, 12, 20), new VillagerTrades.TreasureMapForEmeralds(14, StructureTags.ON_WOODLAND_EXPLORER_MAPS, "filled_map.mansion", MapDecoration.Type.MANSION, 12, 10)}, 4, new VillagerTrades.ItemListing[]{new VillagerTrades.ItemsForEmeralds(Items.ITEM_FRAME, 7, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.WHITE_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.BLUE_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.LIGHT_BLUE_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.RED_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.PINK_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.GREEN_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.LIME_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.GRAY_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.BLACK_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.PURPLE_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.MAGENTA_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.CYAN_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.BROWN_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.YELLOW_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.ORANGE_BANNER, 3, 1, 15), new VillagerTrades.ItemsForEmeralds(Items.LIGHT_GRAY_BANNER, 3, 1, 15)}, 5, new VillagerTrades.ItemListing[]{new VillagerTrades.ItemsForEmeralds(Items.GLOBE_BANNER_PATTERN, 8, 1, 30)})));
         map.put(VillagerProfession.CLERIC, toIntMap(ImmutableMap.of(1, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.ROTTEN_FLESH, 32, 16, 2), new VillagerTrades.ItemsForEmeralds(Items.REDSTONE, 1, 2, 1)}, 2, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.GOLD_INGOT, 3, 12, 10), new VillagerTrades.ItemsForEmeralds(Items.LAPIS_LAZULI, 1, 1, 5)}, 3, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.RABBIT_FOOT, 2, 12, 20), new VillagerTrades.ItemsForEmeralds(Blocks.GLOWSTONE, 4, 1, 12, 10)}, 4, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.SCUTE, 4, 12, 30), new VillagerTrades.EmeraldForItems(Items.GLASS_BOTTLE, 9, 12, 30), new VillagerTrades.ItemsForEmeralds(Items.ENDER_PEARL, 5, 1, 15)}, 5, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.NETHER_WART, 22, 12, 30), new VillagerTrades.ItemsForEmeralds(Items.EXPERIENCE_BOTTLE, 3, 1, 30)})));
         map.put(VillagerProfession.ARMORER, toIntMap(ImmutableMap.of(1, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.COAL, 15, 16, 2), new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_LEGGINGS), 7, 1, 12, 1, 0.2F), new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_BOOTS), 4, 1, 12, 1, 0.2F), new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_HELMET), 5, 1, 12, 1, 0.2F), new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.IRON_CHESTPLATE), 9, 1, 12, 1, 0.2F)}, 2, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.IRON_INGOT, 4, 12, 10), new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.BELL), 36, 1, 12, 5, 0.2F), new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_BOOTS), 1, 1, 12, 5, 0.2F), new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_LEGGINGS), 3, 1, 12, 5, 0.2F)}, 3, new VillagerTrades.ItemListing[]{new VillagerTrades.EmeraldForItems(Items.LAVA_BUCKET, 1, 12, 20), new VillagerTrades.EmeraldForItems(Items.DIAMOND, 1, 12, 20), new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_HELMET), 1, 1, 12, 10, 0.2F), new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.CHAINMAIL_CHESTPLATE), 4, 1, 12, 10, 0.2F), new VillagerTrades.ItemsForEmeralds(new ItemStack(Items.SHIELD), 5, 1, 12, 10, 0.2F)}, 4, new VillagerTrades.ItemListing[]{new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_LEGGINGS, 14, 3, 15, 0.2F), new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_BOOTS, 8, 3, 15, 0.2F)}, 5, new VillagerTrades.ItemListing[]{new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_HELMET, 8, 3, 30, 0.2F), new VillagerTrades.EnchantedItemForEmeralds(Items.DIAMOND_CHESTPLATE, 16, 3, 30, 0.2F)})));
@@ -308,6 +341,52 @@ public class VillagerTrades {
         }
     }
 
+    // Suki start - custom blocks and items
+
+    /**
+     * Based on {@link ItemsForEmeralds}, but this one chooses the {@link ItemStack} sold out of a number of choices
+     */
+    static class ItemsChoiceForEmeralds implements VillagerTrades.ItemListing {
+        private final ItemStack[] itemStacks;
+        private final int emeraldCost;
+        private final int numberOfItems;
+        private final int maxUses;
+        private final int villagerXp;
+        private final float priceMultiplier;
+
+        public ItemsChoiceForEmeralds(Block[] blocks, int price, int count, int maxUses, int experience) {
+            this(Arrays.stream(blocks).map(ItemStack::new).toArray(ItemStack[]::new), price, count, maxUses, experience);
+        }
+
+        public ItemsChoiceForEmeralds(Item[] items, int price, int count, int experience) {
+            this(Arrays.stream(items).map(ItemStack::new).toArray(ItemStack[]::new), price, count, 12, experience);
+        }
+
+        public ItemsChoiceForEmeralds(Item[] items, int price, int count, int maxUses, int experience) {
+            this(Arrays.stream(items).map(ItemStack::new).toArray(ItemStack[]::new), price, count, maxUses, experience);
+        }
+
+        public ItemsChoiceForEmeralds(ItemStack[] stacks, int price, int count, int maxUses, int experience) {
+            this(stacks, price, count, maxUses, experience, 0.05F);
+        }
+
+        public ItemsChoiceForEmeralds(ItemStack[] stacks, int price, int count, int maxUses, int experience, float multiplier) {
+            this.itemStacks = stacks;
+            this.emeraldCost = price;
+            this.numberOfItems = count;
+            this.maxUses = maxUses;
+            this.villagerXp = experience;
+            this.priceMultiplier = multiplier;
+        }
+
+        @Override
+        public MerchantOffer getOffer(Entity entity, RandomSource random) {
+            return new MerchantOffer(new ItemStack(Items.EMERALD, this.emeraldCost), new ItemStack(this.itemStacks[random.nextInt(this.itemStacks.length)].getItem(), this.numberOfItems), this.maxUses, this.villagerXp, this.priceMultiplier);
+        }
+    }
+
+    // Suki end - custom blocks and items
+
     static class SuspiciousStewForEmerald implements VillagerTrades.ItemListing {
         final MobEffect effect;
         final int duration;
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 2e8e5a13e369c4fd26b429b47e2410d06101b127..a5ad6de11e88b6fe88ebe18ed9b4df64cf07c98a 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -855,6 +855,14 @@ public abstract class Player extends LivingEntity {
         return !state.requiresCorrectToolForDrops() || this.inventory.getSelected().isCorrectToolForDrops(state);
     }
 
+    // Suki start - custom blocks and items
+
+    public boolean hasCorrectToolForFasterBreaking(BlockState state) {
+        return hasCorrectToolForDrops(state) || !state.requiresCorrectToolForFasterBreaking(true) || this.inventory.getSelected().isCorrectToolForFasterBreaking(state, true);
+    }
+
+    // Suki end - custom blocks and items
+
     @Override
     public void readAdditionalSaveData(CompoundTag nbt) {
         super.readAdditionalSaveData(nbt);
diff --git a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
index 49b063655dfc09e30d446dbf07503fdda04a7e30..9fe719482611a93bbe708815be86dd913644dfc1 100644
--- a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -425,6 +425,7 @@ public abstract class AbstractContainerMenu {
                 itemstack = this.getCarried();
                 if (AbstractContainerMenu.canItemQuickReplace(slot, itemstack, true) && slot.mayPlace(itemstack) && (this.quickcraftType == 2 || itemstack.getCount() > this.quickcraftSlots.size()) && this.canDragTo(slot)) {
                     this.quickcraftSlots.add(slot);
+
                 }
             } else if (this.quickcraftStatus == 2) {
                 if (!this.quickcraftSlots.isEmpty()) {
@@ -451,6 +452,7 @@ public abstract class AbstractContainerMenu {
                             AbstractContainerMenu.getQuickCraftSlotCount(this.quickcraftSlots, this.quickcraftType, itemstack3, j1);
                             int k1 = Math.min(itemstack3.getMaxStackSize(), slot1.getMaxStackSize(itemstack3));
 
+
                             if (itemstack3.getCount() > k1) {
                                 itemstack3.setCount(k1);
                             }
diff --git a/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java b/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java
index d4f71422b25f70abfe50481d6071abea6ad147c0..91c6c863d8b3d57f2a32a22725b0acc00a7b7db2 100644
--- a/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/StonecutterMenu.java
@@ -2,6 +2,8 @@ package net.minecraft.world.inventory;
 
 import com.google.common.collect.Lists;
 import java.util.List;
+
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
 import net.minecraft.world.Container;
@@ -15,7 +17,9 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
 
 // CraftBukkit start
+import org.bukkit.Bukkit;
 import org.bukkit.Location;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.inventory.CraftInventoryStonecutter;
 import org.bukkit.craftbukkit.inventory.CraftInventoryView;
 import org.bukkit.entity.Player;
@@ -73,6 +77,12 @@ public class StonecutterMenu extends AbstractContainerMenu {
                 super.setChanged();
                 StonecutterMenu.this.slotsChanged(this);
                 StonecutterMenu.this.slotUpdateListener.run();
+                // Suki start - custom blocks and items
+                ((CraftPlayer) StonecutterMenu.this.player).getHandle().resendCraftingRecipes(null, 0);
+//                Bukkit.getScheduler().runTaskLater(Bukkit.getPluginManager().getPlugins()[0], () ->
+//                    ((CraftPlayer) StonecutterMenu.this.player).getHandle().resendCraftingRecipes(), 1
+//                );
+                // Suki end - custom blocks and items
             }
 
             // CraftBukkit start
diff --git a/src/main/java/net/minecraft/world/item/AxeItem.java b/src/main/java/net/minecraft/world/item/AxeItem.java
index 03a6a99dcc0c8fcc32776dd49cf6092b899bf6ed..830630281995b05414863e8bae85b513f8828cab 100644
--- a/src/main/java/net/minecraft/world/item/AxeItem.java
+++ b/src/main/java/net/minecraft/world/item/AxeItem.java
@@ -19,9 +19,68 @@ import net.minecraft.world.level.block.RotatedPillarBlock;
 import net.minecraft.world.level.block.WeatheringCopper;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEvent;
+import org.sucraft.suki.block.SuCraftBlocks;
 
 public class AxeItem extends DiggerItem {
-    protected static final Map<Block, Block> STRIPPABLES = (new ImmutableMap.Builder<Block, Block>()).put(Blocks.OAK_WOOD, Blocks.STRIPPED_OAK_WOOD).put(Blocks.OAK_LOG, Blocks.STRIPPED_OAK_LOG).put(Blocks.DARK_OAK_WOOD, Blocks.STRIPPED_DARK_OAK_WOOD).put(Blocks.DARK_OAK_LOG, Blocks.STRIPPED_DARK_OAK_LOG).put(Blocks.ACACIA_WOOD, Blocks.STRIPPED_ACACIA_WOOD).put(Blocks.ACACIA_LOG, Blocks.STRIPPED_ACACIA_LOG).put(Blocks.BIRCH_WOOD, Blocks.STRIPPED_BIRCH_WOOD).put(Blocks.BIRCH_LOG, Blocks.STRIPPED_BIRCH_LOG).put(Blocks.JUNGLE_WOOD, Blocks.STRIPPED_JUNGLE_WOOD).put(Blocks.JUNGLE_LOG, Blocks.STRIPPED_JUNGLE_LOG).put(Blocks.SPRUCE_WOOD, Blocks.STRIPPED_SPRUCE_WOOD).put(Blocks.SPRUCE_LOG, Blocks.STRIPPED_SPRUCE_LOG).put(Blocks.WARPED_STEM, Blocks.STRIPPED_WARPED_STEM).put(Blocks.WARPED_HYPHAE, Blocks.STRIPPED_WARPED_HYPHAE).put(Blocks.CRIMSON_STEM, Blocks.STRIPPED_CRIMSON_STEM).put(Blocks.CRIMSON_HYPHAE, Blocks.STRIPPED_CRIMSON_HYPHAE).put(Blocks.MANGROVE_WOOD, Blocks.STRIPPED_MANGROVE_WOOD).put(Blocks.MANGROVE_LOG, Blocks.STRIPPED_MANGROVE_LOG).build();
+
+    // Suki start - custom blocks and items
+    protected static final Map<Block, Block> STRIPPABLES = new ImmutableMap.Builder<Block, Block>()
+        .put(Blocks.OAK_WOOD, Blocks.STRIPPED_OAK_WOOD)
+        .put(Blocks.OAK_LOG, Blocks.STRIPPED_OAK_LOG)
+        .put(Blocks.DARK_OAK_WOOD, Blocks.STRIPPED_DARK_OAK_WOOD)
+        .put(Blocks.DARK_OAK_LOG, Blocks.STRIPPED_DARK_OAK_LOG)
+        .put(Blocks.ACACIA_WOOD, Blocks.STRIPPED_ACACIA_WOOD)
+        .put(Blocks.ACACIA_LOG, Blocks.STRIPPED_ACACIA_LOG)
+        .put(Blocks.BIRCH_WOOD, Blocks.STRIPPED_BIRCH_WOOD)
+        .put(Blocks.BIRCH_LOG, Blocks.STRIPPED_BIRCH_LOG)
+        .put(Blocks.JUNGLE_WOOD, Blocks.STRIPPED_JUNGLE_WOOD)
+        .put(Blocks.JUNGLE_LOG, Blocks.STRIPPED_JUNGLE_LOG)
+        .put(Blocks.SPRUCE_WOOD, Blocks.STRIPPED_SPRUCE_WOOD)
+        .put(Blocks.SPRUCE_LOG, Blocks.STRIPPED_SPRUCE_LOG)
+        .put(Blocks.WARPED_STEM, Blocks.STRIPPED_WARPED_STEM)
+        .put(Blocks.WARPED_HYPHAE, Blocks.STRIPPED_WARPED_HYPHAE)
+        .put(Blocks.CRIMSON_STEM, Blocks.STRIPPED_CRIMSON_STEM)
+        .put(Blocks.CRIMSON_HYPHAE, Blocks.STRIPPED_CRIMSON_HYPHAE)
+        .put(Blocks.MANGROVE_WOOD, Blocks.STRIPPED_MANGROVE_WOOD)
+        .put(Blocks.MANGROVE_LOG, Blocks.STRIPPED_MANGROVE_LOG)
+        .put(SuCraftBlocks.OAK_WOOD_SLAB, SuCraftBlocks.STRIPPED_OAK_WOOD_SLAB)
+        .put(SuCraftBlocks.OAK_LOG_SLAB, SuCraftBlocks.STRIPPED_OAK_LOG_SLAB)
+        .put(SuCraftBlocks.DARK_OAK_WOOD_SLAB, SuCraftBlocks.STRIPPED_DARK_OAK_WOOD_SLAB)
+        .put(SuCraftBlocks.DARK_OAK_LOG_SLAB, SuCraftBlocks.STRIPPED_DARK_OAK_LOG_SLAB)
+        .put(SuCraftBlocks.ACACIA_WOOD_SLAB, SuCraftBlocks.STRIPPED_ACACIA_WOOD_SLAB)
+        .put(SuCraftBlocks.ACACIA_LOG_SLAB, SuCraftBlocks.STRIPPED_ACACIA_LOG_SLAB)
+        .put(SuCraftBlocks.BIRCH_WOOD_SLAB, SuCraftBlocks.STRIPPED_BIRCH_WOOD_SLAB)
+        .put(SuCraftBlocks.BIRCH_LOG_SLAB, SuCraftBlocks.STRIPPED_BIRCH_LOG_SLAB)
+        .put(SuCraftBlocks.JUNGLE_WOOD_SLAB, SuCraftBlocks.STRIPPED_JUNGLE_WOOD_SLAB)
+        .put(SuCraftBlocks.JUNGLE_LOG_SLAB, SuCraftBlocks.STRIPPED_JUNGLE_LOG_SLAB)
+        .put(SuCraftBlocks.SPRUCE_WOOD_SLAB, SuCraftBlocks.STRIPPED_SPRUCE_WOOD_SLAB)
+        .put(SuCraftBlocks.SPRUCE_LOG_SLAB, SuCraftBlocks.STRIPPED_SPRUCE_LOG_SLAB)
+        .put(SuCraftBlocks.WARPED_STEM_SLAB, SuCraftBlocks.STRIPPED_WARPED_STEM_SLAB)
+        .put(SuCraftBlocks.WARPED_HYPHAE_SLAB, SuCraftBlocks.STRIPPED_WARPED_HYPHAE_SLAB)
+        .put(SuCraftBlocks.CRIMSON_STEM_SLAB, SuCraftBlocks.STRIPPED_CRIMSON_STEM_SLAB)
+        .put(SuCraftBlocks.CRIMSON_HYPHAE_SLAB, SuCraftBlocks.STRIPPED_CRIMSON_HYPHAE_SLAB)
+        .put(SuCraftBlocks.MANGROVE_WOOD_SLAB, SuCraftBlocks.STRIPPED_MANGROVE_WOOD_SLAB)
+        .put(SuCraftBlocks.MANGROVE_LOG_SLAB, SuCraftBlocks.STRIPPED_MANGROVE_LOG_SLAB)
+        .put(SuCraftBlocks.OAK_WOOD_STAIRS, SuCraftBlocks.STRIPPED_OAK_WOOD_STAIRS)
+        .put(SuCraftBlocks.OAK_LOG_STAIRS, SuCraftBlocks.STRIPPED_OAK_LOG_STAIRS)
+        .put(SuCraftBlocks.DARK_OAK_WOOD_STAIRS, SuCraftBlocks.STRIPPED_DARK_OAK_WOOD_STAIRS)
+        .put(SuCraftBlocks.DARK_OAK_LOG_STAIRS, SuCraftBlocks.STRIPPED_DARK_OAK_LOG_STAIRS)
+        .put(SuCraftBlocks.ACACIA_WOOD_STAIRS, SuCraftBlocks.STRIPPED_ACACIA_WOOD_STAIRS)
+        .put(SuCraftBlocks.ACACIA_LOG_STAIRS, SuCraftBlocks.STRIPPED_ACACIA_LOG_STAIRS)
+        .put(SuCraftBlocks.BIRCH_WOOD_STAIRS, SuCraftBlocks.STRIPPED_BIRCH_WOOD_STAIRS)
+        .put(SuCraftBlocks.BIRCH_LOG_STAIRS, SuCraftBlocks.STRIPPED_BIRCH_LOG_STAIRS)
+        .put(SuCraftBlocks.JUNGLE_WOOD_STAIRS, SuCraftBlocks.STRIPPED_JUNGLE_WOOD_STAIRS)
+        .put(SuCraftBlocks.JUNGLE_LOG_STAIRS, SuCraftBlocks.STRIPPED_JUNGLE_LOG_STAIRS)
+        .put(SuCraftBlocks.SPRUCE_WOOD_STAIRS, SuCraftBlocks.STRIPPED_SPRUCE_WOOD_STAIRS)
+        .put(SuCraftBlocks.SPRUCE_LOG_STAIRS, SuCraftBlocks.STRIPPED_SPRUCE_LOG_STAIRS)
+        .put(SuCraftBlocks.WARPED_STEM_STAIRS, SuCraftBlocks.STRIPPED_WARPED_STEM_STAIRS)
+        .put(SuCraftBlocks.WARPED_HYPHAE_STAIRS, SuCraftBlocks.STRIPPED_WARPED_HYPHAE_STAIRS)
+        .put(SuCraftBlocks.CRIMSON_STEM_STAIRS, SuCraftBlocks.STRIPPED_CRIMSON_STEM_STAIRS)
+        .put(SuCraftBlocks.CRIMSON_HYPHAE_STAIRS, SuCraftBlocks.STRIPPED_CRIMSON_HYPHAE_STAIRS)
+        .put(SuCraftBlocks.MANGROVE_WOOD_STAIRS, SuCraftBlocks.STRIPPED_MANGROVE_WOOD_STAIRS)
+        .put(SuCraftBlocks.MANGROVE_LOG_STAIRS, SuCraftBlocks.STRIPPED_MANGROVE_LOG_STAIRS)
+        .build();
+    // Suki end - custom blocks and items
 
     protected AxeItem(Tier material, float attackDamage, float attackSpeed, Item.Properties settings) {
         super(attackDamage, attackSpeed, material, BlockTags.MINEABLE_WITH_AXE, settings);
@@ -74,7 +133,7 @@ public class AxeItem extends DiggerItem {
 
     private Optional<BlockState> getStripped(BlockState state) {
         return Optional.ofNullable(STRIPPABLES.get(state.getBlock())).map((block) -> {
-            return block.defaultBlockState().setValue(RotatedPillarBlock.AXIS, state.getValue(RotatedPillarBlock.AXIS));
+            return block.withPropertiesOf(state); // Suki - custom blocks and items
         });
     }
 }
diff --git a/src/main/java/net/minecraft/world/item/DyeItem.java b/src/main/java/net/minecraft/world/item/DyeItem.java
index 6a492ac3e67c743210d632aaddb5d5e67948468d..381dacbcefc96bd855e90f341fac4026cb1bfa18 100644
--- a/src/main/java/net/minecraft/world/item/DyeItem.java
+++ b/src/main/java/net/minecraft/world/item/DyeItem.java
@@ -2,14 +2,25 @@ package net.minecraft.world.item;
 
 import com.google.common.collect.Maps;
 import java.util.Map;
+
+import net.minecraft.core.BlockPos;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.sounds.SoundSource;
+import net.minecraft.tags.BlockTags;
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.LivingEntity;
 import net.minecraft.world.entity.animal.Sheep;
 import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.context.UseOnContext;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.EndPortalFrameBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import org.sucraft.suki.block.SuCraftBlockTags;
+import org.sucraft.suki.block.SuCraftBlocks;
 import org.bukkit.event.entity.SheepDyeWoolEvent; // CraftBukkit
 
 public class DyeItem extends Item {
@@ -23,6 +34,54 @@ public class DyeItem extends Item {
         DyeItem.ITEM_BY_COLOR.put(color, this);
     }
 
+    // Suki start - custom blocks and items
+
+    @Override
+    public InteractionResult useOn(UseOnContext context) {
+        Level world = context.getLevel();
+        BlockPos blockposition = context.getClickedPos();
+        BlockState iblockdata = world.getBlockState(blockposition);
+        if (iblockdata.is(Blocks.SOUL_FIRE) || iblockdata.is(SuCraftBlockTags.COLORED_FIRE)) {
+            if (world.isClientSide) {
+                return InteractionResult.SUCCESS;
+            } else {
+
+                Block block1 = switch (this.dyeColor) {
+                    case WHITE -> SuCraftBlocks.WHITE_FIRE;
+                    case ORANGE -> SuCraftBlocks.ORANGE_FIRE;
+                    case MAGENTA -> SuCraftBlocks.MAGENTA_FIRE;
+                    case LIGHT_BLUE -> SuCraftBlocks.LIGHT_BLUE_FIRE;
+                    case YELLOW -> SuCraftBlocks.YELLOW_FIRE;
+                    case LIME -> SuCraftBlocks.LIME_FIRE;
+                    case PINK -> SuCraftBlocks.PINK_FIRE;
+                    case GRAY -> SuCraftBlocks.GRAY_FIRE;
+                    case LIGHT_GRAY -> SuCraftBlocks.LIGHT_GRAY_FIRE;
+                    case CYAN -> SuCraftBlocks.CYAN_FIRE;
+                    case PURPLE -> SuCraftBlocks.PURPLE_FIRE;
+                    case BLUE -> SuCraftBlocks.BLUE_FIRE;
+                    case BROWN -> SuCraftBlocks.BROWN_FIRE;
+                    case GREEN -> SuCraftBlocks.GREEN_FIRE;
+                    case RED -> SuCraftBlocks.RED_FIRE;
+                    case BLACK -> SuCraftBlocks.BLACK_FIRE;
+                };
+                if (iblockdata.is(block1)) {
+                    return InteractionResult.PASS;
+                }
+                BlockState iblockdata1 = block1.defaultBlockState();
+
+                world.setBlock(blockposition, iblockdata1, 2);
+                context.getItemInHand().shrink(1);
+
+                return InteractionResult.CONSUME;
+
+            }
+        } else {
+            return InteractionResult.PASS;
+        }
+    }
+
+    // Suki end - custom blocks and items
+
     @Override
     public InteractionResult interactLivingEntity(ItemStack stack, Player user, LivingEntity entity, InteractionHand hand) {
         if (entity instanceof Sheep) {
diff --git a/src/main/java/net/minecraft/world/item/FlintAndSteelItem.java b/src/main/java/net/minecraft/world/item/FlintAndSteelItem.java
index 81994943198b92a3975910e1c50b9579912ff008..6fe157c073666db14dd79b6ef2a03eb8f39c3f21 100644
--- a/src/main/java/net/minecraft/world/item/FlintAndSteelItem.java
+++ b/src/main/java/net/minecraft/world/item/FlintAndSteelItem.java
@@ -17,6 +17,8 @@ import net.minecraft.world.level.block.CandleCakeBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.gameevent.GameEvent;
+import org.sucraft.suki.block.PeatBlock;
+import org.sucraft.suki.block.SuCraftBlocks;
 
 public class FlintAndSteelItem extends Item {
 
@@ -31,7 +33,7 @@ public class FlintAndSteelItem extends Item {
         BlockPos blockposition = context.getClickedPos();
         BlockState iblockdata = world.getBlockState(blockposition);
 
-        if (!CampfireBlock.canLight(iblockdata) && !CandleBlock.canLight(iblockdata) && !CandleCakeBlock.canLight(iblockdata)) {
+        if (!CampfireBlock.canLight(iblockdata) && !CandleBlock.canLight(iblockdata) && !CandleCakeBlock.canLight(iblockdata) && !PeatBlock.canLightPeat(iblockdata)) { // Suki - custom blocks
             BlockPos blockposition1 = blockposition.relative(context.getClickedFace());
 
             if (BaseFireBlock.canBePlacedAt(world, blockposition1, context.getHorizontalDirection())) {
@@ -71,7 +73,10 @@ public class FlintAndSteelItem extends Item {
             }
             // CraftBukkit end
             world.playSound(entityhuman, blockposition, SoundEvents.FLINTANDSTEEL_USE, SoundSource.BLOCKS, 1.0F, world.getRandom().nextFloat() * 0.4F + 0.8F);
-            world.setBlock(blockposition, (BlockState) iblockdata.setValue(BlockStateProperties.LIT, true), 11);
+            // Suki start - custom blocks and items
+            var newBlockState = iblockdata.getBlock().equals(SuCraftBlocks.PEAT) ? SuCraftBlocks.SMOULDERING_PEAT.defaultBlockState() : (BlockState) iblockdata.setValue(BlockStateProperties.LIT, true);
+            world.setBlock(blockposition, newBlockState, 11);
+            // Suki end - custom blocks and items
             world.gameEvent((Entity) entityhuman, GameEvent.BLOCK_CHANGE, blockposition);
             if (entityhuman != null) {
                 context.getItemInHand().hurtAndBreak(1, entityhuman, (entityhuman1) -> {
diff --git a/src/main/java/net/minecraft/world/item/Item.java b/src/main/java/net/minecraft/world/item/Item.java
index 7e57163c82f7a4f9df0774f049f724c9b201e023..577bc4a10a735d2ee5e9dbc2dc18fe9361bd1fc1 100644
--- a/src/main/java/net/minecraft/world/item/Item.java
+++ b/src/main/java/net/minecraft/world/item/Item.java
@@ -4,22 +4,46 @@ import com.google.common.collect.ImmutableMultimap;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.mojang.logging.LogUtils;
+
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.UUID;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import it.unimi.dsi.fastutil.Pair;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
 import net.minecraft.SharedConstants;
 import net.minecraft.Util;
+import net.minecraft.advancements.Advancement;
+import net.minecraft.advancements.AdvancementRewards;
+import net.minecraft.advancements.CriterionTriggerInstance;
+import net.minecraft.advancements.RequirementsStrategy;
+import net.minecraft.advancements.critereon.EntityPredicate;
+import net.minecraft.advancements.critereon.InventoryChangeTrigger;
+import net.minecraft.advancements.critereon.ItemPredicate;
+import net.minecraft.advancements.critereon.MinMaxBounds;
+import net.minecraft.advancements.critereon.RecipeUnlockedTrigger;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Holder;
 import net.minecraft.core.NonNullList;
 import net.minecraft.core.Registry;
+import net.minecraft.data.recipes.RecipeBuilder;
+import net.minecraft.data.recipes.ShapedRecipeBuilder;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.util.Mth;
+import net.minecraft.world.Container;
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
 import net.minecraft.world.InteractionResultHolder;
@@ -37,6 +61,9 @@ import net.minecraft.world.inventory.ClickAction;
 import net.minecraft.world.inventory.Slot;
 import net.minecraft.world.inventory.tooltip.TooltipComponent;
 import net.minecraft.world.item.context.UseOnContext;
+import net.minecraft.world.item.crafting.Ingredient;
+import net.minecraft.world.item.crafting.Recipe;
+import net.minecraft.world.item.crafting.StonecutterRecipe;
 import net.minecraft.world.level.ClipContext;
 import net.minecraft.world.level.ItemLike;
 import net.minecraft.world.level.Level;
@@ -44,8 +71,20 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
+import org.sucraft.suki.item.ItemReplacementRule;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.inventory.FurnaceRecipe;
+import org.bukkit.inventory.RecipeChoice;
+import org.bukkit.inventory.ShapedRecipe;
+import org.bukkit.inventory.ShapelessRecipe;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
+import static org.sucraft.suki.item.SuCraftItems.CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR;
+
 public class Item implements ItemLike {
     private static final Logger LOGGER = LogUtils.getLogger();
     public static final Map<Block, Item> BY_BLOCK = Maps.newHashMap();
@@ -68,6 +107,367 @@ public class Item implements ItemLike {
     @Nullable
     private final FoodProperties foodProperties;
 
+    // Suki start - custom blocks and items
+
+    public boolean isVanilla = true;
+
+    /**
+     * This is the {@link ResourceLocation} for this item
+     * <br>
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable ResourceLocation customKey;
+
+    /**
+     * This is the {@link ResourceLocation} for this item
+     * <br>
+     * Will always be non-null after it has been registered
+     */
+    public @Nullable ResourceLocation id;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable ItemReplacementRule replacementRule = null;
+
+    public void setRename(@NotNull net.kyori.adventure.text.Component kyoriDisplayName, @NotNull String displayNameJSON, @NotNull net.kyori.adventure.text.Component kyoriDisplayNameInLore, @NotNull String displayNameInLoreJSON) {
+        this.customDisplayName = kyoriDisplayName;
+        this.customDisplayNameJSON = displayNameJSON;
+        this.customDisplayNameInLore = kyoriDisplayNameInLore;
+        this.customDisplayNameInLoreJSON = displayNameInLoreJSON;
+    }
+
+    public void setRename(@NotNull String displayName) {
+        var kyoriDisplayName = net.kyori.adventure.text.Component.text(displayName, PaperAdventure.asAdventure(rarity.color)).decoration(TextDecoration.ITALIC, false);
+        var displayNameJSON = GsonComponentSerializer.gson().serialize(kyoriDisplayName);
+        var kyoriDisplayNameInLore = net.kyori.adventure.text.Component.text(displayName, PaperAdventure.asAdventure(CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR)).decoration(TextDecoration.ITALIC, false);
+        var displayNameInLoreJSON = GsonComponentSerializer.gson().serialize(kyoriDisplayNameInLore);
+        this.setRename(kyoriDisplayName, displayNameJSON, kyoriDisplayNameInLore, displayNameInLoreJSON);
+    }
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable net.kyori.adventure.text.Component customDisplayName = null;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable String customDisplayNameJSON = null;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable net.kyori.adventure.text.Component customDisplayNameInLore = null;
+
+    /**
+     * Must be non-null for SuCraft items
+     */
+    public @Nullable String customDisplayNameInLoreJSON = null;
+
+    /**
+     * Based on {@link RecipeBuilder#ROOT_RECIPE_ADVANCEMENT}
+     */
+    public static final ResourceLocation ROOT_RECIPE_ADVANCEMENT = new ResourceLocation("recipes/root");
+
+    public interface CustomRecipeUnlock {
+
+        void register(@NotNull ResourceLocation recipeKey);
+
+    }
+
+    public record CustomRecipeUnlockByItem(@NotNull Supplier<@NotNull ItemLike> itemSupplier) implements CustomRecipeUnlock {
+
+        @Override
+        public void register(@NotNull ResourceLocation recipeKey) {
+            register(this.itemSupplier.get().asItem(), recipeKey);
+        }
+
+        public static void register(@NotNull Item item, @NotNull ResourceLocation recipeKey) {
+            var advancement = Advancement.Builder.advancement();
+            ItemPredicate[] itemPredicates = {ItemPredicate.Builder.item().of(item).build()};
+            advancement.addCriterion("has_" + item.id.getPath(), new InventoryChangeTrigger.TriggerInstance(EntityPredicate.Composite.ANY, MinMaxBounds.Ints.ANY, MinMaxBounds.Ints.ANY, MinMaxBounds.Ints.ANY, itemPredicates));
+            advancement.parent(ROOT_RECIPE_ADVANCEMENT).addCriterion("has_the_recipe", RecipeUnlockedTrigger.unlocked(recipeKey)).rewards(AdvancementRewards.Builder.recipe(recipeKey)).requirements(RequirementsStrategy.OR);
+        }
+
+    }
+
+//    public record CustomRecipeUnlockedBy(String string, CriterionTriggerInstance criterionTriggerInstance) {}
+
+    public interface CustomRecipe {
+
+        @NotNull ResourceLocation key();
+
+        @NotNull String group();
+
+        void registerUnlocks();
+
+        boolean isSkippableForPlayersThatCannotAcceptLargePackets();
+
+    }
+
+    public interface CustomRecipeWithSingleIngredient extends CustomRecipe {
+
+        @NotNull Item getSingleIngredient();
+
+        @Override
+        default void registerUnlocks() {
+            var ingredient = this.getSingleIngredient();
+            CustomRecipeUnlockByItem.register(ingredient, this.key());
+        }
+
+    }
+
+    public interface CustomRecipeWithConcreteUnlocks extends CustomRecipe {
+
+        @NotNull CustomRecipeUnlock @NotNull [] getUnlocks();
+
+        @Override
+        default void registerUnlocks() {
+            for (var unlock : this.getUnlocks()) {
+                unlock.register(this.key());
+            }
+        }
+
+    }
+
+    public interface CustomMinecraftRecipe extends CustomRecipe {
+
+        @NotNull Recipe<Container> build(@NotNull Item result);
+
+    }
+
+    public interface CustomBukkitRecipe extends CustomRecipe {
+
+        @NotNull org.bukkit.inventory.Recipe build(@NotNull Item result);
+
+    }
+
+    public record CustomStonecutterRecipe(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull Item ingredient, int resultAmount) implements CustomMinecraftRecipe, CustomRecipeWithSingleIngredient {
+
+        @Override
+        public @NotNull StonecutterRecipe build(@NotNull Item result) {
+            var recipeIngredient = new Ingredient(Stream.of(new Ingredient.ItemValue(new ItemStack(ingredient))));
+//            recipeIngredient.exact = true;
+            return new StonecutterRecipe(key, group == null ? key.getPath() : group, recipeIngredient, new ItemStack(result, resultAmount), true);
+        }
+
+        @Override
+        public @NotNull Item getSingleIngredient() {
+            return this.ingredient();
+        }
+
+        @Override
+        public boolean isSkippableForPlayersThatCannotAcceptLargePackets() {
+            return this.isSkippableForPlayersThatCannotAcceptLargePackets;
+        }
+
+    }
+
+    public record CustomShapedRecipeIngredientDefinition(char character, @NotNull ItemLike ingredient) {}
+
+    public record CustomShapedRecipe(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull CustomShapedRecipeIngredientDefinition @NotNull [] ingredients, @NotNull String @NotNull [] patterns, @NotNull CustomRecipeUnlock @NotNull [] unlocks, int resultAmount) implements CustomBukkitRecipe, CustomRecipeWithConcreteUnlocks {
+
+        public @NotNull ShapedRecipe build(@NotNull Item result) {
+            var recipe = new ShapedRecipe(this.key.asBukkit(), new ItemStack(result, this.resultAmount).getBukkitStack());
+            recipe.setGroup(this.group != null ? this.group : this.key.getPath());
+            recipe.shape(this.patterns);
+            for (var definition : this.ingredients) {
+                Material type = CraftMagicNumbers.getMaterial(definition.ingredient.asItem());
+                recipe.setIngredient(definition.character, new org.bukkit.inventory.ItemStack(type));
+            }
+            return recipe;
+        }
+
+        @Override
+        public @NotNull CustomRecipeUnlock @NotNull [] getUnlocks() {
+            return this.unlocks();
+        }
+
+        public static @NotNull CustomShapedRecipe getWithoutUnlocks(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull CustomShapedRecipeIngredientDefinition @NotNull [] ingredients, @NotNull String @NotNull [] patterns, int resultAmount) {
+            return new CustomShapedRecipe(key, group, isSkippableForPlayersThatCannotAcceptLargePackets, ingredients, patterns, new CustomRecipeUnlock[0], resultAmount);
+        }
+
+        public static @NotNull CustomShapedRecipe getUnlockedByItem(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull CustomShapedRecipeIngredientDefinition @NotNull [] ingredients, @NotNull String @NotNull [] patterns, @NotNull Item unlockItem, int resultAmount) {
+            return new CustomShapedRecipe(key, group, isSkippableForPlayersThatCannotAcceptLargePackets, ingredients, patterns, new CustomRecipeUnlock[] {new CustomRecipeUnlockByItem(() -> unlockItem)}, resultAmount);
+        }
+
+        public static @NotNull CustomShapedRecipe craftSlab(@NotNull Block slabBlock, @NotNull Block fullBlock, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+            return craftSlab(slabBlock, fullBlock, null, isSkippableForPlayersThatCannotAcceptLargePackets);
+        }
+
+        public static @NotNull CustomShapedRecipe craftSlab(@NotNull Block slabBlock, @NotNull Block fullBlock, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+            return getUnlockedByItem(
+                ResourceLocation.sucraft(slabBlock.id.getPath() + "_from_" + fullBlock.id.getPath() + "_crafting"),
+                group,
+                isSkippableForPlayersThatCannotAcceptLargePackets,
+                new CustomShapedRecipeIngredientDefinition[] {new CustomShapedRecipeIngredientDefinition('$', fullBlock.asItem())},
+                new String[] {"$$$"}, slabBlock.asItem(),
+                6
+            );
+        }
+
+        public static @NotNull CustomShapedRecipe craftStairs(@NotNull Block slabBlock, @NotNull Block fullBlock, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+            return craftStairs(slabBlock, fullBlock, null, isSkippableForPlayersThatCannotAcceptLargePackets);
+        }
+
+        public static @NotNull CustomShapedRecipe craftStairs(@NotNull Block slabBlock, @NotNull Block fullBlock, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+            return getUnlockedByItem(
+                ResourceLocation.sucraft(slabBlock.id.getPath() + "_from_" + fullBlock.id.getPath() + "_crafting"),
+                group,
+                isSkippableForPlayersThatCannotAcceptLargePackets,
+                new CustomShapedRecipeIngredientDefinition[] {new CustomShapedRecipeIngredientDefinition('$', fullBlock.asItem())},
+                new String[] {"$  ", "$$ ", "$$$"}, slabBlock.asItem(),
+                4
+            );
+        }
+
+        @Override
+        public boolean isSkippableForPlayersThatCannotAcceptLargePackets() {
+            return this.isSkippableForPlayersThatCannotAcceptLargePackets;
+        }
+
+    }
+
+    public record CustomChoiceShapedRecipeIngredientDefinition(char character, @NotNull ItemLike @NotNull [] ingredientChoice) {}
+
+    public record CustomChoiceShapedRecipe(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull CustomChoiceShapedRecipeIngredientDefinition @NotNull [] ingredientChoices, @NotNull String @NotNull [] patterns, @NotNull CustomRecipeUnlock @NotNull [] unlocks, int resultAmount) implements CustomBukkitRecipe, CustomRecipeWithConcreteUnlocks {
+
+        public @NotNull ShapedRecipe build(@NotNull Item result) {
+            var recipe = new ShapedRecipe(this.key.asBukkit(), new ItemStack(result, this.resultAmount).getBukkitStack());
+            recipe.setGroup(this.group != null ? this.group : this.key.getPath());
+            recipe.shape(this.patterns);
+            for (var definition : this.ingredientChoices) {
+                RecipeChoice recipeChoice = new RecipeChoice.MaterialChoice(Arrays.stream(definition.ingredientChoice).map(ingredient -> CraftMagicNumbers.getMaterial(ingredient.asItem())).toArray(Material[]::new));
+                recipe.setIngredient(definition.character, recipeChoice);
+            }
+            return recipe;
+        }
+
+        @Override
+        public @NotNull CustomRecipeUnlock @NotNull [] getUnlocks() {
+            return this.unlocks();
+        }
+
+        public static @NotNull CustomChoiceShapedRecipe getWithoutUnlocks(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull CustomChoiceShapedRecipeIngredientDefinition @NotNull [] ingredientChoices, @NotNull String @NotNull [] patterns, int resultAmount) {
+            return new CustomChoiceShapedRecipe(key, group, isSkippableForPlayersThatCannotAcceptLargePackets, ingredientChoices, patterns, new CustomRecipeUnlock[0], resultAmount);
+        }
+
+        @Override
+        public boolean isSkippableForPlayersThatCannotAcceptLargePackets() {
+            return this.isSkippableForPlayersThatCannotAcceptLargePackets;
+        }
+
+    }
+
+    public record CustomShapelessRecipe(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull ItemLike @NotNull [] ingredients, @NotNull CustomRecipeUnlock @NotNull [] unlocks, int resultAmount) implements CustomBukkitRecipe, CustomRecipeWithConcreteUnlocks {
+
+        public @NotNull ShapelessRecipe build(@NotNull Item result) {
+            var recipe = new ShapelessRecipe(this.key.asBukkit(), new ItemStack(result, this.resultAmount).getBukkitStack());
+            recipe.setGroup(this.group != null ? this.group : this.key.getPath());
+            for (var ingredient : this.ingredients) {
+                Material type = CraftMagicNumbers.getMaterial(ingredient.asItem());
+                recipe.addIngredient(type);
+            }
+            return recipe;
+        }
+
+        @Override
+        public @NotNull CustomRecipeUnlock @NotNull [] getUnlocks() {
+            return this.unlocks();
+        }
+
+        public static @NotNull CustomShapelessRecipe getWithoutUnlocks(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull ItemLike @NotNull [] ingredients, int resultAmount) {
+            return new CustomShapelessRecipe(key, group, isSkippableForPlayersThatCannotAcceptLargePackets, ingredients, new CustomRecipeUnlock[0], resultAmount);
+        }
+
+        public static @NotNull CustomShapelessRecipe getUnlockedByItem(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull ItemLike @NotNull [] ingredients, @NotNull Item unlockItem, int resultAmount) {
+            return new CustomShapelessRecipe(key, group, isSkippableForPlayersThatCannotAcceptLargePackets, ingredients, new CustomRecipeUnlock[]{new CustomRecipeUnlockByItem(() -> unlockItem)}, resultAmount);
+        }
+
+        @Override
+        public boolean isSkippableForPlayersThatCannotAcceptLargePackets() {
+            return this.isSkippableForPlayersThatCannotAcceptLargePackets;
+        }
+
+    }
+
+    public record CustomChoiceShapelessRecipe(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull ItemLike @NotNull [] @NotNull [] ingredientChoices, @NotNull CustomRecipeUnlock @NotNull [] unlocks, int resultAmount) implements CustomBukkitRecipe, CustomRecipeWithConcreteUnlocks {
+
+        public @NotNull ShapelessRecipe build(@NotNull Item result) {
+            var recipe = new ShapelessRecipe(this.key.asBukkit(), new ItemStack(result, this.resultAmount).getBukkitStack());
+            recipe.setGroup(this.group != null ? this.group : this.key.getPath());
+            for (var ingredientChoice : this.ingredientChoices) {
+                Material[] types = Arrays.stream(ingredientChoice).map(ingredient -> CraftMagicNumbers.getMaterial(ingredient.asItem())).toArray(Material[]::new);
+                recipe.addIngredient(new RecipeChoice.MaterialChoice(types));
+            }
+            return recipe;
+        }
+
+        @Override
+        public @NotNull CustomRecipeUnlock @NotNull [] getUnlocks() {
+            return this.unlocks();
+        }
+
+        public static @NotNull CustomChoiceShapelessRecipe getWithoutUnlocks(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull ItemLike @NotNull [] @NotNull [] ingredientChoices, int resultAmount) {
+            return new CustomChoiceShapelessRecipe(key, group, isSkippableForPlayersThatCannotAcceptLargePackets, ingredientChoices, new CustomRecipeUnlock[0], resultAmount);
+        }
+
+        public static @NotNull CustomChoiceShapelessRecipe getUnlockedByItem(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull ItemLike @NotNull [] @NotNull [] ingredientChoices, @NotNull Item unlockItem, int resultAmount) {
+            return new CustomChoiceShapelessRecipe(key, group, isSkippableForPlayersThatCannotAcceptLargePackets, ingredientChoices, new CustomRecipeUnlock[]{new CustomRecipeUnlockByItem(() -> unlockItem)}, resultAmount);
+        }
+
+        @Override
+        public boolean isSkippableForPlayersThatCannotAcceptLargePackets() {
+            return this.isSkippableForPlayersThatCannotAcceptLargePackets;
+        }
+
+    }
+
+    public record CustomFurnaceRecipe(@NotNull ResourceLocation key, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets, @NotNull ItemLike ingredient, float experience, int cookingTime) implements CustomBukkitRecipe, CustomRecipeWithSingleIngredient {
+
+        public @NotNull FurnaceRecipe build(@NotNull Item result) {
+            return new FurnaceRecipe(
+                this.key.asBukkit(),
+                new ItemStack(result).getBukkitStack(),
+                CraftMagicNumbers.getMaterial(this.ingredient.asItem()),
+                experience,
+                cookingTime
+            );
+        }
+
+        @Override
+        public @NotNull Item getSingleIngredient() {
+            return this.ingredient.asItem();
+        }
+
+        @Override
+        public boolean isSkippableForPlayersThatCannotAcceptLargePackets() {
+            return this.isSkippableForPlayersThatCannotAcceptLargePackets;
+        }
+
+    }
+
+    public @NotNull List<@NotNull CustomRecipe> customRecipes = new ArrayList<>(0);
+    public @NotNull List<@NotNull Supplier<CustomRecipe>> customRecipeSuppliers = new ArrayList<>(0);
+
+    public void invokeCustomRecipeSuppliers() {
+        this.customRecipeSuppliers.forEach(supplier -> this.customRecipes.add(supplier.get()));
+        this.customRecipeSuppliers.clear();
+    }
+
+    public @NotNull Item withCustomRecipe(@NotNull CustomRecipe recipe) {
+        this.customRecipes.add(recipe);
+        return this;
+    }
+
+    public @NotNull Item withCustomRecipeSupplier(@NotNull Supplier<CustomRecipe> recipeSupplier) {
+        this.customRecipeSuppliers.add(recipeSupplier);
+        return this;
+    }
+
+    // Suki end - custom blocks and items
+
     public static int getId(Item item) {
         return item == null ? 0 : Registry.ITEM.getId(item);
     }
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 7da482dca5a0da9badff64736cfbfa37259208ce..4f09c7bf60b8c01fcc9c6062890d5a1a44d6ee7b 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -675,6 +675,25 @@ public final class ItemStack {
         return this.getItem().isCorrectToolForDrops(state);
     }
 
+    // Suki start - custom blocks and items
+
+    public boolean isCorrectToolForFasterBreaking(net.minecraft.world.level.block.state.BlockState state, boolean doPlayerObservableLookups) {
+        if (this.isCorrectToolForDrops(state)) {
+            return true;
+        }
+        if (doPlayerObservableLookups) {
+            for (int playerObservableStateId : Block.realStateToPlayerObservableStates[Block.BLOCK_STATE_REGISTRY.getId(state)]) {
+                net.minecraft.world.level.block.state.BlockState playerObservableState = Block.BLOCK_STATE_REGISTRY.byId(playerObservableStateId);
+                if (this.isCorrectToolForFasterBreaking(playerObservableState, false)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    // Suki end - custom blocks and items
+
     public InteractionResult interactLivingEntity(net.minecraft.world.entity.player.Player user, LivingEntity entity, InteractionHand hand) {
         return this.getItem().interactLivingEntity(this, user, entity, hand);
     }
@@ -1329,4 +1348,42 @@ public final class ItemStack {
             return this.mask;
         }
     }
+
+    // Suki start - custom blocks and items
+
+    public static final String ADD_TECHNICAL_PROPERTIES_LORE_TAG_KEY = "AddTechnicalPropertiesLore";
+    public static final String ADD_UNDERLYING_ITEM_LORE_IF_RENAMED_TAG_KEY = "AddUnderlyingItemLoreIfRenamed";
+
+    public boolean getAddTechnicalPropertiesLore() {
+        CompoundTag tag = this.getTag();
+        if (tag == null) {
+            return true;
+        }
+        if (!tag.contains(ADD_TECHNICAL_PROPERTIES_LORE_TAG_KEY, Tag.TAG_BYTE)) {
+            return true;
+        }
+        return tag.getBoolean(ADD_TECHNICAL_PROPERTIES_LORE_TAG_KEY);
+    }
+
+    public void setAddTechnicalPropertiesLore(boolean add) {
+        this.getOrCreateTag().putBoolean(ADD_TECHNICAL_PROPERTIES_LORE_TAG_KEY, add);
+    }
+
+    public boolean getAddUnderlyingItemLoreIfRenamed() {
+        CompoundTag tag = this.getTag();
+        if (tag == null) {
+            return true;
+        }
+        if (!tag.contains(ADD_UNDERLYING_ITEM_LORE_IF_RENAMED_TAG_KEY, Tag.TAG_BYTE)) {
+            return true;
+        }
+        return tag.getBoolean(ADD_UNDERLYING_ITEM_LORE_IF_RENAMED_TAG_KEY);
+    }
+
+    public void setAddUnderlyingItemLoreIfRenamed(boolean add) {
+        this.getOrCreateTag().putBoolean(ADD_UNDERLYING_ITEM_LORE_IF_RENAMED_TAG_KEY, add);
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/item/Items.java b/src/main/java/net/minecraft/world/item/Items.java
index 51016663829b1f36b8e752dcf9c9361282c3f06b..3b4138ee2598d0ff995e62406574e0c9b3035fee 100644
--- a/src/main/java/net/minecraft/world/item/Items.java
+++ b/src/main/java/net/minecraft/world/item/Items.java
@@ -14,6 +14,9 @@ import net.minecraft.world.food.Foods;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.material.Fluids;
+import org.sucraft.suki.item.SuCraftItems;
+import org.sucraft.suki.resourcepack.httpserver.ResourcePackHTTPServer;
+import org.sucraft.suki.resourcepack.sucraft.CreateSuCraftResourcePack;
 
 public class Items {
     public static final Item AIR = registerBlock(Blocks.AIR, new AirItem(Blocks.AIR, new Item.Properties()));
@@ -242,7 +245,7 @@ public class Items {
     public static final Item STONE_SLAB = registerBlock(Blocks.STONE_SLAB, CreativeModeTab.TAB_BUILDING_BLOCKS);
     public static final Item SMOOTH_STONE_SLAB = registerBlock(Blocks.SMOOTH_STONE_SLAB, CreativeModeTab.TAB_BUILDING_BLOCKS);
     public static final Item SANDSTONE_SLAB = registerBlock(Blocks.SANDSTONE_SLAB, CreativeModeTab.TAB_BUILDING_BLOCKS);
-    public static final Item CUT_STANDSTONE_SLAB = registerBlock(Blocks.CUT_SANDSTONE_SLAB, CreativeModeTab.TAB_BUILDING_BLOCKS);
+    public static final Item CUT_SANDSTONE_SLAB = registerBlock(Blocks.CUT_SANDSTONE_SLAB, CreativeModeTab.TAB_BUILDING_BLOCKS);
     public static final Item PETRIFIED_OAK_SLAB = registerBlock(Blocks.PETRIFIED_OAK_SLAB, CreativeModeTab.TAB_BUILDING_BLOCKS);
     public static final Item COBBLESTONE_SLAB = registerBlock(Blocks.COBBLESTONE_SLAB, CreativeModeTab.TAB_BUILDING_BLOCKS);
     public static final Item BRICK_SLAB = registerBlock(Blocks.BRICK_SLAB, CreativeModeTab.TAB_BUILDING_BLOCKS);
@@ -1173,15 +1176,23 @@ public class Items {
         return Optional.empty();
     }
 
-    private static Item registerBlock(Block block) {
+    public static Item registerBlock(Block block) { // Suki - custom blocks and items
         return registerBlock(new BlockItem(block, new Item.Properties()));
     }
 
-    private static Item registerBlock(Block block, CreativeModeTab group) {
+    // Suki start - custom blocks and items
+
+    public static Item registerBlock(Block block, Item.Properties properties) {
+        return registerBlock(new BlockItem(block, properties));
+    }
+
+    // Suki end - custom blocks and items
+
+    public static Item registerBlock(Block block, CreativeModeTab group) { // Suki - custom blocks and items
         return registerBlock(new BlockItem(block, (new Item.Properties()).tab(group)));
     }
 
-    private static Item registerBlock(Block block, Optional<CreativeModeTab> group) {
+    public static Item registerBlock(Block block, Optional<CreativeModeTab> group) { // Suki - custom blocks and items
         return group.map((groupx) -> {
             return registerBlock(block, groupx);
         }).orElseGet(() -> {
@@ -1189,7 +1200,7 @@ public class Items {
         });
     }
 
-    private static Item registerBlock(Block block, CreativeModeTab group, Block... blocks) {
+    public static Item registerBlock(Block block, CreativeModeTab group, Block... blocks) { // Suki - custom blocks and items
         BlockItem blockItem = new BlockItem(block, (new Item.Properties()).tab(group));
 
         for(Block block2 : blocks) {
@@ -1199,23 +1210,42 @@ public class Items {
         return registerBlock(blockItem);
     }
 
-    private static Item registerBlock(BlockItem item) {
+    public static Item registerBlock(BlockItem item) { // Suki - custom blocks and items
         return registerBlock(item.getBlock(), item);
     }
 
-    protected static Item registerBlock(Block block, Item item) {
+    public static Item registerBlock(Block block, Item item) { // Suki - custom blocks and items
         return registerItem(Registry.BLOCK.getKey(block), item);
     }
 
-    private static Item registerItem(String id, Item item) {
+    public static Item registerItem(String id, Item item) { // Suki - custom blocks and items
         return registerItem(new ResourceLocation(id), item);
     }
 
-    private static Item registerItem(ResourceLocation id, Item item) {
+    public static Item registerItem(ResourceLocation id, Item item) { // Suki - custom blocks and items
         if (item instanceof BlockItem) {
             ((BlockItem)item).registerBlocks(Item.BY_BLOCK, item);
         }
-
+        item.id = id; // Suki - custom blocks and items
         return Registry.register(Registry.ITEM, id, item);
     }
+
+    // Suki start - custom blocks and items
+    static {
+
+        // Evaluate the last element to bootstrap Items
+        ECHO_SHARD.asItem();
+        // Set some custom name replacements
+        BOOKSHELF.setRename("Oak Bookshelf");
+        STONECUTTER.setRename("Blockcutter");
+        // Then bootstrap SuCraftItems
+        SuCraftItems.bootstrap();
+
+        // Start the HTTP server that serves the resource pack
+        ResourcePackHTTPServer.getInstance().startIfNotStarted();
+
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/item/crafting/Recipe.java b/src/main/java/net/minecraft/world/item/crafting/Recipe.java
index 6d50c7ae912a36c8d3caaf26e2fc2dc20731b279..46695290d586dabf3b00b3ee3b3046edfb7bb7c7 100644
--- a/src/main/java/net/minecraft/world/item/crafting/Recipe.java
+++ b/src/main/java/net/minecraft/world/item/crafting/Recipe.java
@@ -2,11 +2,16 @@ package net.minecraft.world.item.crafting;
 
 import net.minecraft.core.NonNullList;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.Container;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 public interface Recipe<C extends Container> {
 
@@ -18,6 +23,46 @@ public interface Recipe<C extends Container> {
 
     ItemStack getResultItem();
 
+    // Suki start - custom blocks and items
+
+    default @NotNull ItemStack getReplacedResultItem(@NotNull Player player) {
+        return this.getReplacedResultItem(player.hasSuCraftResourcePack(), player.hasHighPingForCustomBlocks());
+    }
+
+    default @NotNull ItemStack getReplacedResultItem(@NotNull ServerPlayer player) {
+        return this.getReplacedResultItem(player.hasSuCraftResourcePack(), player.hasHighPingForCustomBlocks());
+    }
+
+    default @NotNull ItemStack getReplacedResultItem(boolean hasSuCraftResourcePack, boolean hasHighPingForCustomBlocks) {
+        return this.getResultItem();
+    }
+
+    default @NotNull String getReplacedResultItemDescriptionId(@NotNull Player player) {
+        return this.getReplacedResultItemDescriptionId(player.hasSuCraftResourcePack(), player.hasHighPingForCustomBlocks());
+    }
+
+    default @NotNull String getReplacedResultItemDescriptionId(@NotNull ServerPlayer player) {
+        return this.getReplacedResultItemDescriptionId(player.hasSuCraftResourcePack(), player.hasHighPingForCustomBlocks());
+    }
+
+    default @NotNull String getReplacedResultItemDescriptionId(boolean hasSuCraftResourcePack, boolean hasHighPingForCustomBlocks) {
+        return this.getReplacedResultItem(hasSuCraftResourcePack, hasHighPingForCustomBlocks).getDescriptionId();
+    }
+
+    default boolean shouldAlwaysSend(boolean canPlayerAcceptLargePackets) {
+        return canPlayerAcceptLargePackets || !MinecraftServer.getServer().getRecipeManager().recipesSkippableForPlayersThatCannotAcceptLargePackets.contains(this.getId());
+    }
+
+    default boolean shouldSpecificallySend(@NotNull ServerPlayer player, @Nullable ItemStack stonecutterInput) {
+        return false;
+    }
+
+    default boolean shouldSendRightNow(@NotNull ServerPlayer player, @Nullable ItemStack stonecutterInput) {
+        return this.shouldAlwaysSend(player.canAcceptLargePackets()) || this.shouldSpecificallySend(player, stonecutterInput);
+    }
+
+    // Suki end - custom blocks and items
+
     default NonNullList<ItemStack> getRemainingItems(C inventory) {
         NonNullList<ItemStack> nonnulllist = NonNullList.withSize(inventory.getContainerSize(), ItemStack.EMPTY);
 
diff --git a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
index 4872f70977e73c889fe6e2339d00ebc64459613d..2ff9f663a5211db8278a9656470cb07d67c5866f 100644
--- a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
@@ -14,11 +14,14 @@ import com.mojang.logging.LogUtils;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.HashSet;
+import java.util.IdentityHashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Optional;
+import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
@@ -32,6 +35,7 @@ import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.Container;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
+import org.bukkit.entity.Player;
 import org.slf4j.Logger;
 
 import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap; // CraftBukkit
@@ -43,6 +47,10 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
     public Map<RecipeType<?>, Object2ObjectLinkedOpenHashMap<ResourceLocation, Recipe<?>>> recipes = ImmutableMap.of(); // CraftBukkit
     public Map<ResourceLocation, Recipe<?>> byName = ImmutableMap.of();
     private boolean hasErrors;
+    // Suki start - custom blocks and items
+    public Set<ResourceLocation> stonecutterRecipesThatAreCustom = new HashSet<>(512);
+    public Set<ResourceLocation> recipesSkippableForPlayersThatCannotAcceptLargePackets = new HashSet<>(2048);
+    // Suki end - custom blocks and items
 
     public RecipeManager() {
         super(RecipeManager.GSON, "recipes");
@@ -86,13 +94,34 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
 
     // CraftBukkit start
     public void addRecipe(Recipe<?> irecipe) {
+        // Suki start - custom blocks and items
+        this.addRecipe(irecipe, false);
+    }
+
+    public void addRecipe(Recipe<?> irecipe, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        // Suki end - custom blocks and items
         org.spigotmc.AsyncCatcher.catchOp("Recipe Add"); // Spigot
         Object2ObjectLinkedOpenHashMap<ResourceLocation, Recipe<?>> map = this.recipes.get(irecipe.getType()); // CraftBukkit
 
+        // Suki start - custom blocks nad items
+        if (irecipe instanceof StonecutterRecipe stonecutterRecipe && stonecutterRecipe.registerAsCustom) {
+            this.stonecutterRecipesThatAreCustom.add(irecipe.getId());
+        }
+        // Suki end - custom blocks and items
+
         if (this.byName.containsKey(irecipe.getId()) || map.containsKey(irecipe.getId())) {
             throw new IllegalStateException("Duplicate recipe ignored with ID " + irecipe.getId());
         } else {
-            map.putAndMoveToFirst(irecipe.getId(), irecipe); // CraftBukkit - SPIGOT-4638: last recipe gets priority
+            // Suki start - custom blocks and items
+            if (irecipe.shouldAlwaysSend(true)) {
+                map.putAndMoveToFirst(irecipe.getId(), irecipe); // CraftBukkit - SPIGOT-4638: last recipe gets priority
+            } else {
+                map.putAndMoveToLast(irecipe.getId(), irecipe);
+            }
+            if (isSkippableForPlayersThatCannotAcceptLargePackets) {
+                this.recipesSkippableForPlayersThatCannotAcceptLargePackets.add(irecipe.getId());
+            }
+            // Suki end - custom blocks and items
             this.byName.put(irecipe.getId(), irecipe);
         }
     }
@@ -135,11 +164,40 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
     }
 
     public <C extends Container, T extends Recipe<C>> List<T> getRecipesFor(RecipeType<T> type, C inventory, Level world) {
+        @Nullable Player player = null;
+        var viewers = inventory.getViewers();
+        if (!viewers.isEmpty()) {
+            var viewer = viewers.get(0);
+            if (viewer instanceof Player) {
+                player = (Player) viewer;
+            }
+        }
+        final @Nullable Player finalPlayer = player;
         return (List) this.byType(type).values().stream().filter((irecipe) -> {
             return irecipe.matches(inventory, world);
-        }).sorted(Comparator.comparing((irecipe) -> {
-            return irecipe.getResultItem().getDescriptionId();
-        })).collect(Collectors.toList());
+            // Suki start - custom blocks and items
+//        }).filter()
+        }).filter(
+            recipe -> (finalPlayer != null && finalPlayer.hasSuCraftResourcePack()) || recipe.shouldAlwaysSend(finalPlayer.canAcceptLargePackets())
+        ).sorted((recipe1, recipe2) -> {
+            ItemStack result1;
+            ItemStack result2;
+            if (finalPlayer != null) {
+                result1 = recipe1.getReplacedResultItem(finalPlayer);
+                result2 = recipe2.getReplacedResultItem(finalPlayer);
+            } else {
+                result1 = recipe1.getResultItem();
+                result2 = recipe2.getResultItem();
+            }
+            String descriptionId1 = result1.getDescriptionId();
+            String descriptionId2 = result2.getDescriptionId();
+            int descriptionIdCompare = descriptionId1.compareTo(descriptionId2);
+            if (descriptionIdCompare != 0) {
+                return descriptionIdCompare;
+            }
+            return Integer.compare(descriptionId1.hashCode(), descriptionId2.hashCode());
+        }).collect(Collectors.toList());
+        // Suki end - custom blocks and items
     }
 
     private <C extends Container, T extends Recipe<C>> Map<ResourceLocation, T> byType(RecipeType<T> type) {
diff --git a/src/main/java/net/minecraft/world/item/crafting/RecipeSerializer.java b/src/main/java/net/minecraft/world/item/crafting/RecipeSerializer.java
index 71d491172b73fa5f428e3cab39240349dd715b6d..ee80e8b7ed663dd79a97ee96ad94375c0b5dbe35 100644
--- a/src/main/java/net/minecraft/world/item/crafting/RecipeSerializer.java
+++ b/src/main/java/net/minecraft/world/item/crafting/RecipeSerializer.java
@@ -25,7 +25,7 @@ public interface RecipeSerializer<T extends Recipe<?>> {
     SimpleCookingSerializer<BlastingRecipe> BLASTING_RECIPE = register("blasting", new SimpleCookingSerializer<>(BlastingRecipe::new, 100));
     SimpleCookingSerializer<SmokingRecipe> SMOKING_RECIPE = register("smoking", new SimpleCookingSerializer<>(SmokingRecipe::new, 100));
     SimpleCookingSerializer<CampfireCookingRecipe> CAMPFIRE_COOKING_RECIPE = register("campfire_cooking", new SimpleCookingSerializer<>(CampfireCookingRecipe::new, 100));
-    RecipeSerializer<StonecutterRecipe> STONECUTTER = register("stonecutting", new SingleItemRecipe.Serializer<>(StonecutterRecipe::new));
+    RecipeSerializer<StonecutterRecipe> STONECUTTER = register("stonecutting", new StonecutterRecipe.Serializer()); // Suki - custom blocks and items
     RecipeSerializer<UpgradeRecipe> SMITHING = register("smithing", new UpgradeRecipe.Serializer());
 
     T fromJson(ResourceLocation id, JsonObject json);
diff --git a/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java b/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java
index 6d5803fcdd0a0b2d106745e9e6b859693b2aade2..cc90efa5383fcf5baf6ce8904e522e26fd18d098 100644
--- a/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java
+++ b/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java
@@ -1,7 +1,14 @@
 package net.minecraft.world.item.crafting;
 
+import com.google.gson.JsonObject;
+import net.minecraft.core.Registry;
+import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.GsonHelper;
 import net.minecraft.world.Container;
+import net.minecraft.world.inventory.StonecutterMenu;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
@@ -12,12 +19,23 @@ import org.bukkit.craftbukkit.inventory.CraftRecipe;
 import org.bukkit.craftbukkit.inventory.CraftStonecuttingRecipe;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.inventory.Recipe;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 // CraftBukkit end
 
 public class StonecutterRecipe extends SingleItemRecipe {
 
+    public final boolean registerAsCustom; // Suki - custom blocks and items
+
     public StonecutterRecipe(ResourceLocation id, String group, Ingredient input, ItemStack output) {
+        // Suki start - custom blocks and items
+        this(id, group, input, output, false);
+    }
+
+    public StonecutterRecipe(ResourceLocation id, String group, Ingredient input, ItemStack output, boolean registerAsCustom) {
         super(RecipeType.STONECUTTING, RecipeSerializer.STONECUTTER, id, group, input, output);
+        this.registerAsCustom = registerAsCustom;
+        // Suki end - custom blocks and items
     }
 
     @Override
@@ -41,4 +59,59 @@ public class StonecutterRecipe extends SingleItemRecipe {
         return recipe;
     }
     // CraftBukkit end
+
+    // Suki start - custom blocks and items
+
+    private Boolean isCustom = null;
+
+    public boolean isCustom() {
+        if (this.isCustom == null) {
+            this.isCustom = this.registerAsCustom || MinecraftServer.getServer().getRecipeManager().stonecutterRecipesThatAreCustom.contains(this.getId());
+        }
+        return this.isCustom;
+    }
+
+    @Override
+    public boolean shouldAlwaysSend(boolean canPlayerAcceptLargePackets) {
+        return !this.isCustom() && super.shouldAlwaysSend(canPlayerAcceptLargePackets);
+    }
+
+    @Override
+    public boolean shouldSpecificallySend(@NotNull ServerPlayer player, @Nullable ItemStack stonecutterInput) {
+        if (!this.isCustom()) {
+            return super.shouldSpecificallySend(player, stonecutterInput);
+        }
+        if (stonecutterInput == null) {
+            return false;
+        }
+        return player.containerMenu instanceof StonecutterMenu && this.ingredient.test(stonecutterInput);
+    }
+
+    public static class Serializer extends SingleItemRecipe.Serializer<StonecutterRecipe> {
+
+        protected Serializer() {
+            super(StonecutterRecipe::new);
+        }
+
+        @Override
+        public void toNetwork(FriendlyByteBuf buf, StonecutterRecipe recipe) {
+            buf.writeUtf(recipe.group);
+            recipe.ingredient.toNetwork(buf);
+            buf.writeItem(recipe.result, true);
+        }
+
+    }
+
+    @Override
+    public @NotNull ItemStack getReplacedResultItem(boolean hasSuCraftResourcePack, boolean hasHighPingForCustomBlocks) {
+        ItemStack result = this.getResultItem();
+        var replacementRule1 = result.getItem().replacementRule;
+        if (replacementRule1 != null) {
+            result = replacementRule1.replace(result, hasSuCraftResourcePack, hasHighPingForCustomBlocks, true);
+        };
+        return result;
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index c22a23c50c6e93765561ab78d157bf030db7c76f..9d43f4a89cc29d8f35312602d60db76b73417f82 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1,10 +1,7 @@
 package net.minecraft.world.level;
 
-import co.aikar.timings.Timing;
-import co.aikar.timings.Timings;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerInternalException;
-import com.google.common.base.MoreObjects;
 import com.google.common.collect.Lists;
 import com.mojang.serialization.Codec;
 import java.io.IOException;
@@ -17,7 +14,6 @@ import java.util.function.Supplier;
 import javax.annotation.Nullable;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
-import net.minecraft.ReportedException;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Holder;
@@ -40,8 +36,6 @@ import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.DifficultyInstance;
 import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.entity.Entity;
-import net.minecraft.world.entity.boss.EnderDragonPart;
-import net.minecraft.world.entity.boss.enderdragon.EnderDragon;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.item.ItemStack;
@@ -89,18 +83,17 @@ import net.minecraft.network.protocol.game.ClientboundSetBorderLerpSizePacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderSizePacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDelayPacket;
 import net.minecraft.network.protocol.game.ClientboundSetBorderWarningDistancePacket;
+import org.sucraft.suki.antixray.ChunkPacketBlockControllerAntiXrayCustom;
+import org.sucraft.suki.antixray.ChunkPacketBlockControllerCustom;
 import org.bukkit.Bukkit;
-import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.block.CapturedBlockState;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.util.CraftSpawnCategory;
-import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.entity.SpawnCategory;
 import org.bukkit.event.block.BlockPhysicsEvent;
-import org.bukkit.event.world.GenericGameEvent;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -373,7 +366,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         this.keepSpawnInMemory = this.paperConfig().spawn.keepSpawnLoaded; // Paper
         //this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime); // JettPack - remove tick limiter
         //this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime); // JettPack - remove tick limiter
-        this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor) : com.destroystokyo.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
+        this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new ChunkPacketBlockControllerAntiXrayCustom(this, executor) : new ChunkPacketBlockControllerCustom(this, executor); // Paper - Anti-Xray // Suki - custom blocks and items
         this.entitySliceManager = new io.papermc.paper.world.EntitySliceManager((ServerLevel)this); // Paper
     }
 
diff --git a/src/main/java/net/minecraft/world/level/biome/OverworldBiomeBuilder.java b/src/main/java/net/minecraft/world/level/biome/OverworldBiomeBuilder.java
index eb8ecff9f249341901477b3e89fff66f5608d48b..9e47210a6f4d27cbbbdb93c59898889652971f18 100644
--- a/src/main/java/net/minecraft/world/level/biome/OverworldBiomeBuilder.java
+++ b/src/main/java/net/minecraft/world/level/biome/OverworldBiomeBuilder.java
@@ -12,6 +12,7 @@ import net.minecraft.util.ToFloatFunction;
 import net.minecraft.util.VisibleForDebug;
 import net.minecraft.world.level.levelgen.DensityFunctions;
 import net.minecraft.world.level.levelgen.NoiseRouterData;
+import org.sucraft.suki.biome.SuCraftBiomes;
 
 public final class OverworldBiomeBuilder {
     private static final float VALLEY_SIZE = 0.05F;
@@ -43,7 +44,7 @@ public final class OverworldBiomeBuilder {
     private final Climate.Parameter midInlandContinentalness = Climate.Parameter.span(0.03F, 0.3F);
     private final Climate.Parameter farInlandContinentalness = Climate.Parameter.span(0.3F, 1.0F);
     private final ResourceKey<Biome>[][] OCEANS = new ResourceKey[][]{{Biomes.DEEP_FROZEN_OCEAN, Biomes.DEEP_COLD_OCEAN, Biomes.DEEP_OCEAN, Biomes.DEEP_LUKEWARM_OCEAN, Biomes.WARM_OCEAN}, {Biomes.FROZEN_OCEAN, Biomes.COLD_OCEAN, Biomes.OCEAN, Biomes.LUKEWARM_OCEAN, Biomes.WARM_OCEAN}};
-    private final ResourceKey<Biome>[][] MIDDLE_BIOMES = new ResourceKey[][]{{Biomes.SNOWY_PLAINS, Biomes.SNOWY_PLAINS, Biomes.SNOWY_PLAINS, Biomes.SNOWY_TAIGA, Biomes.TAIGA}, {Biomes.PLAINS, Biomes.PLAINS, Biomes.FOREST, Biomes.TAIGA, Biomes.OLD_GROWTH_SPRUCE_TAIGA}, {Biomes.FLOWER_FOREST, Biomes.PLAINS, Biomes.FOREST, Biomes.BIRCH_FOREST, Biomes.DARK_FOREST}, {Biomes.SAVANNA, Biomes.SAVANNA, Biomes.FOREST, Biomes.JUNGLE, Biomes.JUNGLE}, {Biomes.DESERT, Biomes.DESERT, Biomes.DESERT, Biomes.DESERT, Biomes.DESERT}};
+    private final ResourceKey<Biome>[][] MIDDLE_BIOMES = new ResourceKey[][]{{Biomes.SNOWY_PLAINS, Biomes.SNOWY_PLAINS, Biomes.SNOWY_PLAINS, Biomes.SNOWY_TAIGA, Biomes.TAIGA}, {Biomes.PLAINS, Biomes.PLAINS, Biomes.FOREST, SuCraftBiomes.ORANGE_FOREST, Biomes.TAIGA, Biomes.OLD_GROWTH_SPRUCE_TAIGA}, {Biomes.FLOWER_FOREST, Biomes.PLAINS, Biomes.FOREST, Biomes.BIRCH_FOREST, Biomes.DARK_FOREST}, {Biomes.SAVANNA, Biomes.SAVANNA, Biomes.FOREST, Biomes.JUNGLE, Biomes.JUNGLE}, {Biomes.DESERT, Biomes.DESERT, Biomes.DESERT, Biomes.DESERT, Biomes.DESERT}}; // Suki - custom blocks and items
     private final ResourceKey<Biome>[][] MIDDLE_BIOMES_VARIANT = new ResourceKey[][]{{Biomes.ICE_SPIKES, null, Biomes.SNOWY_TAIGA, null, null}, {null, null, null, null, Biomes.OLD_GROWTH_PINE_TAIGA}, {Biomes.SUNFLOWER_PLAINS, null, null, Biomes.OLD_GROWTH_BIRCH_FOREST, null}, {null, null, Biomes.PLAINS, Biomes.SPARSE_JUNGLE, Biomes.BAMBOO_JUNGLE}, {null, null, null, null, null}};
     private final ResourceKey<Biome>[][] PLATEAU_BIOMES = new ResourceKey[][]{{Biomes.SNOWY_PLAINS, Biomes.SNOWY_PLAINS, Biomes.SNOWY_PLAINS, Biomes.SNOWY_TAIGA, Biomes.SNOWY_TAIGA}, {Biomes.MEADOW, Biomes.MEADOW, Biomes.FOREST, Biomes.TAIGA, Biomes.OLD_GROWTH_SPRUCE_TAIGA}, {Biomes.MEADOW, Biomes.MEADOW, Biomes.MEADOW, Biomes.MEADOW, Biomes.DARK_FOREST}, {Biomes.SAVANNA_PLATEAU, Biomes.SAVANNA_PLATEAU, Biomes.FOREST, Biomes.FOREST, Biomes.JUNGLE}, {Biomes.BADLANDS, Biomes.BADLANDS, Biomes.BADLANDS, Biomes.WOODED_BADLANDS, Biomes.WOODED_BADLANDS}};
     private final ResourceKey<Biome>[][] PLATEAU_BIOMES_VARIANT = new ResourceKey[][]{{Biomes.ICE_SPIKES, null, null, null, null}, {null, null, Biomes.MEADOW, Biomes.MEADOW, Biomes.OLD_GROWTH_PINE_TAIGA}, {null, null, Biomes.FOREST, Biomes.BIRCH_FOREST, null}, {null, null, null, null, null}, {Biomes.ERODED_BADLANDS, Biomes.ERODED_BADLANDS, null, null, null}};
diff --git a/src/main/java/net/minecraft/world/level/block/BaseFireBlock.java b/src/main/java/net/minecraft/world/level/block/BaseFireBlock.java
index a76c452dc5c2069a3071aec31bfb3e977867161e..7cb4ba538a377819784622dbf05df17637d03866 100644
--- a/src/main/java/net/minecraft/world/level/block/BaseFireBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/BaseFireBlock.java
@@ -15,9 +15,12 @@ import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.SlabType;
 import net.minecraft.world.level.portal.PortalShape;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import org.sucraft.suki.block.SuCraftBlocks;
 
 public abstract class BaseFireBlock extends Block {
 
@@ -196,7 +199,10 @@ public abstract class BaseFireBlock extends Block {
             for (int j = 0; j < i; ++j) {
                 Direction enumdirection1 = aenumdirection[j];
 
-                if (world.getBlockState(blockposition_mutableblockposition.set(pos).move(enumdirection1)).is(Blocks.OBSIDIAN)) {
+                // Suki start - custom blocks and items
+                var relative = world.getBlockState(blockposition_mutableblockposition.set(pos).move(enumdirection1));
+                if (relative.is(Blocks.OBSIDIAN) || relative.is(SuCraftBlocks.OBSIDIAN_STAIRS) || (relative.is(SuCraftBlocks.OBSIDIAN_SLAB) && relative.getValue(BlockStateProperties.SLAB_TYPE) == SlabType.DOUBLE)) {
+                    // Suki end - custom blocks and items
                     flag = true;
                     break;
                 }
diff --git a/src/main/java/net/minecraft/world/level/block/Block.java b/src/main/java/net/minecraft/world/level/block/Block.java
index ebbbb5033f88a4cea866b0415001c2f747e1248f..9cd0c93ebcb0e98066b6b3632c0dc69b9f9934ac 100644
--- a/src/main/java/net/minecraft/world/level/block/Block.java
+++ b/src/main/java/net/minecraft/world/level/block/Block.java
@@ -6,6 +6,9 @@ import com.google.common.cache.LoadingCache;
 import com.google.common.collect.ImmutableMap;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.Object2ByteLinkedOpenHashMap;
+
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.function.Function;
@@ -21,9 +24,11 @@ import net.minecraft.core.NonNullList;
 import net.minecraft.core.Registry;
 import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.stats.Stats;
 import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.TagKey;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.util.valueproviders.IntProvider;
@@ -39,6 +44,7 @@ import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.CreativeModeTab;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
 import net.minecraft.world.item.TooltipFlag;
 import net.minecraft.world.item.context.BlockPlaceContext;
 import net.minecraft.world.item.enchantment.EnchantmentHelper;
@@ -58,11 +64,16 @@ import net.minecraft.world.level.block.state.StateDefinition;
 import net.minecraft.world.level.block.state.properties.Property;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.storage.loot.LootContext;
+import net.minecraft.world.level.storage.loot.LootTable;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParams;
 import net.minecraft.world.phys.Vec3;
 import net.minecraft.world.phys.shapes.BooleanOp;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import org.sucraft.suki.block.SuCraftBlockTags;
+import org.sucraft.suki.block.replacementrule.BlockReplacementRule;
+import org.sucraft.suki.item.SuCraftItems;
+import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 import me.jellysquid.mods.lithium.common.util.collections.Object2BooleanCacheTable; // JettPack
 
@@ -71,10 +82,29 @@ public class Block extends BlockBehaviour implements ItemLike {
     private static final Logger LOGGER = LogUtils.getLogger();
     private final Holder.Reference<Block> builtInRegistryHolder;
     public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY = new IdMapper<>();
+    // Suki start - custom blocks and items
+    public static final IdMapper<BlockState> BLOCK_STATE_REGISTRY_VANILLA = new IdMapper<>();
+    public static int[] stateIdReplacementArrayWithResourcePack;
+    public static int[] stateIdReplacementArrayWithoutResourcePack;
+    public static int[][] realStateToPlayerObservableStates;
+    public static void addRealStateToPlayerObservableStates(int realState, int playerObservableState) {
+        int[] existingPlayerObservableStates = realStateToPlayerObservableStates[realState];
+        for (int i = 0; i < existingPlayerObservableStates.length; i++) {
+            if (existingPlayerObservableStates[i] == playerObservableState) {
+                // Already present in the array
+                return;
+            }
+        }
+        int[] newPlayerObservableStates = new int[existingPlayerObservableStates.length + 1];
+        System.arraycopy(existingPlayerObservableStates, 0, newPlayerObservableStates, 0, existingPlayerObservableStates.length);
+        newPlayerObservableStates[existingPlayerObservableStates.length] = playerObservableState;
+        realStateToPlayerObservableStates[realState] = newPlayerObservableStates;
+    }
+    // Suki end - custom blocks and items
     // JettPack start - lithium: shapes.blockstate_cache
     private static final Object2BooleanCacheTable<VoxelShape> FULL_CUBE_CACHE = new Object2BooleanCacheTable<>(
-            512,
-            shape -> !Shapes.joinIsNotEmpty(Shapes.block(), shape, BooleanOp.NOT_SAME)
+        512,
+        shape -> !Shapes.joinIsNotEmpty(Shapes.block(), shape, BooleanOp.NOT_SAME)
     );
     // JettPack end
     public static final int UPDATE_NEIGHBORS = 1;
@@ -129,6 +159,635 @@ public class Block extends BlockBehaviour implements ItemLike {
         return object2bytelinkedopenhashmap;
     });
 
+    // Suki start - custom blocks and items
+
+    public boolean isVanilla = true;
+
+    /**
+     * This is the {@link ResourceLocation} for this block
+     * <br>
+     * Must be non-null for SuCraft blocks
+     */
+    public @Nullable ResourceLocation customKey;
+
+    /**
+     * This is the {@link ResourceLocation} for this item
+     * <br>
+     * Will always be non-null after it has been registered
+     */
+    public @Nullable ResourceLocation id;
+
+    public @Nullable Item customItemForBlock = null;
+
+    /**
+     * Must be non-null for SuCraft blocks
+     */
+    public @Nullable BlockReplacementRule replacementRule = null;
+
+    public @Nullable String customFireType;
+
+    public @Nullable Supplier<@org.jetbrains.annotations.Nullable LootTable> customLootTableSupplier = null;
+
+    public @Nullable LootTable createCustomLootTable() {
+        if (this.customLootTableSupplier == null) {
+            return null;
+        }
+        return this.customLootTableSupplier.get();
+    }
+
+    public @NotNull List<@NotNull Supplier<@NotNull TagKey<Block>>> tagsToAddSuppliers = new ArrayList<>();
+
+    public @NotNull Block withTag(@NotNull Supplier<@NotNull TagKey<Block>> tagToAddSupplier) {
+        this.tagsToAddSuppliers.add(tagToAddSupplier);
+        return this;
+    }
+
+    // Tags that influence block breaking
+
+    public @NotNull Block mineableWithAxe() {
+        return this.withTag(() -> BlockTags.MINEABLE_WITH_AXE);
+    }
+
+    public @NotNull Block mineableWithHoe() {
+        return this.withTag(() -> BlockTags.MINEABLE_WITH_HOE);
+    }
+
+    public @NotNull Block mineableWithPickaxe() {
+        return this.withTag(() -> BlockTags.MINEABLE_WITH_PICKAXE);
+    }
+
+    public @NotNull Block mineableWithShovel() {
+        return this.withTag(() -> BlockTags.MINEABLE_WITH_SHOVEL);
+    }
+
+    public @NotNull Block leaves() {
+        return this.withTag(() -> BlockTags.LEAVES);
+    }
+
+    public @NotNull Block wool() {
+        return this.withTag(() -> BlockTags.WOOL);
+    }
+
+    // Other tags
+
+    public @NotNull Block planks() {
+        return this.withTag(() -> BlockTags.PLANKS);
+    }
+
+    public @NotNull Block stoneBricks() {
+        return this.withTag(() -> BlockTags.STONE_BRICKS);
+    }
+
+    public @NotNull Block stoneBrickFullBlock() {
+        return this.withTag(() -> SuCraftBlockTags.STONE_BRICK_FULL_BLOCKS).stoneBricks();
+    }
+
+    public @NotNull Block stoneBrickSlab() {
+        return this.withTag(() -> SuCraftBlockTags.STONE_BRICK_SLABS).stoneBricks().slab();
+    }
+
+    public @NotNull Block stoneBrickStairs() {
+        return this.withTag(() -> SuCraftBlockTags.STONE_BRICK_STAIRS).stoneBricks().stairs();
+    }
+
+    public @NotNull Block crystalSound() {
+        return this.withTag(() -> BlockTags.CRYSTAL_SOUND_BLOCKS);
+    }
+
+    public @NotNull Block slab() {
+        return this.withTag(() -> BlockTags.SLABS);
+    }
+
+    public @NotNull Block stairs() {
+        return this.withTag(() -> BlockTags.STAIRS);
+    }
+
+    public @NotNull Block woodenSlab() {
+        return this.withTag(() -> BlockTags.WOODEN_SLABS).slab();
+    }
+
+    public @NotNull Block woodenStairs() {
+        return this.withTag(() -> BlockTags.WOODEN_STAIRS).stairs();
+    }
+
+    public @NotNull Block dirt() {
+        return this.withTag(() -> BlockTags.DIRT);
+    }
+
+    public @NotNull Block fire() {
+        return this.withTag(() -> BlockTags.FIRE);
+    }
+
+    public @NotNull Block soulSpeed() {
+        return this.withTag(() -> BlockTags.SOUL_SPEED_BLOCKS);
+    }
+
+    public @NotNull Block soulFireBase() {
+        return this.withTag(() -> BlockTags.SOUL_FIRE_BASE_BLOCKS);
+    }
+
+    public @NotNull Block guardedByPiglins() {
+        return this.withTag(() -> BlockTags.GUARDED_BY_PIGLINS);
+    }
+
+    public @NotNull Block bookshelf() {
+        return this.withTag(() -> SuCraftBlockTags.BOOKSHELVES);
+    }
+
+    public @NotNull Block bookshelfFullBlock() {
+        return this.withTag(() -> SuCraftBlockTags.BOOKSHELF_FULL_BLOCKS);
+    }
+
+    public @NotNull Block bookshelfSlab() {
+        return this.withTag(() -> SuCraftBlockTags.BOOKSHELF_SLABS).slab();
+    }
+
+    public @NotNull Block bookshelfStairs() {
+        return this.withTag(() -> SuCraftBlockTags.BOOKSHELF_STAIRS).stairs();
+    }
+
+    public @NotNull Block woolFullBlock() {
+        return this.withTag(() -> SuCraftBlockTags.WOOL_FULL_BLOCKS);
+    }
+
+    public @NotNull Block woolSlab() {
+        return this.withTag(() -> SuCraftBlockTags.WOOL_SLABS).slab();
+    }
+
+    public @NotNull Block woolStairs() {
+        return this.withTag(() -> SuCraftBlockTags.WOOL_STAIRS).stairs();
+    }
+
+    public @NotNull Block logFullBlock() {
+        return this.withTag(() -> SuCraftBlockTags.LOG_FULL_BLOCKS);
+    }
+
+    public @NotNull Block logSlab() {
+        return this.withTag(() -> SuCraftBlockTags.LOG_SLABS).slab();
+    }
+
+    public @NotNull Block logStairs() {
+        return this.withTag(() -> SuCraftBlockTags.LOG_STAIRS).stairs();
+    }
+
+    public @NotNull Block plankFullBlock() {
+        return this.withTag(() -> SuCraftBlockTags.PLANK_FULL_BLOCKS).planks();
+    }
+
+    public @NotNull Block plankSlab() {
+        return this.withTag(() -> SuCraftBlockTags.PLANK_SLABS).planks();
+    }
+
+    public @NotNull Block plankStairs() {
+        return this.withTag(() -> SuCraftBlockTags.PLANK_STAIRS).planks();
+    }
+
+    public @NotNull Block dyedPlanks() {
+        return this.withTag(() -> SuCraftBlockTags.DYED_PLANKS).planks();
+    }
+
+    public @NotNull Block dyedPlankFullBlock() {
+        return this.withTag(() -> SuCraftBlockTags.DYED_PLANK_FULL_BLOCKS).dyedPlanks().plankFullBlock();
+    }
+
+    public @NotNull Block dyedPlankSlab() {
+        return this.withTag(() -> SuCraftBlockTags.DYED_PLANK_SLABS).dyedPlanks().woodenSlab().plankSlab();
+    }
+
+    public @NotNull Block dyedPlankStairs() {
+        return this.withTag(() -> SuCraftBlockTags.DYED_PLANK_STAIRS).dyedPlanks().woodenStairs().plankStairs();
+    }
+
+    public @NotNull Block coloredFire() {
+        return this.withTag(() -> SuCraftBlockTags.COLORED_FIRE).fire();
+    }
+
+    public @NotNull Block peat() {
+        return this.withTag(() -> SuCraftBlockTags.PEAT);
+    }
+
+    public @NotNull Block peatFullBlock() {
+        return this.withTag(() -> SuCraftBlockTags.PEAT_FULL_BLOCKS).peat();
+    }
+
+    public @NotNull Block peatSlab() {
+        return this.withTag(() -> SuCraftBlockTags.PEAT_SLABS).peat();
+    }
+
+    public @NotNull Block peatStairs() {
+        return this.withTag(() -> SuCraftBlockTags.PEAT_STAIRS).peat();
+    }
+
+    public @NotNull Block terracotta() {
+        return this.withTag(() -> BlockTags.TERRACOTTA);
+    }
+
+    public @NotNull Block terracottaFullBlock() {
+        return this.withTag(() -> SuCraftBlockTags.TERRACOTTA_FULL_BLOCKS).terracotta();
+    }
+
+    public @NotNull Block terracottaSlab() {
+        return this.withTag(() -> SuCraftBlockTags.TERRACOTTA_SLABS).terracotta().slab();
+    }
+
+    public @NotNull Block terracottaStairs() {
+        return this.withTag(() -> SuCraftBlockTags.TERRACOTTA_STAIRS).terracotta().stairs();
+    }
+
+    public @NotNull Block withAddedTagsLike(@NotNull Block block) {
+        this.tagsToAddSuppliers.addAll(block.tagsToAddSuppliers);
+        return this;
+    }
+
+    public boolean breakBeforeClientKnowsToBreak = false;
+
+    public @NotNull Block breakBeforeClientKnowsToBreak() {
+        this.breakBeforeClientKnowsToBreak = true;
+        return this;
+    }
+
+    // Crafting recipes
+
+    public interface CustomRecipe {
+
+        @NotNull Item.CustomRecipe toItemRecipe();
+
+    }
+
+    public record FutureCustomRecipe(@NotNull Supplier<Item.CustomRecipe> supplier) implements CustomRecipe {
+
+        @Override
+        public @NotNull Item.CustomRecipe toItemRecipe() {
+            return this.supplier.get();
+        }
+
+    }
+
+    public record CustomStonecutterRecipe(@NotNull ResourceLocation key, @Nullable String group, @NotNull Block ingredient, int resultAmount) implements CustomRecipe {
+
+        @Override
+        public @NotNull Item.CustomStonecutterRecipe toItemRecipe() {
+            return new Item.CustomStonecutterRecipe(key(), group(), false, ingredient().asItem(), resultAmount());
+        }
+
+    }
+
+    public @NotNull List<@NotNull CustomRecipe> customRecipes = new ArrayList<>(0);
+
+    public @NotNull Block withCustomRecipe(@NotNull CustomRecipe recipe) {
+        if (!this.customRecipes.stream().anyMatch(existingRecipe -> {
+            if (recipe instanceof CustomStonecutterRecipe stonecutterRecipe) {
+                if (existingRecipe instanceof CustomStonecutterRecipe existingStonecutterRecipe) {
+                    if (existingStonecutterRecipe.ingredient.equals(stonecutterRecipe.ingredient)) {
+                        return true;
+                    }
+                }
+            }
+            return false;
+        })) {
+            this.customRecipes.add(recipe);
+        }
+        return this;
+    }
+
+    public @NotNull Block withFutureCustomRecipe(@NotNull Supplier<Item.CustomRecipe> supplier) {
+        return this.withCustomRecipe(new FutureCustomRecipe(supplier));
+    }
+
+    public @NotNull Block withCustomStoneBricksRecipe(@NotNull String recipePrefix, @NotNull Supplier<@NotNull ItemLike> additionalItemSupplier, int stoneBrickAmount, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> {
+            var additionalItem = additionalItemSupplier.get().asItem();
+            ItemLike[] ingredients = new ItemLike[stoneBrickAmount + 1];
+            ingredients[0] = additionalItem;
+            for (int i = 1; i <= stoneBrickAmount; i++) {
+                ingredients[i] = Items.STONE_BRICKS;
+            }
+            var recipeKey = ResourceLocation.sucraft(additionalItem.id.getPath() + "_to_" + recipePrefix + "_stony_bricks");
+            return Item.CustomShapelessRecipe.getUnlockedByItem(recipeKey, null, isSkippableForPlayersThatCannotAcceptLargePackets, ingredients, Items.STONE_BRICKS, stoneBrickAmount);
+        });
+    }
+
+    public @NotNull Block withCustom8StoneBricksRecipe(@NotNull String recipePrefix, @NotNull Supplier<@NotNull ItemLike> additionalItemSupplier, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withCustomStoneBricksRecipe(recipePrefix, additionalItemSupplier, 8, isSkippableForPlayersThatCannotAcceptLargePackets);
+    }
+
+    public @NotNull Block withCustomDyedPlanksRecipe(@NotNull String recipePrefix, @NotNull Supplier<@NotNull ItemLike> dyeItemSupplier, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> {
+            var dyeItem = dyeItemSupplier.get().asItem();
+            ItemLike[] plankIngredientChoice = {
+                Items.OAK_PLANKS,
+                Items.SPRUCE_PLANKS,
+                Items.BIRCH_PLANKS,
+                Items.JUNGLE_PLANKS,
+                Items.ACACIA_PLANKS,
+                Items.DARK_OAK_PLANKS,
+                Items.WARPED_PLANKS,
+                Items.CRIMSON_PLANKS,
+                Items.MANGROVE_PLANKS,
+                SuCraftItems.RED_PLANKS,
+                SuCraftItems.ORANGE_PLANKS,
+                SuCraftItems.YELLOW_PLANKS,
+                SuCraftItems.LIME_PLANKS,
+                SuCraftItems.GREEN_PLANKS,
+                SuCraftItems.CYAN_PLANKS,
+                SuCraftItems.LIGHT_BLUE_PLANKS,
+                SuCraftItems.BLUE_PLANKS,
+                SuCraftItems.BLACK_PLANKS,
+                SuCraftItems.GRAY_PLANKS,
+                SuCraftItems.LIGHT_GRAY_PLANKS,
+                SuCraftItems.WHITE_PLANKS,
+                SuCraftItems.BROWN_PLANKS,
+                SuCraftItems.PURPLE_PLANKS,
+                SuCraftItems.MAGENTA_PLANKS,
+                SuCraftItems.PINK_PLANKS
+            };
+            ItemLike[][] ingredientChoices = new ItemLike[9][];
+            ingredientChoices[0] = new ItemLike[] {dyeItem};
+            for (int i = 1; i < 9; i++) {
+                ingredientChoices[i] = plankIngredientChoice;
+            }
+            var recipeKey = ResourceLocation.sucraft(dyeItem.id.getPath() + "_and_planks_to_" + recipePrefix + "_planks");
+            return Item.CustomChoiceShapelessRecipe.getUnlockedByItem(recipeKey, null, isSkippableForPlayersThatCannotAcceptLargePackets, ingredientChoices, dyeItem, 8);
+        });
+    }
+
+    public @NotNull Block withCustomDyedPlankSlabsRecipe(@NotNull String recipePrefix, @NotNull Supplier<@NotNull ItemLike> dyeItemSupplier, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> {
+            var dyeItem = dyeItemSupplier.get().asItem();
+            ItemLike[] plankSlabIngredientChoice = {
+                Items.OAK_SLAB,
+                Items.SPRUCE_SLAB,
+                Items.BIRCH_SLAB,
+                Items.JUNGLE_SLAB,
+                Items.ACACIA_SLAB,
+                Items.DARK_OAK_SLAB,
+                Items.WARPED_SLAB,
+                Items.CRIMSON_SLAB,
+                Items.MANGROVE_SLAB,
+                SuCraftItems.RED_PLANK_SLAB,
+                SuCraftItems.ORANGE_PLANK_SLAB,
+                SuCraftItems.YELLOW_PLANK_SLAB,
+                SuCraftItems.LIME_PLANK_SLAB,
+                SuCraftItems.GREEN_PLANK_SLAB,
+                SuCraftItems.CYAN_PLANK_SLAB,
+                SuCraftItems.LIGHT_BLUE_PLANK_SLAB,
+                SuCraftItems.BLUE_PLANK_SLAB,
+                SuCraftItems.BLACK_PLANK_SLAB,
+                SuCraftItems.GRAY_PLANK_SLAB,
+                SuCraftItems.LIGHT_GRAY_PLANK_SLAB,
+                SuCraftItems.WHITE_PLANK_SLAB,
+                SuCraftItems.BROWN_PLANK_SLAB,
+                SuCraftItems.PURPLE_PLANK_SLAB,
+                SuCraftItems.MAGENTA_PLANK_SLAB,
+                SuCraftItems.PINK_PLANK_SLAB
+            };
+            ItemLike[][] ingredientChoices = new ItemLike[9][];
+            ingredientChoices[0] = new ItemLike[] {dyeItem};
+            for (int i = 1; i < 9; i++) {
+                ingredientChoices[i] = plankSlabIngredientChoice;
+            }
+            var recipeKey = ResourceLocation.sucraft(dyeItem.id.getPath() + "_and_plank_slabs_to_" + recipePrefix + "_plank_slabs");
+            return Item.CustomChoiceShapelessRecipe.getUnlockedByItem(recipeKey, null, isSkippableForPlayersThatCannotAcceptLargePackets, ingredientChoices, dyeItem, 8);
+        });
+    }
+
+    public @NotNull Block withCustomDyedPlankStairsRecipe(@NotNull String recipePrefix, @NotNull Supplier<@NotNull ItemLike> dyeItemSupplier, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> {
+            var dyeItem = dyeItemSupplier.get().asItem();
+            ItemLike[] plankStairsIngredientChoice = {
+                Items.OAK_STAIRS,
+                Items.SPRUCE_STAIRS,
+                Items.BIRCH_STAIRS,
+                Items.JUNGLE_STAIRS,
+                Items.ACACIA_STAIRS,
+                Items.DARK_OAK_STAIRS,
+                Items.WARPED_STAIRS,
+                Items.CRIMSON_STAIRS,
+                Items.MANGROVE_STAIRS,
+                SuCraftItems.RED_PLANK_STAIRS,
+                SuCraftItems.ORANGE_PLANK_STAIRS,
+                SuCraftItems.YELLOW_PLANK_STAIRS,
+                SuCraftItems.LIME_PLANK_STAIRS,
+                SuCraftItems.GREEN_PLANK_STAIRS,
+                SuCraftItems.CYAN_PLANK_STAIRS,
+                SuCraftItems.LIGHT_BLUE_PLANK_STAIRS,
+                SuCraftItems.BLUE_PLANK_STAIRS,
+                SuCraftItems.BLACK_PLANK_STAIRS,
+                SuCraftItems.GRAY_PLANK_STAIRS,
+                SuCraftItems.LIGHT_GRAY_PLANK_STAIRS,
+                SuCraftItems.WHITE_PLANK_STAIRS,
+                SuCraftItems.BROWN_PLANK_STAIRS,
+                SuCraftItems.PURPLE_PLANK_STAIRS,
+                SuCraftItems.MAGENTA_PLANK_STAIRS,
+                SuCraftItems.PINK_PLANK_STAIRS
+            };
+            ItemLike[][] ingredientChoices = new ItemLike[9][];
+            ingredientChoices[0] = new ItemLike[] {dyeItem};
+            for (int i = 1; i < 9; i++) {
+                ingredientChoices[i] = plankStairsIngredientChoice;
+            }
+            var recipeKey = ResourceLocation.sucraft(dyeItem.id.getPath() + "_and_plank_stairs_to_" + recipePrefix + "_plank_stairs");
+            return Item.CustomChoiceShapelessRecipe.getUnlockedByItem(recipeKey, null, isSkippableForPlayersThatCannotAcceptLargePackets, ingredientChoices, dyeItem, 8);
+        });
+    }
+
+    public @NotNull Block withCustom2x2SquareChoiceRecipe(@NotNull String recipeKeyPath, @NotNull Supplier<@NotNull ItemLike @NotNull []> ingredientChoiceSupplier, int resultAmount, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> {
+            var ingredientChoice = ingredientChoiceSupplier.get();
+            var recipeKey = ResourceLocation.sucraft(recipeKeyPath);
+            return new Item.CustomChoiceShapedRecipe(
+                recipeKey,
+                null,
+                isSkippableForPlayersThatCannotAcceptLargePackets,
+                new Item.CustomChoiceShapedRecipeIngredientDefinition[]{
+                    new Item.CustomChoiceShapedRecipeIngredientDefinition('$', ingredientChoice)
+                },
+                new String[] {"$$", "$$"},
+                Arrays.stream(ingredientChoice).map(ingredient -> new Item.CustomRecipeUnlockByItem(() -> ingredient)).toArray(Item.CustomRecipeUnlock[]::new),
+                resultAmount
+            );
+        });
+    }
+
+    public @NotNull Block withCustom2x2SquareRecipe(@NotNull String resultKeyPart, @NotNull Supplier<@NotNull ItemLike> ingredientSupplier, int resultAmount, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> {
+            var ingredient = ingredientSupplier.get().asItem();
+            var recipeKey = ResourceLocation.sucraft(ingredient.id.getPath() + "_to_" + resultKeyPart);
+            return Item.CustomShapedRecipe.getUnlockedByItem(
+                recipeKey,
+                null,
+                isSkippableForPlayersThatCannotAcceptLargePackets,
+                new Item.CustomShapedRecipeIngredientDefinition[]{
+                    new Item.CustomShapedRecipeIngredientDefinition('$', ingredient)
+                },
+                new String[] {"$$", "$$"},
+                ingredient,
+                resultAmount
+            );
+        });
+    }
+
+    public @NotNull Block withCustom2x2SquareRecipe(@NotNull String resultKeyPart, @NotNull Block ingredient, int resultAmount, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withCustom2x2SquareRecipe(resultKeyPart, () -> ingredient.asItem(), resultAmount, isSkippableForPlayersThatCannotAcceptLargePackets);
+    }
+
+    public @NotNull Block withCustom3x3SquareChoiceRecipe(@NotNull String recipeKeyPath, @NotNull Supplier<@NotNull ItemLike @NotNull []> ingredientChoiceSupplier, int resultAmount, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> {
+            var ingredientChoice = ingredientChoiceSupplier.get();
+            var recipeKey = ResourceLocation.sucraft(recipeKeyPath);
+            return new Item.CustomChoiceShapedRecipe(
+                recipeKey,
+                null,
+                isSkippableForPlayersThatCannotAcceptLargePackets,
+                new Item.CustomChoiceShapedRecipeIngredientDefinition[]{
+                    new Item.CustomChoiceShapedRecipeIngredientDefinition('$', ingredientChoice)
+                },
+                new String[] {"$$$", "$$$", "$$$"},
+                Arrays.stream(ingredientChoice).map(ingredient -> new Item.CustomRecipeUnlockByItem(() -> ingredient)).toArray(Item.CustomRecipeUnlock[]::new),
+                resultAmount
+            );
+        });
+    }
+
+    public @NotNull Block withCustom3x3SquareRecipe(@NotNull String resultKeyPart, @NotNull Supplier<@NotNull ItemLike> ingredientSupplier, int resultAmount, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> {
+            var ingredient = ingredientSupplier.get().asItem();
+            var recipeKey = ResourceLocation.sucraft(ingredient.id.getPath() + "_to_" + resultKeyPart);
+            return Item.CustomShapedRecipe.getUnlockedByItem(
+                recipeKey,
+                null,
+                isSkippableForPlayersThatCannotAcceptLargePackets,
+                new Item.CustomShapedRecipeIngredientDefinition[]{
+                    new Item.CustomShapedRecipeIngredientDefinition('$', ingredient)
+                },
+                new String[] {"$$$", "$$$", "$$$"},
+                ingredient,
+                resultAmount
+            );
+        });
+    }
+
+    public @NotNull Block withCustom3x3SquareRecipe(@NotNull String resultKeyPart, @NotNull Block ingredient, int resultAmount, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withCustom3x3SquareRecipe(resultKeyPart, () -> ingredient.asItem(), resultAmount, isSkippableForPlayersThatCannotAcceptLargePackets);
+    }
+
+    public @NotNull Block withCustom2VerticalChoiceRecipe(@NotNull String recipeKeyPath, @NotNull Supplier<@NotNull ItemLike @NotNull []> ingredientChoiceSupplier, int resultAmount, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> {
+            var ingredientChoice = ingredientChoiceSupplier.get();
+            var recipeKey = ResourceLocation.sucraft(recipeKeyPath);
+            return new Item.CustomChoiceShapedRecipe(
+                recipeKey,
+                null,
+                isSkippableForPlayersThatCannotAcceptLargePackets,
+                new Item.CustomChoiceShapedRecipeIngredientDefinition[]{
+                    new Item.CustomChoiceShapedRecipeIngredientDefinition('$', ingredientChoice)
+                },
+                new String[] {"$", "$"},
+                Arrays.stream(ingredientChoice).map(ingredient -> new Item.CustomRecipeUnlockByItem(() -> ingredient)).toArray(Item.CustomRecipeUnlock[]::new),
+                resultAmount
+            );
+        });
+    }
+
+    public @NotNull Block withCustomFurnaceRecipe(@NotNull Supplier<@NotNull Item> ingredientSupplier, float experience, int cookingTime, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> {
+            var ingredient = ingredientSupplier.get();
+            var recipeKeyPath = id.getPath() + "_from_" + ingredient.id.getPath() + "_furnace";
+            var recipeKey = ResourceLocation.sucraft(recipeKeyPath);
+            return new Item.CustomFurnaceRecipe(
+                recipeKey,
+                null,
+                isSkippableForPlayersThatCannotAcceptLargePackets,
+                ingredient,
+                experience,
+                cookingTime
+            );
+        });
+    }
+
+    public @NotNull Block withCustomFurnaceRecipe(@NotNull Block ingredient, float experience, int cookingTime, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withCustomFurnaceRecipe(() -> ingredient.asItem(), experience, cookingTime, isSkippableForPlayersThatCannotAcceptLargePackets);
+    }
+
+    public @NotNull Block withCustomStonecutterRecipe(@NotNull Block ingredient, @Nullable String group, int resultAmount, boolean transitive, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        @NotNull String uniqueRecipeDescription = id.getPath() + "_from_" + ingredient.id.getPath() + "_stonecutting";
+        this.withCustomRecipe(new CustomStonecutterRecipe(ResourceLocation.sucraft(uniqueRecipeDescription), group, ingredient, resultAmount));
+        if (transitive) {
+            for (CustomRecipe transitiveRecipe : ingredient.customRecipes) {
+                if (transitiveRecipe instanceof CustomStonecutterRecipe transitiveStonecutterRecipe) {
+                    this.withCustomStonecutterRecipe(transitiveStonecutterRecipe.ingredient, null, resultAmount * transitiveStonecutterRecipe.resultAmount, true, isSkippableForPlayersThatCannotAcceptLargePackets);
+                }
+            }
+        }
+        return this;
+    }
+
+    public @NotNull Block withCustomSlabStonecutterRecipe(@NotNull Block ingredient, @Nullable String group, boolean transitive, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withCustomStonecutterRecipe(ingredient, group, 2, transitive, isSkippableForPlayersThatCannotAcceptLargePackets);
+    }
+
+    public @NotNull Block withCustomSlabStonecutterRecipe(@NotNull Block ingredient, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withCustomSlabStonecutterRecipe(ingredient, null, true, isSkippableForPlayersThatCannotAcceptLargePackets);
+    }
+
+    public @NotNull Block withCustomOneToOneStonecutterRecipe(@NotNull Block ingredient, @Nullable String group, boolean transitive, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withCustomStonecutterRecipe(ingredient, group, 1, transitive, isSkippableForPlayersThatCannotAcceptLargePackets);
+    }
+
+    public @NotNull Block withCustomOneToOneStonecutterRecipe(@NotNull Block ingredient, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withCustomOneToOneStonecutterRecipe(ingredient, null, true, isSkippableForPlayersThatCannotAcceptLargePackets);
+    }
+
+    public @NotNull Block withCustomSlabCraftingRecipe(@NotNull Block fullBlock, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> Item.CustomShapedRecipe.craftSlab(this, fullBlock, group, isSkippableForPlayersThatCannotAcceptLargePackets));
+    }
+
+    public @NotNull Block withCustomSlabCraftingRecipe(@NotNull Block fullBlock, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> Item.CustomShapedRecipe.craftSlab(this, fullBlock, isSkippableForPlayersThatCannotAcceptLargePackets));
+    }
+
+    public @NotNull Block withCustomStairsCraftingRecipe(@NotNull Block fullBlock, @Nullable String group, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> Item.CustomShapedRecipe.craftStairs(this, fullBlock, group, isSkippableForPlayersThatCannotAcceptLargePackets));
+    }
+
+    public @NotNull Block withCustomStairsCraftingRecipe(@NotNull Block fullBlock, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        return this.withFutureCustomRecipe(() -> Item.CustomShapedRecipe.craftStairs(this, fullBlock, isSkippableForPlayersThatCannotAcceptLargePackets));
+    }
+
+    public @NotNull Block withCustomSlabStonecutterRecipe(@NotNull Block ingredient, @Nullable String group, boolean transitive) {
+        return this.withCustomSlabStonecutterRecipe(ingredient, group, transitive, false);
+    }
+
+    public @NotNull Block withCustomSlabStonecutterRecipe(@NotNull Block ingredient) {
+        return this.withCustomSlabStonecutterRecipe(ingredient, false);
+    }
+
+    public @NotNull Block withCustomOneToOneStonecutterRecipe(@NotNull Block ingredient, @Nullable String group, boolean transitive) {
+        return this.withCustomOneToOneStonecutterRecipe(ingredient, group, transitive, false);
+    }
+
+    public @NotNull Block withCustomOneToOneStonecutterRecipe(@NotNull Block ingredient) {
+        return this.withCustomOneToOneStonecutterRecipe(ingredient, false);
+    }
+
+    public @NotNull Block withCustomSlabCraftingRecipe(@NotNull Block fullBlock, @Nullable String group) {
+        return this.withCustomSlabCraftingRecipe(fullBlock, group, true);
+    }
+
+    public @NotNull Block withCustomSlabCraftingRecipe(@NotNull Block fullBlock) {
+        return this.withCustomSlabCraftingRecipe(fullBlock, true);
+    }
+
+    public @NotNull Block withCustomStairsCraftingRecipe(@NotNull Block fullBlock, @Nullable String group) {
+        return this.withCustomStairsCraftingRecipe(fullBlock, group, true);
+    }
+
+    public @NotNull Block withCustomStairsCraftingRecipe(@NotNull Block fullBlock) {
+        return this.withCustomStairsCraftingRecipe(fullBlock, true);
+    }
+
+    // Suki end - custom blocks and items
+
     public static int getId(@Nullable BlockState state) {
         if (state == null) {
             return 0;
@@ -644,4 +1303,14 @@ public class Block extends BlockBehaviour implements ItemLike {
             return this.hash; // JettPack
         }
     }
+
+    // Suki start - custom blocks and items
+
+    public void updateDestroyTime(float destroyTime) {
+        this.properties.destroyTime(destroyTime);
+        this.getStateDefinition().getPossibleStates().forEach(state -> state.destroySpeed = destroyTime);
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/block/Blocks.java b/src/main/java/net/minecraft/world/level/block/Blocks.java
index 9b15d0a0fe5bc8c1ecb4b89eaed7a6e264940ce6..affdec53564f12a131603923c19be94a291326d1 100644
--- a/src/main/java/net/minecraft/world/level/block/Blocks.java
+++ b/src/main/java/net/minecraft/world/level/block/Blocks.java
@@ -7,6 +7,7 @@ import net.minecraft.core.Registry;
 import net.minecraft.core.cauldron.CauldronInteraction;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.data.worldgen.features.TreeFeatures;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.util.valueproviders.UniformInt;
 import net.minecraft.world.effect.MobEffects;
 import net.minecraft.world.entity.EntityType;
@@ -34,6 +35,11 @@ import net.minecraft.world.level.block.state.properties.WoodType;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.level.material.Material;
 import net.minecraft.world.level.material.MaterialColor;
+import org.sucraft.suki.block.StrippedHyphaeBlock;
+import org.sucraft.suki.block.StrippedLogBlock;
+import org.sucraft.suki.block.StrippedStemBlock;
+import org.sucraft.suki.block.StrippedWoodBlock;
+import org.sucraft.suki.block.SuCraftBlocks;
 import org.jetbrains.annotations.NotNull;
 
 public class Blocks {
@@ -1095,7 +1101,7 @@ public class Blocks {
         return (boolean)true;
     }
 
-    private static Boolean ocelotOrParrot(BlockState state, BlockGetter world, BlockPos pos, EntityType<?> type) {
+    public static Boolean ocelotOrParrot(BlockState state, BlockGetter world, BlockPos pos, EntityType<?> type) { // Suki - custom blocks and items
         return type == EntityType.OCELOT || type == EntityType.PARROT;
     }
 
@@ -1142,7 +1148,7 @@ public class Blocks {
         return true;
     }
 
-    private static boolean never(BlockState state, BlockGetter world, BlockPos pos) {
+    public static boolean never(BlockState state, BlockGetter world, BlockPos pos) { // Suki - custom blocks and items
         return false;
     }
 
@@ -1150,7 +1156,7 @@ public class Blocks {
         return new StainedGlassBlock(color, BlockBehaviour.Properties.of(Material.GLASS, color).strength(0.3F).sound(SoundType.GLASS).noOcclusion().isValidSpawn(Blocks::never).isRedstoneConductor(Blocks::never).isSuffocating(Blocks::never).isViewBlocking(Blocks::never));
     }
 
-    private static LeavesBlock leaves(SoundType soundGroup) {
+    public static LeavesBlock leaves(SoundType soundGroup) {
         return new LeavesBlock(BlockBehaviour.Properties.of(Material.LEAVES).strength(0.2F).randomTicks().sound(soundGroup).noOcclusion().isValidSpawn(Blocks::ocelotOrParrot).isSuffocating(Blocks::never).isViewBlocking(Blocks::never));
     }
 
@@ -1174,6 +1180,7 @@ public class Blocks {
     }
 
     private static Block register(String id, Block block) {
+        block.id = new ResourceLocation(id); // Suki - custom blocks and items
         return Registry.register(Registry.BLOCK, id, block);
     }
 
@@ -1182,13 +1189,60 @@ public class Blocks {
     }
 
     static {
+        // Suki start - custom blocks and items
+        // Evaluate the last element to bootstrap Blocks
+        REINFORCED_DEEPSLATE.asBlock();
+        // Then bootstrap SuCraftBlocks
+        SuCraftBlocks.bootstrap();
+        // Suki end - custom blocks and items
         for(Block block : Registry.BLOCK) {
             for(BlockState blockState : block.getStateDefinition().getPossibleStates()) {
                 Block.BLOCK_STATE_REGISTRY.add(blockState);
+                // Suki start - custom blocks and items
+                if (block.isVanilla) {
+                    Block.BLOCK_STATE_REGISTRY_VANILLA.add(blockState);
+                }
+                // Suki end - custom blocks and items
             }
 
             block.getLootTable();
         }
 
+        // Suki start - custom blocks and items
+
+        // Initialize the global state replacement arrays so we can populate them
+        Block.stateIdReplacementArrayWithResourcePack = new int[Block.BLOCK_STATE_REGISTRY.size()];
+        Block.stateIdReplacementArrayWithoutResourcePack = new int[Block.BLOCK_STATE_REGISTRY.size()];
+        // Initialize the global state replacement arrays with identities (aka no replacement is done)
+        for (int id = 0; id < Block.BLOCK_STATE_REGISTRY.size(); id++) {
+            Block.stateIdReplacementArrayWithResourcePack[id] = id;
+            Block.stateIdReplacementArrayWithoutResourcePack[id] = id;
+        }
+        // Initialize the global real state to observable states arrays with empty arrays
+        Block.realStateToPlayerObservableStates = new int[Block.BLOCK_STATE_REGISTRY.size()][];
+        for (int id = 0; id < Block.BLOCK_STATE_REGISTRY.size(); id++) {
+            Block.realStateToPlayerObservableStates[id] = new int[0];
+        }
+        // Then overwrite them where necessary with all the needed replacements
+        for (Block block : Registry.BLOCK) {
+            if (block.replacementRule != null) {
+                block.replacementRule.writeToStateIdReplacementArrays();
+            }
+        }
+        // Special case: we want to make sure we replace (for players with the resource pack) all fire states with age greater than 0 to age 0 (due to the way we write the fire blockstates asset)
+        for (BlockState fireBlockState : Blocks.FIRE.getStateDefinition().getPossibleStates()) {
+            int id = Block.BLOCK_STATE_REGISTRY.getId(fireBlockState);
+            if (Block.stateIdReplacementArrayWithResourcePack[id] == id && fireBlockState.getValue(BlockStateProperties.AGE_15) > 0) { // If not replaced yet before and with age greater than 0
+                Block.stateIdReplacementArrayWithResourcePack[id] = Block.BLOCK_STATE_REGISTRY.getId(Blocks.FIRE.withPropertiesOf(fireBlockState).setValue(BlockStateProperties.AGE_15, 0));
+            }
+        }
+        // TEMP TODO REMOVE
+//        for (BlockState state : Blocks.NOTE_BLOCK.getStateDefinition().getPossibleStates()) {
+//            if (!state.equals(Blocks.NOTE_BLOCK.defaultBlockState())) {
+//                Block.stateIdReplacementArrayWithResourcePack[Block.BLOCK_STATE_REGISTRY.getId(state)] = Block.BLOCK_STATE_REGISTRY.getId(Blocks.NOTE_BLOCK.defaultBlockState());
+//            }
+//        }
+
+        // Suki end - custom blocks and items
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/ComposterBlock.java b/src/main/java/net/minecraft/world/level/block/ComposterBlock.java
index c7ca1390bc8becb46dd843a4e1006af99b8639bb..5d9b7d789d4bda512f1a861a1c2f936983da1ea5 100644
--- a/src/main/java/net/minecraft/world/level/block/ComposterBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ComposterBlock.java
@@ -38,6 +38,7 @@ import net.minecraft.world.WorldlyContainerHolder;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.item.ItemEntity;
 import net.minecraft.world.entity.player.Player;
+import org.sucraft.suki.item.SuCraftItems;
 import org.bukkit.craftbukkit.inventory.CraftBlockInventoryHolder;
 import org.bukkit.craftbukkit.util.DummyGeneratorAccess;
 // CraftBukkit end
@@ -75,6 +76,16 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
         ComposterBlock.add(0.3F, Items.BIRCH_LEAVES);
         ComposterBlock.add(0.3F, Items.AZALEA_LEAVES);
         ComposterBlock.add(0.3F, Items.MANGROVE_LEAVES);
+        // Suki start - custom blocks and items
+        ComposterBlock.add(0.3F, SuCraftItems.PALE_BIRCH_LEAVES);
+        // Not included in initial release
+//        ComposterBlock.add(0.3F, SuCraftItems.FIERY_BIRCH_LEAVES);
+        ComposterBlock.add(0.3F, SuCraftItems.ORANGE_OAK_LEAVES);
+        ComposterBlock.add(0.3F, SuCraftItems.RED_OAK_LEAVES);
+        ComposterBlock.add(0.3F, SuCraftItems.YELLOW_MAPLE_LEAVES);
+        ComposterBlock.add(0.3F, SuCraftItems.ORANGE_MAPLE_LEAVES);
+        ComposterBlock.add(0.3F, SuCraftItems.RED_MAPLE_LEAVES);
+        // Suki end - custom blocks and items
         ComposterBlock.add(0.3F, Items.OAK_SAPLING);
         ComposterBlock.add(0.3F, Items.SPRUCE_SAPLING);
         ComposterBlock.add(0.3F, Items.BIRCH_SAPLING);
@@ -97,6 +108,10 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
         ComposterBlock.add(0.3F, Items.HANGING_ROOTS);
         ComposterBlock.add(0.3F, Items.MANGROVE_ROOTS);
         ComposterBlock.add(0.5F, Items.DRIED_KELP_BLOCK);
+        // Suki start - custom blocks and items
+        // Not included in initial release
+//        ComposterBlock.add(0.25F, SuCraftItems.DRIED_KELP_SLAB);
+        // Suki end - custom blocks and items
         ComposterBlock.add(0.5F, Items.TALL_GRASS);
         ComposterBlock.add(0.5F, Items.FLOWERING_AZALEA_LEAVES);
         ComposterBlock.add(0.5F, Items.CACTUS);
@@ -149,12 +164,29 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
         ComposterBlock.add(0.65F, Items.SPORE_BLOSSOM);
         ComposterBlock.add(0.65F, Items.AZALEA);
         ComposterBlock.add(0.65F, Items.MOSS_BLOCK);
+        // Suki start - custom blocks and items
+        ComposterBlock.add(0.65F, SuCraftItems.MOSS_STAIRS);
+        ComposterBlock.add(0.325F, SuCraftItems.MOSS_SLAB);
+        // Suki end - custom blocks and items
         ComposterBlock.add(0.65F, Items.BIG_DRIPLEAF);
         ComposterBlock.add(0.85F, Items.HAY_BLOCK);
+        // Suki start - custom blocks and items
+        ComposterBlock.add(0.85F, SuCraftItems.HAY_STAIRS);
+        ComposterBlock.add(0.425F, SuCraftItems.HAY_SLAB);
+        ComposterBlock.add(0.375F, SuCraftItems.THATCH);
+        ComposterBlock.add(0.375F, SuCraftItems.THATCH_STAIRS);
+        ComposterBlock.add(0.1875F, SuCraftItems.THATCH_SLAB);
+        // Suki end - custom blocks and items
         ComposterBlock.add(0.85F, Items.BROWN_MUSHROOM_BLOCK);
         ComposterBlock.add(0.85F, Items.RED_MUSHROOM_BLOCK);
         ComposterBlock.add(0.85F, Items.NETHER_WART_BLOCK);
         ComposterBlock.add(0.85F, Items.WARPED_WART_BLOCK);
+        // Suki start - custom blocks and items
+        ComposterBlock.add(0.85F, SuCraftItems.NETHER_WART_STAIRS);
+        ComposterBlock.add(0.85F, SuCraftItems.WARPED_WART_STAIRS);
+        ComposterBlock.add(0.425F, SuCraftItems.NETHER_WART_SLAB);
+        ComposterBlock.add(0.425F, SuCraftItems.WARPED_WART_SLAB);
+        // Suki end - custom blocks and items
         ComposterBlock.add(0.85F, Items.FLOWERING_AZALEA);
         ComposterBlock.add(0.85F, Items.BREAD);
         ComposterBlock.add(0.85F, Items.BAKED_POTATO);
diff --git a/src/main/java/net/minecraft/world/level/block/EnchantmentTableBlock.java b/src/main/java/net/minecraft/world/level/block/EnchantmentTableBlock.java
index f4ee3ce287528337a0f9a3b612c157254f895a58..c36391ff478675968356832320995abc48d32b33 100644
--- a/src/main/java/net/minecraft/world/level/block/EnchantmentTableBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/EnchantmentTableBlock.java
@@ -5,6 +5,7 @@ import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.network.chat.Component;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.InteractionHand;
 import net.minecraft.world.InteractionResult;
@@ -24,10 +25,13 @@ import net.minecraft.world.level.block.entity.BlockEntityType;
 import net.minecraft.world.level.block.entity.EnchantmentTableBlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.SlabType;
 import net.minecraft.world.level.pathfinder.PathComputationType;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
+import org.sucraft.suki.block.SuCraftBlockTags;
 
 public class EnchantmentTableBlock extends BaseEntityBlock {
     protected static final VoxelShape SHAPE = Block.box(0.0D, 0.0D, 0.0D, 16.0D, 12.0D, 16.0D);
@@ -40,7 +44,10 @@ public class EnchantmentTableBlock extends BaseEntityBlock {
     }
 
     public static boolean isValidBookShelf(Level world, BlockPos tablePos, BlockPos bookshelfOffset) {
-        return world.getBlockState(tablePos.offset(bookshelfOffset)).is(Blocks.BOOKSHELF) && world.isEmptyBlock(tablePos.offset(bookshelfOffset.getX() / 2, bookshelfOffset.getY(), bookshelfOffset.getZ() / 2));
+        // Suki start - custom blocks and items
+        var blockState = world.getBlockState(tablePos.offset(bookshelfOffset));
+        return (blockState.is(SuCraftBlockTags.BOOKSHELF_FULL_BLOCKS) || blockState.is(SuCraftBlockTags.BOOKSHELF_STAIRS) || (blockState.is(SuCraftBlockTags.BOOKSHELF_SLABS) && blockState.getValue(BlockStateProperties.SLAB_TYPE) == SlabType.DOUBLE)) && world.isEmptyBlock(tablePos.offset(bookshelfOffset.getX() / 2, bookshelfOffset.getY(), bookshelfOffset.getZ() / 2));
+        // Suki end - custom blocks and items
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/FireBlock.java b/src/main/java/net/minecraft/world/level/block/FireBlock.java
index e34b8cff424ad58eee65a65fa510fa9908dbdf39..73d06f4014a3b960d2ae6cbd28011c389050eb7b 100644
--- a/src/main/java/net/minecraft/world/level/block/FireBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/FireBlock.java
@@ -28,6 +28,7 @@ import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 // CraftBukkit start
+import org.sucraft.suki.block.SuCraftBlocks;
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.CraftBlockStates;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -416,6 +417,60 @@ public class FireBlock extends BaseFireBlock {
         blockfire.setFlammable(Blocks.ACACIA_STAIRS, 5, 20);
         blockfire.setFlammable(Blocks.DARK_OAK_STAIRS, 5, 20);
         blockfire.setFlammable(Blocks.MANGROVE_STAIRS, 5, 20);
+
+        // Suki start - custom blocks and items
+
+        blockfire.setFlammable(SuCraftBlocks.WHITE_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.ORANGE_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.MAGENTA_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.LIGHT_BLUE_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.YELLOW_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.LIME_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.PINK_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.GRAY_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.LIGHT_GRAY_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.CYAN_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.PURPLE_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.BLUE_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.BROWN_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.GREEN_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.RED_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.BLACK_PLANKS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.WHITE_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.ORANGE_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.MAGENTA_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.LIGHT_BLUE_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.YELLOW_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.LIME_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.PINK_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.GRAY_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.LIGHT_GRAY_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.CYAN_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.PURPLE_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.BLUE_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.BROWN_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.GREEN_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.RED_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.BLACK_PLANK_SLAB, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.WHITE_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.ORANGE_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.MAGENTA_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.LIGHT_BLUE_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.YELLOW_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.LIME_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.PINK_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.GRAY_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.LIGHT_GRAY_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.CYAN_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.PURPLE_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.BLUE_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.BROWN_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.GREEN_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.RED_PLANK_STAIRS, 5, 20);
+        blockfire.setFlammable(SuCraftBlocks.BLACK_PLANK_STAIRS, 5, 20);
+
+        // Suki end - custom blocks and items
+
         blockfire.setFlammable(Blocks.OAK_LOG, 5, 5);
         blockfire.setFlammable(Blocks.SPRUCE_LOG, 5, 5);
         blockfire.setFlammable(Blocks.BIRCH_LOG, 5, 5);
@@ -444,6 +499,68 @@ public class FireBlock extends BaseFireBlock {
         blockfire.setFlammable(Blocks.ACACIA_WOOD, 5, 5);
         blockfire.setFlammable(Blocks.DARK_OAK_WOOD, 5, 5);
         blockfire.setFlammable(Blocks.MANGROVE_WOOD, 5, 5);
+
+        // Suki start - custom blocks and items
+
+        blockfire.setFlammable(SuCraftBlocks.OAK_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.SPRUCE_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.BIRCH_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.JUNGLE_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.ACACIA_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.DARK_OAK_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.MANGROVE_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_OAK_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_SPRUCE_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_BIRCH_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_JUNGLE_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_ACACIA_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_DARK_OAK_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_MANGROVE_LOG_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_OAK_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_SPRUCE_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_BIRCH_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_JUNGLE_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_ACACIA_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_DARK_OAK_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_MANGROVE_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.OAK_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.SPRUCE_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.BIRCH_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.JUNGLE_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.ACACIA_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.DARK_OAK_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.MANGROVE_WOOD_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.OAK_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.SPRUCE_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.BIRCH_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.JUNGLE_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.ACACIA_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.DARK_OAK_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.MANGROVE_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_OAK_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_SPRUCE_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_BIRCH_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_JUNGLE_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_ACACIA_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_DARK_OAK_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_MANGROVE_LOG_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_OAK_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_SPRUCE_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_BIRCH_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_JUNGLE_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_ACACIA_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_DARK_OAK_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.STRIPPED_MANGROVE_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.OAK_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.SPRUCE_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.BIRCH_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.JUNGLE_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.ACACIA_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.DARK_OAK_WOOD_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.MANGROVE_WOOD_STAIRS, 5, 5);
+
+        // Suki end - custom blocks and items
+
         blockfire.setFlammable(Blocks.MANGROVE_ROOTS, 5, 20);
         blockfire.setFlammable(Blocks.OAK_LEAVES, 30, 60);
         blockfire.setFlammable(Blocks.SPRUCE_LEAVES, 30, 60);
@@ -452,7 +569,41 @@ public class FireBlock extends BaseFireBlock {
         blockfire.setFlammable(Blocks.ACACIA_LEAVES, 30, 60);
         blockfire.setFlammable(Blocks.DARK_OAK_LEAVES, 30, 60);
         blockfire.setFlammable(Blocks.MANGROVE_LEAVES, 30, 60);
+
+        // Suki start - custom blocks and items
+
+        blockfire.setFlammable(SuCraftBlocks.PALE_BIRCH_LEAVES, 30, 60);
+        // Not included in initial release
+//        blockfire.setFlammable(SuCraftBlocks.FIERY_BIRCH_LEAVES, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.ORANGE_OAK_LEAVES, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.RED_OAK_LEAVES, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.YELLOW_MAPLE_LEAVES, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.ORANGE_MAPLE_LEAVES, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.RED_MAPLE_LEAVES, 30, 60);
+
+        // Suki end - custom blocks and items
+
         blockfire.setFlammable(Blocks.BOOKSHELF, 30, 20);
+
+        // Suki start - custom blocks and items
+
+        blockfire.setFlammable(SuCraftBlocks.SPRUCE_BOOKSHELF, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.BIRCH_BOOKSHELF, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.JUNGLE_BOOKSHELF, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.ACACIA_BOOKSHELF, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.DARK_OAK_BOOKSHELF, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.MANGROVE_BOOKSHELF, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.OAK_BOOKSHELF_SLAB, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.SPRUCE_BOOKSHELF_SLAB, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.BIRCH_BOOKSHELF_SLAB, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.JUNGLE_BOOKSHELF_SLAB, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.OAK_BOOKSHELF_STAIRS, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.SPRUCE_BOOKSHELF_STAIRS, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.BIRCH_BOOKSHELF_STAIRS, 30, 20);
+        blockfire.setFlammable(SuCraftBlocks.JUNGLE_BOOKSHELF_STAIRS, 30, 20);
+
+        // Suki end - custom blocks and items
+
         blockfire.setFlammable(Blocks.TNT, 15, 100);
         blockfire.setFlammable(Blocks.GRASS, 60, 100);
         blockfire.setFlammable(Blocks.FERN, 60, 100);
@@ -492,9 +643,69 @@ public class FireBlock extends BaseFireBlock {
         blockfire.setFlammable(Blocks.GREEN_WOOL, 30, 60);
         blockfire.setFlammable(Blocks.RED_WOOL, 30, 60);
         blockfire.setFlammable(Blocks.BLACK_WOOL, 30, 60);
+
+        // Suki start - custom blocks and items
+
+        blockfire.setFlammable(SuCraftBlocks.WHITE_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.ORANGE_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.MAGENTA_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.LIGHT_BLUE_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.YELLOW_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.LIME_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.PINK_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.GRAY_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.LIGHT_GRAY_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.CYAN_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.PURPLE_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.BLUE_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.BROWN_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.GREEN_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.RED_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.BLACK_WOOL_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.WHITE_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.ORANGE_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.MAGENTA_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.LIGHT_BLUE_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.YELLOW_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.LIME_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.PINK_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.GRAY_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.LIGHT_GRAY_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.CYAN_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.PURPLE_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.BLUE_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.BROWN_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.GREEN_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.RED_WOOL_STAIRS, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.BLACK_WOOL_STAIRS, 30, 60);
+
+        // Suki end - custom blocks and items
+
         blockfire.setFlammable(Blocks.VINE, 15, 100);
         blockfire.setFlammable(Blocks.COAL_BLOCK, 5, 5);
+
+        // Suki start - custom blocks and items
+
+        blockfire.setFlammable(SuCraftBlocks.CHARCOAL_BLOCK, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.COAL_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.CHARCOAL_SLAB, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.COAL_STAIRS, 5, 5);
+        blockfire.setFlammable(SuCraftBlocks.CHARCOAL_STAIRS, 5, 5);
+
+        // Suki end - custom blocks and items
+
         blockfire.setFlammable(Blocks.HAY_BLOCK, 60, 20);
+
+        // Suki start - custom blocks and items
+
+        blockfire.setFlammable(SuCraftBlocks.HAY_STAIRS, 60, 20);
+        blockfire.setFlammable(SuCraftBlocks.HAY_SLAB, 60, 20);
+        blockfire.setFlammable(SuCraftBlocks.THATCH, 60, 20);
+        blockfire.setFlammable(SuCraftBlocks.THATCH_STAIRS, 60, 20);
+        blockfire.setFlammable(SuCraftBlocks.THATCH_SLAB, 60, 20);
+
+        // Suki end - custom blocks and items
+
         blockfire.setFlammable(Blocks.TARGET, 15, 20);
         blockfire.setFlammable(Blocks.WHITE_CARPET, 60, 20);
         blockfire.setFlammable(Blocks.ORANGE_CARPET, 60, 20);
@@ -513,6 +724,13 @@ public class FireBlock extends BaseFireBlock {
         blockfire.setFlammable(Blocks.RED_CARPET, 60, 20);
         blockfire.setFlammable(Blocks.BLACK_CARPET, 60, 20);
         blockfire.setFlammable(Blocks.DRIED_KELP_BLOCK, 30, 60);
+
+        // Suki start - custom blocks and items
+        // Not included in initial release
+//        blockfire.setFlammable(SuCraftBlocks.DRIED_KELP_SLAB, 30, 60);
+
+        // Suki end - custom blocks and items
+
         blockfire.setFlammable(Blocks.BAMBOO, 60, 60);
         blockfire.setFlammable(Blocks.SCAFFOLDING, 60, 60);
         blockfire.setFlammable(Blocks.LECTERN, 30, 20);
@@ -532,5 +750,14 @@ public class FireBlock extends BaseFireBlock {
         blockfire.setFlammable(Blocks.SMALL_DRIPLEAF, 60, 100);
         blockfire.setFlammable(Blocks.HANGING_ROOTS, 30, 60);
         blockfire.setFlammable(Blocks.GLOW_LICHEN, 15, 100);
+
+        // Suki start - custom blocks and items
+
+        blockfire.setFlammable(SuCraftBlocks.PAPER_BLOCK, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.PAPER_SLAB, 30, 60);
+        blockfire.setFlammable(SuCraftBlocks.PAPER_STAIRS, 30, 60);
+
+        // Suki end - custom blocks and items
+
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/InfestedBlock.java b/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
index f33033c99ac52e2c64adeb8c58ae87625e92b299..486422fe2e458fbd9988b8f55c4c06de674a5c54 100644
--- a/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/InfestedBlock.java
@@ -5,6 +5,7 @@ import java.util.Iterator;
 import java.util.Map;
 import java.util.function.Supplier;
 import net.minecraft.core.BlockPos;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.monster.Silverfish;
@@ -25,7 +26,13 @@ public class InfestedBlock extends Block {
     private static final Map<BlockState, BlockState> INFESTED_TO_HOST_STATES = Maps.newIdentityHashMap();
 
     public InfestedBlock(Block regularBlock, BlockBehaviour.Properties settings) {
-        super(settings.destroyTime(regularBlock.defaultDestroyTime() / 2.0F).explosionResistance(0.75F));
+        // Suki start - custom block and items
+        this(regularBlock, settings, true);
+    }
+
+    public InfestedBlock(Block regularBlock, BlockBehaviour.Properties settings, boolean halveDestroyTime) { // If we create infested blocks from custom blocks, it may be that their destroy time was already halved (due to being observable as an infested block by players) in which case we can set the halveDestroyTime flag to false, to prevent repeated halving
+        super(settings.destroyTime(halveDestroyTime ? regularBlock.defaultDestroyTime() / 2.0F : regularBlock.defaultDestroyTime()).explosionResistance(0.75F));
+        // Suki end - custom block and items
         this.hostBlock = regularBlock;
         InfestedBlock.BLOCK_BY_HOST_BLOCK.put(regularBlock, this);
     }
diff --git a/src/main/java/net/minecraft/world/level/block/NoteBlock.java b/src/main/java/net/minecraft/world/level/block/NoteBlock.java
index c14eb4f7decdbcd6176d3bff95d595a947d4ec95..115df2d50fe0c6ba7cf9e2f1e799afe71c3630de 100644
--- a/src/main/java/net/minecraft/world/level/block/NoteBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/NoteBlock.java
@@ -70,7 +70,7 @@ public class NoteBlock extends Block {
             // CraftBukkit end
             // Paper - TODO any way to cancel the game event?
             world.blockEvent(blockposition, this, 0, 0);
-            world.gameEvent(entity, GameEvent.NOTE_BLOCK_PLAY, blockposition);
+            //world.gameEvent(entity, GameEvent.NOTE_BLOCK_PLAY, blockposition); // Suki - custom blocks and items
         }
 
     }
diff --git a/src/main/java/net/minecraft/world/level/block/StairBlock.java b/src/main/java/net/minecraft/world/level/block/StairBlock.java
index 827713a332baa6d280cd61d40faf8f6243b3b08c..33ccb8c4d0282a27101fca72ed37352013af3ca2 100644
--- a/src/main/java/net/minecraft/world/level/block/StairBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/StairBlock.java
@@ -81,7 +81,7 @@ public class StairBlock extends Block implements SimpleWaterloggedBlock {
         return voxelShape;
     }
 
-    protected StairBlock(BlockState baseBlockState, BlockBehaviour.Properties settings) {
+    public StairBlock(BlockState baseBlockState, BlockBehaviour.Properties settings) { // Suki - custom blocks and items
         super(settings);
         this.registerDefaultState(this.stateDefinition.any().setValue(FACING, Direction.NORTH).setValue(HALF, Half.BOTTOM).setValue(SHAPE, StairsShape.STRAIGHT).setValue(WATERLOGGED, Boolean.valueOf(false)));
         this.base = baseBlockState.getBlock();
diff --git a/src/main/java/net/minecraft/world/level/block/StonecutterBlock.java b/src/main/java/net/minecraft/world/level/block/StonecutterBlock.java
index 0a95842c53a9d0286c57bcb42db97e468e30fb7d..2b57654c5b1a0f8dad230beda56859e961fd4999 100644
--- a/src/main/java/net/minecraft/world/level/block/StonecutterBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/StonecutterBlock.java
@@ -25,7 +25,7 @@ import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
 public class StonecutterBlock extends Block {
-    private static final Component CONTAINER_TITLE = Component.translatable("container.stonecutter");
+    private static final Component CONTAINER_TITLE = Component.literal("Blockcutter")/*Component.translatable("container.stonecutter")*/; // Suki - custom blocks and items
     public static final DirectionProperty FACING = HorizontalDirectionalBlock.FACING;
     protected static final VoxelShape SHAPE = Block.box(0.0D, 0.0D, 0.0D, 16.0D, 9.0D, 16.0D);
 
diff --git a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
index ebf718cea97d4ff88e888675eeceeca253dc01cb..dcc531a0a660f79447d4b6556ec4b7f27758e2f9 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
@@ -45,6 +45,9 @@ import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.Vec3;
 // CraftBukkit start
+import org.sucraft.suki.block.SuCraftBlocks;
+import org.sucraft.suki.item.SuCraftItemTags;
+import org.sucraft.suki.item.SuCraftItems;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
@@ -143,11 +146,27 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
 
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Items.LAVA_BUCKET, 20000);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Blocks.COAL_BLOCK, 16000);
+        // Suki start - custom blocks and items
+        AbstractFurnaceBlockEntity.add(map, (ItemLike) SuCraftBlocks.COAL_STAIRS, 16000);
+        AbstractFurnaceBlockEntity.add(map, (ItemLike) SuCraftBlocks.COAL_SLAB, 8000);
+        AbstractFurnaceBlockEntity.add(map, (ItemLike) SuCraftBlocks.CHARCOAL_BLOCK, 16000);
+        AbstractFurnaceBlockEntity.add(map, (ItemLike) SuCraftBlocks.CHARCOAL_STAIRS, 16000);
+        AbstractFurnaceBlockEntity.add(map, (ItemLike) SuCraftBlocks.CHARCOAL_SLAB, 8000);
+        // Suki end - custom blocks and items
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Items.BLAZE_ROD, 2400);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Items.COAL, 1600);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Items.CHARCOAL, 1600);
-        AbstractFurnaceBlockEntity.add(map, ItemTags.LOGS, 300);
-        AbstractFurnaceBlockEntity.add(map, ItemTags.PLANKS, 300);
+        // Suki start - custom blocks and items
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.PEAT_FULL_BLOCKS, 450);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.PEAT_STAIRS, 450);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.PEAT_SLABS, 225);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.LOG_FULL_BLOCKS, 300);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.LOG_STAIRS, 300);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.LOG_SLABS, 150);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.PLANK_FULL_BLOCKS, 300);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.DYED_PLANK_STAIRS, 300);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.DYED_PLANK_SLABS, 150);
+        // Suki end - custom blocks and items
         AbstractFurnaceBlockEntity.add(map, ItemTags.WOODEN_STAIRS, 300);
         AbstractFurnaceBlockEntity.add(map, ItemTags.WOODEN_SLABS, 150);
         AbstractFurnaceBlockEntity.add(map, ItemTags.WOODEN_TRAPDOORS, 300);
@@ -167,7 +186,11 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Blocks.ACACIA_FENCE_GATE, 300);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Blocks.MANGROVE_FENCE_GATE, 300);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Blocks.NOTE_BLOCK, 300);
-        AbstractFurnaceBlockEntity.add(map, (ItemLike) Blocks.BOOKSHELF, 300);
+        // Suki start - custom blocks and items
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.BOOKSHELF_FULL_BLOCKS, 300);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.BOOKSHELF_STAIRS, 300);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.BOOKSHELF_SLABS, 150);
+        // Suki end - custom blocks and items
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Blocks.LECTERN, 300);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Blocks.JUKEBOX, 300);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Blocks.CHEST, 300);
@@ -186,13 +209,21 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Items.WOODEN_PICKAXE, 200);
         AbstractFurnaceBlockEntity.add(map, ItemTags.WOODEN_DOORS, 200);
         AbstractFurnaceBlockEntity.add(map, ItemTags.BOATS, 1200);
-        AbstractFurnaceBlockEntity.add(map, ItemTags.WOOL, 100);
+        // Suki start - custom blocks and items
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.WOOL_FULL_BLOCKS, 100);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.WOOL_STAIRS, 100);
+        AbstractFurnaceBlockEntity.add(map, SuCraftItemTags.WOOL_SLABS, 50);
+        // Suki end - custom blocks and items
         AbstractFurnaceBlockEntity.add(map, ItemTags.WOODEN_BUTTONS, 100);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Items.STICK, 100);
         AbstractFurnaceBlockEntity.add(map, ItemTags.SAPLINGS, 100);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Items.BOWL, 100);
         AbstractFurnaceBlockEntity.add(map, ItemTags.WOOL_CARPETS, 67);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Blocks.DRIED_KELP_BLOCK, 4001);
+        // Suki start - custom blocks and items
+        // Not included in initial release
+//        AbstractFurnaceBlockEntity.add(map, (ItemLike) SuCraftBlocks.DRIED_KELP_SLAB, 2001);
+        // Suki end - custom blocks and items
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Items.CROSSBOW, 300);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Blocks.BAMBOO, 50);
         AbstractFurnaceBlockEntity.add(map, (ItemLike) Blocks.DEAD_BUSH, 100);
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index e784f0b6d862b1d981ce7d63dbf7f1e3e21b0923..5202f33a90adc04bbf5dfa7f91117b8c5597ae03 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -40,6 +40,8 @@ import net.minecraft.world.phys.shapes.VoxelShape;
 // CraftBukkit start
 import com.google.common.collect.ImmutableList;
 import java.util.AbstractList;
+
+import org.sucraft.suki.block.SuCraftBlocks;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.block.BlockPistonRetractEvent;
 import org.bukkit.event.block.BlockPistonExtendEvent;
@@ -302,7 +304,7 @@ public class PistonBaseBlock extends DirectionalBlock {
         if (pos.getY() >= world.getMinBuildHeight() && pos.getY() <= world.getMaxBuildHeight() - 1 && world.getWorldBorder().isWithinBounds(pos)) {
             if (state.isAir()) {
                 return true;
-            } else if (!state.is(Blocks.OBSIDIAN) && !state.is(Blocks.CRYING_OBSIDIAN) && !state.is(Blocks.RESPAWN_ANCHOR) && !state.is(Blocks.REINFORCED_DEEPSLATE)) {
+            } else if (!state.is(Blocks.OBSIDIAN) && !state.is(SuCraftBlocks.OBSIDIAN_STAIRS) && !state.is(SuCraftBlocks.OBSIDIAN_SLAB) && !state.is(Blocks.CRYING_OBSIDIAN) && !state.is(SuCraftBlocks.CRYING_OBSIDIAN_STAIRS) && !state.is(SuCraftBlocks.CRYING_OBSIDIAN_SLAB) && !state.is(Blocks.RESPAWN_ANCHOR) && !state.is(Blocks.REINFORCED_DEEPSLATE)) {
                 if (direction == Direction.DOWN && pos.getY() == world.getMinBuildHeight()) {
                     return false;
                 } else if (direction == Direction.UP && pos.getY() == world.getMaxBuildHeight() - 1) {
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
index 09c95fea219fc777aeb9354387aa694fcc9fe03a..8fe5a34529622bbaa8def0b2a18ca9aff23d5792 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockBehaviour.java
@@ -19,6 +19,7 @@ import net.minecraft.core.HolderSet;
 import net.minecraft.core.Registry;
 import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.tags.FluidTags;
 import net.minecraft.tags.TagKey;
@@ -84,7 +85,7 @@ public abstract class BlockBehaviour {
     protected final float speedFactor;
     protected final float jumpFactor;
     protected final boolean dynamicShape;
-    protected final BlockBehaviour.Properties properties;
+    public final BlockBehaviour.Properties properties; // Suki - custom blocks and items
     @Nullable
     protected ResourceLocation drops;
 
@@ -361,7 +362,7 @@ public abstract class BlockBehaviour {
         if (f == -1.0F) {
             return 0.0F;
         } else {
-            int i = player.hasCorrectToolForDrops(state) ? 30 : 100;
+            int i = player.hasCorrectToolForFasterBreaking(state) ? 30 : 100; // Suki - custom blocks and items
 
             return player.getDestroySpeed(state) / f / (float) i;
         }
@@ -425,7 +426,7 @@ public abstract class BlockBehaviour {
         SoundType soundType;
         ToIntFunction<BlockState> lightEmission;
         float explosionResistance;
-        float destroyTime;
+        public float destroyTime; // Suki - custom blocks and items
         boolean requiresCorrectToolForDrops;
         boolean isRandomlyTicking;
         float friction;
@@ -628,6 +629,15 @@ public abstract class BlockBehaviour {
             return this;
         }
 
+        // Suki start - custom blocks and items
+
+        public BlockBehaviour.Properties doesNotRequireCorrectToolForDrops() {
+            this.requiresCorrectToolForDrops = false;
+            return this;
+        }
+
+        // Suki end - custom blocks and items
+
         public BlockBehaviour.Properties color(MaterialColor color) {
             this.materialColor = (iblockdata) -> {
                 return color;
@@ -684,7 +694,7 @@ public abstract class BlockBehaviour {
         private final boolean isAir;
         private final Material material;
         private final MaterialColor materialColor;
-        public final float destroySpeed;
+        public float destroySpeed; // Suki - custom blocks and items
         private final boolean requiresCorrectToolForDrops;
         private final boolean canOcclude;
 
@@ -1166,6 +1176,25 @@ public abstract class BlockBehaviour {
             return this.requiresCorrectToolForDrops;
         }
 
+        // Suki start - custom blocks and items
+
+        public boolean requiresCorrectToolForFasterBreaking(boolean doPlayerObservableLookups) {
+            if (!this.requiresCorrectToolForDrops()) {
+                return false;
+            }
+            if (doPlayerObservableLookups) {
+                for (int playerObservableStateId : Block.realStateToPlayerObservableStates[Block.BLOCK_STATE_REGISTRY.getId(this.asState())]) {
+                    net.minecraft.world.level.block.state.BlockState playerObservableState = Block.BLOCK_STATE_REGISTRY.byId(playerObservableStateId);
+                    if (!playerObservableState.requiresCorrectToolForFasterBreaking(false)) {
+                        return false;
+                    }
+                }
+            }
+            return true;
+        }
+
+        // Suki end - custom blocks and items
+
         public BlockBehaviour.OffsetType getOffsetType() {
             return this.offsetType;
         }
diff --git a/src/main/java/net/minecraft/world/level/block/state/StateHolder.java b/src/main/java/net/minecraft/world/level/block/state/StateHolder.java
index 340d0648fcf9b9749c4daa1c25a226b947707c3d..85389883e50c59438bf6002c5e2e850d31d2686b 100644
--- a/src/main/java/net/minecraft/world/level/block/state/StateHolder.java
+++ b/src/main/java/net/minecraft/world/level/block/state/StateHolder.java
@@ -81,6 +81,19 @@ public abstract class StateHolder<O, S> {
         return stringBuilder.toString();
     }
 
+    // Suki start - custom blocks and items
+
+    public String toVariantString() {
+        // Based on StateHolder.toString
+        StringBuilder stringBuilder = new StringBuilder();
+        if (!this.getValues().isEmpty()) {
+            stringBuilder.append(this.getValues().entrySet().stream().map(PROPERTY_ENTRY_TO_STRING_FUNCTION).collect(Collectors.joining(",")));
+        }
+        return stringBuilder.toString();
+    }
+
+    // Suki end - custom blocks and items
+
     public Collection<Property<?>> getProperties() {
         return Collections.unmodifiableCollection(this.values.keySet());
     }
diff --git a/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java b/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
index ba9b0f419b0785a0b1e3bc57f18bfe5edaa192bd..15b442229c2ed58ed93dc52dc5424b517bd14278 100644
--- a/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
+++ b/src/main/java/net/minecraft/world/level/chunk/HashMapPalette.java
@@ -11,7 +11,7 @@ public class HashMapPalette<T> implements Palette<T> {
     private final IdMap<T> registry;
     private final CrudeIncrementalIntIdentityHashBiMap<T> values;
     private final PaletteResize<T> resizeHandler;
-    private final int bits;
+    public final int bits; // Suki - custom blocks and items
 
     public HashMapPalette(IdMap<T> idList, int bits, PaletteResize<T> listener, List<T> entries) {
         this(idList, bits, listener);
@@ -90,7 +90,7 @@ public class HashMapPalette<T> implements Palette<T> {
         buf.writeVarInt(i);
 
         for(int j = 0; j < i; ++j) {
-            buf.writeVarInt(this.registry.getId(this.values.byId(j)));
+            buf.writeVarIntThreeBytes(this.registry.getId(this.values.byId(j))); // Suki - custom blocks and items
         }
 
     }
@@ -99,9 +99,7 @@ public class HashMapPalette<T> implements Palette<T> {
     public int getSerializedSize() {
         int i = FriendlyByteBuf.getVarIntSize(this.getSize());
 
-        for(int j = 0; j < this.getSize(); ++j) {
-            i += FriendlyByteBuf.getVarIntSize(this.registry.getId(this.values.byId(j)));
-        }
+        i += this.getSize() * 3; // Suki - custom blocks and items
 
         return i;
     }
@@ -121,4 +119,13 @@ public class HashMapPalette<T> implements Palette<T> {
     public Palette<T> copy() {
         return new HashMapPalette<>(this.registry, this.bits, this.resizeHandler, this.values.copy());
     }
+
+    // Suki start - custom blocks and items
+
+    public HashMapPalette<T> copyBlank(List<T> entries) {
+        return new HashMapPalette<>(this.registry, this.bits, (newSize, added) -> 0, entries);
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
index 3ea5715b065ac0aeea68feadaaf871564d6572ec..2a01d3d22566255c0903820daa6dc8efd9df018b 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -333,4 +333,45 @@ public class LevelChunkSection {
         this.biomes = datapaletteblock;
     }
 
+    // Suki start - custom blocks and entities
+
+    public boolean potentiallyContainsBlockEntity() {
+        return potentiallyContainsBlockEntity(null, null);
+    }
+
+    private static boolean potentiallyContainsBlockEntity(@NotNull BlockState state) {
+        Block block = state.getBlock();
+        var replacementRule = block.replacementRule;
+        if (replacementRule != null) {
+            if (replacementRule.hasAsReal(block)) {
+                if (replacementRule.rendersAsEntity(state)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    public boolean potentiallyContainsBlockEntity(short @Nullable [] positions, @NotNull BlockState @Nullable [] states) {
+        if (states != null) {
+            for (BlockState state : states) {
+                if (potentiallyContainsBlockEntity(state)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+        boolean[] potentiallyContainsBlockEntity = { false };
+        this.getStates().getAllEarlyStop(state -> {
+            if (potentiallyContainsBlockEntity(state)) {
+                potentiallyContainsBlockEntity[0] = true;
+                return true;
+            }
+            return false;
+        });
+        return potentiallyContainsBlockEntity[0];
+    }
+
+    // Suki end - custom blocks and entities
+
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java b/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java
index fb65457bc03a24b5f67e8eef538da8d6c2aabd6e..d6715b8386f6a639a6221840e1eecb87d19be5dc 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LinearPalette.java
@@ -10,7 +10,7 @@ public class LinearPalette<T> implements Palette<T> {
     private final IdMap<T> registry;
     private final T[] values;
     private final PaletteResize<T> resizeHandler;
-    private final int bits;
+    public final int bits; // Suki start - custom blocks and items
     private int size;
 
     private LinearPalette(IdMap<T> idList, int bits, PaletteResize<T> listener, List<T> list) {
@@ -92,7 +92,7 @@ public class LinearPalette<T> implements Palette<T> {
         buf.writeVarInt(this.size);
 
         for(int i = 0; i < this.size; ++i) {
-            buf.writeVarInt(this.registry.getId(this.values[i]));
+            buf.writeVarIntThreeBytes(this.registry.getId(this.values[i])); // Suki - custom blocks and items
         }
 
     }
@@ -101,9 +101,7 @@ public class LinearPalette<T> implements Palette<T> {
     public int getSerializedSize() {
         int i = FriendlyByteBuf.getVarIntSize(this.getSize());
 
-        for(int j = 0; j < this.getSize(); ++j) {
-            i += FriendlyByteBuf.getVarIntSize(this.registry.getId(this.values[j]));
-        }
+        i += this.getSize() * 3; // Suki - custom blocks and items
 
         return i;
     }
@@ -117,4 +115,13 @@ public class LinearPalette<T> implements Palette<T> {
     public Palette<T> copy() {
         return new LinearPalette<>(this.registry, (T[])((Object[])this.values.clone()), this.resizeHandler, this.bits, this.size);
     }
+
+    // Suki start - custom blocks and items
+
+    public LinearPalette<T> copyBlank(List<T> entries) {
+        return new LinearPalette<>(this.registry, this.bits, (newSize, added) -> 0, entries);
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
index 5f578da4a7251b17d6a12821a3cd090e66b52a8a..f036df38e4b1c98b3ff6465bf3a6118e063c3adf 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -233,6 +233,21 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
         });
     }
 
+    // Suki start - custom blocks and items
+
+    public void getAllEarlyStop(Predicate<T> whetherToStop) {
+        Palette<T> palette = this.data.palette();
+        IntSet intSet = new IntArraySet();
+        this.data.storage.getAll(intSet::add);
+        for (int id : intSet) {
+            if (whetherToStop.test(palette.valueFor(id))) {
+                break;
+            }
+        }
+    }
+
+    // Suki end - custom blocks and items
+
     public synchronized void read(FriendlyByteBuf buf) { // Paper - synchronize
         this.acquire();
 
@@ -434,7 +449,7 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
         // JettPack end
     }
 
-    static record Configuration<T>(Palette.Factory factory, int bits) {
+    public static record Configuration<T>(Palette.Factory factory, int bits) { // Suki - custom blocks and items
         public PalettedContainer.Data<T> createData(IdMap<T> idList, PaletteResize<T> listener, int size) {
             BitStorage bitStorage = (BitStorage)(this.bits == 0 ? new ZeroBitStorage(size) : new SimpleBitStorage(this.bits, size));
             Palette<T> palette = this.factory.create(this.bits, idList, listener, List.of());
@@ -471,6 +486,12 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
         // Paper start - Anti-Xray - Add chunk packet info
         public void write(FriendlyByteBuf buf, @Nullable com.destroystokyo.paper.antixray.ChunkPacketInfo<T> chunkPacketInfo, int bottomBlockY) {
             buf.writeByte(this.storage.getBits());
+            // Suki start - custom blocks and items
+            if (chunkPacketInfo != null) {
+                int chunkSectionIndex = (bottomBlockY >> 4) - chunkPacketInfo.getChunk().getMinSection();
+                chunkPacketInfo.setPaletteIndex(chunkSectionIndex, buf.writerIndex());
+            }
+            // Suki end - custom blocks and items
             this.palette.write(buf);
 
             if (chunkPacketInfo != null) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java b/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java
index 76cfa5797a71df34c7b933798815863f437debcd..32b5a52f4e454175d3e0eee44d7ba57d96b00fcf 100644
--- a/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java
+++ b/src/main/java/net/minecraft/world/level/chunk/SingleValuePalette.java
@@ -8,12 +8,12 @@ import net.minecraft.network.FriendlyByteBuf;
 import org.apache.commons.lang3.Validate;
 
 public class SingleValuePalette<T> implements Palette<T> {
-    private final IdMap<T> registry;
+    public final IdMap<T> registry; // Suki - custom blocks and items
     @Nullable
     private T value;
-    private final PaletteResize<T> resizeHandler;
+    private final @Nullable PaletteResize<T> resizeHandler; // Suki - custom blocks and items
 
-    public SingleValuePalette(IdMap<T> idList, PaletteResize<T> listener, List<T> entries) {
+    public SingleValuePalette(IdMap<T> idList, @Nullable PaletteResize<T> listener, List<T> entries) { // Suki - custom blocks and items
         this.registry = idList;
         this.resizeHandler = listener;
         if (entries.size() > 0) {
@@ -23,13 +23,18 @@ public class SingleValuePalette<T> implements Palette<T> {
 
     }
 
-    public static <A> Palette<A> create(int bitSize, IdMap<A> idList, PaletteResize<A> listener, List<A> entries) {
+    public static <A> Palette<A> create(int bitSize, IdMap<A> idList, @Nullable PaletteResize<A> listener, List<A> entries) { // Suki - custom blocks and items
         return new SingleValuePalette<>(idList, listener, entries);
     }
 
     @Override
     public int idFor(T object) {
         if (this.value != null && this.value != object) {
+            // Suki start - custom blocks and items
+            if (this.resizeHandler == null) {
+                throw new IllegalStateException("Tried to expand SingleValuePalette without a resizeHandler");
+            }
+            // Suki end - custom blocks and items
             return this.resizeHandler.onResize(1, object);
         } else {
             this.value = object;
@@ -65,7 +70,7 @@ public class SingleValuePalette<T> implements Palette<T> {
         if (this.value == null) {
             throw new IllegalStateException("Use of an uninitialized palette");
         } else {
-            buf.writeVarInt(this.registry.getId(this.value));
+            buf.writeVarIntThreeBytes(this.registry.getId(this.value)); // Suki - custom blocks and items
         }
     }
 
@@ -74,7 +79,7 @@ public class SingleValuePalette<T> implements Palette<T> {
         if (this.value == null) {
             throw new IllegalStateException("Use of an uninitialized palette");
         } else {
-            return FriendlyByteBuf.getVarIntSize(this.registry.getId(this.value));
+            return 3; // Suki - custom blocks and items
         }
     }
 
@@ -91,4 +96,13 @@ public class SingleValuePalette<T> implements Palette<T> {
             return this;
         }
     }
+
+    // Suki start - custom blocks and items
+
+    public SingleValuePalette<T> copyBlank(List<T> entries) {
+        return new SingleValuePalette<>(this.registry, (newSize, added) -> 0, entries);
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/feature/configurations/TreeConfiguration.java b/src/main/java/net/minecraft/world/level/levelgen/feature/configurations/TreeConfiguration.java
index b8405113d67a02ee933af65a7b8a912df64356b4..94683dd3896bb37193fd4e0237062696f67fb44a 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/feature/configurations/TreeConfiguration.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/feature/configurations/TreeConfiguration.java
@@ -3,15 +3,24 @@ package net.minecraft.world.level.levelgen.feature.configurations;
 import com.google.common.collect.ImmutableList;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
+
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.levelgen.feature.featuresize.FeatureSize;
 import net.minecraft.world.level.levelgen.feature.foliageplacers.FoliagePlacer;
 import net.minecraft.world.level.levelgen.feature.rootplacers.RootPlacer;
 import net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProvider;
+import net.minecraft.world.level.levelgen.feature.stateproviders.BlockStateProviderType;
 import net.minecraft.world.level.levelgen.feature.treedecorators.TreeDecorator;
 import net.minecraft.world.level.levelgen.feature.trunkplacers.TrunkPlacer;
+import org.jetbrains.annotations.NotNull;
 
 public class TreeConfiguration implements FeatureConfiguration {
     public static final Codec<TreeConfiguration> CODEC = RecordCodecBuilder.create((instance) -> {
@@ -61,10 +70,29 @@ public class TreeConfiguration implements FeatureConfiguration {
         this.forceDirt = forceDirt;
     }
 
+    // Suki start - custom blocks and items
+
+    public @NotNull TreeConfigurationBuilder cloneBuilder() {
+        var builder = new TreeConfigurationBuilder(
+            this.trunkProvider,
+            this.trunkPlacer,
+            this.foliageProvider,
+            this.foliagePlacer,
+            this.rootPlacer,
+            this.minimumSize
+        );
+        builder.decorators = new ArrayList<>(this.decorators);
+        builder.ignoreVines = this.ignoreVines;
+        builder.forceDirt = this.forceDirt;
+        return builder;
+    }
+
+    // Suki end - custom blocks and items
+
     public static class TreeConfigurationBuilder {
-        public final BlockStateProvider trunkProvider;
+        public BlockStateProvider trunkProvider; // Suki - custom blocks and items
         private final TrunkPlacer trunkPlacer;
-        public final BlockStateProvider foliageProvider;
+        public BlockStateProvider foliageProvider; // Suki - custom blocks and items
         private final FoliagePlacer foliagePlacer;
         private final Optional<RootPlacer> rootPlacer;
         private BlockStateProvider dirtProvider;
@@ -107,6 +135,20 @@ public class TreeConfiguration implements FeatureConfiguration {
             return this;
         }
 
+        // Suki start - custom blocks and items
+
+        public TreeConfiguration.TreeConfigurationBuilder withLog(@NotNull Block log) {
+            this.trunkProvider = BlockStateProvider.simple(log);
+            return this;
+        }
+
+        public TreeConfiguration.TreeConfigurationBuilder withLeaves(@NotNull Block leaves) {
+            this.foliageProvider = BlockStateProvider.simple(leaves);
+            return this;
+        }
+
+        // Suki end - custom blocks and items
+
         public TreeConfiguration build() {
             return new TreeConfiguration(this.trunkProvider, this.trunkPlacer, this.foliageProvider, this.foliagePlacer, this.rootPlacer, this.dirtProvider, this.minimumSize, this.decorators, this.ignoreVines, this.forceDirt);
         }
diff --git a/src/main/java/net/minecraft/world/level/portal/PortalShape.java b/src/main/java/net/minecraft/world/level/portal/PortalShape.java
index 3414f3190e1a760c602613e82e551e797c3aa575..522d75e3296a92412b04ef71a961042ec7d60227 100644
--- a/src/main/java/net/minecraft/world/level/portal/PortalShape.java
+++ b/src/main/java/net/minecraft/world/level/portal/PortalShape.java
@@ -17,8 +17,10 @@ import net.minecraft.world.level.block.NetherPortalBlock;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.SlabType;
 import net.minecraft.world.phys.Vec3;
 // CraftBukkit start
+import org.sucraft.suki.block.SuCraftBlocks;
 import org.bukkit.craftbukkit.event.CraftPortalEvent;
 import org.bukkit.event.world.PortalCreateEvent;
 // CraftBukkit end
@@ -30,7 +32,7 @@ public class PortalShape {
     private static final int MIN_HEIGHT = 3;
     public static final int MAX_HEIGHT = 21;
     private static final BlockBehaviour.StatePredicate FRAME = (iblockdata, iblockaccess, blockposition) -> {
-        return iblockdata.is(Blocks.OBSIDIAN);
+        return iblockdata.is(Blocks.OBSIDIAN) || iblockdata.is(SuCraftBlocks.OBSIDIAN_STAIRS) || (iblockdata.is(SuCraftBlocks.OBSIDIAN_SLAB) && iblockdata.getValue(BlockStateProperties.SLAB_TYPE) == SlabType.DOUBLE); // Suki - custom blocks and items
     };
     private final LevelAccessor level;
     private final Direction.Axis axis;
diff --git a/src/main/java/net/minecraft/world/level/storage/loot/LootTables.java b/src/main/java/net/minecraft/world/level/storage/loot/LootTables.java
index aef7198ca8b781d02204098811086b25050ab262..b499428caa585b203fb44ad944886383d12d904b 100644
--- a/src/main/java/net/minecraft/world/level/storage/loot/LootTables.java
+++ b/src/main/java/net/minecraft/world/level/storage/loot/LootTables.java
@@ -9,12 +9,17 @@ import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.function.Function;
+
+import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.server.packs.resources.SimpleJsonResourceReloadListener;
 import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParamSet;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParamSets;
+import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 
 public class LootTables extends SimpleJsonResourceReloadListener {
@@ -52,6 +57,16 @@ public class LootTables extends SimpleJsonResourceReloadListener {
             }
 
         });
+        // Suki start - custom blocks and items
+        for (Block block : Registry.BLOCK) {
+            @Nullable LootTable customLootTable = block.createCustomLootTable();
+            if (customLootTable != null) {
+                // The below is taken from
+                var lootTableKey = block.getLootTable();
+                builder.put(lootTableKey, customLootTable);
+            }
+        }
+        // Suki end - custom blocks and items
         builder.put(BuiltInLootTables.EMPTY, LootTable.EMPTY);
         ImmutableMap<ResourceLocation, LootTable> immutablemap = builder.build();
         LootContextParamSet lootcontextparameterset = LootContextParamSets.ALL_PARAMS;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index ad26167586279b54c812463e6b3626d89fe1652c..06fee2cfb5e981ffa2dc8705a0545e87e20234d5 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -42,6 +42,7 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
 import java.util.function.Consumer;
+import java.util.function.Predicate;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.stream.Collectors;
@@ -1437,6 +1438,23 @@ public final class CraftServer implements Server {
         return true;
     }
 
+    // Suki start - custom blocks and items
+
+    @Override
+    public boolean addRecipe(Recipe recipe, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        if (this.addRecipe(recipe)) {
+            if (isSkippableForPlayersThatCannotAcceptLargePackets) {
+                var recipeManager = MinecraftServer.getServer().getRecipeManager();
+                var key = ((Keyed) recipe).getKey();
+                recipeManager.recipesSkippableForPlayersThatCannotAcceptLargePackets.add(new ResourceLocation(key.getNamespace(), key.getKey()));
+            }
+            return true;
+        }
+        return false;
+    }
+
+    // Suki end - custom blocks and items
+
     @Override
     public List<Recipe> getRecipesFor(ItemStack result) {
         Validate.notNull(result, "Result cannot be null");
@@ -2929,6 +2947,21 @@ public final class CraftServer implements Server {
     public CraftPotionBrewer getPotionBrewer() {
         return this.potionBrewer;
     }
+
+    // Suki start - custom blocks and items
+
+    @Override
+    public void addCanAcceptLargePacketsDisjunct(Predicate<Player> disjunct) {
+        this.getHandle().canAcceptLargePacketsDisjuncts.add(disjunct);
+    }
+
+    @Override
+    public void addCanAcceptServerResourcePackDisjunct(Predicate<Player> disjunct) {
+        this.getHandle().canAcceptServerResourcePackDisjuncts.add(disjunct);
+    }
+
+    // Suki end - custom blocks and items
+
     // Paper end
 
     // Yatopia start
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index fe8433163a775aa19569b3681b5108b5d0b6c016..ecaf2a1b5f869f975df13e37dab8f6e722c784df 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -67,6 +67,7 @@ import net.minecraft.world.phys.HitResult;
 import net.minecraft.world.phys.Vec3;
 import org.sucraft.suki.structure.WorldStructure;
 import org.apache.commons.lang.Validate;
+import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.bukkit.BlockChangeDelegate;
 import org.bukkit.Bukkit;
 import org.bukkit.Chunk;
@@ -552,13 +553,16 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         if (playersInRange.isEmpty()) return true;
 
         // Paper start - Anti-Xray - Bypass
-        Map<Object, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>();
+        Map<ImmutablePair<Boolean, Boolean>, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>(); // Suki - custom blocks and items
         for (ServerPlayer player : playersInRange) {
             if (player.connection == null) continue;
 
             Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-            player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
-                return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, (Boolean) s);
+            // Suki start - custom blocks and items
+            boolean hasResourcePack = player.hasSuCraftResourcePack();
+            player.connection.send(refreshPackets.computeIfAbsent(new ImmutablePair<>(shouldModify, hasResourcePack), s -> { // Use connection to prevent creating firing event
+                return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, s.left, s.right);
+                // Suki end - custom blocks and items
             }));
             // Paper end
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 717678f25848f43078c4d277baddbca6e92e7e34..dab90145f6a67375830c16cab9e086cf09519d92 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -27,6 +27,8 @@ import java.util.WeakHashMap;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.advancements.AdvancementProgress;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos; // Paper
@@ -133,6 +135,7 @@ import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Player;
 import org.bukkit.event.player.PlayerHideEntityEvent;
 import org.bukkit.event.player.PlayerRegisterChannelEvent;
+import org.bukkit.event.player.PlayerResourcePackStatusEvent;
 import org.bukkit.event.player.PlayerShowEntityEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerUnregisterChannelEvent;
@@ -2548,6 +2551,34 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     public void setResourcePackStatus(org.bukkit.event.player.PlayerResourcePackStatusEvent.Status status) {
         this.resourcePackStatus = status;
     }
+
+    // Suki start - custom blocks and items
+
+    @Override
+    public boolean hasSuCraftResourcePack() {
+        // Currently we simply assume that if any resource pack was successfully loaded, it includes at least the SuCraft resource pack
+        // TODO maybe make this smarter, but for now taking ACCEPTED is nicer at the start - even though it may lead to FAILED_DOWNLOAD later in a small number of cases
+        // TODO ^ Maybe it's best to assume the player has the resource while status is ACCEPTED, and refresh the most important things (world chunks, player's own inventory) on FAILED_DOWNLOAD - which will be rare but then it's fixed reasonably enough I think
+        return this.resourcePackStatus == PlayerResourcePackStatusEvent.Status.ACCEPTED || this.resourcePackStatus == PlayerResourcePackStatusEvent.Status.SUCCESSFULLY_LOADED;
+    }
+
+    @Override
+    public boolean hasHighPingForCustomBlocks() {
+        return this.getPing() > GlobalConfiguration.get().customBlocksAndItems.maxPingThatCountsAsLowForCustomBlocks;
+    }
+
+    @Override
+    public boolean canAcceptLargePackets() {
+        return this.getHandle().canAcceptLargePackets();
+    }
+
+    @Override
+    public boolean canAcceptServerResourcePack() {
+        return this.getHandle().canAcceptServerResourcePack();
+    }
+
+    // Suki end - custom blocks and items
+
     // Paper end
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 3c4dadd0012c11191c873fe25a7625193563915d..4cbda2cf5a2272369f4ab79ec5c0bf0e2c40c354 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -47,6 +47,7 @@ import net.minecraft.nbt.StringTag;
 import net.minecraft.nbt.Tag;
 import net.minecraft.network.chat.Component;
 import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
 import org.apache.commons.lang.Validate;
 import org.apache.commons.lang3.EnumUtils;
 import org.bukkit.Material;
@@ -112,9 +113,9 @@ import java.util.Collections;
  * <li> SerializableMeta.Deserializers deserializer()
  */
 @DelegateDeserialization(CraftMetaItem.SerializableMeta.class)
-class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
+public class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta { // Suki - custom blocks and items
 
-    static class ItemMetaKey {
+    public static class ItemMetaKey { // Suki - custom blocks and items
 
         @Retention(RetentionPolicy.SOURCE)
         @Target(ElementType.FIELD)
@@ -128,7 +129,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
 
         final String BUKKIT;
-        final String NBT;
+        public final String NBT; // Suki - custom blocks and items
 
         ItemMetaKey(final String both) {
             this(both, both);
@@ -238,12 +239,12 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
     }
 
-    static final ItemMetaKey NAME = new ItemMetaKey("Name", "display-name");
+    public static final ItemMetaKey NAME = new ItemMetaKey("Name", "display-name"); // Suki - custom blocks and items
     static final ItemMetaKey LOCNAME = new ItemMetaKey("LocName", "loc-name");
     @Specific(Specific.To.NBT)
-    static final ItemMetaKey DISPLAY = new ItemMetaKey("display");
-    static final ItemMetaKey LORE = new ItemMetaKey("Lore", "lore");
-    static final ItemMetaKey CUSTOM_MODEL_DATA = new ItemMetaKey("CustomModelData", "custom-model-data");
+    public static final ItemMetaKey DISPLAY = new ItemMetaKey("display"); // Suki - custom blocks and items
+    public static final ItemMetaKey LORE = new ItemMetaKey("Lore", "lore"); // Suki - custom blocks and items
+    public static final ItemMetaKey CUSTOM_MODEL_DATA = new ItemMetaKey("CustomModelData", "custom-model-data"); // Suki - custom blocks and items
     static final ItemMetaKey ENCHANTMENTS = new ItemMetaKey("Enchantments", "enchants");
     @Specific(Specific.To.NBT)
     static final ItemMetaKey ENCHANTMENTS_ID = new ItemMetaKey("id");
@@ -278,6 +279,7 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     static final ItemMetaKey CAN_DESTROY = new ItemMetaKey("CanDestroy");
     static final ItemMetaKey CAN_PLACE_ON = new ItemMetaKey("CanPlaceOn");
     // Paper end
+    static final ItemMetaKey ADD_TECHNICAL_PROPERTIES_LORE_TAG_KEY = new ItemMetaKey(ItemStack.ADD_TECHNICAL_PROPERTIES_LORE_TAG_KEY); // Suki - custom blocks and items
 
     // We store the raw original JSON representation of all text data. See SPIGOT-5063, SPIGOT-5656, SPIGOT-5304
     private String displayName;
@@ -295,6 +297,10 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
     private Set<Namespaced> placeableKeys = Sets.newHashSet();
     private Set<Namespaced> destroyableKeys = Sets.newHashSet();
     // Paper end
+    // Suki start - custom blocks and items
+    private Boolean addTechnicalPropertiesLore;
+    private Boolean addUnderlyingItemLoreIfRenamed;
+    // Suki end - custom blocks and items
 
     private static final Set<String> HANDLED_TAGS = Sets.newHashSet();
     private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
@@ -430,6 +436,12 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
         // Paper end
 
+        // Suki start - custom blocks and items
+        if (tag.contains(ADD_TECHNICAL_PROPERTIES_LORE_TAG_KEY.NBT, Tag.TAG_BYTE)) {
+            this.addTechnicalPropertiesLore = tag.getBoolean(ADD_TECHNICAL_PROPERTIES_LORE_TAG_KEY.NBT);
+        }
+        // Suki end - custom blocks and items
+
         Set<String> keys = tag.getAllKeys();
         for (String key : keys) {
             if (!CraftMetaItem.getHandledTags().contains(key)) {
@@ -741,6 +753,12 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         }
         // Paper end
 
+        // Suki start - custom blocks and items
+        if (this.addTechnicalPropertiesLore != null) {
+            itemTag.putBoolean(ADD_TECHNICAL_PROPERTIES_LORE_TAG_KEY.NBT, this.addTechnicalPropertiesLore);
+        }
+        // Suki end - custom blocks and items
+
         for (Map.Entry<String, Tag> e : this.unhandledTags.entrySet()) {
             itemTag.put(e.getKey(), e.getValue());
         }
@@ -1815,4 +1833,29 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
         return true;
     }
     // Paper end
+
+    // Suki start - custom blocks and items
+
+    @Override
+    public boolean getAddTechnicalPropertiesLore() {
+        return this.addTechnicalPropertiesLore == null || this.addTechnicalPropertiesLore;
+    }
+
+    @Override
+    public void setAddTechnicalPropertiesLore(boolean add) {
+        this.addTechnicalPropertiesLore = add ? null : false;
+    }
+
+    @Override
+    public boolean getAddUnderlyingItemLoreIfRenamed() {
+        return this.addUnderlyingItemLoreIfRenamed == null || this.addUnderlyingItemLoreIfRenamed;
+    }
+
+    @Override
+    public void setAddUnderlyingItemLoreIfRenamed(boolean add) {
+        this.addUnderlyingItemLoreIfRenamed = add ? null : false;
+    }
+
+    // Suki end - custom blocks and items
+
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index b3f5b7e5ea44174bf2769e9b80d4e21f9438b77f..484655ef1fd61855c490d2d37725e9108a7b0928 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -143,12 +143,25 @@ public final class CraftMagicNumbers implements UnsafeValues {
             ENTITY_TYPES_ENTITY_TYPE.put(net.minecraft.core.Registry.ENTITY_TYPE.get(CraftNamespacedKey.toMinecraft(type.getKey())), type);
         }
         // Paper end
-        for (Block block : net.minecraft.core.Registry.BLOCK) {
-            BLOCK_MATERIAL.put(block, Material.getMaterial(net.minecraft.core.Registry.BLOCK.getKey(block).getPath().toUpperCase(Locale.ROOT)));
+        for (Block block : net.minecraft.core.Registry.BLOCK) {// Suki start - custom blocks and items
+            var key = net.minecraft.core.Registry.BLOCK.getKey(block);
+            String materialName = key.getPath().toUpperCase(Locale.ROOT);
+            if (key.getNamespace().equals(ResourceLocation.SUCRAFT_NAMESPACE)) {
+                materialName = "SUCRAFT_" + materialName;
+            }
+            BLOCK_MATERIAL.put(block, Material.getMaterial(materialName));
+            // Suki end - custom blocks and items
         }
 
         for (Item item : net.minecraft.core.Registry.ITEM) {
-            ITEM_MATERIAL.put(item, Material.getMaterial(net.minecraft.core.Registry.ITEM.getKey(item).getPath().toUpperCase(Locale.ROOT)));
+            // Suki start - custom blocks and items
+            var key = net.minecraft.core.Registry.ITEM.getKey(item);
+            String materialName = key.getPath().toUpperCase(Locale.ROOT);
+            if (key.getNamespace().equals(ResourceLocation.SUCRAFT_NAMESPACE)) {
+                materialName = "SUCRAFT_" + materialName;
+            }
+            ITEM_MATERIAL.put(item, Material.getMaterial(materialName));
+            // Suki end - custom blocks and items
         }
 
         for (net.minecraft.world.level.material.Fluid fluid : net.minecraft.core.Registry.FLUID) {
diff --git a/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerAntiXrayCustom.java b/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerAntiXrayCustom.java
new file mode 100644
index 0000000000000000000000000000000000000000..4937900b4acace0df5e0ff71ed23f1130ff6c5ea
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerAntiXrayCustom.java
@@ -0,0 +1,29 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.antixray;
+
+import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.chunk.LevelChunk;
+import java.util.concurrent.Executor;
+
+public final class ChunkPacketBlockControllerAntiXrayCustom extends ChunkPacketBlockControllerAntiXray {
+
+    public ChunkPacketBlockControllerAntiXrayCustom(Level level, Executor executor) {
+        super(level, executor);
+    }
+
+    @Override
+    public boolean shouldModify(ServerPlayer player, LevelChunk chunk) {
+        return true;
+    }
+
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        obfuscateXray(chunkPacketInfoAntiXray);
+        ChunkPacketBlockControllerCustom.replaceCustom(chunkPacketInfoAntiXray);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerCustom.java b/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerCustom.java
new file mode 100644
index 0000000000000000000000000000000000000000..5c336ee0a758771cca5d18b86d6db195caa731c3
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerCustom.java
@@ -0,0 +1,212 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.antixray;
+
+import com.destroystokyo.paper.antixray.BitStorageReader;
+import com.destroystokyo.paper.antixray.BitStorageWriter;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import it.unimi.dsi.fastutil.ints.Int2IntArrayMap;
+import it.unimi.dsi.fastutil.ints.Int2IntMap;
+import it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap;
+import it.unimi.dsi.fastutil.ints.IntArraySet;
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.Mth;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.GlobalPalette;
+import net.minecraft.world.level.chunk.HashMapPalette;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LinearPalette;
+import net.minecraft.world.level.chunk.Palette;
+import net.minecraft.world.level.chunk.SingleValuePalette;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.Executor;
+
+public final class ChunkPacketBlockControllerCustom extends ChunkPacketBlockControllerModifierBase {
+
+    public ChunkPacketBlockControllerCustom(Level level, Executor executor) {
+        super(level, executor);
+    }
+
+    @Override
+    public boolean shouldModify(ServerPlayer player, LevelChunk chunk) {
+        return true;
+    }
+
+    @Override
+    public void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        replaceCustom(chunkPacketInfoAntiXray);
+    }
+
+    public static void replaceCustom(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+
+        // bitStorageReader, bitStorageWriter and nearbyChunkSections could also be reused (with ThreadLocal if necessary) but it's not worth it
+        BitStorageReader bitStorageReader = new BitStorageReader();
+        BitStorageWriter bitStorageWriter = new BitStorageWriter();
+        LevelChunk chunk = chunkPacketInfoAntiXray.getChunk();
+        int sectionsCount = chunk.getSectionsCount();
+        bitStorageReader.setBuffer(chunkPacketInfoAntiXray.getBuffer());
+        bitStorageWriter.setBuffer(chunkPacketInfoAntiXray.getBuffer());
+
+        for (int chunkSectionIndex = 0; chunkSectionIndex < sectionsCount; chunkSectionIndex++) {
+            if (chunkPacketInfoAntiXray.isWritten(chunkSectionIndex)) {
+
+                // Get the current (potentially to be replaced) palette
+                var oldPalette = chunkPacketInfoAntiXray.getPalette(chunkSectionIndex);
+                int oldPaletteSize = oldPalette.getSize();
+
+                // Get the appropriate global replacements
+                int[] globalBlockStateReplacementsForResourcePackStatus = chunkPacketInfoAntiXray.doesPlayerHaveResourcePack ? Block.stateIdReplacementArrayWithResourcePack : Block.stateIdReplacementArrayWithoutResourcePack;
+
+                // First we store the old and new global ids, and flag if there will be any replacements
+                int[] oldStateRegistryIdsByOldPaletteId = new int[oldPaletteSize];
+                int[] newStateRegistryIdsByOldPaletteId = new int[oldPaletteSize];
+                boolean anyReplacements = false;
+                for (int oldPaletteId = 0; oldPaletteId < oldPaletteSize; oldPaletteId++) {
+                    BlockState oldValue = oldPalette.valueFor(oldPaletteId);
+                    int oldStateRegistryId = Block.BLOCK_STATE_REGISTRY.getId(oldValue);
+                    oldStateRegistryIdsByOldPaletteId[oldPaletteId] = oldStateRegistryId;
+                    int newStateRegistryId = globalBlockStateReplacementsForResourcePackStatus[oldStateRegistryId];
+                    newStateRegistryIdsByOldPaletteId[oldPaletteId] = newStateRegistryId;
+                    anyReplacements |= oldStateRegistryId != newStateRegistryId;
+                }
+
+                // If no replacements are necessary, we are done with this section (this will always be false in the case of a global palette that contains some non-vanilla block states)
+                if (!anyReplacements) {
+                    continue;
+                }
+
+                // Prepare for potential block replacements later
+                int[] blockStateReplacements = null;
+
+                // Special case for the global palette, where we don't have to find a new list of which global ids are needed in the new palette: we can just use the palette containing all vanilla blocks
+                // But the palette isn't written at all to the packet in this case (the client simply expects the vanilla global palette), so we simply need to compute the needed block replacements
+                if (oldPalette instanceof GlobalPalette<?>) {
+
+                    // We can just straight up use the appropriate precomputed array over all block states
+                    blockStateReplacements = globalBlockStateReplacementsForResourcePackStatus;
+
+                } else {
+                    // If not a global palette, we must figure out what will go into the new palette
+
+                    // We create sets of the old and new global ids so that we can for example check for old global ids whether they will be still present
+                    IntSet newStateRegistryIds = (oldPaletteSize <= 16) ? new IntArraySet(oldPaletteSize) : new IntOpenHashSet(oldPaletteSize * 2);
+                    Arrays.stream(newStateRegistryIdsByOldPaletteId).forEach(newStateRegistryIds::add);
+                    int newPaletteSize = newStateRegistryIds.size();
+
+                    // Create the global ids that will be in the new palette
+                    int[] newStateRegistryIdsByNewPaletteId = new int[newStateRegistryIds.size()];
+                    Arrays.fill(newStateRegistryIdsByNewPaletteId, -1); // -1 marks we have not decided which new palette state registry id to put at this palette id yet
+
+                    // Put the new global ids in the same position as the old global id they replace, if possible
+                    Int2IntMap newPaletteIdByNewStateRegistryId = newStateRegistryIds.size() <= 16 ? new Int2IntArrayMap(newStateRegistryIds.size()) : new Int2IntOpenHashMap(newStateRegistryIds.size() * 2);
+                    for (int oldPaletteId = 0; oldPaletteId < oldPaletteSize && oldPaletteId < newPaletteSize /* We cannot store them in the same palette id beyond the new palette size */; oldPaletteId++) {
+                        int newStateRegistryId = newStateRegistryIdsByOldPaletteId[oldPaletteId];
+                        // Get the existing new palette id, or use the current old palette id
+                        final int finalOldPaletteId = oldPaletteId;
+                        int newPaletteId = newPaletteIdByNewStateRegistryId.computeIfAbsent(newStateRegistryId, key -> finalOldPaletteId);
+                        newStateRegistryIdsByNewPaletteId[newPaletteId] = newStateRegistryId;
+                    }
+
+                    // Go over all new global ids and assign any of them that still need it a new palette id
+                    int[] nextNewPaletteId = {0};
+                    while (nextNewPaletteId[0] < newStateRegistryIdsByNewPaletteId.length && newStateRegistryIdsByNewPaletteId[nextNewPaletteId[0]] != -1) {
+                        nextNewPaletteId[0]++;
+                    }
+                    for (int newStateRegistryId : newStateRegistryIds) {
+                        newPaletteIdByNewStateRegistryId.computeIfAbsent(newStateRegistryId, key -> {
+                            int newPaletteId = nextNewPaletteId[0];
+                            do {
+                                nextNewPaletteId[0]++;
+                            } while (nextNewPaletteId[0] < newStateRegistryIdsByNewPaletteId.length && newStateRegistryIdsByNewPaletteId[nextNewPaletteId[0]] != -1);
+                            newStateRegistryIdsByNewPaletteId[newPaletteId] = key;
+                            return newPaletteId;
+                        });
+                    }
+
+                    // Create the necessary entries for the new palette
+                    List<BlockState> newPaletteBlockStateList = new ArrayList<>(Arrays.stream(newStateRegistryIdsByNewPaletteId).mapToObj(stateRegistryId -> Block.BLOCK_STATE_REGISTRY.byId(stateRegistryId)).toList());
+
+                    // Make sure we fit into the protocol by keeping the exact same number of bits and such, so we add some unused block states to the palette to get the same size as before
+                    for (BlockState paddingBlockState : Block.BLOCK_STATE_REGISTRY) {
+                        if (newPaletteBlockStateList.size() == oldPaletteSize) {
+                            break;
+                        }
+                        if (!newPaletteBlockStateList.contains(paddingBlockState)) {
+                            newPaletteBlockStateList.add(paddingBlockState);
+                        }
+                    }
+
+                    // We clone the palette with the new entries, so that we can then write it to the buffer
+                    Palette<BlockState> newPalette = null; // Will be initialized in one of the cases below for sure
+                    if (oldPalette instanceof SingleValuePalette<BlockState> oldSingleValuePalette) {
+                        newPalette = oldSingleValuePalette.copyBlank(newPaletteBlockStateList);
+                    } else if (oldPalette instanceof LinearPalette<BlockState> oldLinearPalette) {
+                        newPalette = oldLinearPalette.copyBlank(newPaletteBlockStateList);
+                    } else if (oldPalette instanceof HashMapPalette<BlockState> oldHashMapPalette) {
+                        newPalette = oldHashMapPalette.copyBlank(newPaletteBlockStateList);
+                    }
+
+                    // Write the new palette to the buffer
+                    FriendlyByteBuf paletteWriter;
+                    {
+                        ByteBuf byteBuf = Unpooled.wrappedBuffer(chunkPacketInfoAntiXray.getBuffer());
+                        byteBuf.writerIndex(chunkPacketInfoAntiXray.getPaletteIndex(chunkSectionIndex));
+                        paletteWriter = new FriendlyByteBuf(byteBuf);
+                    }
+                    newPalette.write(paletteWriter);
+
+                    // For any palette id where the global id at that index in the new palette is not the replacement for the global id at that index in the old palette, we must replace the palette id of all block occurrences to the palette id where the replacement is in fact stored in the new palette
+                    for (int oldPaletteId = 0; oldPaletteId < oldPaletteSize; oldPaletteId++) {
+                        // If the replacement is no longer in the right position
+                        int newStateRegistryId = newStateRegistryIdsByOldPaletteId[oldPaletteId];
+                        int newPaletteIdOfNewStateRegistryId = newPaletteIdByNewStateRegistryId.get(newStateRegistryId);
+                        if (newPaletteIdOfNewStateRegistryId != oldPaletteId) {
+                            if (blockStateReplacements == null) {
+                                blockStateReplacements = new int[oldPaletteSize];
+                                for (int i = 0; i < oldPaletteSize; i++) {
+                                    blockStateReplacements[i] = i;
+                                }
+                            }
+                            blockStateReplacements[oldPaletteId] = newPaletteIdOfNewStateRegistryId;
+                        }
+                    }
+
+                }
+
+                if (blockStateReplacements != null) {
+                    int readBits = chunkPacketInfoAntiXray.getBits(chunkSectionIndex);
+                    bitStorageReader.setBits(readBits);
+                    bitStorageReader.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex));
+                    int writeBits;
+                    if (oldPalette instanceof GlobalPalette<?>) {
+                        writeBits = Mth.ceillog2(Block.BLOCK_STATE_REGISTRY_VANILLA.size()); // Make sure we do not write 16 or more bits (because we have more block states than vanilla), but 15 bits (which corresponds to the number of block states in vanilla - as would normally be computed the same way in net.minecraft.world.level.chunk.PalettedContainer.Strategy.SECTION_STATES.getConfiguration in the default case
+                    } else {
+                        writeBits = readBits;
+                    }
+                    bitStorageWriter.setBits(writeBits);
+                    bitStorageWriter.setIndex(chunkPacketInfoAntiXray.getIndex(chunkSectionIndex));
+
+                    // Modify all layers of the current chunk section
+                    for (int xyz = 0; xyz < 4096/* = 16*16*16 */; xyz++) {
+                        int bits = bitStorageReader.read();
+                        bitStorageWriter.write(blockStateReplacements[bits]);
+                    }
+                    bitStorageWriter.flush();
+                }
+            }
+        }
+
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerModifier.java b/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..a3769298e42c968da13121aabae5dfe68c928a6c
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerModifier.java
@@ -0,0 +1,15 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.antixray;
+
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+
+public interface ChunkPacketBlockControllerModifier {
+
+    /**
+     * This method represents modifying the blocks, which can be obfuscation, but doesn't have to be
+     * (naming based on existing method in ChunkPacketBlockControllerAntiXray)
+     */
+    void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray);
+
+}
diff --git a/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerModifierBase.java b/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerModifierBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..dfdae5423158f845f23f7a5213123142fc0200ed
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/antixray/ChunkPacketBlockControllerModifierBase.java
@@ -0,0 +1,66 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.antixray;
+
+import com.destroystokyo.paper.antixray.ChunkPacketBlockController;
+import com.destroystokyo.paper.antixray.ChunkPacketInfo;
+import com.destroystokyo.paper.antixray.ChunkPacketInfoAntiXray;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.GlobalPalette;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.level.chunk.LevelChunkSection;
+import net.minecraft.world.level.chunk.Palette;
+import org.bukkit.Bukkit;
+
+import java.util.concurrent.Executor;
+
+public abstract class ChunkPacketBlockControllerModifierBase extends ChunkPacketBlockController implements ChunkPacketBlockControllerModifier { // Suki - custom blocks and items
+
+    public static final Palette<BlockState> GLOBAL_BLOCKSTATE_PALETTE = new GlobalPalette<>(Block.BLOCK_STATE_REGISTRY);
+    public static final LevelChunkSection EMPTY_SECTION = null;
+    protected final Executor executor;
+
+    public ChunkPacketBlockControllerModifierBase(Level level, Executor executor) {
+        this.executor = executor;
+    }
+
+    @Override
+    public void obfuscate(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray) {
+        this.obfuscateInternal(chunkPacketInfoAntiXray);
+        chunkPacketInfoAntiXray.getChunkPacket().setReady(true);
+    }
+
+    public abstract void obfuscateInternal(ChunkPacketInfoAntiXray chunkPacketInfoAntiXray);
+
+    @Override
+    public ChunkPacketInfoAntiXray getChunkPacketInfo(ClientboundLevelChunkWithLightPacket chunkPacket, LevelChunk chunk, boolean doesPlayerHaveResourcePack) {
+        // Return a new instance to collect data and objects in the right state while creating the chunk packet for thread safe access later
+        return new ChunkPacketInfoAntiXray(chunkPacket, chunk, this, doesPlayerHaveResourcePack);
+    }
+
+    @Override
+    public void modifyBlocks(ClientboundLevelChunkWithLightPacket chunkPacket, ChunkPacketInfo<BlockState> chunkPacketInfo) {
+        if (!(chunkPacketInfo instanceof ChunkPacketInfoAntiXray)) {
+            chunkPacket.setReady(true);
+            return;
+        }
+
+        if (!Bukkit.isPrimaryThread()) {
+            // Plugins?
+            MinecraftServer.getServer().scheduleOnMain(() -> modifyBlocks(chunkPacket, chunkPacketInfo));
+            return;
+        }
+
+        LevelChunk chunk = chunkPacketInfo.getChunk();
+        int x = chunk.getPos().x;
+        int z = chunk.getPos().z;
+        Level level = chunk.getLevel();
+        ((ChunkPacketInfoAntiXray) chunkPacketInfo).setNearbyChunks(level.getChunkIfLoaded(x - 1, z), level.getChunkIfLoaded(x + 1, z), level.getChunkIfLoaded(x, z - 1), level.getChunkIfLoaded(x, z + 1));
+        executor.execute((Runnable) chunkPacketInfo);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTagsProvider.java b/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTagsProvider.java
index df2bccc465bdc0fd16ca7c8a5353891a576633ae..b7b3a817b9457b76bfe39f6bac90a8457f4ea2d9 100644
--- a/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTagsProvider.java
+++ b/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTagsProvider.java
@@ -2,11 +2,19 @@
 
 package org.sucraft.suki.biome;
 
+import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.BiomeTags;
+import net.minecraft.tags.StructureTags;
+import net.minecraft.tags.TagKey;
 import net.minecraft.world.level.biome.Biome;
 import org.sucraft.suki.data.SuCraftTagsProvider;
 import net.minecraft.world.level.biome.Biomes;
+import org.sucraft.suki.structure.SuCraftBuiltinStructures;
+
+import java.util.List;
+import java.util.Map;
 
 /**
  * Based on {@link net.minecraft.data.tags.BiomeTagsProvider}
@@ -18,9 +26,17 @@ public class SuCraftBiomeTagsProvider extends SuCraftTagsProvider<Biome> {
     }
 
     @Override
-    protected void addTags() {
+    protected void addTags(Map<TagKey<Biome>, List<Holder<Biome>>> existingRegistryTagEntries) {
+
+        MinecraftServer.LOGGER.info("Adding onto existing biome tags...");
+        this.tag(BiomeTags.IS_FOREST).add(SuCraftBiomes.ORANGE_FOREST);
+        this.tag(BiomeTags.STRONGHOLD_BIASED_TO).add(SuCraftBiomes.ORANGE_FOREST);
+        this.tag(BiomeTags.HAS_MINESHAFT).add(SuCraftBiomes.ORANGE_FOREST);
+        this.tag(BiomeTags.HAS_RUINED_PORTAL_STANDARD).add(SuCraftBiomes.ORANGE_FOREST);
+
         MinecraftServer.LOGGER.info("Adding custom biome tags...");
         this.tag(SuCraftBiomeTags.HAS_STRONGHOLD_SURFACE).add(Biomes.PLAINS).add(Biomes.SUNFLOWER_PLAINS).add(Biomes.SNOWY_PLAINS).add(Biomes.ICE_SPIKES).add(Biomes.DESERT).add(Biomes.FOREST).add(Biomes.FLOWER_FOREST).add(Biomes.BIRCH_FOREST).add(Biomes.DARK_FOREST).add(Biomes.OLD_GROWTH_BIRCH_FOREST).add(Biomes.OLD_GROWTH_PINE_TAIGA).add(Biomes.OLD_GROWTH_SPRUCE_TAIGA).add(Biomes.TAIGA).add(Biomes.SNOWY_TAIGA).add(Biomes.SAVANNA).add(Biomes.SAVANNA_PLATEAU).add(Biomes.WINDSWEPT_HILLS).add(Biomes.WINDSWEPT_GRAVELLY_HILLS).add(Biomes.WINDSWEPT_FOREST).add(Biomes.WINDSWEPT_SAVANNA).add(Biomes.JUNGLE).add(Biomes.SPARSE_JUNGLE).add(Biomes.BAMBOO_JUNGLE).add(Biomes.BADLANDS).add(Biomes.ERODED_BADLANDS).add(Biomes.WOODED_BADLANDS).add(Biomes.MEADOW).add(Biomes.GROVE).add(Biomes.SNOWY_SLOPES).add(Biomes.FROZEN_PEAKS).add(Biomes.JAGGED_PEAKS).add(Biomes.STONY_PEAKS).add(Biomes.MUSHROOM_FIELDS); // Suki - custom strongholds - surface strongholds
+
     }
 
 }
diff --git a/src/main/java/org/sucraft/suki/biome/SuCraftBiomes.java b/src/main/java/org/sucraft/suki/biome/SuCraftBiomes.java
new file mode 100644
index 0000000000000000000000000000000000000000..6abf0987ca8fa10c5102312c0dbd495178486131
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/biome/SuCraftBiomes.java
@@ -0,0 +1,28 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.biome;
+
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.data.BuiltinRegistries;
+import net.minecraft.data.worldgen.biome.OverworldBiomes;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.biome.Biome;
+
+/**
+ * Based on {@link net.minecraft.world.level.biome.Biomes} and {@link net.minecraft.data.worldgen.biome.Biomes}
+ */
+public class SuCraftBiomes {
+
+    public static final ResourceKey<Biome> ORANGE_FOREST = register("orange_forest");
+
+    private static ResourceKey<Biome> register(String name) {
+        return ResourceKey.create(Registry.BIOME_REGISTRY, ResourceLocation.sucraft(name));
+    }
+
+    public static Holder<Biome> bootstrap(Registry<Biome> registry) {
+        return BuiltinRegistries.register(registry, ORANGE_FOREST, OverworldBiomes.forest(false, false, false, true));
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/biome/features/SuCraftBiomeDefaultFeatures.java b/src/main/java/org/sucraft/suki/biome/features/SuCraftBiomeDefaultFeatures.java
new file mode 100644
index 0000000000000000000000000000000000000000..cbc5b3e48283c37c8cec0141988ea25dfc5e090c
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/biome/features/SuCraftBiomeDefaultFeatures.java
@@ -0,0 +1,18 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.biome.features;
+
+import net.minecraft.world.level.biome.BiomeGenerationSettings;
+import net.minecraft.world.level.levelgen.GenerationStep;
+import org.sucraft.suki.biome.placements.SuCraftVegetationPlacements;
+
+/**
+ * Based on {@link net.minecraft.data.worldgen.BiomeDefaultFeatures}
+ */
+public class SuCraftBiomeDefaultFeatures {
+
+    public static void addOrangeTintedOtherBirchTrees(BiomeGenerationSettings.Builder builder) {
+        builder.addFeature(GenerationStep.Decoration.VEGETAL_DECORATION, SuCraftVegetationPlacements.TREES_ORANGE_TINTED_BIRCH_AND_OAK);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/biome/features/SuCraftFeatureUtils.java b/src/main/java/org/sucraft/suki/biome/features/SuCraftFeatureUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..b9821d2228fe6aa13ee194122412d5fb20fefadf
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/biome/features/SuCraftFeatureUtils.java
@@ -0,0 +1,27 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.biome.features;
+
+import net.minecraft.core.Holder;
+import net.minecraft.data.BuiltinRegistries;
+import net.minecraft.data.worldgen.features.FeatureUtils;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
+import net.minecraft.world.level.levelgen.feature.Feature;
+import net.minecraft.world.level.levelgen.feature.configurations.FeatureConfiguration;
+import net.minecraft.world.level.levelgen.feature.configurations.NoneFeatureConfiguration;
+
+/**
+ * Based on {@link FeatureUtils}
+ */
+public class SuCraftFeatureUtils {
+
+    public static Holder<ConfiguredFeature<NoneFeatureConfiguration, ?>> register(String id, Feature<NoneFeatureConfiguration> feature) {
+        return FeatureUtils.register(ResourceLocation.sucraft(id).toString(), feature);
+    }
+
+    public static <FC extends FeatureConfiguration, F extends Feature<FC>> Holder<ConfiguredFeature<FC, ?>> register(String id, F feature, FC config) {
+        return FeatureUtils.register(ResourceLocation.sucraft(id).toString(), feature, config);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/biome/features/SuCraftTreeFeatures.java b/src/main/java/org/sucraft/suki/biome/features/SuCraftTreeFeatures.java
new file mode 100644
index 0000000000000000000000000000000000000000..0f088681ed3df848c34593336046ff751d8f86ba
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/biome/features/SuCraftTreeFeatures.java
@@ -0,0 +1,65 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.biome.features;
+
+import net.minecraft.core.Holder;
+import net.minecraft.data.worldgen.features.TreeFeatures;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
+import net.minecraft.world.level.levelgen.feature.Feature;
+import net.minecraft.world.level.levelgen.feature.configurations.TreeConfiguration;
+import org.sucraft.suki.block.SuCraftBlocks;
+
+/**
+ * Based on {@link TreeFeatures}
+ */
+public class SuCraftTreeFeatures {
+
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> RED_OAK = SuCraftFeatureUtils.register("red_oak", Feature.TREE, TreeFeatures.OAK.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> RED_OAK_BEES_0002 = SuCraftFeatureUtils.register("red_oak_bees_0002", Feature.TREE, TreeFeatures.OAK_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> RED_OAK_BEES_002 = SuCraftFeatureUtils.register("red_oak_bees_002", Feature.TREE, TreeFeatures.OAK_BEES_002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_RED_OAK = SuCraftFeatureUtils.register("fancy_red_oak", Feature.TREE, TreeFeatures.FANCY_OAK.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_RED_OAK_BEES_0002 = SuCraftFeatureUtils.register("fancy_red_oak_bees_0002", Feature.TREE, TreeFeatures.FANCY_OAK_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_RED_OAK_BEES_002 = SuCraftFeatureUtils.register("fancy_red_oak_bees_002", Feature.TREE, TreeFeatures.FANCY_OAK_BEES_002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_RED_OAK_BEES = SuCraftFeatureUtils.register("fancy_red_oak_bees", Feature.TREE, TreeFeatures.FANCY_OAK_BEES.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_OAK_LEAVES).build());
+
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> ORANGE_OAK = SuCraftFeatureUtils.register("orange_oak", Feature.TREE, TreeFeatures.OAK.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> ORANGE_OAK_BEES_0002 = SuCraftFeatureUtils.register("orange_oak_bees_0002", Feature.TREE, TreeFeatures.OAK_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> ORANGE_OAK_BEES_002 = SuCraftFeatureUtils.register("orange_oak_bees_002", Feature.TREE, TreeFeatures.OAK_BEES_002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_ORANGE_OAK = SuCraftFeatureUtils.register("fancy_orange_oak", Feature.TREE, TreeFeatures.FANCY_OAK.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_ORANGE_OAK_BEES_0002 = SuCraftFeatureUtils.register("fancy_orange_oak_bees_0002", Feature.TREE, TreeFeatures.FANCY_OAK_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_ORANGE_OAK_BEES_002 = SuCraftFeatureUtils.register("fancy_orange_oak_bees_002", Feature.TREE, TreeFeatures.FANCY_OAK_BEES_002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_OAK_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_ORANGE_OAK_BEES = SuCraftFeatureUtils.register("fancy_orange_oak_bees", Feature.TREE, TreeFeatures.FANCY_OAK_BEES.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_OAK_LEAVES).build());
+
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> YELLOW_MAPLE = SuCraftFeatureUtils.register("yellow_maple", Feature.TREE, TreeFeatures.OAK.value().config().cloneBuilder().withLeaves(SuCraftBlocks.YELLOW_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> YELLOW_MAPLE_BEES_0002 = SuCraftFeatureUtils.register("yellow_maple_bees_0002", Feature.TREE, TreeFeatures.OAK_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.YELLOW_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> YELLOW_MAPLE_BEES_002 = SuCraftFeatureUtils.register("yellow_maple_bees_002", Feature.TREE, TreeFeatures.OAK_BEES_002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.YELLOW_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_YELLOW_MAPLE = SuCraftFeatureUtils.register("fancy_yellow_maple", Feature.TREE, TreeFeatures.FANCY_OAK.value().config().cloneBuilder().withLeaves(SuCraftBlocks.YELLOW_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_YELLOW_MAPLE_BEES_0002 = SuCraftFeatureUtils.register("fancy_yellow_maple_bees_0002", Feature.TREE, TreeFeatures.FANCY_OAK_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.YELLOW_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_YELLOW_MAPLE_BEES_002 = SuCraftFeatureUtils.register("fancy_yellow_maple_bees_002", Feature.TREE, TreeFeatures.FANCY_OAK_BEES_002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.YELLOW_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_YELLOW_MAPLE_BEES = SuCraftFeatureUtils.register("fancy_yellow_maple_bees", Feature.TREE, TreeFeatures.FANCY_OAK_BEES.value().config().cloneBuilder().withLeaves(SuCraftBlocks.YELLOW_MAPLE_LEAVES).build());
+
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> ORANGE_MAPLE = SuCraftFeatureUtils.register("orange_maple", Feature.TREE, TreeFeatures.OAK.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> ORANGE_MAPLE_BEES_0002 = SuCraftFeatureUtils.register("orange_maple_bees_0002", Feature.TREE, TreeFeatures.OAK_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> ORANGE_MAPLE_BEES_002 = SuCraftFeatureUtils.register("orange_maple_bees_002", Feature.TREE, TreeFeatures.OAK_BEES_002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_ORANGE_MAPLE = SuCraftFeatureUtils.register("fancy_orange_maple", Feature.TREE, TreeFeatures.FANCY_OAK.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_ORANGE_MAPLE_BEES_0002 = SuCraftFeatureUtils.register("fancy_orange_maple_bees_0002", Feature.TREE, TreeFeatures.FANCY_OAK_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_ORANGE_MAPLE_BEES_002 = SuCraftFeatureUtils.register("fancy_orange_maple_bees_002", Feature.TREE, TreeFeatures.FANCY_OAK_BEES_002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_ORANGE_MAPLE_BEES = SuCraftFeatureUtils.register("fancy_orange_maple_bees", Feature.TREE, TreeFeatures.FANCY_OAK_BEES.value().config().cloneBuilder().withLeaves(SuCraftBlocks.ORANGE_MAPLE_LEAVES).build());
+
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> RED_MAPLE = SuCraftFeatureUtils.register("red_maple", Feature.TREE, TreeFeatures.OAK.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> RED_MAPLE_BEES_0002 = SuCraftFeatureUtils.register("red_maple_bees_0002", Feature.TREE, TreeFeatures.OAK_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> RED_MAPLE_BEES_002 = SuCraftFeatureUtils.register("red_maple_bees_002", Feature.TREE, TreeFeatures.OAK_BEES_002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_RED_MAPLE = SuCraftFeatureUtils.register("fancy_red_maple", Feature.TREE, TreeFeatures.FANCY_OAK.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_RED_MAPLE_BEES_0002 = SuCraftFeatureUtils.register("fancy_red_maple_bees_0002", Feature.TREE, TreeFeatures.FANCY_OAK_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_RED_MAPLE_BEES_002 = SuCraftFeatureUtils.register("fancy_red_maple_bees_002", Feature.TREE, TreeFeatures.FANCY_OAK_BEES_002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_MAPLE_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> FANCY_RED_MAPLE_BEES = SuCraftFeatureUtils.register("fancy_red_maple_bees", Feature.TREE, TreeFeatures.FANCY_OAK_BEES.value().config().cloneBuilder().withLeaves(SuCraftBlocks.RED_MAPLE_LEAVES).build());
+
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> PALE_BIRCH = SuCraftFeatureUtils.register("pale_birch", Feature.TREE, TreeFeatures.BIRCH.value().config().cloneBuilder().withLeaves(SuCraftBlocks.PALE_BIRCH_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> PALE_BIRCH_BEES_0002 = SuCraftFeatureUtils.register("pale_birch_bees_0002", Feature.TREE, TreeFeatures.BIRCH_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.PALE_BIRCH_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> PALE_BIRCH_BEES_002 = SuCraftFeatureUtils.register("pale_birch_bees_002", Feature.TREE, TreeFeatures.BIRCH_BEES_002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.PALE_BIRCH_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> PALE_BIRCH_BEES_005 = SuCraftFeatureUtils.register("pale_birch_bees_005", Feature.TREE, TreeFeatures.BIRCH_BEES_005.value().config().cloneBuilder().withLeaves(SuCraftBlocks.PALE_BIRCH_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> SUPER_PALE_BIRCH_BEES_0002 = SuCraftFeatureUtils.register("super_pale_birch_bees_0002", Feature.TREE, TreeFeatures.SUPER_BIRCH_BEES_0002.value().config().cloneBuilder().withLeaves(SuCraftBlocks.PALE_BIRCH_LEAVES).build());
+    public static final Holder<ConfiguredFeature<TreeConfiguration, ?>> SUPER_PALE_BIRCH_BEES= SuCraftFeatureUtils.register("super_pale_birch_bees", Feature.TREE, TreeFeatures.SUPER_BIRCH_BEES.value().config().cloneBuilder().withLeaves(SuCraftBlocks.PALE_BIRCH_LEAVES).build());
+
+}
diff --git a/src/main/java/org/sucraft/suki/biome/features/SuCraftVegetationFeatures.java b/src/main/java/org/sucraft/suki/biome/features/SuCraftVegetationFeatures.java
new file mode 100644
index 0000000000000000000000000000000000000000..8305820dca4670f8e1a798619b120aa20d2cf2cb
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/biome/features/SuCraftVegetationFeatures.java
@@ -0,0 +1,45 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.biome.features;
+
+import net.minecraft.core.Holder;
+import net.minecraft.data.worldgen.features.FeatureUtils;
+import net.minecraft.data.worldgen.placement.TreePlacements;
+import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
+import net.minecraft.world.level.levelgen.feature.Feature;
+import net.minecraft.world.level.levelgen.feature.WeightedPlacedFeature;
+import net.minecraft.world.level.levelgen.feature.configurations.RandomFeatureConfiguration;
+import org.sucraft.suki.biome.placements.SuCraftTreePlacements;
+
+import java.util.List;
+
+/**
+ * Based on {@link net.minecraft.data.worldgen.features.VegetationFeatures}
+ */
+public class SuCraftVegetationFeatures {
+
+    public static final Holder<ConfiguredFeature<RandomFeatureConfiguration, ?>> TREES_ORANGE_TINTED_BIRCH_AND_OAK = SuCraftFeatureUtils.register(
+        "trees_orange_tinted_birch_and_oak",
+        Feature.RANDOM_SELECTOR,
+        new RandomFeatureConfiguration(
+            List.of(
+//                new WeightedPlacedFeature(TreePlacements.BIRCH_BEES_0002_PLACED, 0.15F),
+//                new WeightedPlacedFeature(SuCraftTreePlacements.PALE_BIRCH_BEES_0002, 0.2F),
+                new WeightedPlacedFeature(TreePlacements.OAK_BEES_0002, 0.15F),
+                new WeightedPlacedFeature(TreePlacements.FANCY_OAK_BEES_0002, 0.01F),
+//                new WeightedPlacedFeature(SuCraftTreePlacements.RED_OAK_BEES_0002, 0.22F),
+//                new WeightedPlacedFeature(SuCraftTreePlacements.FANCY_RED_OAK_BEES_0002, 0.025F),
+//                new WeightedPlacedFeature(SuCraftTreePlacements.ORANGE_OAK_BEES_0002, 0.22F),
+//                new WeightedPlacedFeature(SuCraftTreePlacements.FANCY_ORANGE_OAK_BEES_0002, 0.025F),
+                new WeightedPlacedFeature(SuCraftTreePlacements.YELLOW_MAPLE_BEES_0002, 0.22F),
+                new WeightedPlacedFeature(SuCraftTreePlacements.FANCY_YELLOW_MAPLE_BEES_0002, 0.025F),
+                new WeightedPlacedFeature(SuCraftTreePlacements.ORANGE_MAPLE_BEES_0002, 0.22F),
+                new WeightedPlacedFeature(SuCraftTreePlacements.FANCY_ORANGE_MAPLE_BEES_0002, 0.025F),
+                new WeightedPlacedFeature(SuCraftTreePlacements.RED_MAPLE_BEES_0002, 0.22F),
+                new WeightedPlacedFeature(SuCraftTreePlacements.FANCY_RED_MAPLE_BEES_0002, 0.025F)
+            ),
+            SuCraftTreePlacements.ORANGE_MAPLE_BEES_0002
+        )
+    );
+
+}
diff --git a/src/main/java/org/sucraft/suki/biome/placements/SuCraftPlacementUtils.java b/src/main/java/org/sucraft/suki/biome/placements/SuCraftPlacementUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ba200f75daf233e04ce5247772bfba743d6aae1
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/biome/placements/SuCraftPlacementUtils.java
@@ -0,0 +1,27 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.biome.placements;
+
+import net.minecraft.core.Holder;
+import net.minecraft.data.worldgen.placement.PlacementUtils;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
+import net.minecraft.world.level.levelgen.placement.PlacedFeature;
+import net.minecraft.world.level.levelgen.placement.PlacementModifier;
+
+import java.util.List;
+
+/**
+ * Based on {@link PlacementUtils}
+ */
+public class SuCraftPlacementUtils {
+
+    public static Holder<PlacedFeature> register(String id, Holder<? extends ConfiguredFeature<?, ?>> registryEntry, List<PlacementModifier> modifiers) {
+        return PlacementUtils.register(ResourceLocation.sucraft(id).toString(), registryEntry, modifiers);
+    }
+
+    public static Holder<PlacedFeature> register(String id, Holder<? extends ConfiguredFeature<?, ?>> registryEntry, PlacementModifier... modifiers) {
+        return PlacementUtils.register(ResourceLocation.sucraft(id).toString(), registryEntry, modifiers);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/biome/placements/SuCraftTreePlacements.java b/src/main/java/org/sucraft/suki/biome/placements/SuCraftTreePlacements.java
new file mode 100644
index 0000000000000000000000000000000000000000..c54c93de137bb6a76a31f19fe5da4faf04dac1bb
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/biome/placements/SuCraftTreePlacements.java
@@ -0,0 +1,65 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.biome.placements;
+
+import net.minecraft.core.Holder;
+import net.minecraft.data.worldgen.placement.PlacementUtils;
+import net.minecraft.data.worldgen.placement.TreePlacements;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.levelgen.placement.PlacedFeature;
+import org.sucraft.suki.biome.features.SuCraftTreeFeatures;
+
+/**
+ * Based on {@link TreePlacements}
+ */
+public class SuCraftTreePlacements {
+
+    public static final Holder<PlacedFeature> RED_OAK = SuCraftPlacementUtils.register("red_oak", SuCraftTreeFeatures.RED_OAK, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> RED_OAK_BEES_0002 = SuCraftPlacementUtils.register("red_oak_bees_0002", SuCraftTreeFeatures.RED_OAK_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> RED_OAK_BEES_002 = SuCraftPlacementUtils.register("red_oak_bees_002", SuCraftTreeFeatures.RED_OAK_BEES_002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_RED_OAK = SuCraftPlacementUtils.register("fancy_red_oak", SuCraftTreeFeatures.FANCY_RED_OAK, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_RED_OAK_BEES_0002 = SuCraftPlacementUtils.register("fancy_red_oak_bees_0002", SuCraftTreeFeatures.FANCY_RED_OAK_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_RED_OAK_BEES_002 = SuCraftPlacementUtils.register("fancy_red_oak_bees_002", SuCraftTreeFeatures.FANCY_RED_OAK_BEES_002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_RED_OAK_BEES = SuCraftPlacementUtils.register("fancy_red_oak_bees", SuCraftTreeFeatures.FANCY_RED_OAK_BEES, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+
+    public static final Holder<PlacedFeature> ORANGE_OAK = SuCraftPlacementUtils.register("orange_oak", SuCraftTreeFeatures.ORANGE_OAK, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> ORANGE_OAK_BEES_0002 = SuCraftPlacementUtils.register("orange_oak_bees_0002", SuCraftTreeFeatures.ORANGE_OAK_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> ORANGE_OAK_BEES_002 = SuCraftPlacementUtils.register("orange_oak_bees_002", SuCraftTreeFeatures.ORANGE_OAK_BEES_002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_ORANGE_OAK = SuCraftPlacementUtils.register("fancy_orange_oak", SuCraftTreeFeatures.FANCY_ORANGE_OAK, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_ORANGE_OAK_BEES_0002 = SuCraftPlacementUtils.register("fancy_orange_oak_bees_0002", SuCraftTreeFeatures.FANCY_ORANGE_OAK_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_ORANGE_OAK_BEES_002 = SuCraftPlacementUtils.register("fancy_orange_oak_bees_002", SuCraftTreeFeatures.FANCY_ORANGE_OAK_BEES_002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_ORANGE_OAK_BEES = SuCraftPlacementUtils.register("fancy_orange_oak_bees", SuCraftTreeFeatures.FANCY_ORANGE_OAK_BEES, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+
+    public static final Holder<PlacedFeature> YELLOW_MAPLE = SuCraftPlacementUtils.register("yellow_maple", SuCraftTreeFeatures.YELLOW_MAPLE, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> YELLOW_MAPLE_BEES_0002 = SuCraftPlacementUtils.register("yellow_maple_bees_0002", SuCraftTreeFeatures.YELLOW_MAPLE_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> YELLOW_MAPLE_BEES_002 = SuCraftPlacementUtils.register("yellow_maple_bees_002", SuCraftTreeFeatures.YELLOW_MAPLE_BEES_002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_YELLOW_MAPLE = SuCraftPlacementUtils.register("fancy_yellow_maple", SuCraftTreeFeatures.FANCY_YELLOW_MAPLE, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_YELLOW_MAPLE_BEES_0002 = SuCraftPlacementUtils.register("fancy_yellow_maple_bees_0002", SuCraftTreeFeatures.FANCY_YELLOW_MAPLE_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_YELLOW_MAPLE_BEES_002 = SuCraftPlacementUtils.register("fancy_yellow_maple_bees_002", SuCraftTreeFeatures.FANCY_YELLOW_MAPLE_BEES_002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_YELLOW_MAPLE_BEES = SuCraftPlacementUtils.register("fancy_yellow_maple_bees", SuCraftTreeFeatures.FANCY_YELLOW_MAPLE_BEES, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+
+    public static final Holder<PlacedFeature> ORANGE_MAPLE = SuCraftPlacementUtils.register("orange_maple", SuCraftTreeFeatures.ORANGE_MAPLE, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> ORANGE_MAPLE_BEES_0002 = SuCraftPlacementUtils.register("orange_maple_bees_0002", SuCraftTreeFeatures.ORANGE_MAPLE_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> ORANGE_MAPLE_BEES_002 = SuCraftPlacementUtils.register("orange_maple_bees_002", SuCraftTreeFeatures.ORANGE_MAPLE_BEES_002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_ORANGE_MAPLE = SuCraftPlacementUtils.register("fancy_orange_maple", SuCraftTreeFeatures.FANCY_ORANGE_MAPLE, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_ORANGE_MAPLE_BEES_0002 = SuCraftPlacementUtils.register("fancy_orange_maple_bees_0002", SuCraftTreeFeatures.FANCY_ORANGE_MAPLE_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_ORANGE_MAPLE_BEES_002 = SuCraftPlacementUtils.register("fancy_orange_maple_bees_002", SuCraftTreeFeatures.FANCY_ORANGE_MAPLE_BEES_002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_ORANGE_MAPLE_BEES = SuCraftPlacementUtils.register("fancy_orange_maple_bees", SuCraftTreeFeatures.FANCY_ORANGE_MAPLE_BEES, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+
+    public static final Holder<PlacedFeature> RED_MAPLE = SuCraftPlacementUtils.register("red_maple", SuCraftTreeFeatures.RED_MAPLE, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> RED_MAPLE_BEES_0002 = SuCraftPlacementUtils.register("red_maple_bees_0002", SuCraftTreeFeatures.RED_MAPLE_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> RED_MAPLE_BEES_002 = SuCraftPlacementUtils.register("red_maple_bees_002", SuCraftTreeFeatures.RED_MAPLE_BEES_002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_RED_MAPLE = SuCraftPlacementUtils.register("fancy_red_maple", SuCraftTreeFeatures.FANCY_RED_MAPLE, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_RED_MAPLE_BEES_0002 = SuCraftPlacementUtils.register("fancy_red_maple_bees_0002", SuCraftTreeFeatures.FANCY_RED_MAPLE_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_RED_MAPLE_BEES_002 = SuCraftPlacementUtils.register("fancy_red_maple_bees_002", SuCraftTreeFeatures.FANCY_RED_MAPLE_BEES_002, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+    public static final Holder<PlacedFeature> FANCY_RED_MAPLE_BEES = SuCraftPlacementUtils.register("fancy_red_maple_bees", SuCraftTreeFeatures.FANCY_RED_MAPLE_BEES, PlacementUtils.filteredByBlockSurvival(Blocks.OAK_SAPLING));
+
+    public static final Holder<PlacedFeature> PALE_BIRCH = SuCraftPlacementUtils.register("pale_birch", SuCraftTreeFeatures.PALE_BIRCH, PlacementUtils.filteredByBlockSurvival(Blocks.BIRCH_SAPLING));
+    public static final Holder<PlacedFeature> PALE_BIRCH_BEES_0002 = SuCraftPlacementUtils.register("pale_birch_bees_0002", SuCraftTreeFeatures.PALE_BIRCH_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.BIRCH_SAPLING));
+    public static final Holder<PlacedFeature> PALE_BIRCH_BEES_002 = SuCraftPlacementUtils.register("pale_birch_bees_002", SuCraftTreeFeatures.PALE_BIRCH_BEES_002, PlacementUtils.filteredByBlockSurvival(Blocks.BIRCH_SAPLING));
+    public static final Holder<PlacedFeature> PALE_BIRCH_BEES_005 = SuCraftPlacementUtils.register("pale_birch_bees_005", SuCraftTreeFeatures.PALE_BIRCH_BEES_005, PlacementUtils.filteredByBlockSurvival(Blocks.BIRCH_SAPLING));
+    public static final Holder<PlacedFeature> SUPER_PALE_BIRCH_BEES_0002 = SuCraftPlacementUtils.register("super_pale_birch_bees_0002", SuCraftTreeFeatures.SUPER_PALE_BIRCH_BEES_0002, PlacementUtils.filteredByBlockSurvival(Blocks.BIRCH_SAPLING));
+    public static final Holder<PlacedFeature> SUPER_PALE_BIRCH_BEES = SuCraftPlacementUtils.register("super_pale_birch_bees", SuCraftTreeFeatures.SUPER_PALE_BIRCH_BEES, PlacementUtils.filteredByBlockSurvival(Blocks.BIRCH_SAPLING));
+
+
+}
diff --git a/src/main/java/org/sucraft/suki/biome/placements/SuCraftVegetationPlacements.java b/src/main/java/org/sucraft/suki/biome/placements/SuCraftVegetationPlacements.java
new file mode 100644
index 0000000000000000000000000000000000000000..eff581056dfe2110d8ae4cbf68e7737f6cfbfc9a
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/biome/placements/SuCraftVegetationPlacements.java
@@ -0,0 +1,19 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.biome.placements;
+
+import net.minecraft.core.Holder;
+import net.minecraft.data.worldgen.features.VegetationFeatures;
+import net.minecraft.data.worldgen.placement.PlacementUtils;
+import net.minecraft.data.worldgen.placement.VegetationPlacements;
+import net.minecraft.world.level.levelgen.placement.PlacedFeature;
+import org.sucraft.suki.biome.features.SuCraftVegetationFeatures;
+
+/**
+ * Based on {@link net.minecraft.data.worldgen.placement.VegetationPlacements}
+ */
+public class SuCraftVegetationPlacements {
+
+    public static final Holder<PlacedFeature> TREES_ORANGE_TINTED_BIRCH_AND_OAK = SuCraftPlacementUtils.register("trees_orange_tinted_birch_and_oak", SuCraftVegetationFeatures.TREES_ORANGE_TINTED_BIRCH_AND_OAK, VegetationPlacements.treePlacement(PlacementUtils.countExtra(11, 0.125F, 3)));
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/ConcreteDirectionalBlock.java b/src/main/java/org/sucraft/suki/block/ConcreteDirectionalBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..e86c89ef29266f8578422678fbd30180439ac201
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/ConcreteDirectionalBlock.java
@@ -0,0 +1,36 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block;
+
+import net.minecraft.core.Direction;
+import net.minecraft.world.item.context.BlockPlaceContext;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.DirectionalBlock;
+import net.minecraft.world.level.block.Rotation;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.StateDefinition;
+
+public class ConcreteDirectionalBlock extends DirectionalBlock {
+
+    public ConcreteDirectionalBlock(BlockBehaviour.Properties settings) {
+        super(settings);
+        this.registerDefaultState(this.defaultBlockState().setValue(FACING, Direction.SOUTH));
+    }
+
+    @Override
+    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
+        builder.add(FACING);
+    }
+
+    @Override
+    public BlockState rotate(BlockState state, Rotation rotation) {
+        return state.setValue(FACING, rotation.rotate(state.getValue(FACING)));
+    }
+
+    @Override
+    public BlockState getStateForPlacement(BlockPlaceContext ctx) {
+        return this.defaultBlockState().setValue(FACING, ctx.getNearestLookingDirection().getOpposite().getOpposite());
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/FallingSlabBlock.java b/src/main/java/org/sucraft/suki/block/FallingSlabBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..d34315009b02eb4b6b6365a055b6635ff5eeb72a
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/FallingSlabBlock.java
@@ -0,0 +1,76 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.particles.BlockParticleOption;
+import net.minecraft.core.particles.ParticleTypes;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.entity.item.FallingBlockEntity;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelAccessor;
+import net.minecraft.world.level.block.Fallable;
+import net.minecraft.world.level.block.SlabBlock;
+import net.minecraft.world.level.block.StairBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.level.material.Material;
+
+/**
+ * Based on {@link net.minecraft.world.level.block.FallingBlock}
+ */
+public class FallingSlabBlock extends SlabBlock implements Fallable {
+
+    public FallingSlabBlock(Properties settings) {
+        super(settings);
+    }
+
+    @Override
+    public void onPlace(BlockState state, Level world, BlockPos pos, BlockState oldState, boolean notify) {
+        world.scheduleTick(pos, this, this.getDelayAfterPlace());
+    }
+
+    @Override
+    public BlockState updateShape(BlockState state, Direction direction, BlockState neighborState, LevelAccessor world, BlockPos pos, BlockPos neighborPos) {
+        world.scheduleTick(pos, this, this.getDelayAfterPlace());
+        return super.updateShape(state, direction, neighborState, world, pos, neighborPos);
+    }
+
+    @Override
+    public void tick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
+        if ((isFree(world.getBlockState(pos.below())) || state.getValue(BlockStateProperties.SLAB_TYPE) == SlabType.TOP) && pos.getY() >= world.getMinBuildHeight()) {
+            FallingBlockEntity fallingBlockEntity = FallingBlockEntity.fall(world, pos, state);
+            this.falling(fallingBlockEntity);
+        }
+    }
+
+    protected void falling(FallingBlockEntity entity) {
+    }
+
+    protected int getDelayAfterPlace() {
+        return 2;
+    }
+
+    public static boolean isFree(BlockState state) {
+        Material material = state.getMaterial();
+        return state.isAir() || state.is(BlockTags.FIRE) || material.isLiquid() || material.isReplaceable();
+    }
+
+    @Override
+    public void animateTick(BlockState state, Level world, BlockPos pos, RandomSource random) {
+        if (random.nextInt(16) == 0) {
+            BlockPos blockPos = pos.below();
+            if (isFree(world.getBlockState(blockPos))) {
+                double d = (double)pos.getX() + random.nextDouble();
+                double e = (double)pos.getY() - 0.05D;
+                double f = (double)pos.getZ() + random.nextDouble();
+                world.addParticle(new BlockParticleOption(ParticleTypes.FALLING_DUST, state), d, e, f, 0.0D, 0.0D, 0.0D);
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/FallingStairBlock.java b/src/main/java/org/sucraft/suki/block/FallingStairBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..fa11b95960799e68e87b3f9fef1f1c1b6fe84ab8
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/FallingStairBlock.java
@@ -0,0 +1,73 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.core.particles.BlockParticleOption;
+import net.minecraft.core.particles.ParticleTypes;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.entity.item.FallingBlockEntity;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelAccessor;
+import net.minecraft.world.level.block.Fallable;
+import net.minecraft.world.level.block.StairBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.material.Material;
+
+/**
+ * Based on {@link net.minecraft.world.level.block.FallingBlock}
+ */
+public class FallingStairBlock extends StairBlock implements Fallable {
+
+    public FallingStairBlock(BlockState baseBlockState, Properties settings) {
+        super(baseBlockState, settings);
+    }
+
+    @Override
+    public void onPlace(BlockState state, Level world, BlockPos pos, BlockState oldState, boolean notify) {
+        world.scheduleTick(pos, this, this.getDelayAfterPlace());
+    }
+
+    @Override
+    public BlockState updateShape(BlockState state, Direction direction, BlockState neighborState, LevelAccessor world, BlockPos pos, BlockPos neighborPos) {
+        world.scheduleTick(pos, this, this.getDelayAfterPlace());
+        return super.updateShape(state, direction, neighborState, world, pos, neighborPos);
+    }
+
+    @Override
+    public void tick(BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
+        if (isFree(world.getBlockState(pos.below())) && pos.getY() >= world.getMinBuildHeight()) {
+            FallingBlockEntity fallingBlockEntity = FallingBlockEntity.fall(world, pos, state);
+            this.falling(fallingBlockEntity);
+        }
+    }
+
+    protected void falling(FallingBlockEntity entity) {
+    }
+
+    protected int getDelayAfterPlace() {
+        return 2;
+    }
+
+    public static boolean isFree(BlockState state) {
+        Material material = state.getMaterial();
+        return state.isAir() || state.is(BlockTags.FIRE) || material.isLiquid() || material.isReplaceable();
+    }
+
+    @Override
+    public void animateTick(BlockState state, Level world, BlockPos pos, RandomSource random) {
+        if (random.nextInt(16) == 0) {
+            BlockPos blockPos = pos.below();
+            if (isFree(world.getBlockState(blockPos))) {
+                double d = (double)pos.getX() + random.nextDouble();
+                double e = (double)pos.getY() - 0.05D;
+                double f = (double)pos.getZ() + random.nextDouble();
+                world.addParticle(new BlockParticleOption(ParticleTypes.FALLING_DUST, state), d, e, f, 0.0D, 0.0D, 0.0D);
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/PeatBlock.java b/src/main/java/org/sucraft/suki/block/PeatBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..871ec61d3ff2bfc716b97772110ca3ae30b5b66f
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/PeatBlock.java
@@ -0,0 +1,26 @@
+package org.sucraft.suki.block;
+
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.BlockState;
+
+public class PeatBlock extends Block {
+
+    private final boolean lit;
+
+    public PeatBlock(BlockBehaviour.Properties settings, boolean lit) {
+        super(settings);
+        this.lit = lit;
+    }
+
+    public static boolean isLitPeat(BlockState state) {
+        Block block = state.getBlock();
+        return block instanceof PeatBlock peatBlock && peatBlock.lit;
+    }
+
+    public static boolean canLightPeat(BlockState state) {
+        Block block = state.getBlock();
+        return block instanceof PeatBlock peatBlock && !peatBlock.lit;
+    }
+
+}
diff --git a/src/main/java/net/minecraft/world/level/block/StrippedBlock.java b/src/main/java/org/sucraft/suki/block/StrippedBlock.java
similarity index 84%
rename from src/main/java/net/minecraft/world/level/block/StrippedBlock.java
rename to src/main/java/org/sucraft/suki/block/StrippedBlock.java
index 55022bf39ac71f03774c547e6f2498795a2c8306..12c3ecc652d0ed7f5aa77da5851b0b20220051c0 100644
--- a/src/main/java/net/minecraft/world/level/block/StrippedBlock.java
+++ b/src/main/java/org/sucraft/suki/block/StrippedBlock.java
@@ -1,6 +1,6 @@
 // Suki - bone meal regrows bark
 
-package net.minecraft.world.level.block;
+package org.sucraft.suki.block;
 
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.ServerLevel;
@@ -11,6 +11,10 @@ import net.minecraft.util.RandomSource;
 import net.minecraft.world.entity.player.Player;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.BonemealableBlock;
+import net.minecraft.world.level.block.RotatedPillarBlock;
+import net.minecraft.world.level.block.SoundType;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.gameevent.GameEvent;
@@ -23,8 +27,8 @@ public abstract class StrippedBlock extends RotatedPillarBlock implements Boneme
 
     public final @NotNull Block unstrippedBlock;
 
-    public StrippedBlock(@NotNull Block unstrippedBlock, BlockBehaviour.Properties settingsWithoutStrenthOrSound, SoundType soundType) {
-        super(settingsWithoutStrenthOrSound.strength(2.0F).sound(soundType));
+    public StrippedBlock(@NotNull Block unstrippedBlock, BlockBehaviour.Properties settingsWithoutStrengthOrSound, SoundType soundType) {
+        super(settingsWithoutStrengthOrSound.strength(2.0F).sound(soundType));
         this.unstrippedBlock = unstrippedBlock;
     }
 
@@ -59,7 +63,7 @@ public abstract class StrippedBlock extends RotatedPillarBlock implements Boneme
     @Override
     public void performBonemeal(@Nullable Player player, ServerLevel world, RandomSource random, BlockPos pos, BlockState state) {
         world.playSound(null, pos, SoundEvents.AXE_STRIP, SoundSource.BLOCKS, 1.0F, 1.0F);
-        BlockState newState = unstrippedBlock.defaultBlockState().setValue(RotatedPillarBlock.AXIS, state.getValue(RotatedPillarBlock.AXIS));
+        BlockState newState = this.unstrippedBlock.withPropertiesOf(state);
         world.setBlock(pos, newState, 3);
         world.gameEvent(GameEvent.BLOCK_CHANGE, pos, GameEvent.Context.of(player, newState));
     }
diff --git a/src/main/java/net/minecraft/world/level/block/StrippedHyphaeBlock.java b/src/main/java/org/sucraft/suki/block/StrippedHyphaeBlock.java
similarity index 78%
rename from src/main/java/net/minecraft/world/level/block/StrippedHyphaeBlock.java
rename to src/main/java/org/sucraft/suki/block/StrippedHyphaeBlock.java
index c18aca56348a11bd33597710f770f977aa8da873..2ea9f1ca2b9e71290b67415e03072ebae93b0c28 100644
--- a/src/main/java/net/minecraft/world/level/block/StrippedHyphaeBlock.java
+++ b/src/main/java/org/sucraft/suki/block/StrippedHyphaeBlock.java
@@ -1,7 +1,9 @@
 // Suki - bone meal regrows bark
 
-package net.minecraft.world.level.block;
+package org.sucraft.suki.block;
 
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.SoundType;
 import net.minecraft.world.level.material.Material;
 import net.minecraft.world.level.material.MaterialColor;
 import org.jetbrains.annotations.NotNull;
diff --git a/src/main/java/net/minecraft/world/level/block/StrippedLogBlock.java b/src/main/java/org/sucraft/suki/block/StrippedLogBlock.java
similarity index 80%
rename from src/main/java/net/minecraft/world/level/block/StrippedLogBlock.java
rename to src/main/java/org/sucraft/suki/block/StrippedLogBlock.java
index 0a1dbd9fa8086d6d7b3b231de859ffbd9f0f5653..e07f83ffb0365abee382421960d6c48300564ecf 100644
--- a/src/main/java/net/minecraft/world/level/block/StrippedLogBlock.java
+++ b/src/main/java/org/sucraft/suki/block/StrippedLogBlock.java
@@ -1,8 +1,11 @@
 // Suki - bone meal regrows bark
 
-package net.minecraft.world.level.block;
+package org.sucraft.suki.block;
 
 import net.minecraft.core.Direction;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.RotatedPillarBlock;
+import net.minecraft.world.level.block.SoundType;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.material.Material;
 import net.minecraft.world.level.material.MaterialColor;
diff --git a/src/main/java/org/sucraft/suki/block/StrippedSlabBlock.java b/src/main/java/org/sucraft/suki/block/StrippedSlabBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..b5ef7436c5ce69f5ff6a51d7abead8ef6c09b219
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/StrippedSlabBlock.java
@@ -0,0 +1,75 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.sounds.SoundSource;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.BonemealableBlock;
+import net.minecraft.world.level.block.RotatedPillarBlock;
+import net.minecraft.world.level.block.SlabBlock;
+import net.minecraft.world.level.block.SoundType;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.material.Material;
+import net.minecraft.world.level.material.MaterialColor;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class StrippedSlabBlock extends SlabBlock implements BonemealableBlock {
+
+    /**
+     * Only null while not initialized yet
+     */
+    public @Nullable Block unstrippedBlock;
+
+    public StrippedSlabBlock(Properties settings) {
+        super(settings);
+    }
+
+    public @NotNull StrippedSlabBlock withUnstrippedBlock(@NotNull Block unstrippedBlock) {
+        if (this.unstrippedBlock != null) {
+            throw new IllegalStateException("Cannot set unstripped block of a stripped slab block (" + this.id + ") while it was already set (to " + this.unstrippedBlock.id + ")");
+        }
+        this.unstrippedBlock = unstrippedBlock;
+        return this;
+    }
+
+    @Override
+    public boolean isValidBonemealTarget(BlockGetter world, BlockPos pos, BlockState state, boolean isClient) {
+        if (world instanceof Level level) {
+            return level.paperConfig().boneMealRegrowsBark.enabled;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isBonemealSuccess(Level world, RandomSource random, BlockPos pos, BlockState state) {
+        return true;
+    }
+
+    @Override
+    public void performBonemeal(ServerLevel world, RandomSource random, BlockPos pos, BlockState state) {
+        performBonemeal(null, world, random, pos, state);
+    }
+
+    @Override
+    public void performBonemeal(@Nullable Player player, ServerLevel world, RandomSource random, BlockPos pos, BlockState state) {
+        world.playSound(null, pos, SoundEvents.AXE_STRIP, SoundSource.BLOCKS, 1.0F, 1.0F);
+        BlockState newState = this.unstrippedBlock.withPropertiesOf(state);
+        world.setBlock(pos, newState, 3);
+        world.gameEvent(GameEvent.BLOCK_CHANGE, pos, GameEvent.Context.of(player, newState));
+    }
+
+    @Override
+    public boolean isBonemealUsedUp(Level world, RandomSource random, BlockPos pos, BlockState state, boolean success) {
+        return (double) world.random.nextFloat() < world.paperConfig().boneMealRegrowsBark.boneMealIsUsedUpChance;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/StrippedStairBlock.java b/src/main/java/org/sucraft/suki/block/StrippedStairBlock.java
new file mode 100644
index 0000000000000000000000000000000000000000..1adb273f18e316863849dcbd426989e6e1adfa30
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/StrippedStairBlock.java
@@ -0,0 +1,72 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.sounds.SoundSource;
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.level.BlockGetter;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.BonemealableBlock;
+import net.minecraft.world.level.block.SlabBlock;
+import net.minecraft.world.level.block.StairBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.gameevent.GameEvent;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class StrippedStairBlock extends StairBlock implements BonemealableBlock {
+
+    /**
+	 * Only null while not initialized yet
+     */
+    public @Nullable Block unstrippedBlock;
+
+    public StrippedStairBlock(BlockState baseBlockState, Properties settings) {
+        super(baseBlockState, settings);
+    }
+
+    public @NotNull StrippedStairBlock withUnstrippedBlock(@NotNull Block unstrippedBlock) {
+        if (this.unstrippedBlock != null) {
+            throw new IllegalStateException("Cannot set unstripped block of a stripped stair block (" + this.id + ") while it was already set (to " + this.unstrippedBlock.id + ")");
+        }
+        this.unstrippedBlock = unstrippedBlock;
+        return this;
+    }
+
+    @Override
+    public boolean isValidBonemealTarget(BlockGetter world, BlockPos pos, BlockState state, boolean isClient) {
+        if (world instanceof Level level) {
+            return level.paperConfig().boneMealRegrowsBark.enabled;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isBonemealSuccess(Level world, RandomSource random, BlockPos pos, BlockState state) {
+        return true;
+    }
+
+    @Override
+    public void performBonemeal(ServerLevel world, RandomSource random, BlockPos pos, BlockState state) {
+        performBonemeal(null, world, random, pos, state);
+    }
+
+    @Override
+    public void performBonemeal(@Nullable Player player, ServerLevel world, RandomSource random, BlockPos pos, BlockState state) {
+        world.playSound(null, pos, SoundEvents.AXE_STRIP, SoundSource.BLOCKS, 1.0F, 1.0F);
+        BlockState newState = this.unstrippedBlock.withPropertiesOf(state);
+        world.setBlock(pos, newState, 3);
+        world.gameEvent(GameEvent.BLOCK_CHANGE, pos, GameEvent.Context.of(player, newState));
+    }
+
+    @Override
+    public boolean isBonemealUsedUp(Level world, RandomSource random, BlockPos pos, BlockState state, boolean success) {
+        return (double) world.random.nextFloat() < world.paperConfig().boneMealRegrowsBark.boneMealIsUsedUpChance;
+    }
+
+}
diff --git a/src/main/java/net/minecraft/world/level/block/StrippedStemBlock.java b/src/main/java/org/sucraft/suki/block/StrippedStemBlock.java
similarity index 78%
rename from src/main/java/net/minecraft/world/level/block/StrippedStemBlock.java
rename to src/main/java/org/sucraft/suki/block/StrippedStemBlock.java
index 6ff782b536a1a2a6afb6ec233cb68b825be36183..43967020f7953c844945bb153de37177f660e3fb 100644
--- a/src/main/java/net/minecraft/world/level/block/StrippedStemBlock.java
+++ b/src/main/java/org/sucraft/suki/block/StrippedStemBlock.java
@@ -1,7 +1,9 @@
 // Suki - bone meal regrows bark
 
-package net.minecraft.world.level.block;
+package org.sucraft.suki.block;
 
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.SoundType;
 import net.minecraft.world.level.material.Material;
 import net.minecraft.world.level.material.MaterialColor;
 import org.jetbrains.annotations.NotNull;
diff --git a/src/main/java/net/minecraft/world/level/block/StrippedWoodBlock.java b/src/main/java/org/sucraft/suki/block/StrippedWoodBlock.java
similarity index 78%
rename from src/main/java/net/minecraft/world/level/block/StrippedWoodBlock.java
rename to src/main/java/org/sucraft/suki/block/StrippedWoodBlock.java
index 32d7035f98aa575c4b65d154c312a13047a24fb7..d4aae38dddbebddb8e8bc2b059a54cb9400b64d6 100644
--- a/src/main/java/net/minecraft/world/level/block/StrippedWoodBlock.java
+++ b/src/main/java/org/sucraft/suki/block/StrippedWoodBlock.java
@@ -1,7 +1,9 @@
 // Suki - bone meal regrows bark
 
-package net.minecraft.world.level.block;
+package org.sucraft.suki.block;
 
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.SoundType;
 import net.minecraft.world.level.material.Material;
 import net.minecraft.world.level.material.MaterialColor;
 import org.jetbrains.annotations.NotNull;
diff --git a/src/main/java/org/sucraft/suki/block/SuCraftBlockLoot.java b/src/main/java/org/sucraft/suki/block/SuCraftBlockLoot.java
new file mode 100644
index 0000000000000000000000000000000000000000..85bf00234c4ddb1dcdf7a8ff0a4b4021a846eae0
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/SuCraftBlockLoot.java
@@ -0,0 +1,49 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block;
+
+import net.minecraft.data.loot.BlockLoot;
+import net.minecraft.world.level.ItemLike;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.storage.loot.LootTable;
+import net.minecraft.world.level.storage.loot.providers.number.NumberProvider;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Partially based on {@link net.minecraft.data.loot.BlockLoot}
+ */
+public final class SuCraftBlockLoot {
+
+    private SuCraftBlockLoot() {}
+
+    private static final @NotNull BlockLoot blockLoot = new BlockLoot();
+
+    public static @NotNull LootTable dropSelf(@NotNull Block block) {
+        return dropSingleItem(block);
+    }
+
+    public static @NotNull LootTable dropSingleOrDoubleSlabSelf(@NotNull Block slabBlock) {
+        return blockLoot.createSlabItemTable(slabBlock).build();
+    }
+
+    public static @NotNull LootTable dropSingleItem(@NotNull ItemLike drop) {
+        return blockLoot.createSingleItemTable(drop).build();
+    }
+
+    public static @NotNull LootTable dropSingleItemWhenSilkTouch(@NotNull ItemLike drop) {
+        return blockLoot.createSilkTouchOnlyTable(drop).build();
+    }
+
+    public static @NotNull LootTable dropSingleItemAndSingleItemWhenSilkTouch(@NotNull ItemLike withoutSilkTouch, @NotNull Block withSilkTouch) {
+        return blockLoot.createSingleItemTableWithSilkTouch(withSilkTouch, withoutSilkTouch).build();
+    }
+
+    public static @NotNull LootTable dropSingleItemAndSingleItemWhenSilkTouch(@NotNull ItemLike withoutSilkTouch, @NotNull NumberProvider withoutSilkTouchAmount, @NotNull Block withSilkTouch) {
+        return blockLoot.createSingleItemTableWithSilkTouch(withSilkTouch, withoutSilkTouch, withoutSilkTouchAmount).build();
+    }
+
+    public static @NotNull LootTable dropLeaves(@NotNull Block block, @NotNull Block saplingBlock) {
+        return blockLoot.createLeavesDrops(block, saplingBlock, blockLoot.NORMAL_LEAVES_SAPLING_CHANCES).build();
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/SuCraftBlockTags.java b/src/main/java/org/sucraft/suki/block/SuCraftBlockTags.java
new file mode 100644
index 0000000000000000000000000000000000000000..a32c032a361fd737e737170e4e02c69ebcc41415
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/SuCraftBlockTags.java
@@ -0,0 +1,58 @@
+// Suki - custom resources
+
+package org.sucraft.suki.block;
+
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.block.Block;
+
+/**
+ * Based on {@link net.minecraft.tags.BlockTags}
+ */
+public class SuCraftBlockTags {
+
+    // Suki start - custom blocks and items
+    public static final TagKey<Block> BOOKSHELVES = create("bookshelves");
+    public static final TagKey<Block> BOOKSHELF_FULL_BLOCKS = create("bookshelf_full_blocks");
+    public static final TagKey<Block> BOOKSHELF_SLABS = create("bookshelf_slabs");
+    public static final TagKey<Block> BOOKSHELF_STAIRS = create("bookshelf_stairs");
+    public static final TagKey<Block> WOOL_FULL_BLOCKS = create("wool_full_blocks");
+    public static final TagKey<Block> WOOL_SLABS = create("wool_slabs");
+    public static final TagKey<Block> WOOL_STAIRS = create("wool_stairs");
+    public static final TagKey<Block> LOG_FULL_BLOCKS = create("log_full_blocks");
+    public static final TagKey<Block> LOG_SLABS = create("log_slabs");
+    public static final TagKey<Block> LOG_STAIRS = create("log_stairs");
+    public static final TagKey<Block> PLANK_FULL_BLOCKS = create("plank_full_blocks");
+    public static final TagKey<Block> PLANK_SLABS = create("plank_slabs");
+    public static final TagKey<Block> PLANK_STAIRS = create("plank_stairs");
+    public static final TagKey<Block> DYED_PLANKS = create("dyed_planks");
+    public static final TagKey<Block> DYED_PLANK_FULL_BLOCKS = create("dyed_plank_full_blocks");
+    public static final TagKey<Block> DYED_PLANK_SLABS = create("dyed_plank_slabs");
+    public static final TagKey<Block> DYED_PLANK_STAIRS = create("dyed_plank_stairs");
+    public static final TagKey<Block> COLORED_FIRE = create("colored_fire");
+    public static final TagKey<Block> PEAT = create("peat");
+    public static final TagKey<Block> PEAT_FULL_BLOCKS = create("peat_full_blocks");
+    public static final TagKey<Block> PEAT_SLABS = create("peat_slabs");
+    public static final TagKey<Block> PEAT_STAIRS = create("peat_stairs");
+    public static final TagKey<Block> VANILLA_STONE_BRICKS = create("vanilla_stone_bricks");
+    public static final TagKey<Block> VANILLA_PLANKS = create("vanilla_planks");
+    public static final TagKey<Block> STONE_BRICK_FULL_BLOCKS = create("stone_brick_full_blocks");
+    public static final TagKey<Block> STONE_BRICK_SLABS = create("stone_brick_slabs");
+    public static final TagKey<Block> STONE_BRICK_STAIRS = create("stone_brick_stairs");
+    public static final TagKey<Block> VANILLA_WOODEN_SLABS = create("vanilla_wooden_slabs");
+    public static final TagKey<Block> VANILLA_WOODEN_STAIRS = create("vanilla_wooden_stairs");
+    public static final TagKey<Block> VANILLA_LEAVES = create("vanilla_leaves");
+    public static final TagKey<Block> VANILLA_DIRT = create("vanilla_dirt");
+    public static final TagKey<Block> TERRACOTTA_FULL_BLOCKS = create("terracotta_full_blocks");
+    public static final TagKey<Block> TERRACOTTA_SLABS = create("terracotta_slabs");
+    public static final TagKey<Block> TERRACOTTA_STAIRS = create("terracotta_stairs");
+    // Suki end - custom blocks and items
+
+    private static TagKey<Block> create(String id) {
+        return TagKey.create(Registry.BLOCK_REGISTRY, ResourceLocation.sucraft(id));
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/SuCraftBlockTagsProvider.java b/src/main/java/org/sucraft/suki/block/SuCraftBlockTagsProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..ea7465a8fc5ee4ff5d872fb7c0f96ffc18c0c381
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/SuCraftBlockTagsProvider.java
@@ -0,0 +1,261 @@
+// Suki - custom resources
+
+package org.sucraft.suki.block;
+
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.SlabBlock;
+import net.minecraft.world.level.block.StairBlock;
+import org.sucraft.suki.data.SuCraftTagsProvider;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+import java.util.Map;
+import java.util.function.Supplier;
+
+/**
+ * Based on {@link net.minecraft.data.tags.BlockTagsProvider}
+ */
+public class SuCraftBlockTagsProvider extends SuCraftTagsProvider<Block> {
+
+    public SuCraftBlockTagsProvider(Registry<Block> registry) {
+        super(registry);
+    }
+
+    @Override
+    protected void addTags(Map<TagKey<Block>, List<Holder<Block>>> existingRegistryTagEntries) {
+        MinecraftServer.LOGGER.info("Adding onto existing block tags...");
+
+        // Suki start - custom blocks and items
+
+        this.tag(BlockTags.STONE_BRICKS).add(Blocks.STONE_BRICK_SLAB, Blocks.MOSSY_STONE_BRICK_SLAB, Blocks.STONE_BRICK_STAIRS, Blocks.MOSSY_STONE_BRICK_STAIRS);
+
+        this.tag(SuCraftBlockTags.BOOKSHELVES).add(Blocks.BOOKSHELF);
+        this.tag(SuCraftBlockTags.BOOKSHELF_FULL_BLOCKS).add(Blocks.BOOKSHELF);
+        this.tag(SuCraftBlockTags.LOG_FULL_BLOCKS).addTag(BlockTags.LOGS_THAT_BURN).addTag(BlockTags.CRIMSON_STEMS).addTag(BlockTags.WARPED_STEMS);
+        this.tag(SuCraftBlockTags.WOOL_FULL_BLOCKS).add(Blocks.RED_WOOL, Blocks.ORANGE_WOOL, Blocks.YELLOW_WOOL, Blocks.LIME_WOOL, Blocks.GREEN_WOOL, Blocks.CYAN_WOOL, Blocks.LIGHT_BLUE_WOOL, Blocks.BLUE_WOOL, Blocks.BLACK_WOOL, Blocks.GRAY_WOOL, Blocks.LIGHT_GRAY_WOOL, Blocks.WHITE_WOOL, Blocks.BROWN_WOOL, Blocks.PURPLE_WOOL, Blocks.MAGENTA_WOOL, Blocks.PINK_WOOL);
+        this.tag(SuCraftBlockTags.PLANK_FULL_BLOCKS).add(Blocks.OAK_PLANKS, Blocks.SPRUCE_PLANKS, Blocks.BIRCH_PLANKS, Blocks.JUNGLE_PLANKS, Blocks.ACACIA_PLANKS, Blocks.DARK_OAK_PLANKS, Blocks.WARPED_PLANKS, Blocks.CRIMSON_PLANKS, Blocks.MANGROVE_PLANKS);
+        this.tag(SuCraftBlockTags.PLANK_SLABS).addTag(BlockTags.WOODEN_SLABS);
+        this.tag(SuCraftBlockTags.PLANK_STAIRS).addTag(BlockTags.WOODEN_STAIRS);
+        this.tag(SuCraftBlockTags.VANILLA_STONE_BRICKS).add(Blocks.STONE_BRICKS, Blocks.MOSSY_STONE_BRICKS, Blocks.CRACKED_STONE_BRICKS, Blocks.CHISELED_STONE_BRICKS);
+        this.tag(SuCraftBlockTags.VANILLA_PLANKS).add(Blocks.OAK_PLANKS, Blocks.SPRUCE_PLANKS, Blocks.BIRCH_PLANKS, Blocks.JUNGLE_PLANKS, Blocks.ACACIA_PLANKS, Blocks.DARK_OAK_PLANKS, Blocks.CRIMSON_PLANKS, Blocks.WARPED_PLANKS, Blocks.MANGROVE_PLANKS);
+        this.tag(SuCraftBlockTags.STONE_BRICK_FULL_BLOCKS).add(Blocks.STONE_BRICKS, Blocks.MOSSY_STONE_BRICKS, Blocks.CRACKED_STONE_BRICKS, Blocks.CHISELED_STONE_BRICKS);
+        this.tag(SuCraftBlockTags.STONE_BRICK_SLABS).add(Blocks.STONE_BRICK_SLAB, Blocks.MOSSY_STONE_BRICK_SLAB);
+        this.tag(SuCraftBlockTags.STONE_BRICK_STAIRS).add(Blocks.STONE_BRICK_STAIRS, Blocks.MOSSY_STONE_BRICK_STAIRS);
+        this.tag(SuCraftBlockTags.VANILLA_WOODEN_SLABS).add(Blocks.OAK_SLAB, Blocks.SPRUCE_SLAB, Blocks.BIRCH_SLAB, Blocks.JUNGLE_SLAB, Blocks.ACACIA_SLAB, Blocks.DARK_OAK_SLAB, Blocks.CRIMSON_SLAB, Blocks.WARPED_SLAB, Blocks.MANGROVE_SLAB);
+        this.tag(SuCraftBlockTags.VANILLA_WOODEN_STAIRS).add(Blocks.OAK_STAIRS, Blocks.SPRUCE_STAIRS, Blocks.BIRCH_STAIRS, Blocks.JUNGLE_STAIRS, Blocks.ACACIA_STAIRS, Blocks.DARK_OAK_STAIRS, Blocks.CRIMSON_STAIRS, Blocks.WARPED_STAIRS, Blocks.MANGROVE_STAIRS);
+        this.tag(SuCraftBlockTags.VANILLA_LEAVES).add(Blocks.JUNGLE_LEAVES, Blocks.OAK_LEAVES, Blocks.SPRUCE_LEAVES, Blocks.DARK_OAK_LEAVES, Blocks.ACACIA_LEAVES, Blocks.BIRCH_LEAVES, Blocks.AZALEA_LEAVES, Blocks.FLOWERING_AZALEA_LEAVES, Blocks.MANGROVE_LEAVES);
+        this.tag(SuCraftBlockTags.VANILLA_DIRT).add(Blocks.DIRT, Blocks.GRASS_BLOCK, Blocks.PODZOL, Blocks.COARSE_DIRT, Blocks.MYCELIUM, Blocks.ROOTED_DIRT, Blocks.MOSS_BLOCK, Blocks.MUD, Blocks.MUDDY_MANGROVE_ROOTS);
+        this.tag(SuCraftBlockTags.TERRACOTTA_FULL_BLOCKS).add(Blocks.TERRACOTTA, Blocks.WHITE_TERRACOTTA, Blocks.ORANGE_TERRACOTTA, Blocks.MAGENTA_TERRACOTTA, Blocks.LIGHT_BLUE_TERRACOTTA, Blocks.YELLOW_TERRACOTTA, Blocks.LIME_TERRACOTTA, Blocks.PINK_TERRACOTTA, Blocks.GRAY_TERRACOTTA, Blocks.LIGHT_GRAY_TERRACOTTA, Blocks.CYAN_TERRACOTTA, Blocks.PURPLE_TERRACOTTA, Blocks.BLUE_TERRACOTTA, Blocks.BROWN_TERRACOTTA, Blocks.GREEN_TERRACOTTA, Blocks.RED_TERRACOTTA, Blocks.BLACK_TERRACOTTA);
+
+        for (@NotNull Block block : Registry.BLOCK) {
+            block.tagsToAddSuppliers.stream().map(Supplier::get).distinct().forEach(tagToAdd -> {
+                // Some tags may not be valid to transfer, but such a check is not implemented yet
+                if (isValidTagFor(tagToAdd, block)) {
+                    this.tag(tagToAdd).add(block);
+                }
+            });
+        }
+
+        this.tag(BlockTags.INFINIBURN_OVERWORLD).addTag(SuCraftBlockTags.PEAT);
+
+        // Suki end - custom blocks and items
+
+        // The below is a literal copy from BlockTagsProvider.addTags, which adds the tags transitively (for instance adding DEAD_BUSH_MAY_PLACE_ON to all blocks with the tag DIRT) after we have added more of some of those tags
+        this.tag(BlockTags.WOOL).add(Blocks.WHITE_WOOL, Blocks.ORANGE_WOOL, Blocks.MAGENTA_WOOL, Blocks.LIGHT_BLUE_WOOL, Blocks.YELLOW_WOOL, Blocks.LIME_WOOL, Blocks.PINK_WOOL, Blocks.GRAY_WOOL, Blocks.LIGHT_GRAY_WOOL, Blocks.CYAN_WOOL, Blocks.PURPLE_WOOL, Blocks.BLUE_WOOL, Blocks.BROWN_WOOL, Blocks.GREEN_WOOL, Blocks.RED_WOOL, Blocks.BLACK_WOOL);
+        this.tag(BlockTags.PLANKS).add(Blocks.OAK_PLANKS, Blocks.SPRUCE_PLANKS, Blocks.BIRCH_PLANKS, Blocks.JUNGLE_PLANKS, Blocks.ACACIA_PLANKS, Blocks.DARK_OAK_PLANKS, Blocks.CRIMSON_PLANKS, Blocks.WARPED_PLANKS, Blocks.MANGROVE_PLANKS);
+        this.tag(BlockTags.STONE_BRICKS).add(Blocks.STONE_BRICKS, Blocks.MOSSY_STONE_BRICKS, Blocks.CRACKED_STONE_BRICKS, Blocks.CHISELED_STONE_BRICKS);
+        this.tag(BlockTags.WOODEN_BUTTONS).add(Blocks.OAK_BUTTON, Blocks.SPRUCE_BUTTON, Blocks.BIRCH_BUTTON, Blocks.JUNGLE_BUTTON, Blocks.ACACIA_BUTTON, Blocks.DARK_OAK_BUTTON, Blocks.CRIMSON_BUTTON, Blocks.WARPED_BUTTON, Blocks.MANGROVE_BUTTON);
+        this.tag(BlockTags.BUTTONS).addTag(BlockTags.WOODEN_BUTTONS).add(Blocks.STONE_BUTTON).add(Blocks.POLISHED_BLACKSTONE_BUTTON);
+        this.tag(BlockTags.WOOL_CARPETS).add(Blocks.WHITE_CARPET, Blocks.ORANGE_CARPET, Blocks.MAGENTA_CARPET, Blocks.LIGHT_BLUE_CARPET, Blocks.YELLOW_CARPET, Blocks.LIME_CARPET, Blocks.PINK_CARPET, Blocks.GRAY_CARPET, Blocks.LIGHT_GRAY_CARPET, Blocks.CYAN_CARPET, Blocks.PURPLE_CARPET, Blocks.BLUE_CARPET, Blocks.BROWN_CARPET, Blocks.GREEN_CARPET, Blocks.RED_CARPET, Blocks.BLACK_CARPET);
+        this.tag(BlockTags.WOODEN_DOORS).add(Blocks.OAK_DOOR, Blocks.SPRUCE_DOOR, Blocks.BIRCH_DOOR, Blocks.JUNGLE_DOOR, Blocks.ACACIA_DOOR, Blocks.DARK_OAK_DOOR, Blocks.CRIMSON_DOOR, Blocks.WARPED_DOOR, Blocks.MANGROVE_DOOR);
+        this.tag(BlockTags.WOODEN_STAIRS).add(Blocks.OAK_STAIRS, Blocks.SPRUCE_STAIRS, Blocks.BIRCH_STAIRS, Blocks.JUNGLE_STAIRS, Blocks.ACACIA_STAIRS, Blocks.DARK_OAK_STAIRS, Blocks.CRIMSON_STAIRS, Blocks.WARPED_STAIRS, Blocks.MANGROVE_STAIRS);
+        this.tag(BlockTags.WOODEN_SLABS).add(Blocks.OAK_SLAB, Blocks.SPRUCE_SLAB, Blocks.BIRCH_SLAB, Blocks.JUNGLE_SLAB, Blocks.ACACIA_SLAB, Blocks.DARK_OAK_SLAB, Blocks.CRIMSON_SLAB, Blocks.WARPED_SLAB, Blocks.MANGROVE_SLAB);
+        this.tag(BlockTags.WOODEN_FENCES).add(Blocks.OAK_FENCE, Blocks.ACACIA_FENCE, Blocks.DARK_OAK_FENCE, Blocks.SPRUCE_FENCE, Blocks.BIRCH_FENCE, Blocks.JUNGLE_FENCE, Blocks.CRIMSON_FENCE, Blocks.WARPED_FENCE, Blocks.MANGROVE_FENCE);
+        this.tag(BlockTags.DOORS).addTag(BlockTags.WOODEN_DOORS).add(Blocks.IRON_DOOR);
+        this.tag(BlockTags.SAPLINGS).add(Blocks.OAK_SAPLING, Blocks.SPRUCE_SAPLING, Blocks.BIRCH_SAPLING, Blocks.JUNGLE_SAPLING, Blocks.ACACIA_SAPLING, Blocks.DARK_OAK_SAPLING, Blocks.AZALEA, Blocks.FLOWERING_AZALEA, Blocks.MANGROVE_PROPAGULE);
+        this.tag(BlockTags.DARK_OAK_LOGS).add(Blocks.DARK_OAK_LOG, Blocks.DARK_OAK_WOOD, Blocks.STRIPPED_DARK_OAK_LOG, Blocks.STRIPPED_DARK_OAK_WOOD);
+        this.tag(BlockTags.OAK_LOGS).add(Blocks.OAK_LOG, Blocks.OAK_WOOD, Blocks.STRIPPED_OAK_LOG, Blocks.STRIPPED_OAK_WOOD);
+        this.tag(BlockTags.ACACIA_LOGS).add(Blocks.ACACIA_LOG, Blocks.ACACIA_WOOD, Blocks.STRIPPED_ACACIA_LOG, Blocks.STRIPPED_ACACIA_WOOD);
+        this.tag(BlockTags.BIRCH_LOGS).add(Blocks.BIRCH_LOG, Blocks.BIRCH_WOOD, Blocks.STRIPPED_BIRCH_LOG, Blocks.STRIPPED_BIRCH_WOOD);
+        this.tag(BlockTags.JUNGLE_LOGS).add(Blocks.JUNGLE_LOG, Blocks.JUNGLE_WOOD, Blocks.STRIPPED_JUNGLE_LOG, Blocks.STRIPPED_JUNGLE_WOOD);
+        this.tag(BlockTags.SPRUCE_LOGS).add(Blocks.SPRUCE_LOG, Blocks.SPRUCE_WOOD, Blocks.STRIPPED_SPRUCE_LOG, Blocks.STRIPPED_SPRUCE_WOOD);
+        this.tag(BlockTags.CRIMSON_STEMS).add(Blocks.CRIMSON_STEM, Blocks.STRIPPED_CRIMSON_STEM, Blocks.CRIMSON_HYPHAE, Blocks.STRIPPED_CRIMSON_HYPHAE);
+        this.tag(BlockTags.WARPED_STEMS).add(Blocks.WARPED_STEM, Blocks.STRIPPED_WARPED_STEM, Blocks.WARPED_HYPHAE, Blocks.STRIPPED_WARPED_HYPHAE);
+        this.tag(BlockTags.MANGROVE_LOGS).add(Blocks.MANGROVE_LOG, Blocks.MANGROVE_WOOD, Blocks.STRIPPED_MANGROVE_LOG, Blocks.STRIPPED_MANGROVE_WOOD);
+        this.tag(BlockTags.LOGS_THAT_BURN).addTag(BlockTags.DARK_OAK_LOGS).addTag(BlockTags.OAK_LOGS).addTag(BlockTags.ACACIA_LOGS).addTag(BlockTags.BIRCH_LOGS).addTag(BlockTags.JUNGLE_LOGS).addTag(BlockTags.SPRUCE_LOGS).addTag(BlockTags.MANGROVE_LOGS);
+        this.tag(BlockTags.OVERWORLD_NATURAL_LOGS).add(Blocks.ACACIA_LOG).add(Blocks.BIRCH_LOG).add(Blocks.OAK_LOG).add(Blocks.JUNGLE_LOG).add(Blocks.SPRUCE_LOG).add(Blocks.DARK_OAK_LOG).add(Blocks.MANGROVE_LOG);
+        this.tag(BlockTags.LOGS).addTag(BlockTags.LOGS_THAT_BURN).addTag(BlockTags.CRIMSON_STEMS).addTag(BlockTags.WARPED_STEMS);
+        this.tag(BlockTags.ANVIL).add(Blocks.ANVIL, Blocks.CHIPPED_ANVIL, Blocks.DAMAGED_ANVIL);
+        this.tag(BlockTags.SMALL_FLOWERS).add(Blocks.DANDELION, Blocks.POPPY, Blocks.BLUE_ORCHID, Blocks.ALLIUM, Blocks.AZURE_BLUET, Blocks.RED_TULIP, Blocks.ORANGE_TULIP, Blocks.WHITE_TULIP, Blocks.PINK_TULIP, Blocks.OXEYE_DAISY, Blocks.CORNFLOWER, Blocks.LILY_OF_THE_VALLEY, Blocks.WITHER_ROSE);
+        this.tag(BlockTags.DIRT).add(Blocks.DIRT, Blocks.GRASS_BLOCK, Blocks.PODZOL, Blocks.COARSE_DIRT, Blocks.MYCELIUM, Blocks.ROOTED_DIRT, Blocks.MOSS_BLOCK, Blocks.MUD, Blocks.MUDDY_MANGROVE_ROOTS);
+        this.tag(BlockTags.ENDERMAN_HOLDABLE).addTag(BlockTags.SMALL_FLOWERS).addTag(BlockTags.DIRT).add(Blocks.SAND, Blocks.RED_SAND, Blocks.GRAVEL, Blocks.BROWN_MUSHROOM, Blocks.RED_MUSHROOM, Blocks.TNT, Blocks.CACTUS, Blocks.CLAY, Blocks.PUMPKIN, Blocks.CARVED_PUMPKIN, Blocks.MELON, Blocks.CRIMSON_FUNGUS, Blocks.CRIMSON_NYLIUM, Blocks.CRIMSON_ROOTS, Blocks.WARPED_FUNGUS, Blocks.WARPED_NYLIUM, Blocks.WARPED_ROOTS);
+        this.tag(BlockTags.FLOWER_POTS).add(Blocks.FLOWER_POT, Blocks.POTTED_POPPY, Blocks.POTTED_BLUE_ORCHID, Blocks.POTTED_ALLIUM, Blocks.POTTED_AZURE_BLUET, Blocks.POTTED_RED_TULIP, Blocks.POTTED_ORANGE_TULIP, Blocks.POTTED_WHITE_TULIP, Blocks.POTTED_PINK_TULIP, Blocks.POTTED_OXEYE_DAISY, Blocks.POTTED_DANDELION, Blocks.POTTED_OAK_SAPLING, Blocks.POTTED_SPRUCE_SAPLING, Blocks.POTTED_BIRCH_SAPLING, Blocks.POTTED_JUNGLE_SAPLING, Blocks.POTTED_ACACIA_SAPLING, Blocks.POTTED_DARK_OAK_SAPLING, Blocks.POTTED_RED_MUSHROOM, Blocks.POTTED_BROWN_MUSHROOM, Blocks.POTTED_DEAD_BUSH, Blocks.POTTED_FERN, Blocks.POTTED_CACTUS, Blocks.POTTED_CORNFLOWER, Blocks.POTTED_LILY_OF_THE_VALLEY, Blocks.POTTED_WITHER_ROSE, Blocks.POTTED_BAMBOO, Blocks.POTTED_CRIMSON_FUNGUS, Blocks.POTTED_WARPED_FUNGUS, Blocks.POTTED_CRIMSON_ROOTS, Blocks.POTTED_WARPED_ROOTS, Blocks.POTTED_AZALEA, Blocks.POTTED_FLOWERING_AZALEA, Blocks.POTTED_MANGROVE_PROPAGULE);
+        this.tag(BlockTags.BANNERS).add(Blocks.WHITE_BANNER, Blocks.ORANGE_BANNER, Blocks.MAGENTA_BANNER, Blocks.LIGHT_BLUE_BANNER, Blocks.YELLOW_BANNER, Blocks.LIME_BANNER, Blocks.PINK_BANNER, Blocks.GRAY_BANNER, Blocks.LIGHT_GRAY_BANNER, Blocks.CYAN_BANNER, Blocks.PURPLE_BANNER, Blocks.BLUE_BANNER, Blocks.BROWN_BANNER, Blocks.GREEN_BANNER, Blocks.RED_BANNER, Blocks.BLACK_BANNER, Blocks.WHITE_WALL_BANNER, Blocks.ORANGE_WALL_BANNER, Blocks.MAGENTA_WALL_BANNER, Blocks.LIGHT_BLUE_WALL_BANNER, Blocks.YELLOW_WALL_BANNER, Blocks.LIME_WALL_BANNER, Blocks.PINK_WALL_BANNER, Blocks.GRAY_WALL_BANNER, Blocks.LIGHT_GRAY_WALL_BANNER, Blocks.CYAN_WALL_BANNER, Blocks.PURPLE_WALL_BANNER, Blocks.BLUE_WALL_BANNER, Blocks.BROWN_WALL_BANNER, Blocks.GREEN_WALL_BANNER, Blocks.RED_WALL_BANNER, Blocks.BLACK_WALL_BANNER);
+        this.tag(BlockTags.WOODEN_PRESSURE_PLATES).add(Blocks.OAK_PRESSURE_PLATE, Blocks.SPRUCE_PRESSURE_PLATE, Blocks.BIRCH_PRESSURE_PLATE, Blocks.JUNGLE_PRESSURE_PLATE, Blocks.ACACIA_PRESSURE_PLATE, Blocks.DARK_OAK_PRESSURE_PLATE, Blocks.CRIMSON_PRESSURE_PLATE, Blocks.WARPED_PRESSURE_PLATE, Blocks.MANGROVE_PRESSURE_PLATE);
+        this.tag(BlockTags.STONE_PRESSURE_PLATES).add(Blocks.STONE_PRESSURE_PLATE, Blocks.POLISHED_BLACKSTONE_PRESSURE_PLATE);
+        this.tag(BlockTags.PRESSURE_PLATES).add(Blocks.LIGHT_WEIGHTED_PRESSURE_PLATE, Blocks.HEAVY_WEIGHTED_PRESSURE_PLATE).addTag(BlockTags.WOODEN_PRESSURE_PLATES).addTag(BlockTags.STONE_PRESSURE_PLATES);
+        this.tag(BlockTags.STAIRS).addTag(BlockTags.WOODEN_STAIRS).add(Blocks.COBBLESTONE_STAIRS, Blocks.SANDSTONE_STAIRS, Blocks.NETHER_BRICK_STAIRS, Blocks.STONE_BRICK_STAIRS, Blocks.BRICK_STAIRS, Blocks.PURPUR_STAIRS, Blocks.QUARTZ_STAIRS, Blocks.RED_SANDSTONE_STAIRS, Blocks.PRISMARINE_BRICK_STAIRS, Blocks.PRISMARINE_STAIRS, Blocks.DARK_PRISMARINE_STAIRS, Blocks.POLISHED_GRANITE_STAIRS, Blocks.SMOOTH_RED_SANDSTONE_STAIRS, Blocks.MOSSY_STONE_BRICK_STAIRS, Blocks.POLISHED_DIORITE_STAIRS, Blocks.MOSSY_COBBLESTONE_STAIRS, Blocks.END_STONE_BRICK_STAIRS, Blocks.STONE_STAIRS, Blocks.SMOOTH_SANDSTONE_STAIRS, Blocks.SMOOTH_QUARTZ_STAIRS, Blocks.GRANITE_STAIRS, Blocks.ANDESITE_STAIRS, Blocks.RED_NETHER_BRICK_STAIRS, Blocks.POLISHED_ANDESITE_STAIRS, Blocks.DIORITE_STAIRS, Blocks.BLACKSTONE_STAIRS, Blocks.POLISHED_BLACKSTONE_BRICK_STAIRS, Blocks.POLISHED_BLACKSTONE_STAIRS, Blocks.COBBLED_DEEPSLATE_STAIRS, Blocks.POLISHED_DEEPSLATE_STAIRS, Blocks.DEEPSLATE_TILE_STAIRS, Blocks.DEEPSLATE_BRICK_STAIRS, Blocks.OXIDIZED_CUT_COPPER_STAIRS, Blocks.WEATHERED_CUT_COPPER_STAIRS, Blocks.EXPOSED_CUT_COPPER_STAIRS, Blocks.CUT_COPPER_STAIRS, Blocks.WAXED_WEATHERED_CUT_COPPER_STAIRS, Blocks.WAXED_EXPOSED_CUT_COPPER_STAIRS, Blocks.WAXED_CUT_COPPER_STAIRS, Blocks.WAXED_OXIDIZED_CUT_COPPER_STAIRS, Blocks.MUD_BRICK_STAIRS);
+        this.tag(BlockTags.SLABS).addTag(BlockTags.WOODEN_SLABS).add(Blocks.STONE_SLAB, Blocks.SMOOTH_STONE_SLAB, Blocks.STONE_BRICK_SLAB, Blocks.SANDSTONE_SLAB, Blocks.PURPUR_SLAB, Blocks.QUARTZ_SLAB, Blocks.RED_SANDSTONE_SLAB, Blocks.BRICK_SLAB, Blocks.COBBLESTONE_SLAB, Blocks.NETHER_BRICK_SLAB, Blocks.PETRIFIED_OAK_SLAB, Blocks.PRISMARINE_SLAB, Blocks.PRISMARINE_BRICK_SLAB, Blocks.DARK_PRISMARINE_SLAB, Blocks.POLISHED_GRANITE_SLAB, Blocks.SMOOTH_RED_SANDSTONE_SLAB, Blocks.MOSSY_STONE_BRICK_SLAB, Blocks.POLISHED_DIORITE_SLAB, Blocks.MOSSY_COBBLESTONE_SLAB, Blocks.END_STONE_BRICK_SLAB, Blocks.SMOOTH_SANDSTONE_SLAB, Blocks.SMOOTH_QUARTZ_SLAB, Blocks.GRANITE_SLAB, Blocks.ANDESITE_SLAB, Blocks.RED_NETHER_BRICK_SLAB, Blocks.POLISHED_ANDESITE_SLAB, Blocks.DIORITE_SLAB, Blocks.CUT_SANDSTONE_SLAB, Blocks.CUT_RED_SANDSTONE_SLAB, Blocks.BLACKSTONE_SLAB, Blocks.POLISHED_BLACKSTONE_BRICK_SLAB, Blocks.POLISHED_BLACKSTONE_SLAB, Blocks.COBBLED_DEEPSLATE_SLAB, Blocks.POLISHED_DEEPSLATE_SLAB, Blocks.DEEPSLATE_TILE_SLAB, Blocks.DEEPSLATE_BRICK_SLAB, Blocks.WAXED_WEATHERED_CUT_COPPER_SLAB, Blocks.WAXED_EXPOSED_CUT_COPPER_SLAB, Blocks.WAXED_CUT_COPPER_SLAB, Blocks.OXIDIZED_CUT_COPPER_SLAB, Blocks.WEATHERED_CUT_COPPER_SLAB, Blocks.EXPOSED_CUT_COPPER_SLAB, Blocks.CUT_COPPER_SLAB, Blocks.WAXED_OXIDIZED_CUT_COPPER_SLAB, Blocks.MUD_BRICK_SLAB);
+        this.tag(BlockTags.WALLS).add(Blocks.COBBLESTONE_WALL, Blocks.MOSSY_COBBLESTONE_WALL, Blocks.BRICK_WALL, Blocks.PRISMARINE_WALL, Blocks.RED_SANDSTONE_WALL, Blocks.MOSSY_STONE_BRICK_WALL, Blocks.GRANITE_WALL, Blocks.STONE_BRICK_WALL, Blocks.NETHER_BRICK_WALL, Blocks.ANDESITE_WALL, Blocks.RED_NETHER_BRICK_WALL, Blocks.SANDSTONE_WALL, Blocks.END_STONE_BRICK_WALL, Blocks.DIORITE_WALL, Blocks.BLACKSTONE_WALL, Blocks.POLISHED_BLACKSTONE_BRICK_WALL, Blocks.POLISHED_BLACKSTONE_WALL, Blocks.COBBLED_DEEPSLATE_WALL, Blocks.POLISHED_DEEPSLATE_WALL, Blocks.DEEPSLATE_TILE_WALL, Blocks.DEEPSLATE_BRICK_WALL, Blocks.MUD_BRICK_WALL);
+        this.tag(BlockTags.CORAL_PLANTS).add(Blocks.TUBE_CORAL, Blocks.BRAIN_CORAL, Blocks.BUBBLE_CORAL, Blocks.FIRE_CORAL, Blocks.HORN_CORAL);
+        this.tag(BlockTags.CORALS).addTag(BlockTags.CORAL_PLANTS).add(Blocks.TUBE_CORAL_FAN, Blocks.BRAIN_CORAL_FAN, Blocks.BUBBLE_CORAL_FAN, Blocks.FIRE_CORAL_FAN, Blocks.HORN_CORAL_FAN);
+        this.tag(BlockTags.WALL_CORALS).add(Blocks.TUBE_CORAL_WALL_FAN, Blocks.BRAIN_CORAL_WALL_FAN, Blocks.BUBBLE_CORAL_WALL_FAN, Blocks.FIRE_CORAL_WALL_FAN, Blocks.HORN_CORAL_WALL_FAN);
+        this.tag(BlockTags.SAND).add(Blocks.SAND, Blocks.RED_SAND);
+        this.tag(BlockTags.RAILS).add(Blocks.RAIL, Blocks.POWERED_RAIL, Blocks.DETECTOR_RAIL, Blocks.ACTIVATOR_RAIL);
+        this.tag(BlockTags.CORAL_BLOCKS).add(Blocks.TUBE_CORAL_BLOCK, Blocks.BRAIN_CORAL_BLOCK, Blocks.BUBBLE_CORAL_BLOCK, Blocks.FIRE_CORAL_BLOCK, Blocks.HORN_CORAL_BLOCK);
+        this.tag(BlockTags.ICE).add(Blocks.ICE, Blocks.PACKED_ICE, Blocks.BLUE_ICE, Blocks.FROSTED_ICE);
+        this.tag(BlockTags.VALID_SPAWN).add(Blocks.GRASS_BLOCK, Blocks.PODZOL);
+        this.tag(BlockTags.LEAVES).add(Blocks.JUNGLE_LEAVES, Blocks.OAK_LEAVES, Blocks.SPRUCE_LEAVES, Blocks.DARK_OAK_LEAVES, Blocks.ACACIA_LEAVES, Blocks.BIRCH_LEAVES, Blocks.AZALEA_LEAVES, Blocks.FLOWERING_AZALEA_LEAVES, Blocks.MANGROVE_LEAVES);
+        this.tag(BlockTags.IMPERMEABLE).add(Blocks.GLASS, Blocks.WHITE_STAINED_GLASS, Blocks.ORANGE_STAINED_GLASS, Blocks.MAGENTA_STAINED_GLASS, Blocks.LIGHT_BLUE_STAINED_GLASS, Blocks.YELLOW_STAINED_GLASS, Blocks.LIME_STAINED_GLASS, Blocks.PINK_STAINED_GLASS, Blocks.GRAY_STAINED_GLASS, Blocks.LIGHT_GRAY_STAINED_GLASS, Blocks.CYAN_STAINED_GLASS, Blocks.PURPLE_STAINED_GLASS, Blocks.BLUE_STAINED_GLASS, Blocks.BROWN_STAINED_GLASS, Blocks.GREEN_STAINED_GLASS, Blocks.RED_STAINED_GLASS, Blocks.BLACK_STAINED_GLASS, Blocks.TINTED_GLASS);
+        this.tag(BlockTags.WOODEN_TRAPDOORS).add(Blocks.ACACIA_TRAPDOOR, Blocks.BIRCH_TRAPDOOR, Blocks.DARK_OAK_TRAPDOOR, Blocks.JUNGLE_TRAPDOOR, Blocks.OAK_TRAPDOOR, Blocks.SPRUCE_TRAPDOOR, Blocks.CRIMSON_TRAPDOOR, Blocks.WARPED_TRAPDOOR, Blocks.MANGROVE_TRAPDOOR);
+        this.tag(BlockTags.TRAPDOORS).addTag(BlockTags.WOODEN_TRAPDOORS).add(Blocks.IRON_TRAPDOOR);
+        this.tag(BlockTags.UNDERWATER_BONEMEALS).add(Blocks.SEAGRASS).addTag(BlockTags.CORALS).addTag(BlockTags.WALL_CORALS);
+        this.tag(BlockTags.BAMBOO_PLANTABLE_ON).addTag(BlockTags.SAND).addTag(BlockTags.DIRT).add(Blocks.BAMBOO, Blocks.BAMBOO_SAPLING, Blocks.GRAVEL);
+        this.tag(BlockTags.STANDING_SIGNS).add(Blocks.OAK_SIGN, Blocks.SPRUCE_SIGN, Blocks.BIRCH_SIGN, Blocks.ACACIA_SIGN, Blocks.JUNGLE_SIGN, Blocks.DARK_OAK_SIGN, Blocks.CRIMSON_SIGN, Blocks.WARPED_SIGN, Blocks.MANGROVE_SIGN);
+        this.tag(BlockTags.WALL_SIGNS).add(Blocks.OAK_WALL_SIGN, Blocks.SPRUCE_WALL_SIGN, Blocks.BIRCH_WALL_SIGN, Blocks.ACACIA_WALL_SIGN, Blocks.JUNGLE_WALL_SIGN, Blocks.DARK_OAK_WALL_SIGN, Blocks.CRIMSON_WALL_SIGN, Blocks.WARPED_WALL_SIGN, Blocks.MANGROVE_WALL_SIGN);
+        this.tag(BlockTags.SIGNS).addTag(BlockTags.STANDING_SIGNS).addTag(BlockTags.WALL_SIGNS);
+        this.tag(BlockTags.BEDS).add(Blocks.RED_BED, Blocks.BLACK_BED, Blocks.BLUE_BED, Blocks.BROWN_BED, Blocks.CYAN_BED, Blocks.GRAY_BED, Blocks.GREEN_BED, Blocks.LIGHT_BLUE_BED, Blocks.LIGHT_GRAY_BED, Blocks.LIME_BED, Blocks.MAGENTA_BED, Blocks.ORANGE_BED, Blocks.PINK_BED, Blocks.PURPLE_BED, Blocks.WHITE_BED, Blocks.YELLOW_BED);
+        this.tag(BlockTags.FENCES).addTag(BlockTags.WOODEN_FENCES).add(Blocks.NETHER_BRICK_FENCE);
+        this.tag(BlockTags.DRAGON_IMMUNE).add(Blocks.BARRIER, Blocks.BEDROCK, Blocks.END_PORTAL, Blocks.END_PORTAL_FRAME, Blocks.END_GATEWAY, Blocks.COMMAND_BLOCK, Blocks.REPEATING_COMMAND_BLOCK, Blocks.CHAIN_COMMAND_BLOCK, Blocks.STRUCTURE_BLOCK, Blocks.JIGSAW, Blocks.MOVING_PISTON, Blocks.OBSIDIAN, Blocks.CRYING_OBSIDIAN, Blocks.END_STONE, Blocks.IRON_BARS, Blocks.RESPAWN_ANCHOR, Blocks.REINFORCED_DEEPSLATE);
+        this.tag(BlockTags.DRAGON_TRANSPARENT).add(Blocks.LIGHT).addTag(BlockTags.FIRE);
+        this.tag(BlockTags.WITHER_IMMUNE).add(Blocks.BARRIER, Blocks.BEDROCK, Blocks.END_PORTAL, Blocks.END_PORTAL_FRAME, Blocks.END_GATEWAY, Blocks.COMMAND_BLOCK, Blocks.REPEATING_COMMAND_BLOCK, Blocks.CHAIN_COMMAND_BLOCK, Blocks.STRUCTURE_BLOCK, Blocks.JIGSAW, Blocks.MOVING_PISTON, Blocks.LIGHT, Blocks.REINFORCED_DEEPSLATE);
+        this.tag(BlockTags.WITHER_SUMMON_BASE_BLOCKS).add(Blocks.SOUL_SAND, Blocks.SOUL_SOIL);
+        this.tag(BlockTags.TALL_FLOWERS).add(Blocks.SUNFLOWER, Blocks.LILAC, Blocks.PEONY, Blocks.ROSE_BUSH);
+        this.tag(BlockTags.FLOWERS).addTag(BlockTags.SMALL_FLOWERS).addTag(BlockTags.TALL_FLOWERS).add(Blocks.FLOWERING_AZALEA_LEAVES, Blocks.FLOWERING_AZALEA, Blocks.MANGROVE_PROPAGULE);
+        this.tag(BlockTags.BEEHIVES).add(Blocks.BEE_NEST, Blocks.BEEHIVE);
+        this.tag(BlockTags.CROPS).add(Blocks.BEETROOTS, Blocks.CARROTS, Blocks.POTATOES, Blocks.WHEAT, Blocks.MELON_STEM, Blocks.PUMPKIN_STEM);
+        this.tag(BlockTags.BEE_GROWABLES).addTag(BlockTags.CROPS).add(Blocks.SWEET_BERRY_BUSH).add(Blocks.CAVE_VINES).add(Blocks.CAVE_VINES_PLANT);
+        this.tag(BlockTags.SHULKER_BOXES).add(Blocks.SHULKER_BOX, Blocks.BLACK_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.LIGHT_GRAY_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.WHITE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX);
+        this.tag(BlockTags.PORTALS).add(Blocks.NETHER_PORTAL, Blocks.END_PORTAL, Blocks.END_GATEWAY);
+        this.tag(BlockTags.FIRE).add(Blocks.FIRE, Blocks.SOUL_FIRE);
+        this.tag(BlockTags.NYLIUM).add(Blocks.CRIMSON_NYLIUM, Blocks.WARPED_NYLIUM);
+        this.tag(BlockTags.WART_BLOCKS).add(Blocks.NETHER_WART_BLOCK, Blocks.WARPED_WART_BLOCK);
+        this.tag(BlockTags.BEACON_BASE_BLOCKS).add(Blocks.NETHERITE_BLOCK, Blocks.EMERALD_BLOCK, Blocks.DIAMOND_BLOCK, Blocks.GOLD_BLOCK, Blocks.IRON_BLOCK);
+        this.tag(BlockTags.SOUL_SPEED_BLOCKS).add(Blocks.SOUL_SAND, Blocks.SOUL_SOIL);
+        this.tag(BlockTags.WALL_POST_OVERRIDE).add(Blocks.TORCH, Blocks.SOUL_TORCH, Blocks.REDSTONE_TORCH, Blocks.TRIPWIRE).addTag(BlockTags.SIGNS).addTag(BlockTags.BANNERS).addTag(BlockTags.PRESSURE_PLATES);
+        this.tag(BlockTags.CLIMBABLE).add(Blocks.LADDER, Blocks.VINE, Blocks.SCAFFOLDING, Blocks.WEEPING_VINES, Blocks.WEEPING_VINES_PLANT, Blocks.TWISTING_VINES, Blocks.TWISTING_VINES_PLANT, Blocks.CAVE_VINES, Blocks.CAVE_VINES_PLANT);
+        this.tag(BlockTags.FALL_DAMAGE_RESETTING).addTag(BlockTags.CLIMBABLE).add(Blocks.SWEET_BERRY_BUSH, Blocks.COBWEB);
+        this.tag(BlockTags.PIGLIN_REPELLENTS).add(Blocks.SOUL_FIRE).add(Blocks.SOUL_TORCH).add(Blocks.SOUL_LANTERN).add(Blocks.SOUL_WALL_TORCH).add(Blocks.SOUL_CAMPFIRE);
+        this.tag(BlockTags.HOGLIN_REPELLENTS).add(Blocks.WARPED_FUNGUS).add(Blocks.POTTED_WARPED_FUNGUS).add(Blocks.NETHER_PORTAL).add(Blocks.RESPAWN_ANCHOR);
+        this.tag(BlockTags.GOLD_ORES).add(Blocks.GOLD_ORE, Blocks.NETHER_GOLD_ORE, Blocks.DEEPSLATE_GOLD_ORE);
+        this.tag(BlockTags.IRON_ORES).add(Blocks.IRON_ORE, Blocks.DEEPSLATE_IRON_ORE);
+        this.tag(BlockTags.DIAMOND_ORES).add(Blocks.DIAMOND_ORE, Blocks.DEEPSLATE_DIAMOND_ORE);
+        this.tag(BlockTags.REDSTONE_ORES).add(Blocks.REDSTONE_ORE, Blocks.DEEPSLATE_REDSTONE_ORE);
+        this.tag(BlockTags.COAL_ORES).add(Blocks.COAL_ORE, Blocks.DEEPSLATE_COAL_ORE);
+        this.tag(BlockTags.EMERALD_ORES).add(Blocks.EMERALD_ORE, Blocks.DEEPSLATE_EMERALD_ORE);
+        this.tag(BlockTags.COPPER_ORES).add(Blocks.COPPER_ORE, Blocks.DEEPSLATE_COPPER_ORE);
+        this.tag(BlockTags.LAPIS_ORES).add(Blocks.LAPIS_ORE, Blocks.DEEPSLATE_LAPIS_ORE);
+        this.tag(BlockTags.SOUL_FIRE_BASE_BLOCKS).add(Blocks.SOUL_SAND, Blocks.SOUL_SOIL);
+        this.tag(BlockTags.NON_FLAMMABLE_WOOD).add(Blocks.WARPED_STEM, Blocks.STRIPPED_WARPED_STEM, Blocks.WARPED_HYPHAE, Blocks.STRIPPED_WARPED_HYPHAE, Blocks.CRIMSON_STEM, Blocks.STRIPPED_CRIMSON_STEM, Blocks.CRIMSON_HYPHAE, Blocks.STRIPPED_CRIMSON_HYPHAE, Blocks.CRIMSON_PLANKS, Blocks.WARPED_PLANKS, Blocks.CRIMSON_SLAB, Blocks.WARPED_SLAB, Blocks.CRIMSON_PRESSURE_PLATE, Blocks.WARPED_PRESSURE_PLATE, Blocks.CRIMSON_FENCE, Blocks.WARPED_FENCE, Blocks.CRIMSON_TRAPDOOR, Blocks.WARPED_TRAPDOOR, Blocks.CRIMSON_FENCE_GATE, Blocks.WARPED_FENCE_GATE, Blocks.CRIMSON_STAIRS, Blocks.WARPED_STAIRS, Blocks.CRIMSON_BUTTON, Blocks.WARPED_BUTTON, Blocks.CRIMSON_DOOR, Blocks.WARPED_DOOR, Blocks.CRIMSON_SIGN, Blocks.WARPED_SIGN, Blocks.CRIMSON_WALL_SIGN, Blocks.WARPED_WALL_SIGN);
+        this.tag(BlockTags.STRIDER_WARM_BLOCKS).add(Blocks.LAVA);
+        this.tag(BlockTags.CAMPFIRES).add(Blocks.CAMPFIRE, Blocks.SOUL_CAMPFIRE);
+        this.tag(BlockTags.GUARDED_BY_PIGLINS).add(Blocks.GOLD_BLOCK, Blocks.BARREL, Blocks.CHEST, Blocks.ENDER_CHEST, Blocks.GILDED_BLACKSTONE, Blocks.TRAPPED_CHEST, Blocks.RAW_GOLD_BLOCK).addTag(BlockTags.SHULKER_BOXES).addTag(BlockTags.GOLD_ORES);
+        this.tag(BlockTags.PREVENT_MOB_SPAWNING_INSIDE).addTag(BlockTags.RAILS);
+        this.tag(BlockTags.FENCE_GATES).add(Blocks.ACACIA_FENCE_GATE, Blocks.BIRCH_FENCE_GATE, Blocks.DARK_OAK_FENCE_GATE, Blocks.JUNGLE_FENCE_GATE, Blocks.OAK_FENCE_GATE, Blocks.SPRUCE_FENCE_GATE, Blocks.CRIMSON_FENCE_GATE, Blocks.WARPED_FENCE_GATE, Blocks.MANGROVE_FENCE_GATE);
+        this.tag(BlockTags.UNSTABLE_BOTTOM_CENTER).addTag(BlockTags.FENCE_GATES);
+        this.tag(BlockTags.MUSHROOM_GROW_BLOCK).add(Blocks.MYCELIUM).add(Blocks.PODZOL).add(Blocks.CRIMSON_NYLIUM).add(Blocks.WARPED_NYLIUM);
+        this.tag(BlockTags.INFINIBURN_OVERWORLD).add(Blocks.NETHERRACK, Blocks.MAGMA_BLOCK);
+        this.tag(BlockTags.INFINIBURN_NETHER).addTag(BlockTags.INFINIBURN_OVERWORLD);
+        this.tag(BlockTags.INFINIBURN_END).addTag(BlockTags.INFINIBURN_OVERWORLD).add(Blocks.BEDROCK);
+        this.tag(BlockTags.STONE_ORE_REPLACEABLES).add(Blocks.STONE).add(Blocks.GRANITE).add(Blocks.DIORITE).add(Blocks.ANDESITE);
+        this.tag(BlockTags.DEEPSLATE_ORE_REPLACEABLES).add(Blocks.DEEPSLATE).add(Blocks.TUFF);
+        this.tag(BlockTags.BASE_STONE_OVERWORLD).add(Blocks.STONE).add(Blocks.GRANITE).add(Blocks.DIORITE).add(Blocks.ANDESITE).add(Blocks.TUFF).add(Blocks.DEEPSLATE);
+        this.tag(BlockTags.BASE_STONE_NETHER).add(Blocks.NETHERRACK).add(Blocks.BASALT).add(Blocks.BLACKSTONE);
+        this.tag(BlockTags.OVERWORLD_CARVER_REPLACEABLES).addTag(BlockTags.BASE_STONE_OVERWORLD).addTag(BlockTags.DIRT).addTag(BlockTags.SAND).addTag(BlockTags.TERRACOTTA).addTag(BlockTags.IRON_ORES).addTag(BlockTags.COPPER_ORES).add(Blocks.WATER, Blocks.GRAVEL, Blocks.SANDSTONE, Blocks.RED_SANDSTONE, Blocks.CALCITE, Blocks.SNOW, Blocks.PACKED_ICE, Blocks.RAW_IRON_BLOCK, Blocks.RAW_COPPER_BLOCK);
+        this.tag(BlockTags.NETHER_CARVER_REPLACEABLES).addTag(BlockTags.BASE_STONE_OVERWORLD).addTag(BlockTags.BASE_STONE_NETHER).addTag(BlockTags.DIRT).addTag(BlockTags.NYLIUM).addTag(BlockTags.WART_BLOCKS).add(Blocks.SOUL_SAND, Blocks.SOUL_SOIL);
+        this.tag(BlockTags.CANDLES).add(Blocks.CANDLE, Blocks.WHITE_CANDLE, Blocks.ORANGE_CANDLE, Blocks.MAGENTA_CANDLE, Blocks.LIGHT_BLUE_CANDLE, Blocks.YELLOW_CANDLE, Blocks.LIME_CANDLE, Blocks.PINK_CANDLE, Blocks.GRAY_CANDLE, Blocks.LIGHT_GRAY_CANDLE, Blocks.CYAN_CANDLE, Blocks.PURPLE_CANDLE, Blocks.BLUE_CANDLE, Blocks.BROWN_CANDLE, Blocks.GREEN_CANDLE, Blocks.RED_CANDLE, Blocks.BLACK_CANDLE);
+        this.tag(BlockTags.CANDLE_CAKES).add(Blocks.CANDLE_CAKE, Blocks.WHITE_CANDLE_CAKE, Blocks.ORANGE_CANDLE_CAKE, Blocks.MAGENTA_CANDLE_CAKE, Blocks.LIGHT_BLUE_CANDLE_CAKE, Blocks.YELLOW_CANDLE_CAKE, Blocks.LIME_CANDLE_CAKE, Blocks.PINK_CANDLE_CAKE, Blocks.GRAY_CANDLE_CAKE, Blocks.LIGHT_GRAY_CANDLE_CAKE, Blocks.CYAN_CANDLE_CAKE, Blocks.PURPLE_CANDLE_CAKE, Blocks.BLUE_CANDLE_CAKE, Blocks.BROWN_CANDLE_CAKE, Blocks.GREEN_CANDLE_CAKE, Blocks.RED_CANDLE_CAKE, Blocks.BLACK_CANDLE_CAKE);
+        this.tag(BlockTags.CRYSTAL_SOUND_BLOCKS).add(Blocks.AMETHYST_BLOCK, Blocks.BUDDING_AMETHYST);
+        this.tag(BlockTags.CAULDRONS).add(Blocks.CAULDRON, Blocks.WATER_CAULDRON, Blocks.LAVA_CAULDRON, Blocks.POWDER_SNOW_CAULDRON);
+        this.tag(BlockTags.INSIDE_STEP_SOUND_BLOCKS).add(Blocks.SNOW, Blocks.POWDER_SNOW, Blocks.SCULK_VEIN);
+        this.tag(BlockTags.DRIPSTONE_REPLACEABLE).addTag(BlockTags.BASE_STONE_OVERWORLD);
+        this.tag(BlockTags.CAVE_VINES).add(Blocks.CAVE_VINES_PLANT).add(Blocks.CAVE_VINES);
+        this.tag(BlockTags.MOSS_REPLACEABLE).addTag(BlockTags.BASE_STONE_OVERWORLD).addTag(BlockTags.CAVE_VINES).addTag(BlockTags.DIRT);
+        this.tag(BlockTags.LUSH_GROUND_REPLACEABLE).addTag(BlockTags.MOSS_REPLACEABLE).add(Blocks.CLAY).add(Blocks.GRAVEL).add(Blocks.SAND);
+        this.tag(BlockTags.AZALEA_ROOT_REPLACEABLE).addTag(BlockTags.BASE_STONE_OVERWORLD).addTag(BlockTags.DIRT).addTag(BlockTags.TERRACOTTA).add(Blocks.RED_SAND).add(Blocks.CLAY).add(Blocks.GRAVEL).add(Blocks.SAND).add(Blocks.SNOW_BLOCK).add(Blocks.POWDER_SNOW);
+        this.tag(BlockTags.SMALL_DRIPLEAF_PLACEABLE).add(Blocks.CLAY).add(Blocks.MOSS_BLOCK);
+        this.tag(BlockTags.BIG_DRIPLEAF_PLACEABLE).addTag(BlockTags.SMALL_DRIPLEAF_PLACEABLE).addTag(BlockTags.DIRT).add(Blocks.FARMLAND);
+        this.tag(BlockTags.OCCLUDES_VIBRATION_SIGNALS).addTag(BlockTags.WOOL);
+        this.tag(BlockTags.DAMPENS_VIBRATIONS).addTag(BlockTags.WOOL).addTag(BlockTags.WOOL_CARPETS);
+        this.tag(BlockTags.SNOW).add(Blocks.SNOW, Blocks.SNOW_BLOCK, Blocks.POWDER_SNOW);
+        this.tag(BlockTags.MINEABLE_WITH_AXE).add(Blocks.NOTE_BLOCK, Blocks.ATTACHED_MELON_STEM, Blocks.ATTACHED_PUMPKIN_STEM, Blocks.AZALEA, Blocks.BAMBOO, Blocks.BARREL, Blocks.BEE_NEST, Blocks.BEEHIVE, Blocks.BEETROOTS, Blocks.BIG_DRIPLEAF_STEM, Blocks.BIG_DRIPLEAF, Blocks.BOOKSHELF, Blocks.BROWN_MUSHROOM_BLOCK, Blocks.BROWN_MUSHROOM, Blocks.CAMPFIRE, Blocks.CARROTS, Blocks.CARTOGRAPHY_TABLE, Blocks.CARVED_PUMPKIN, Blocks.CAVE_VINES_PLANT, Blocks.CAVE_VINES, Blocks.CHEST, Blocks.CHORUS_FLOWER, Blocks.CHORUS_PLANT, Blocks.COCOA, Blocks.COMPOSTER, Blocks.CRAFTING_TABLE, Blocks.CRIMSON_FUNGUS, Blocks.DAYLIGHT_DETECTOR, Blocks.DEAD_BUSH, Blocks.FERN, Blocks.FLETCHING_TABLE, Blocks.GLOW_LICHEN, Blocks.GRASS, Blocks.HANGING_ROOTS, Blocks.JACK_O_LANTERN, Blocks.JUKEBOX, Blocks.LADDER, Blocks.LARGE_FERN, Blocks.LECTERN, Blocks.LILY_PAD, Blocks.LOOM, Blocks.MELON_STEM, Blocks.MELON, Blocks.MUSHROOM_STEM, Blocks.NETHER_WART, Blocks.POTATOES, Blocks.PUMPKIN_STEM, Blocks.PUMPKIN, Blocks.RED_MUSHROOM_BLOCK, Blocks.RED_MUSHROOM, Blocks.SCAFFOLDING, Blocks.SMALL_DRIPLEAF, Blocks.SMITHING_TABLE, Blocks.SOUL_CAMPFIRE, Blocks.SPORE_BLOSSOM, Blocks.SUGAR_CANE, Blocks.SWEET_BERRY_BUSH, Blocks.TALL_GRASS, Blocks.TRAPPED_CHEST, Blocks.TWISTING_VINES_PLANT, Blocks.TWISTING_VINES, Blocks.VINE, Blocks.WARPED_FUNGUS, Blocks.WEEPING_VINES_PLANT, Blocks.WEEPING_VINES, Blocks.WHEAT).addTag(BlockTags.BANNERS).addTag(BlockTags.FENCE_GATES).addTag(BlockTags.LOGS).addTag(BlockTags.PLANKS).addTag(BlockTags.SAPLINGS).addTag(BlockTags.SIGNS).addTag(BlockTags.WOODEN_BUTTONS).addTag(BlockTags.WOODEN_DOORS).addTag(BlockTags.WOODEN_FENCES).addTag(BlockTags.WOODEN_PRESSURE_PLATES).addTag(BlockTags.WOODEN_SLABS).addTag(BlockTags.WOODEN_STAIRS).addTag(BlockTags.WOODEN_TRAPDOORS).add(Blocks.MANGROVE_ROOTS);
+        this.tag(BlockTags.MINEABLE_WITH_HOE).add(Blocks.NETHER_WART_BLOCK, Blocks.WARPED_WART_BLOCK, Blocks.HAY_BLOCK, Blocks.DRIED_KELP_BLOCK, Blocks.TARGET, Blocks.SHROOMLIGHT, Blocks.SPONGE, Blocks.WET_SPONGE, Blocks.JUNGLE_LEAVES, Blocks.OAK_LEAVES, Blocks.SPRUCE_LEAVES, Blocks.DARK_OAK_LEAVES, Blocks.ACACIA_LEAVES, Blocks.BIRCH_LEAVES, Blocks.AZALEA_LEAVES, Blocks.FLOWERING_AZALEA_LEAVES, Blocks.MANGROVE_LEAVES, Blocks.SCULK_SENSOR, Blocks.MOSS_BLOCK, Blocks.MOSS_CARPET, Blocks.SCULK, Blocks.SCULK_CATALYST, Blocks.SCULK_VEIN, Blocks.SCULK_SHRIEKER);
+        this.tag(BlockTags.MINEABLE_WITH_PICKAXE).add(Blocks.STONE, Blocks.GRANITE, Blocks.POLISHED_GRANITE, Blocks.DIORITE, Blocks.POLISHED_DIORITE, Blocks.ANDESITE, Blocks.POLISHED_ANDESITE, Blocks.COBBLESTONE, Blocks.GOLD_ORE, Blocks.DEEPSLATE_GOLD_ORE, Blocks.IRON_ORE, Blocks.DEEPSLATE_IRON_ORE, Blocks.COAL_ORE, Blocks.DEEPSLATE_COAL_ORE, Blocks.NETHER_GOLD_ORE, Blocks.LAPIS_ORE, Blocks.DEEPSLATE_LAPIS_ORE, Blocks.LAPIS_BLOCK, Blocks.DISPENSER, Blocks.SANDSTONE, Blocks.CHISELED_SANDSTONE, Blocks.CUT_SANDSTONE, Blocks.GOLD_BLOCK, Blocks.IRON_BLOCK, Blocks.BRICKS, Blocks.MOSSY_COBBLESTONE, Blocks.OBSIDIAN, Blocks.SPAWNER, Blocks.DIAMOND_ORE, Blocks.DEEPSLATE_DIAMOND_ORE, Blocks.DIAMOND_BLOCK, Blocks.FURNACE, Blocks.COBBLESTONE_STAIRS, Blocks.STONE_PRESSURE_PLATE, Blocks.IRON_DOOR, Blocks.REDSTONE_ORE, Blocks.DEEPSLATE_REDSTONE_ORE, Blocks.NETHERRACK, Blocks.BASALT, Blocks.POLISHED_BASALT, Blocks.STONE_BRICKS, Blocks.MOSSY_STONE_BRICKS, Blocks.CRACKED_STONE_BRICKS, Blocks.CHISELED_STONE_BRICKS, Blocks.IRON_BARS, Blocks.CHAIN, Blocks.BRICK_STAIRS, Blocks.STONE_BRICK_STAIRS, Blocks.NETHER_BRICKS, Blocks.NETHER_BRICK_FENCE, Blocks.NETHER_BRICK_STAIRS, Blocks.ENCHANTING_TABLE, Blocks.BREWING_STAND, Blocks.END_STONE, Blocks.SANDSTONE_STAIRS, Blocks.EMERALD_ORE, Blocks.DEEPSLATE_EMERALD_ORE, Blocks.ENDER_CHEST, Blocks.EMERALD_BLOCK, Blocks.LIGHT_WEIGHTED_PRESSURE_PLATE, Blocks.HEAVY_WEIGHTED_PRESSURE_PLATE, Blocks.REDSTONE_BLOCK, Blocks.NETHER_QUARTZ_ORE, Blocks.HOPPER, Blocks.QUARTZ_BLOCK, Blocks.CHISELED_QUARTZ_BLOCK, Blocks.QUARTZ_PILLAR, Blocks.QUARTZ_STAIRS, Blocks.DROPPER, Blocks.WHITE_TERRACOTTA, Blocks.ORANGE_TERRACOTTA, Blocks.MAGENTA_TERRACOTTA, Blocks.LIGHT_BLUE_TERRACOTTA, Blocks.YELLOW_TERRACOTTA, Blocks.LIME_TERRACOTTA, Blocks.PINK_TERRACOTTA, Blocks.GRAY_TERRACOTTA, Blocks.LIGHT_GRAY_TERRACOTTA, Blocks.CYAN_TERRACOTTA, Blocks.PURPLE_TERRACOTTA, Blocks.BLUE_TERRACOTTA, Blocks.BROWN_TERRACOTTA, Blocks.GREEN_TERRACOTTA, Blocks.RED_TERRACOTTA, Blocks.BLACK_TERRACOTTA, Blocks.IRON_TRAPDOOR, Blocks.PRISMARINE, Blocks.PRISMARINE_BRICKS, Blocks.DARK_PRISMARINE, Blocks.PRISMARINE_STAIRS, Blocks.PRISMARINE_BRICK_STAIRS, Blocks.DARK_PRISMARINE_STAIRS, Blocks.PRISMARINE_SLAB, Blocks.PRISMARINE_BRICK_SLAB, Blocks.DARK_PRISMARINE_SLAB, Blocks.TERRACOTTA, Blocks.COAL_BLOCK, Blocks.RED_SANDSTONE, Blocks.CHISELED_RED_SANDSTONE, Blocks.CUT_RED_SANDSTONE, Blocks.RED_SANDSTONE_STAIRS, Blocks.STONE_SLAB, Blocks.SMOOTH_STONE_SLAB, Blocks.SANDSTONE_SLAB, Blocks.CUT_SANDSTONE_SLAB, Blocks.PETRIFIED_OAK_SLAB, Blocks.COBBLESTONE_SLAB, Blocks.BRICK_SLAB, Blocks.STONE_BRICK_SLAB, Blocks.NETHER_BRICK_SLAB, Blocks.QUARTZ_SLAB, Blocks.RED_SANDSTONE_SLAB, Blocks.CUT_RED_SANDSTONE_SLAB, Blocks.PURPUR_SLAB, Blocks.SMOOTH_STONE, Blocks.SMOOTH_SANDSTONE, Blocks.SMOOTH_QUARTZ, Blocks.SMOOTH_RED_SANDSTONE, Blocks.PURPUR_BLOCK, Blocks.PURPUR_PILLAR, Blocks.PURPUR_STAIRS, Blocks.END_STONE_BRICKS, Blocks.MAGMA_BLOCK, Blocks.RED_NETHER_BRICKS, Blocks.BONE_BLOCK, Blocks.OBSERVER, Blocks.WHITE_GLAZED_TERRACOTTA, Blocks.ORANGE_GLAZED_TERRACOTTA, Blocks.MAGENTA_GLAZED_TERRACOTTA, Blocks.LIGHT_BLUE_GLAZED_TERRACOTTA, Blocks.YELLOW_GLAZED_TERRACOTTA, Blocks.LIME_GLAZED_TERRACOTTA, Blocks.PINK_GLAZED_TERRACOTTA, Blocks.GRAY_GLAZED_TERRACOTTA, Blocks.LIGHT_GRAY_GLAZED_TERRACOTTA, Blocks.CYAN_GLAZED_TERRACOTTA, Blocks.PURPLE_GLAZED_TERRACOTTA, Blocks.BLUE_GLAZED_TERRACOTTA, Blocks.BROWN_GLAZED_TERRACOTTA, Blocks.GREEN_GLAZED_TERRACOTTA, Blocks.RED_GLAZED_TERRACOTTA, Blocks.BLACK_GLAZED_TERRACOTTA, Blocks.WHITE_CONCRETE, Blocks.ORANGE_CONCRETE, Blocks.MAGENTA_CONCRETE, Blocks.LIGHT_BLUE_CONCRETE, Blocks.YELLOW_CONCRETE, Blocks.LIME_CONCRETE, Blocks.PINK_CONCRETE, Blocks.GRAY_CONCRETE, Blocks.LIGHT_GRAY_CONCRETE, Blocks.CYAN_CONCRETE, Blocks.PURPLE_CONCRETE, Blocks.BLUE_CONCRETE, Blocks.BROWN_CONCRETE, Blocks.GREEN_CONCRETE, Blocks.RED_CONCRETE, Blocks.BLACK_CONCRETE, Blocks.DEAD_TUBE_CORAL_BLOCK, Blocks.DEAD_BRAIN_CORAL_BLOCK, Blocks.DEAD_BUBBLE_CORAL_BLOCK, Blocks.DEAD_FIRE_CORAL_BLOCK, Blocks.DEAD_HORN_CORAL_BLOCK, Blocks.TUBE_CORAL_BLOCK, Blocks.BRAIN_CORAL_BLOCK, Blocks.BUBBLE_CORAL_BLOCK, Blocks.FIRE_CORAL_BLOCK, Blocks.HORN_CORAL_BLOCK, Blocks.DEAD_TUBE_CORAL, Blocks.DEAD_BRAIN_CORAL, Blocks.DEAD_BUBBLE_CORAL, Blocks.DEAD_FIRE_CORAL, Blocks.DEAD_HORN_CORAL, Blocks.DEAD_TUBE_CORAL_FAN, Blocks.DEAD_BRAIN_CORAL_FAN, Blocks.DEAD_BUBBLE_CORAL_FAN, Blocks.DEAD_FIRE_CORAL_FAN, Blocks.DEAD_HORN_CORAL_FAN, Blocks.DEAD_TUBE_CORAL_WALL_FAN, Blocks.DEAD_BRAIN_CORAL_WALL_FAN, Blocks.DEAD_BUBBLE_CORAL_WALL_FAN, Blocks.DEAD_FIRE_CORAL_WALL_FAN, Blocks.DEAD_HORN_CORAL_WALL_FAN, Blocks.POLISHED_GRANITE_STAIRS, Blocks.SMOOTH_RED_SANDSTONE_STAIRS, Blocks.MOSSY_STONE_BRICK_STAIRS, Blocks.POLISHED_DIORITE_STAIRS, Blocks.MOSSY_COBBLESTONE_STAIRS, Blocks.END_STONE_BRICK_STAIRS, Blocks.STONE_STAIRS, Blocks.SMOOTH_SANDSTONE_STAIRS, Blocks.SMOOTH_QUARTZ_STAIRS, Blocks.GRANITE_STAIRS, Blocks.ANDESITE_STAIRS, Blocks.RED_NETHER_BRICK_STAIRS, Blocks.POLISHED_ANDESITE_STAIRS, Blocks.DIORITE_STAIRS, Blocks.POLISHED_GRANITE_SLAB, Blocks.SMOOTH_RED_SANDSTONE_SLAB, Blocks.MOSSY_STONE_BRICK_SLAB, Blocks.POLISHED_DIORITE_SLAB, Blocks.MOSSY_COBBLESTONE_SLAB, Blocks.END_STONE_BRICK_SLAB, Blocks.SMOOTH_SANDSTONE_SLAB, Blocks.SMOOTH_QUARTZ_SLAB, Blocks.GRANITE_SLAB, Blocks.ANDESITE_SLAB, Blocks.RED_NETHER_BRICK_SLAB, Blocks.POLISHED_ANDESITE_SLAB, Blocks.DIORITE_SLAB, Blocks.SMOKER, Blocks.BLAST_FURNACE, Blocks.GRINDSTONE, Blocks.STONECUTTER, Blocks.BELL, Blocks.LANTERN, Blocks.SOUL_LANTERN, Blocks.WARPED_NYLIUM, Blocks.CRIMSON_NYLIUM, Blocks.NETHERITE_BLOCK, Blocks.ANCIENT_DEBRIS, Blocks.CRYING_OBSIDIAN, Blocks.RESPAWN_ANCHOR, Blocks.LODESTONE, Blocks.BLACKSTONE, Blocks.BLACKSTONE_STAIRS, Blocks.BLACKSTONE_SLAB, Blocks.POLISHED_BLACKSTONE, Blocks.POLISHED_BLACKSTONE_BRICKS, Blocks.CRACKED_POLISHED_BLACKSTONE_BRICKS, Blocks.CHISELED_POLISHED_BLACKSTONE, Blocks.POLISHED_BLACKSTONE_BRICK_SLAB, Blocks.POLISHED_BLACKSTONE_BRICK_STAIRS, Blocks.GILDED_BLACKSTONE, Blocks.POLISHED_BLACKSTONE_STAIRS, Blocks.POLISHED_BLACKSTONE_SLAB, Blocks.POLISHED_BLACKSTONE_PRESSURE_PLATE, Blocks.CHISELED_NETHER_BRICKS, Blocks.CRACKED_NETHER_BRICKS, Blocks.QUARTZ_BRICKS, Blocks.TUFF, Blocks.CALCITE, Blocks.OXIDIZED_COPPER, Blocks.WEATHERED_COPPER, Blocks.EXPOSED_COPPER, Blocks.COPPER_BLOCK, Blocks.COPPER_ORE, Blocks.DEEPSLATE_COPPER_ORE, Blocks.OXIDIZED_CUT_COPPER, Blocks.WEATHERED_CUT_COPPER, Blocks.EXPOSED_CUT_COPPER, Blocks.CUT_COPPER, Blocks.OXIDIZED_CUT_COPPER_STAIRS, Blocks.WEATHERED_CUT_COPPER_STAIRS, Blocks.EXPOSED_CUT_COPPER_STAIRS, Blocks.CUT_COPPER_STAIRS, Blocks.OXIDIZED_CUT_COPPER_SLAB, Blocks.WEATHERED_CUT_COPPER_SLAB, Blocks.EXPOSED_CUT_COPPER_SLAB, Blocks.CUT_COPPER_SLAB, Blocks.WAXED_COPPER_BLOCK, Blocks.WAXED_WEATHERED_COPPER, Blocks.WAXED_EXPOSED_COPPER, Blocks.WAXED_OXIDIZED_COPPER, Blocks.WAXED_OXIDIZED_CUT_COPPER, Blocks.WAXED_WEATHERED_CUT_COPPER, Blocks.WAXED_EXPOSED_CUT_COPPER, Blocks.WAXED_CUT_COPPER, Blocks.WAXED_OXIDIZED_CUT_COPPER_STAIRS, Blocks.WAXED_WEATHERED_CUT_COPPER_STAIRS, Blocks.WAXED_EXPOSED_CUT_COPPER_STAIRS, Blocks.WAXED_CUT_COPPER_STAIRS, Blocks.WAXED_OXIDIZED_CUT_COPPER_SLAB, Blocks.WAXED_WEATHERED_CUT_COPPER_SLAB, Blocks.WAXED_EXPOSED_CUT_COPPER_SLAB, Blocks.WAXED_CUT_COPPER_SLAB, Blocks.LIGHTNING_ROD, Blocks.POINTED_DRIPSTONE, Blocks.DRIPSTONE_BLOCK, Blocks.DEEPSLATE, Blocks.COBBLED_DEEPSLATE, Blocks.COBBLED_DEEPSLATE_STAIRS, Blocks.COBBLED_DEEPSLATE_SLAB, Blocks.POLISHED_DEEPSLATE, Blocks.POLISHED_DEEPSLATE_STAIRS, Blocks.POLISHED_DEEPSLATE_SLAB, Blocks.DEEPSLATE_TILES, Blocks.DEEPSLATE_TILE_STAIRS, Blocks.DEEPSLATE_TILE_SLAB, Blocks.DEEPSLATE_BRICKS, Blocks.DEEPSLATE_BRICK_STAIRS, Blocks.DEEPSLATE_BRICK_SLAB, Blocks.CHISELED_DEEPSLATE, Blocks.CRACKED_DEEPSLATE_BRICKS, Blocks.CRACKED_DEEPSLATE_TILES, Blocks.SMOOTH_BASALT, Blocks.RAW_IRON_BLOCK, Blocks.RAW_COPPER_BLOCK, Blocks.RAW_GOLD_BLOCK, Blocks.ICE, Blocks.PACKED_ICE, Blocks.BLUE_ICE, Blocks.STONE_BUTTON, Blocks.PISTON, Blocks.STICKY_PISTON, Blocks.PISTON_HEAD, Blocks.AMETHYST_CLUSTER, Blocks.SMALL_AMETHYST_BUD, Blocks.MEDIUM_AMETHYST_BUD, Blocks.LARGE_AMETHYST_BUD, Blocks.AMETHYST_BLOCK, Blocks.BUDDING_AMETHYST, Blocks.INFESTED_COBBLESTONE, Blocks.INFESTED_CHISELED_STONE_BRICKS, Blocks.INFESTED_CRACKED_STONE_BRICKS, Blocks.INFESTED_DEEPSLATE, Blocks.INFESTED_STONE, Blocks.INFESTED_MOSSY_STONE_BRICKS, Blocks.INFESTED_STONE_BRICKS).addTag(BlockTags.WALLS).addTag(BlockTags.SHULKER_BOXES).addTag(BlockTags.ANVIL).addTag(BlockTags.CAULDRONS).addTag(BlockTags.RAILS).add(Blocks.CONDUIT).add(Blocks.MUD_BRICKS).add(Blocks.MUD_BRICK_STAIRS).add(Blocks.MUD_BRICK_SLAB).add(Blocks.PACKED_MUD);
+        this.tag(BlockTags.MINEABLE_WITH_SHOVEL).add(Blocks.CLAY, Blocks.DIRT, Blocks.COARSE_DIRT, Blocks.PODZOL, Blocks.FARMLAND, Blocks.GRASS_BLOCK, Blocks.GRAVEL, Blocks.MYCELIUM, Blocks.SAND, Blocks.RED_SAND, Blocks.SNOW_BLOCK, Blocks.SNOW, Blocks.SOUL_SAND, Blocks.DIRT_PATH, Blocks.WHITE_CONCRETE_POWDER, Blocks.ORANGE_CONCRETE_POWDER, Blocks.MAGENTA_CONCRETE_POWDER, Blocks.LIGHT_BLUE_CONCRETE_POWDER, Blocks.YELLOW_CONCRETE_POWDER, Blocks.LIME_CONCRETE_POWDER, Blocks.PINK_CONCRETE_POWDER, Blocks.GRAY_CONCRETE_POWDER, Blocks.LIGHT_GRAY_CONCRETE_POWDER, Blocks.CYAN_CONCRETE_POWDER, Blocks.PURPLE_CONCRETE_POWDER, Blocks.BLUE_CONCRETE_POWDER, Blocks.BROWN_CONCRETE_POWDER, Blocks.GREEN_CONCRETE_POWDER, Blocks.RED_CONCRETE_POWDER, Blocks.BLACK_CONCRETE_POWDER, Blocks.SOUL_SOIL, Blocks.ROOTED_DIRT, Blocks.MUDDY_MANGROVE_ROOTS, Blocks.MUD);
+        this.tag(BlockTags.NEEDS_DIAMOND_TOOL).add(Blocks.OBSIDIAN, Blocks.CRYING_OBSIDIAN, Blocks.NETHERITE_BLOCK, Blocks.RESPAWN_ANCHOR, Blocks.ANCIENT_DEBRIS);
+        this.tag(BlockTags.NEEDS_IRON_TOOL).add(Blocks.DIAMOND_BLOCK, Blocks.DIAMOND_ORE, Blocks.DEEPSLATE_DIAMOND_ORE, Blocks.EMERALD_ORE, Blocks.DEEPSLATE_EMERALD_ORE, Blocks.EMERALD_BLOCK, Blocks.GOLD_BLOCK, Blocks.RAW_GOLD_BLOCK, Blocks.GOLD_ORE, Blocks.DEEPSLATE_GOLD_ORE, Blocks.REDSTONE_ORE, Blocks.DEEPSLATE_REDSTONE_ORE);
+        this.tag(BlockTags.NEEDS_STONE_TOOL).add(Blocks.IRON_BLOCK, Blocks.RAW_IRON_BLOCK, Blocks.IRON_ORE, Blocks.DEEPSLATE_IRON_ORE, Blocks.LAPIS_BLOCK, Blocks.LAPIS_ORE, Blocks.DEEPSLATE_LAPIS_ORE, Blocks.COPPER_BLOCK, Blocks.RAW_COPPER_BLOCK, Blocks.COPPER_ORE, Blocks.DEEPSLATE_COPPER_ORE, Blocks.CUT_COPPER_SLAB, Blocks.CUT_COPPER_STAIRS, Blocks.CUT_COPPER, Blocks.WEATHERED_COPPER, Blocks.WEATHERED_CUT_COPPER_SLAB, Blocks.WEATHERED_CUT_COPPER_STAIRS, Blocks.WEATHERED_CUT_COPPER, Blocks.OXIDIZED_COPPER, Blocks.OXIDIZED_CUT_COPPER_SLAB, Blocks.OXIDIZED_CUT_COPPER_STAIRS, Blocks.OXIDIZED_CUT_COPPER, Blocks.EXPOSED_COPPER, Blocks.EXPOSED_CUT_COPPER_SLAB, Blocks.EXPOSED_CUT_COPPER_STAIRS, Blocks.EXPOSED_CUT_COPPER, Blocks.WAXED_COPPER_BLOCK, Blocks.WAXED_CUT_COPPER_SLAB, Blocks.WAXED_CUT_COPPER_STAIRS, Blocks.WAXED_CUT_COPPER, Blocks.WAXED_WEATHERED_COPPER, Blocks.WAXED_WEATHERED_CUT_COPPER_SLAB, Blocks.WAXED_WEATHERED_CUT_COPPER_STAIRS, Blocks.WAXED_WEATHERED_CUT_COPPER, Blocks.WAXED_EXPOSED_COPPER, Blocks.WAXED_EXPOSED_CUT_COPPER_SLAB, Blocks.WAXED_EXPOSED_CUT_COPPER_STAIRS, Blocks.WAXED_EXPOSED_CUT_COPPER, Blocks.WAXED_OXIDIZED_COPPER, Blocks.WAXED_OXIDIZED_CUT_COPPER_SLAB, Blocks.WAXED_OXIDIZED_CUT_COPPER_STAIRS, Blocks.WAXED_OXIDIZED_CUT_COPPER, Blocks.LIGHTNING_ROD);
+        this.tag(BlockTags.FEATURES_CANNOT_REPLACE).add(Blocks.BEDROCK, Blocks.SPAWNER, Blocks.CHEST, Blocks.END_PORTAL_FRAME, Blocks.REINFORCED_DEEPSLATE);
+        this.tag(BlockTags.LAVA_POOL_STONE_CANNOT_REPLACE).addTag(BlockTags.FEATURES_CANNOT_REPLACE).addTag(BlockTags.LEAVES).addTag(BlockTags.LOGS);
+        this.tag(BlockTags.GEODE_INVALID_BLOCKS).add(Blocks.BEDROCK, Blocks.WATER, Blocks.LAVA, Blocks.ICE, Blocks.PACKED_ICE, Blocks.BLUE_ICE);
+        this.tag(BlockTags.ANIMALS_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK);
+        this.tag(BlockTags.AXOLOTLS_SPAWNABLE_ON).add(Blocks.CLAY);
+        this.tag(BlockTags.GOATS_SPAWNABLE_ON).add(Blocks.STONE, Blocks.SNOW, Blocks.SNOW_BLOCK, Blocks.PACKED_ICE, Blocks.GRAVEL);
+        this.tag(BlockTags.MOOSHROOMS_SPAWNABLE_ON).add(Blocks.MYCELIUM);
+        this.tag(BlockTags.PARROTS_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK, Blocks.AIR).addTag(BlockTags.LEAVES).addTag(BlockTags.LOGS);
+        this.tag(BlockTags.POLAR_BEARS_SPAWNABLE_ON_ALTERNATE).add(Blocks.ICE);
+        this.tag(BlockTags.RABBITS_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK, Blocks.SNOW, Blocks.SNOW_BLOCK, Blocks.SAND);
+        this.tag(BlockTags.FOXES_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK, Blocks.SNOW, Blocks.SNOW_BLOCK, Blocks.PODZOL, Blocks.COARSE_DIRT);
+        this.tag(BlockTags.WOLVES_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK, Blocks.SNOW, Blocks.SNOW_BLOCK);
+        this.tag(BlockTags.FROGS_SPAWNABLE_ON).add(Blocks.GRASS_BLOCK, Blocks.MUD, Blocks.MANGROVE_ROOTS, Blocks.MUDDY_MANGROVE_ROOTS);
+        this.tag(BlockTags.TERRACOTTA).add(Blocks.TERRACOTTA, Blocks.WHITE_TERRACOTTA, Blocks.ORANGE_TERRACOTTA, Blocks.MAGENTA_TERRACOTTA, Blocks.LIGHT_BLUE_TERRACOTTA, Blocks.YELLOW_TERRACOTTA, Blocks.LIME_TERRACOTTA, Blocks.PINK_TERRACOTTA, Blocks.GRAY_TERRACOTTA, Blocks.LIGHT_GRAY_TERRACOTTA, Blocks.CYAN_TERRACOTTA, Blocks.PURPLE_TERRACOTTA, Blocks.BLUE_TERRACOTTA, Blocks.BROWN_TERRACOTTA, Blocks.GREEN_TERRACOTTA, Blocks.RED_TERRACOTTA, Blocks.BLACK_TERRACOTTA);
+        this.tag(BlockTags.AZALEA_GROWS_ON).addTag(BlockTags.DIRT).addTag(BlockTags.SAND).addTag(BlockTags.TERRACOTTA).add(Blocks.SNOW_BLOCK).add(Blocks.POWDER_SNOW);
+        this.tag(BlockTags.REPLACEABLE_PLANTS).add(Blocks.GRASS, Blocks.FERN, Blocks.DEAD_BUSH, Blocks.VINE, Blocks.GLOW_LICHEN, Blocks.SUNFLOWER, Blocks.LILAC, Blocks.ROSE_BUSH, Blocks.PEONY, Blocks.TALL_GRASS, Blocks.LARGE_FERN, Blocks.HANGING_ROOTS);
+        this.tag(BlockTags.FROG_PREFER_JUMP_TO).add(Blocks.LILY_PAD, Blocks.BIG_DRIPLEAF);
+        this.tag(BlockTags.SCULK_REPLACEABLE).addTag(BlockTags.BASE_STONE_OVERWORLD).addTag(BlockTags.DIRT).addTag(BlockTags.TERRACOTTA).addTag(BlockTags.NYLIUM).addTag(BlockTags.BASE_STONE_NETHER).addTag(BlockTags.SAND).add(Blocks.GRAVEL).add(Blocks.SOUL_SAND).add(Blocks.SOUL_SOIL).add(Blocks.CALCITE).add(Blocks.SMOOTH_BASALT).add(Blocks.CLAY).add(Blocks.DRIPSTONE_BLOCK).add(Blocks.END_STONE).add(Blocks.RED_SANDSTONE).add(Blocks.SANDSTONE);
+        this.tag(BlockTags.SCULK_REPLACEABLE_WORLD_GEN).addTag(BlockTags.SCULK_REPLACEABLE).add(Blocks.DEEPSLATE_BRICKS).add(Blocks.DEEPSLATE_TILES).add(Blocks.COBBLED_DEEPSLATE).add(Blocks.CRACKED_DEEPSLATE_BRICKS).add(Blocks.CRACKED_DEEPSLATE_TILES).add(Blocks.POLISHED_DEEPSLATE);
+        this.tag(BlockTags.CONVERTABLE_TO_MUD).add(Blocks.DIRT, Blocks.COARSE_DIRT, Blocks.ROOTED_DIRT);
+        this.tag(BlockTags.ANCIENT_CITY_REPLACEABLE).add(Blocks.DEEPSLATE).add(Blocks.DEEPSLATE_BRICKS).add(Blocks.DEEPSLATE_TILES).add(Blocks.DEEPSLATE_BRICK_SLAB).add(Blocks.DEEPSLATE_TILE_SLAB).add(Blocks.DEEPSLATE_BRICK_STAIRS).add(Blocks.DEEPSLATE_TILE_WALL).add(Blocks.DEEPSLATE_BRICK_WALL).add(Blocks.COBBLED_DEEPSLATE).add(Blocks.CRACKED_DEEPSLATE_BRICKS).add(Blocks.CRACKED_DEEPSLATE_TILES).add(Blocks.GRAY_WOOL);
+        this.tag(BlockTags.MANGROVE_LOGS_CAN_GROW_THROUGH).add(Blocks.MUD, Blocks.MUDDY_MANGROVE_ROOTS, Blocks.MANGROVE_ROOTS, Blocks.MANGROVE_LEAVES, Blocks.MANGROVE_LOG, Blocks.MANGROVE_PROPAGULE, Blocks.MOSS_CARPET, Blocks.VINE);
+        this.tag(BlockTags.MANGROVE_ROOTS_CAN_GROW_THROUGH).add(Blocks.MUD, Blocks.MUDDY_MANGROVE_ROOTS, Blocks.MANGROVE_ROOTS, Blocks.MOSS_CARPET, Blocks.VINE, Blocks.MANGROVE_PROPAGULE, Blocks.SNOW);
+        this.tag(BlockTags.DEAD_BUSH_MAY_PLACE_ON).addTag(BlockTags.SAND).addTag(BlockTags.TERRACOTTA).addTag(BlockTags.DIRT);
+        this.tag(BlockTags.SNOW_LAYER_CANNOT_SURVIVE_ON).add(Blocks.ICE).add(Blocks.PACKED_ICE).add(Blocks.BARRIER);
+        this.tag(BlockTags.SNOW_LAYER_CAN_SURVIVE_ON).add(Blocks.HONEY_BLOCK).add(Blocks.SOUL_SAND).add(Blocks.MUD);
+        this.tag(BlockTags.COMPLETES_FIND_TREE_TUTORIAL).addTag(BlockTags.LOGS).addTag(BlockTags.LEAVES).addTag(BlockTags.WART_BLOCKS);
+        this.tag(BlockTags.SNAPS_GOAT_HORN).addTag(BlockTags.OVERWORLD_NATURAL_LOGS).add(Blocks.STONE).add(Blocks.PACKED_ICE).add(Blocks.IRON_ORE).add(Blocks.COAL_ORE).add(Blocks.COPPER_ORE).add(Blocks.EMERALD_ORE);
+
+    }
+    
+    public static boolean isValidTagFor(@NotNull TagKey<Block> tag, @NotNull Block block) {
+        
+        // Don't spread tags meant for full blocks to stairs and slabs
+        if (tag.equals(SuCraftBlockTags.BOOKSHELF_FULL_BLOCKS)
+            || tag.equals(SuCraftBlockTags.WOOL_FULL_BLOCKS)
+            || tag.equals(SuCraftBlockTags.LOG_FULL_BLOCKS)
+            || tag.equals(SuCraftBlockTags.PLANK_FULL_BLOCKS)
+            || tag.equals(SuCraftBlockTags.DYED_PLANK_FULL_BLOCKS)
+            || tag.equals(SuCraftBlockTags.PEAT_FULL_BLOCKS)
+            || tag.equals(SuCraftBlockTags.STONE_BRICK_FULL_BLOCKS)
+            || tag.equals(BlockTags.STONE_ORE_REPLACEABLES)
+            || tag.equals(BlockTags.DEEPSLATE_ORE_REPLACEABLES)
+            || tag.equals(BlockTags.BASE_STONE_OVERWORLD)
+            || tag.equals(BlockTags.BASE_STONE_NETHER)
+            || tag.equals(BlockTags.OVERWORLD_CARVER_REPLACEABLES)
+            || tag.equals(BlockTags.NETHER_CARVER_REPLACEABLES)) {
+            if (block.defaultBlockState().is(BlockTags.SLABS)
+                || block.defaultBlockState().is(BlockTags.STAIRS)
+                || block instanceof SlabBlock
+                || block instanceof StairBlock) {
+                return false;
+            }
+        }
+        // Don't spread some tags meant for full blocks to slabs (but they are okay on stairs)
+        if (tag.equals(BlockTags.BEACON_BASE_BLOCKS)
+            || tag.equals(BlockTags.WITHER_SUMMON_BASE_BLOCKS)
+            || tag.equals(BlockTags.DEAD_BUSH_MAY_PLACE_ON)) {
+            if (block.defaultBlockState().is(BlockTags.SLABS)
+                || block instanceof SlabBlock) {
+                return false;
+            }
+        }
+        
+        return true;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/SuCraftBlocks.java b/src/main/java/org/sucraft/suki/block/SuCraftBlocks.java
new file mode 100644
index 0000000000000000000000000000000000000000..726ca5423fff63072d1fce72064e6e7cf407fedb
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/SuCraftBlocks.java
@@ -0,0 +1,1531 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block;
+
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.world.item.DyeColor;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.ItemLike;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.InfestedBlock;
+import net.minecraft.world.level.block.LeavesBlock;
+import net.minecraft.world.level.block.RotatedPillarBlock;
+import net.minecraft.world.level.block.SlabBlock;
+import net.minecraft.world.level.block.SoulFireBlock;
+import net.minecraft.world.level.block.SoundType;
+import net.minecraft.world.level.block.StairBlock;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.level.material.Material;
+import net.minecraft.world.level.material.MaterialColor;
+import net.minecraft.world.level.storage.loot.LootTable;
+import net.minecraft.world.level.storage.loot.providers.number.ConstantValue;
+import org.sucraft.suki.block.replacementrule.BlockReplacementRuleBuilder;
+import org.sucraft.suki.block.replacementrule.SingleMultiStateRealBlockReplacementRuleBuilder;
+import org.sucraft.suki.block.replacementrule.SingleStateRealBlockReplacementRule;
+import org.sucraft.suki.block.replacementrule.BlockReplacementRule;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.blockanditemdata.model.ModelContent;
+import org.sucraft.suki.blockanditemdata.model.ModelCreation;
+import org.sucraft.suki.blockanditemdata.model.ProximityBlockEntityModelVisualPropertiesUniverse;
+import org.sucraft.suki.blockanditemdata.texture.Texture;
+import org.sucraft.suki.blockanditemdata.texture.TextureContent;
+import org.sucraft.suki.item.SuCraftItems;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Arrays;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.StreamSupport;
+
+/**
+ * Based on {@link net.minecraft.world.level.block.Blocks}
+ */
+public class SuCraftBlocks {
+
+    public static final Block SNOWY_STONE_BRICKS = registerStoneBricks("snowy", Blocks.INFESTED_STONE_BRICKS, Blocks.STONE_BRICKS, Blocks.STONE_BRICKS).withCustom8StoneBricksRecipe("snowy", () -> Items.SNOW_BLOCK, false).withCustomStoneBricksRecipe("snowy", () -> Items.SNOWBALL, 2, true);
+    public static final Block DIRTY_STONE_BRICKS = registerStoneBricks("dirty", Blocks.INFESTED_CRACKED_STONE_BRICKS, Blocks.CRACKED_STONE_BRICKS, Blocks.STONE_BRICKS).withCustom8StoneBricksRecipe("dirty", () -> Items.DIRT, false).withCustomStoneBricksRecipe("dirty", () -> SuCraftItems.DIRT_SLAB, 4, true);
+    public static final Block INFESTED_SNOWY_STONE_BRICKS = registerInfested(SNOWY_STONE_BRICKS);
+    public static final Block INFESTED_DIRTY_STONE_BRICKS = registerInfested(DIRTY_STONE_BRICKS);
+    public static final Block SPRUCE_BOOKSHELF = registerBookshelf("spruce");
+    public static final Block BIRCH_BOOKSHELF = registerBookshelf("birch");
+    public static final Block JUNGLE_BOOKSHELF = registerBookshelf("jungle");
+    public static final Block ACACIA_BOOKSHELF = registerBookshelf("acacia");
+    public static final Block DARK_OAK_BOOKSHELF = registerBookshelf("dark_oak");
+    public static final Block WARPED_BOOKSHELF = registerBookshelf("warped");
+    public static final Block CRIMSON_BOOKSHELF = registerBookshelf("crimson");
+//    public static final Block MANGROVE_BOOKSHELF = registerBookshelf("mangrove");
+    public static final Block BLACK_PLANKS = registerDyedPlanks("black", Blocks.DARK_OAK_PLANKS, DyeColor.BLACK.getMaterialColor(), () -> Items.BLACK_DYE);
+    public static final Block BLUE_PLANKS = registerDyedPlanks("blue", Blocks.WARPED_PLANKS, DyeColor.BLUE.getMaterialColor(), () -> Items.BLUE_DYE);
+    public static final Block BROWN_PLANKS = registerDyedPlanks("brown", Blocks.SPRUCE_PLANKS, DyeColor.BROWN.getMaterialColor(), () -> Items.BROWN_DYE);
+    public static final Block CYAN_PLANKS = registerDyedPlanks("cyan", Blocks.WARPED_PLANKS, DyeColor.CYAN.getMaterialColor(), () -> Items.CYAN_DYE);
+    public static final Block GRAY_PLANKS = registerDyedPlanks("gray", Blocks.SPRUCE_PLANKS, DyeColor.GRAY.getMaterialColor(), () -> Items.GRAY_DYE);
+    public static final Block GREEN_PLANKS = registerDyedPlanks("green", Blocks.WARPED_PLANKS, DyeColor.GREEN.getMaterialColor(), () -> Items.GREEN_DYE);
+    public static final Block LIGHT_BLUE_PLANKS = registerDyedPlanks("light_blue", Blocks.WARPED_PLANKS, DyeColor.LIGHT_BLUE.getMaterialColor(), () -> Items.LIGHT_BLUE_DYE);
+    public static final Block LIGHT_GRAY_PLANKS = registerDyedPlanks("light_gray", Blocks.OAK_PLANKS, DyeColor.LIGHT_GRAY.getMaterialColor(), () -> Items.LIGHT_GRAY_DYE);
+    public static final Block LIME_PLANKS = registerDyedPlanks("lime", Blocks.WARPED_PLANKS, DyeColor.LIME.getMaterialColor(), () -> Items.LIME_DYE);
+    public static final Block MAGENTA_PLANKS = registerDyedPlanks("magenta", Blocks.CRIMSON_PLANKS, DyeColor.MAGENTA.getMaterialColor(), () -> Items.MAGENTA_DYE);
+    public static final Block ORANGE_PLANKS = registerDyedPlanks("orange", Blocks.ACACIA_PLANKS, DyeColor.ORANGE.getMaterialColor(), () -> Items.ORANGE_DYE);
+    public static final Block PINK_PLANKS = registerDyedPlanks("pink", Blocks.JUNGLE_PLANKS, DyeColor.PINK.getMaterialColor(), () -> Items.PINK_DYE);
+    public static final Block PURPLE_PLANKS = registerDyedPlanks("purple", Blocks.CRIMSON_PLANKS, DyeColor.PURPLE.getMaterialColor(), () -> Items.PURPLE_DYE);
+    public static final Block RED_PLANKS = registerDyedPlanks("red", Blocks.MANGROVE_PLANKS, DyeColor.RED.getMaterialColor(), () -> Items.RED_DYE);
+    public static final Block WHITE_PLANKS = registerDyedPlanks("white", Blocks.BIRCH_PLANKS, DyeColor.WHITE.getMaterialColor(), () -> Items.WHITE_DYE);
+    public static final Block YELLOW_PLANKS = registerDyedPlanks("yellow", Blocks.BIRCH_PLANKS, DyeColor.YELLOW.getMaterialColor(), () -> Items.YELLOW_DYE);
+
+    /**
+     * Based on {@link Blocks#DIRT}
+     */
+    public static final Block DIRT_BRICKS = register(
+        "dirt_bricks",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.DIRT)
+            .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.DIRT).strength(0.5F, 1.0F).sound(SoundType.GRAVEL)).mineableWithShovel().dirt(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomOneToOneStonecutterRecipe(Blocks.DIRT).withCustom2x2SquareRecipe("dirt_bricks", Blocks.DIRT, 4, false);
+
+    public static final Block POLISHED_CALCITE = registerPolished(Blocks.CALCITE, "calcite", Blocks.CALCITE, MaterialColor.TERRACOTTA_WHITE);
+    public static final Block POLISHED_DRIPSTONE = registerPolished(Blocks.DRIPSTONE_BLOCK, "dripstone", Blocks.DRIPSTONE_BLOCK, MaterialColor.TERRACOTTA_BROWN);
+    public static final Block POLISHED_TUFF = registerPolished(Blocks.TUFF, "tuff", Blocks.TUFF, MaterialColor.TERRACOTTA_GRAY);
+    public static final Block ANDESITE_BRICKS = registerBricks(Blocks.ANDESITE, "andesite", Blocks.POLISHED_ANDESITE, MaterialColor.STONE, Blocks.POLISHED_ANDESITE);
+    public static final Block CALCITE_BRICKS = registerBricks(Blocks.CALCITE, "calcite", Blocks.CALCITE, MaterialColor.TERRACOTTA_WHITE, POLISHED_CALCITE);
+    public static final Block DIORITE_BRICKS = registerBricks(Blocks.DIORITE, "diorite", Blocks.POLISHED_DIORITE, MaterialColor.QUARTZ, Blocks.POLISHED_DIORITE);
+    public static final Block DRIPSTONE_BRICKS = registerBricks(Blocks.DRIPSTONE_BLOCK, "dripstone", Blocks.DRIPSTONE_BLOCK, MaterialColor.TERRACOTTA_BROWN, POLISHED_DRIPSTONE);
+    public static final Block GRANITE_BRICKS = registerBricks(Blocks.GRANITE, "granite", Blocks.POLISHED_GRANITE, MaterialColor.DIRT, Blocks.POLISHED_GRANITE);
+    public static final Block TUFF_BRICKS = registerBricks(Blocks.TUFF, "tuff", Blocks.TUFF, MaterialColor.TERRACOTTA_GRAY, POLISHED_TUFF);
+    public static final Block CHISELED_ANDESITE_BRICKS = registerChiseledBricks(ANDESITE_BRICKS,"andesite", Blocks.POLISHED_ANDESITE, MaterialColor.STONE, () -> new ItemLike[] {Items.ANDESITE_SLAB, Items.POLISHED_ANDESITE_SLAB, SuCraftItems.ANDESITE_BRICK_SLAB});
+    public static final Block CHISELED_CALCITE_BRICKS = registerChiseledBricks(CALCITE_BRICKS, "calcite", Blocks.CALCITE, MaterialColor.TERRACOTTA_WHITE, () -> new ItemLike[] {SuCraftItems.CALCITE_SLAB, SuCraftItems.POLISHED_CALCITE_SLAB, SuCraftItems.CALCITE_BRICK_SLAB});
+    public static final Block CHISELED_DIORITE_BRICKS = registerChiseledBricks(DIORITE_BRICKS, "diorite", Blocks.POLISHED_DIORITE, MaterialColor.QUARTZ, () -> new ItemLike[] {Items.DIORITE_SLAB, Items.POLISHED_DIORITE_SLAB, SuCraftItems.DIORITE_BRICK_SLAB});
+    public static final Block CHISELED_DRIPSTONE_BRICKS = registerChiseledBricks(DRIPSTONE_BRICKS, "dripstone", Blocks.DRIPSTONE_BLOCK, MaterialColor.TERRACOTTA_BROWN, () -> new ItemLike[] {SuCraftItems.DRIPSTONE_SLAB, SuCraftItems.POLISHED_DRIPSTONE_SLAB, SuCraftItems.DRIPSTONE_BRICK_SLAB});
+    public static final Block CHISELED_GRANITE_BRICKS = registerChiseledBricks(GRANITE_BRICKS, "granite", Blocks.POLISHED_GRANITE, MaterialColor.DIRT, () -> new ItemLike[] {Items.GRANITE_SLAB, Items.POLISHED_GRANITE_SLAB, SuCraftItems.GRANITE_BRICK_SLAB});
+    public static final Block CHISELED_TUFF_BRICKS = registerChiseledBricks(TUFF_BRICKS, "tuff", Blocks.TUFF, MaterialColor.TERRACOTTA_GRAY, () -> new ItemLike[] {SuCraftItems.TUFF_SLAB, SuCraftItems.POLISHED_TUFF_SLAB, SuCraftItems.TUFF_BRICK_SLAB});
+
+    /**
+     * Based on {@link Blocks#SANDSTONE} and {@link Blocks#SOUL_SAND}
+     */
+    public static final Block SOUL_SANDSTONE = register(
+        "soul_sandstone",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.SOUL_SOIL)
+            .withModelCreation(Model.BottomTopPillarCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BROWN).strength(0.8F, 0.8F)).mineableWithPickaxe().soulSpeed().soulFireBase(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustom2x2SquareChoiceRecipe("soul_sand_or_soil_to_soul_sandstone", () -> new ItemLike[] {Items.SOUL_SAND, Items.SOUL_SOIL}, 4, false);
+
+    public static final Block SANDSTONE_BRICKS = registerBricks(Blocks.SANDSTONE, "sandstone", Blocks.SANDSTONE, MaterialColor.SAND, Blocks.CUT_SANDSTONE);
+    public static final Block RED_SANDSTONE_BRICKS = registerBricks(Blocks.RED_SANDSTONE, "red_sandstone", Blocks.RED_SANDSTONE, MaterialColor.COLOR_ORANGE, Blocks.CUT_RED_SANDSTONE);
+
+    /**
+     * Based on {@link Blocks#CHISELED_SANDSTONE} and {@link Blocks#SOUL_SAND}
+     */
+    public static final Block CHISELED_SOUL_SANDSTONE = register(
+        "chiseled_soul_sandstone",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.SOUL_SOIL)
+            .withModelCreation(Model.YPillarCube.defaultCreationWithAlternativeEnd(new Texture(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), TextureContent.Existing.getInstance())).withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BROWN).strength(0.8F)).mineableWithPickaxe().soulSpeed().soulFireBase(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomOneToOneStonecutterRecipe(SOUL_SANDSTONE).withCustom2VerticalChoiceRecipe("soul_sandstone_slabs_to_chiseled_soul_sandstone", () -> new ItemLike[] {SuCraftItems.SOUL_SANDSTONE_SLAB, SuCraftItems.SMOOTH_SOUL_SANDSTONE_SLAB, SuCraftItems.CUT_SOUL_SANDSTONE_SLAB}, 1, true);
+
+    /**
+     * Based on {@link Blocks#CUT_SANDSTONE} and {@link Blocks#SOUL_SAND}
+     */
+    public static final Block CUT_SOUL_SANDSTONE = register(
+        "cut_soul_sandstone",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.SOUL_SOIL)
+            .withModelCreation(Model.YPillarCube.defaultCreationWithAlternativeEnd(new Texture(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), TextureContent.Existing.getInstance())).withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BROWN).strength(0.8F)).mineableWithPickaxe().soulSpeed().soulFireBase(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomOneToOneStonecutterRecipe(SOUL_SANDSTONE).withCustom2x2SquareRecipe("cut_soul_sandstone", SOUL_SANDSTONE, 4, true);
+
+    public static final Block SOUL_SANDSTONE_BRICKS = registerBricks(SOUL_SANDSTONE, "soul_sandstone", Blocks.SOUL_SOIL, MaterialColor.COLOR_BROWN, CUT_SOUL_SANDSTONE).soulSpeed().soulFireBase();
+    // Not included in initial release
+//    public static final Block ANDESITE_COBBLESTONE = registerCobblestone(Blocks.ANDESITE, "andesite", Blocks.ANDESITE, MaterialColor.STONE);
+//    public static final Block DIORITE_COBBLESTONE = registerCobblestone(Blocks.DIORITE, "diorite", Blocks.DIORITE, MaterialColor.QUARTZ);
+//    public static final Block GRANITE_COBBLESTONE = registerCobblestone(Blocks.GRANITE, "granite", Blocks.GRANITE, MaterialColor.DIRT);
+    public static final Block CHISELED_PRISMARINE_BRICKS = registerChiseledBricks(Blocks.PRISMARINE_BRICKS, "prismarine", Blocks.PRISMARINE_BRICKS, MaterialColor.DIAMOND, () -> new ItemLike[] {Items.PRISMARINE_BRICK_SLAB});
+    public static final Block ANDESITE_PILLAR = registerStonePillar(Blocks.ANDESITE, "andesite", Blocks.POLISHED_ANDESITE, MaterialColor.STONE, () -> new ItemLike[] {Items.ANDESITE, Items.POLISHED_ANDESITE});
+    public static final Block CALCITE_PILLAR = registerStonePillar(Blocks.CALCITE, "calcite", Blocks.CALCITE, MaterialColor.TERRACOTTA_WHITE, () -> new ItemLike[] {Items.CALCITE, SuCraftItems.POLISHED_CALCITE});
+    public static final Block DIORITE_PILLAR = registerStonePillar(Blocks.DIORITE, "diorite", Blocks.POLISHED_DIORITE, MaterialColor.QUARTZ, () -> new ItemLike[] {Items.DIORITE, Items.POLISHED_DIORITE});
+    public static final Block DRIPSTONE_PILLAR = registerStonePillar(Blocks.DRIPSTONE_BLOCK, "dripstone", Blocks.DRIPSTONE_BLOCK, MaterialColor.TERRACOTTA_BROWN, () -> new ItemLike[] {Items.DRIPSTONE_BLOCK, SuCraftItems.POLISHED_DRIPSTONE});
+    public static final Block GRANITE_PILLAR = registerStonePillar(Blocks.GRANITE, "granite", Blocks.POLISHED_GRANITE, MaterialColor.DIRT, () -> new ItemLike[] {Items.GRANITE, Items.POLISHED_GRANITE});
+    public static final Block TUFF_PILLAR = registerStonePillar(Blocks.TUFF, "tuff", Blocks.TUFF, MaterialColor.TERRACOTTA_GRAY, () -> new ItemLike[] {Items.TUFF, SuCraftItems.POLISHED_TUFF});
+    // Not included in initial release
+//    public static final Block RUSTY_BIRCH_LEAVES = registerLeaves("rusty_birch", Blocks.BIRCH_LEAVES, Blocks.BIRCH_SAPLING/*TODO make drop specific sapling*/, Blocks.BIRCH_LEAVES, MaterialColor.COLOR_ORANGE);
+    public static final Block PALE_BIRCH_LEAVES = registerLeaves("pale_birch", Blocks.BIRCH_LEAVES, Blocks.BIRCH_SAPLING/*TODO make drop specific sapling*/, Blocks.BIRCH_LEAVES, MaterialColor.COLOR_YELLOW);
+    public static final Block RED_OAK_LEAVES = registerLeaves("red_oak", Blocks.OAK_LEAVES, Blocks.OAK_SAPLING/*TODO make drop specific sapling*/, Blocks.OAK_LEAVES, MaterialColor.COLOR_RED);
+    public static final Block ORANGE_OAK_LEAVES = registerLeaves("orange_oak", Blocks.OAK_LEAVES, Blocks.OAK_SAPLING/*TODO make drop specific sapling*/, Blocks.OAK_LEAVES, MaterialColor.COLOR_ORANGE);
+    public static final Block RED_MAPLE_LEAVES = registerLeaves("red_maple", Blocks.OAK_LEAVES, Blocks.OAK_SAPLING/*TODO make drop specific sapling*/, Blocks.OAK_LEAVES, MaterialColor.COLOR_RED);
+    public static final Block ORANGE_MAPLE_LEAVES = registerLeaves("orange_maple", Blocks.OAK_LEAVES, Blocks.OAK_SAPLING/*TODO make drop specific sapling*/, Blocks.OAK_LEAVES, MaterialColor.COLOR_ORANGE);
+    public static final Block YELLOW_MAPLE_LEAVES = registerLeaves("yellow_maple", Blocks.OAK_LEAVES, Blocks.OAK_SAPLING/*TODO make drop specific sapling*/, Blocks.OAK_LEAVES, MaterialColor.COLOR_YELLOW);
+    public static final Block DIRT_SLAB = registerFakeSlab(Blocks.DIRT, "dirt", Blocks.MUD_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel().dirt();
+//    public static final Block DIRT_SLAB = registerRealSlab(Blocks.DIRT, "dirt", null, Blocks.WAXED_CUT_COPPER_SLAB, Blocks.CUT_COPPER_SLAB, Blocks.MUD_BRICK_SLAB, BlockBehaviour.Properties.of(Material.DIRT).strength(0.5F).sound(SoundType.GRAVEL)).breakBeforeClientKnowsToBreak().mineableWithShovel().dirt();
+    public static final Block SNOWY_STONE_BRICK_SLAB = registerFakeSlab(SNOWY_STONE_BRICKS, "snowy_stone_brick", null, Blocks.STONE_BRICK_SLAB).stoneBrickSlab();
+    public static final Block DIRTY_STONE_BRICK_SLAB = registerFakeSlab(DIRTY_STONE_BRICKS, "dirty_stone_brick", null, Blocks.STONE_BRICK_SLAB).stoneBrickSlab();
+    public static final Block CRACKED_STONE_BRICK_SLAB = registerFakeSlab(Blocks.CRACKED_STONE_BRICKS, "cracked_stone_brick", "cracked_stone_bricks", Blocks.STONE_BRICK_SLAB).stoneBrickSlab();
+    public static final Block BLACK_PLANK_SLAB = registerFakeDyedPlankSlab(BLACK_PLANKS, "black", Blocks.DARK_OAK_SLAB, () -> Items.BLACK_DYE);
+    public static final Block BLUE_PLANK_SLAB = registerFakeDyedPlankSlab(BLUE_PLANKS, "blue", Blocks.WARPED_SLAB, () -> Items.BLUE_DYE);
+    public static final Block BROWN_PLANK_SLAB = registerFakeDyedPlankSlab(BROWN_PLANKS, "brown", Blocks.SPRUCE_SLAB, () -> Items.BROWN_DYE);
+    public static final Block CYAN_PLANK_SLAB = registerFakeDyedPlankSlab(CYAN_PLANKS, "cyan", Blocks.WARPED_SLAB, () -> Items.CYAN_DYE);
+    public static final Block GRAY_PLANK_SLAB = registerFakeDyedPlankSlab(GRAY_PLANKS, "gray", Blocks.SPRUCE_SLAB, () -> Items.GRAY_DYE);
+    public static final Block GREEN_PLANK_SLAB = registerFakeDyedPlankSlab(GREEN_PLANKS, "green", Blocks.WARPED_SLAB, () -> Items.GREEN_DYE);
+    public static final Block LIGHT_BLUE_PLANK_SLAB = registerFakeDyedPlankSlab(LIGHT_BLUE_PLANKS, "light_blue", Blocks.WARPED_SLAB, () -> Items.LIGHT_BLUE_DYE);
+    public static final Block LIGHT_GRAY_PLANK_SLAB = registerFakeDyedPlankSlab(LIGHT_GRAY_PLANKS, "light_gray", Blocks.OAK_SLAB, () -> Items.LIGHT_GRAY_DYE);
+    public static final Block LIME_PLANK_SLAB = registerFakeDyedPlankSlab(LIME_PLANKS, "lime", Blocks.WARPED_SLAB, () -> Items.LIME_DYE);
+    public static final Block MAGENTA_PLANK_SLAB = registerFakeDyedPlankSlab(MAGENTA_PLANKS, "magenta", Blocks.CRIMSON_SLAB, () -> Items.MAGENTA_DYE);
+    public static final Block ORANGE_PLANK_SLAB = registerFakeDyedPlankSlab(ORANGE_PLANKS, "orange", Blocks.ACACIA_SLAB, () -> Items.ORANGE_DYE);
+    public static final Block PINK_PLANK_SLAB = registerFakeDyedPlankSlab(PINK_PLANKS, "pink", Blocks.JUNGLE_SLAB, () -> Items.PINK_DYE);
+    public static final Block PURPLE_PLANK_SLAB = registerFakeDyedPlankSlab(PURPLE_PLANKS, "purple", Blocks.CRIMSON_SLAB, () -> Items.PURPLE_DYE);
+    public static final Block RED_PLANK_SLAB = registerFakeDyedPlankSlab(RED_PLANKS, "red", Blocks.MANGROVE_SLAB, () -> Items.RED_DYE);
+    public static final Block WHITE_PLANK_SLAB = registerFakeDyedPlankSlab(WHITE_PLANKS, "white", Blocks.BIRCH_SLAB, () -> Items.WHITE_DYE);
+    public static final Block YELLOW_PLANK_SLAB = registerFakeDyedPlankSlab(YELLOW_PLANKS, "yellow", Blocks.BIRCH_SLAB, () -> Items.YELLOW_DYE);
+    public static final Block BLACK_WOOL_SLAB = registerFakeWoolSlab(Blocks.BLACK_WOOL, "black", Blocks.BLACKSTONE_SLAB);
+    public static final Block BLUE_WOOL_SLAB = registerFakeWoolSlab(Blocks.BLUE_WOOL, "blue", Blocks.WARPED_SLAB);
+    public static final Block BROWN_WOOL_SLAB = registerFakeWoolSlab(Blocks.BROWN_WOOL, "brown", Blocks.SPRUCE_SLAB);
+    public static final Block CYAN_WOOL_SLAB = registerFakeWoolSlab(Blocks.CYAN_WOOL, "cyan", Blocks.WARPED_SLAB);
+    public static final Block GRAY_WOOL_SLAB = registerFakeWoolSlab(Blocks.GRAY_WOOL, "gray", Blocks.STONE_SLAB);
+    public static final Block GREEN_WOOL_SLAB = registerFakeWoolSlab(Blocks.GREEN_WOOL, "green", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block LIGHT_BLUE_WOOL_SLAB = registerFakeWoolSlab(Blocks.LIGHT_BLUE_WOOL, "light_blue", Blocks.PRISMARINE_BRICK_SLAB);
+    public static final Block LIGHT_GRAY_WOOL_SLAB = registerFakeWoolSlab(Blocks.LIGHT_GRAY_WOOL, "light_gray", Blocks.SMOOTH_STONE_SLAB);
+    public static final Block LIME_WOOL_SLAB = registerFakeWoolSlab(Blocks.LIME_WOOL, "lime", Blocks.OXIDIZED_CUT_COPPER_SLAB);
+    public static final Block MAGENTA_WOOL_SLAB = registerFakeWoolSlab(Blocks.MAGENTA_WOOL, "magenta", Blocks.PURPUR_SLAB);
+    public static final Block ORANGE_WOOL_SLAB = registerFakeWoolSlab(Blocks.ORANGE_WOOL, "orange", Blocks.SMOOTH_RED_SANDSTONE_SLAB);
+    public static final Block PINK_WOOL_SLAB = registerFakeWoolSlab(Blocks.PINK_WOOL, "pink", Blocks.PURPUR_SLAB);
+    public static final Block PURPLE_WOOL_SLAB = registerFakeWoolSlab(Blocks.PURPLE_WOOL, "purple", Blocks.PURPUR_SLAB);
+    public static final Block RED_WOOL_SLAB = registerFakeWoolSlab(Blocks.RED_WOOL, "red", Blocks.MANGROVE_SLAB);
+    public static final Block WHITE_WOOL_SLAB = registerFakeWoolSlab(Blocks.WHITE_WOOL, "white", Blocks.SMOOTH_QUARTZ_SLAB);
+    public static final Block YELLOW_WOOL_SLAB = registerFakeWoolSlab(Blocks.YELLOW_WOOL, "yellow", Blocks.BIRCH_SLAB);
+    public static final Block BLACK_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.BLACK_CONCRETE, "black", Blocks.BLACKSTONE_SLAB);
+    public static final Block BLUE_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.BLUE_CONCRETE, "blue", Blocks.WARPED_SLAB);
+    public static final Block BROWN_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.BROWN_CONCRETE, "brown", Blocks.SPRUCE_SLAB);
+    public static final Block CYAN_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.CYAN_CONCRETE, "cyan", Blocks.WARPED_SLAB);
+    public static final Block GRAY_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.GRAY_CONCRETE, "gray", Blocks.STONE_SLAB);
+    public static final Block GREEN_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.GREEN_CONCRETE, "green", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block LIGHT_BLUE_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.LIGHT_BLUE_CONCRETE, "light_blue", Blocks.PRISMARINE_BRICK_SLAB);
+    public static final Block LIGHT_GRAY_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.LIGHT_GRAY_CONCRETE, "light_gray", Blocks.SMOOTH_STONE_SLAB);
+    public static final Block LIME_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.LIME_CONCRETE, "lime", Blocks.OXIDIZED_CUT_COPPER_SLAB);
+    public static final Block MAGENTA_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.MAGENTA_CONCRETE, "magenta", Blocks.PURPUR_SLAB);
+    public static final Block ORANGE_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.ORANGE_CONCRETE, "orange", Blocks.SMOOTH_RED_SANDSTONE_SLAB);
+    public static final Block PINK_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.PINK_CONCRETE, "pink", Blocks.PURPUR_SLAB);
+    public static final Block PURPLE_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.PURPLE_CONCRETE, "purple", Blocks.PURPUR_SLAB);
+    public static final Block RED_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.RED_CONCRETE, "red", Blocks.MANGROVE_SLAB);
+    public static final Block WHITE_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.WHITE_CONCRETE, "white", Blocks.SMOOTH_QUARTZ_SLAB);
+    public static final Block YELLOW_CONCRETE_SLAB = registerFakeConcreteSlab(Blocks.YELLOW_CONCRETE, "yellow", Blocks.BIRCH_SLAB);
+    public static final Block BLACK_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.BLACK_CONCRETE_POWDER, "black", Blocks.BLACKSTONE_SLAB);
+    public static final Block BLUE_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.BLUE_CONCRETE_POWDER, "blue", Blocks.WARPED_SLAB);
+    public static final Block BROWN_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.BROWN_CONCRETE_POWDER, "brown", Blocks.SPRUCE_SLAB);
+    public static final Block CYAN_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.CYAN_CONCRETE_POWDER, "cyan", Blocks.WARPED_SLAB);
+    public static final Block GRAY_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.GRAY_CONCRETE_POWDER, "gray", Blocks.STONE_SLAB);
+    public static final Block GREEN_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.GREEN_CONCRETE_POWDER, "green", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block LIGHT_BLUE_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.LIGHT_BLUE_CONCRETE_POWDER, "light_blue", Blocks.PRISMARINE_BRICK_SLAB);
+    public static final Block LIGHT_GRAY_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.LIGHT_GRAY_CONCRETE_POWDER, "light_gray", Blocks.SMOOTH_STONE_SLAB);
+    public static final Block LIME_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.LIME_CONCRETE_POWDER, "lime", Blocks.OXIDIZED_CUT_COPPER_SLAB);
+    public static final Block MAGENTA_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.MAGENTA_CONCRETE_POWDER, "magenta", Blocks.PURPUR_SLAB);
+    public static final Block ORANGE_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.ORANGE_CONCRETE_POWDER, "orange", Blocks.SMOOTH_RED_SANDSTONE_SLAB);
+    public static final Block PINK_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.PINK_CONCRETE_POWDER, "pink", Blocks.PURPUR_SLAB);
+    public static final Block PURPLE_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.PURPLE_CONCRETE_POWDER, "purple", Blocks.PURPUR_SLAB);
+    public static final Block RED_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.RED_CONCRETE_POWDER, "red", Blocks.MANGROVE_SLAB);
+    public static final Block WHITE_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.WHITE_CONCRETE_POWDER, "white", Blocks.SMOOTH_QUARTZ_SLAB);
+    public static final Block YELLOW_CONCRETE_POWDER_SLAB = registerFakeConcretePowderSlab(Blocks.YELLOW_CONCRETE_POWDER, "yellow", Blocks.BIRCH_SLAB);
+    public static final Block BLACK_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.BLACK_TERRACOTTA, "black", Blocks.BLACKSTONE_SLAB);
+    public static final Block BLUE_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.BLUE_TERRACOTTA, "blue", Blocks.POLISHED_BLACKSTONE_SLAB);
+    public static final Block BROWN_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.BROWN_TERRACOTTA, "brown", Blocks.DARK_OAK_SLAB);
+    public static final Block CYAN_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.CYAN_TERRACOTTA, "cyan", Blocks.STONE_SLAB);
+    public static final Block GRAY_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.GRAY_TERRACOTTA, "gray", Blocks.DARK_OAK_SLAB);
+    public static final Block GREEN_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.GREEN_TERRACOTTA, "green", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block LIGHT_BLUE_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.LIGHT_BLUE_TERRACOTTA, "light_blue", Blocks.STONE_SLAB);
+    public static final Block LIGHT_GRAY_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.LIGHT_GRAY_TERRACOTTA, "light_gray", Blocks.JUNGLE_SLAB);
+    public static final Block LIME_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.LIME_TERRACOTTA, "lime", Blocks.DARK_PRISMARINE_SLAB);
+    public static final Block MAGENTA_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.MAGENTA_TERRACOTTA, "magenta", Blocks.PURPUR_SLAB);
+    public static final Block ORANGE_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.ORANGE_TERRACOTTA, "orange", Blocks.SMOOTH_RED_SANDSTONE_SLAB);
+    public static final Block PINK_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.PINK_TERRACOTTA, "pink", Blocks.MANGROVE_SLAB);
+    public static final Block PURPLE_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.PURPLE_TERRACOTTA, "purple", Blocks.PURPUR_SLAB);
+    public static final Block RED_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.RED_TERRACOTTA, "red", Blocks.MANGROVE_SLAB);
+    public static final Block WHITE_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.WHITE_TERRACOTTA, "white", Blocks.SMOOTH_QUARTZ_SLAB);
+    public static final Block YELLOW_TERRACOTTA_SLAB = registerFakeTerracottaSlab(Blocks.YELLOW_TERRACOTTA, "yellow", Blocks.OAK_SLAB);
+    public static final Block COARSE_DIRT_SLAB = registerFakeSlab(Blocks.COARSE_DIRT, "coarse_dirt", Blocks.MUD_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block SAND_SLAB = registerFakeFallingSlab(Blocks.SAND, null, "sand", "sand", Blocks.SANDSTONE_SLAB, null).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block RED_SAND_SLAB = registerFakeFallingSlab(Blocks.RED_SAND, null, "red_sand", "red_sand", Blocks.RED_SANDSTONE_SLAB, null).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block CLAY_SLAB = registerFakeSlab(Blocks.CLAY, "clay", Blocks.ANDESITE_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block MUD_SLAB = registerFakeSlab(Blocks.MUD, "mud", Blocks.POLISHED_BLACKSTONE_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block PACKED_MUD_SLAB = registerFakeSlab(Blocks.PACKED_MUD, "packed_mud", Blocks.MUD_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithPickaxe();
+    public static final Block AMETHYST_SLAB = registerFakeSlab(Blocks.AMETHYST_BLOCK, "amethyst", "amethyst_block", Blocks.PURPUR_SLAB).mineableWithPickaxe().crystalSound();
+    public static final Block COAL_SLAB = registerFakeSlab(Blocks.COAL_BLOCK, "coal", "coal_block", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
+    public static final Block OAK_BOOKSHELF_SLAB = registerFakeBookshelfSlab(Blocks.BOOKSHELF, "oak", Blocks.OAK_SLAB);
+    public static final Block SPRUCE_BOOKSHELF_SLAB = registerFakeBookshelfSlab(SPRUCE_BOOKSHELF, "spruce", Blocks.SPRUCE_SLAB);
+    public static final Block BIRCH_BOOKSHELF_SLAB = registerFakeBookshelfSlab(BIRCH_BOOKSHELF, "birch", Blocks.BIRCH_SLAB);
+    public static final Block JUNGLE_BOOKSHELF_SLAB = registerFakeBookshelfSlab(JUNGLE_BOOKSHELF, "jungle", Blocks.JUNGLE_SLAB);
+    public static final Block CALCITE_SLAB = registerFakeSlab(Blocks.CALCITE, "calcite", Blocks.SMOOTH_QUARTZ_SLAB).mineableWithPickaxe();
+    public static final Block DRIPSTONE_SLAB = registerFakeSlab(Blocks.DRIPSTONE_BLOCK, "dripstone", "dripstone_block", Blocks.GRANITE_SLAB).mineableWithPickaxe();
+    public static final Block TUFF_SLAB = registerFakeSlab(Blocks.TUFF, "tuff", Blocks.COBBLESTONE_SLAB).mineableWithPickaxe();
+    public static final Block POLISHED_CALCITE_SLAB = registerFakePolishedSlab(POLISHED_CALCITE, "calcite", Blocks.QUARTZ_SLAB);
+    public static final Block POLISHED_DRIPSTONE_SLAB = registerFakePolishedSlab(POLISHED_DRIPSTONE, "dripstone", Blocks.POLISHED_GRANITE_SLAB);
+    public static final Block POLISHED_TUFF_SLAB = registerFakePolishedSlab(POLISHED_TUFF, "tuff", Blocks.ANDESITE_SLAB);
+    public static final Block ANDESITE_BRICK_SLAB = registerFakeCustomBrickSlab(ANDESITE_BRICKS, "andesite", Blocks.POLISHED_ANDESITE_SLAB);
+    public static final Block CALCITE_BRICK_SLAB = registerFakeCustomBrickSlab(CALCITE_BRICKS, "calcite", Blocks.QUARTZ_SLAB);
+    public static final Block DIORITE_BRICK_SLAB = registerFakeCustomBrickSlab(DIORITE_BRICKS, "diorite", Blocks.POLISHED_DIORITE_SLAB);
+    public static final Block DRIPSTONE_BRICK_SLAB = registerFakeCustomBrickSlab(DRIPSTONE_BRICKS, "dripstone", Blocks.POLISHED_GRANITE_SLAB);
+    public static final Block GRANITE_BRICK_SLAB = registerFakeCustomBrickSlab(GRANITE_BRICKS, "granite", Blocks.POLISHED_GRANITE_SLAB);
+    public static final Block TUFF_BRICK_SLAB = registerFakeCustomBrickSlab(TUFF_BRICKS, "tuff", Blocks.STONE_BRICK_SLAB);
+    public static final Block ANDESITE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(ANDESITE_PILLAR, "andesite", Blocks.POLISHED_ANDESITE_SLAB);
+    public static final Block CALCITE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(CALCITE_PILLAR, "calcite", Blocks.QUARTZ_SLAB);
+    public static final Block DIORITE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(DIORITE_PILLAR, "diorite", Blocks.POLISHED_DIORITE_SLAB);
+    public static final Block DRIPSTONE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(DRIPSTONE_PILLAR, "dripstone", Blocks.POLISHED_GRANITE_SLAB);
+    public static final Block GRANITE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(GRANITE_PILLAR, "granite", Blocks.POLISHED_GRANITE_SLAB);
+    public static final Block TUFF_PILLAR_SLAB = registerFakeCustomStonePillarSlab(TUFF_PILLAR, "tuff", Blocks.COBBLESTONE_SLAB);
+    public static final Block SOUL_SANDSTONE_SLAB = registerFakeSlab(SOUL_SANDSTONE, null, "soul_sandstone", NamespacedKeyWithoutIntention.sucraft("soul_sandstone"), null, null, NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), NamespacedKeyWithoutIntention.sucraft("soul_sandstone"), NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), Blocks.DARK_OAK_SLAB, null).mineableWithPickaxe().soulSpeed().soulFireBase();
+    public static final Block SANDSTONE_BRICK_SLAB = registerFakeSandstoneBrickSlab(SANDSTONE_BRICKS, null, Blocks.SANDSTONE_SLAB);
+    public static final Block RED_SANDSTONE_BRICK_SLAB = registerFakeSandstoneBrickSlab(RED_SANDSTONE_BRICKS, "red", Blocks.RED_SANDSTONE_SLAB);
+    public static final Block SOUL_SANDSTONE_BRICK_SLAB = registerFakeSandstoneBrickSlab(SOUL_SANDSTONE_BRICKS, "soul", Blocks.DARK_OAK_SLAB).soulSpeed().soulFireBase();
+
+    /**
+     * Based on {@link Blocks#SMOOTH_SANDSTONE} and {@link Blocks#SOUL_SAND}
+     */
+    public static final Block SMOOTH_SOUL_SANDSTONE = register(
+        "smooth_soul_sandstone",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.SOUL_SOIL)
+            .withModelCreation(Model.creation(ModelContent.OneTextureCube.creation(new Texture(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), TextureContent.Existing.getInstance()))).withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BROWN).strength(0.8F)).mineableWithPickaxe().soulSpeed().soulFireBase(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomFurnaceRecipe(SOUL_SANDSTONE, 0.1F, 200, false);
+
+    public static final Block SMOOTH_SOUL_SANDSTONE_SLAB = registerFakeSlab(SMOOTH_SOUL_SANDSTONE, null, "smooth_soul_sandstone", NamespacedKeyWithoutIntention.sucraft("smooth_soul_sandstone"), NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), null, null, null, null, Blocks.DARK_OAK_SLAB, null).mineableWithPickaxe().soulSpeed().soulFireBase();
+    public static final Block CUT_SOUL_SANDSTONE_SLAB = registerFakeSlab(CUT_SOUL_SANDSTONE, null, "cut_soul_sandstone", NamespacedKeyWithoutIntention.sucraft("cut_soul_sandstone"), null, NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), null, null, null, Blocks.DARK_OAK_SLAB, null).mineableWithPickaxe().soulSpeed().soulFireBase();
+    public static final Block GRAVEL_SLAB = registerFakeFallingSlab(Blocks.GRAVEL, null, "gravel", "gravel", Blocks.ANDESITE_SLAB, null).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block NETHERRACK_SLAB = registerFakeSlab(Blocks.NETHERRACK, "netherrack", Blocks.RED_NETHER_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithPickaxe();
+    public static final Block SOUL_SOIL_SLAB = registerFakeSlab(Blocks.SOUL_SOIL, "soul_soil", Blocks.DARK_OAK_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel().soulSpeed().soulFireBase();
+    public static final Block RAW_COPPER_SLAB = registerFakeRawMetalSlab(Blocks.RAW_COPPER_BLOCK, "copper", Blocks.CUT_COPPER_SLAB);
+    public static final Block RAW_GOLD_SLAB = registerFakeRawMetalSlab(Blocks.RAW_GOLD_BLOCK, "gold", Blocks.OAK_SLAB).guardedByPiglins();
+    public static final Block RAW_IRON_SLAB = registerFakeRawMetalSlab(Blocks.RAW_IRON_BLOCK, "iron", Blocks.JUNGLE_SLAB);
+    public static final Block ANCIENT_DEBRIS_SLAB = registerFakeSlab(Blocks.ANCIENT_DEBRIS, null, "ancient_debris", NamespacedKeyWithoutIntention.minecraft("ancient_debris"), NamespacedKeyWithoutIntention.minecraft("ancient_debris_side"), NamespacedKeyWithoutIntention.minecraft("ancient_debris_top"), null, null, null, Blocks.POLISHED_GRANITE_SLAB, null).mineableWithPickaxe();
+    public static final Block DIRT_BRICK_SLAB = registerFakeSlab(DIRT_BRICKS, "dirt_brick", null, Blocks.MUD_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel().dirt();
+    // Not included in initial release
+//    public static final Block STONE_PILLAR = registerStonePillar(Blocks.STONE, "stone", Blocks.STONE, MaterialColor.STONE, () -> new ItemLike[] {Items.STONE});
+//    public static final Block STONE_PILLAR_SLAB = registerFakeCustomStonePillarSlab(STONE_PILLAR, "stone", Blocks.STONE_SLAB);
+    public static final Block OAK_LOG_SLAB = registerFakeLogSlab(Blocks.OAK_LOG, "oak", Blocks.OAK_SLAB);
+    public static final Block SPRUCE_LOG_SLAB = registerFakeLogSlab(Blocks.SPRUCE_LOG, "spruce", Blocks.SPRUCE_SLAB);
+    public static final Block BIRCH_LOG_SLAB = registerFakeLogSlab(Blocks.BIRCH_LOG, "birch", Blocks.BIRCH_SLAB);
+    public static final Block JUNGLE_LOG_SLAB = registerFakeLogSlab(Blocks.JUNGLE_LOG, "jungle", Blocks.JUNGLE_SLAB);
+    public static final Block ACACIA_LOG_SLAB = registerFakeLogSlab(Blocks.ACACIA_LOG, "acacia", Blocks.ACACIA_SLAB);
+    public static final Block DARK_OAK_LOG_SLAB = registerFakeLogSlab(Blocks.DARK_OAK_LOG, "dark_oak", Blocks.DARK_OAK_SLAB);
+    public static final Block WARPED_STEM_SLAB = registerFakeStemSlab(Blocks.WARPED_STEM, "warped", Blocks.WARPED_SLAB);
+    public static final Block CRIMSON_STEM_SLAB = registerFakeStemSlab(Blocks.CRIMSON_STEM, "crimson", Blocks.CRIMSON_SLAB);
+    public static final Block MANGROVE_LOG_SLAB = registerFakeLogSlab(Blocks.MANGROVE_LOG, "mangrove", Blocks.MANGROVE_SLAB);
+    public static final Block STRIPPED_OAK_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_OAK_LOG, "oak", Blocks.OAK_SLAB, OAK_LOG_SLAB);
+    public static final Block STRIPPED_SPRUCE_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_SPRUCE_LOG, "spruce", Blocks.SPRUCE_SLAB, SPRUCE_LOG_SLAB);
+    public static final Block STRIPPED_BIRCH_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_BIRCH_LOG, "birch", Blocks.BIRCH_SLAB, BIRCH_LOG_SLAB);
+    public static final Block STRIPPED_JUNGLE_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_JUNGLE_LOG, "jungle", Blocks.JUNGLE_SLAB, JUNGLE_LOG_SLAB);
+    public static final Block STRIPPED_ACACIA_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_ACACIA_LOG, "acacia", Blocks.ACACIA_SLAB, ACACIA_LOG_SLAB);
+    public static final Block STRIPPED_DARK_OAK_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_DARK_OAK_LOG, "dark_oak", Blocks.DARK_OAK_SLAB, DARK_OAK_LOG_SLAB);
+    public static final Block STRIPPED_WARPED_STEM_SLAB = registerFakeStrippedStemSlab(Blocks.STRIPPED_WARPED_STEM, "warped", Blocks.WARPED_SLAB, WARPED_STEM_SLAB);
+    public static final Block STRIPPED_CRIMSON_STEM_SLAB = registerFakeStrippedStemSlab(Blocks.STRIPPED_CRIMSON_STEM, "crimson", Blocks.CRIMSON_SLAB, CRIMSON_STEM_SLAB);
+    public static final Block STRIPPED_MANGROVE_LOG_SLAB = registerFakeStrippedLogSlab(Blocks.STRIPPED_MANGROVE_LOG, "mangrove", Blocks.MANGROVE_SLAB, MANGROVE_LOG_SLAB);
+    public static final Block OAK_WOOD_SLAB = registerFakeWoodSlab(Blocks.OAK_WOOD, "oak", Blocks.OAK_SLAB);
+    public static final Block SPRUCE_WOOD_SLAB = registerFakeWoodSlab(Blocks.SPRUCE_WOOD, "spruce", Blocks.SPRUCE_SLAB);
+    public static final Block BIRCH_WOOD_SLAB = registerFakeWoodSlab(Blocks.BIRCH_WOOD, "birch", Blocks.BIRCH_SLAB);
+    public static final Block JUNGLE_WOOD_SLAB = registerFakeWoodSlab(Blocks.JUNGLE_WOOD, "jungle", Blocks.JUNGLE_SLAB);
+    public static final Block ACACIA_WOOD_SLAB = registerFakeWoodSlab(Blocks.ACACIA_WOOD, "acacia", Blocks.ACACIA_SLAB);
+    public static final Block DARK_OAK_WOOD_SLAB = registerFakeWoodSlab(Blocks.DARK_OAK_WOOD, "dark_oak", Blocks.DARK_OAK_SLAB);
+    public static final Block WARPED_HYPHAE_SLAB = registerFakeHyphaeSlab(Blocks.WARPED_HYPHAE, "warped", Blocks.WARPED_SLAB);
+    public static final Block CRIMSON_HYPHAE_SLAB = registerFakeHyphaeSlab(Blocks.CRIMSON_HYPHAE, "crimson", Blocks.CRIMSON_SLAB);
+    public static final Block MANGROVE_WOOD_SLAB = registerFakeWoodSlab(Blocks.MANGROVE_WOOD, "mangrove", Blocks.MANGROVE_SLAB);
+    public static final Block STRIPPED_OAK_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_OAK_WOOD, "oak", Blocks.OAK_SLAB, OAK_WOOD_SLAB);
+    public static final Block STRIPPED_SPRUCE_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_SPRUCE_WOOD, "spruce", Blocks.SPRUCE_SLAB, SPRUCE_WOOD_SLAB);
+    public static final Block STRIPPED_BIRCH_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_BIRCH_WOOD, "birch", Blocks.BIRCH_SLAB, BIRCH_WOOD_SLAB);
+    public static final Block STRIPPED_JUNGLE_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_JUNGLE_WOOD, "jungle", Blocks.JUNGLE_SLAB, JUNGLE_WOOD_SLAB);
+    public static final Block STRIPPED_ACACIA_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_ACACIA_WOOD, "acacia", Blocks.ACACIA_SLAB, ACACIA_WOOD_SLAB);
+    public static final Block STRIPPED_DARK_OAK_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_DARK_OAK_WOOD, "dark_oak", Blocks.DARK_OAK_SLAB, DARK_OAK_WOOD_SLAB);
+    public static final Block STRIPPED_WARPED_HYPHAE_SLAB = registerFakeStrippedHyphaeSlab(Blocks.STRIPPED_WARPED_HYPHAE, "warped", Blocks.WARPED_SLAB, WARPED_HYPHAE_SLAB);
+    public static final Block STRIPPED_CRIMSON_HYPHAE_SLAB = registerFakeStrippedHyphaeSlab(Blocks.STRIPPED_CRIMSON_HYPHAE, "crimson", Blocks.CRIMSON_SLAB, CRIMSON_HYPHAE_SLAB);
+    public static final Block STRIPPED_MANGROVE_WOOD_SLAB = registerFakeStrippedWoodSlab(Blocks.STRIPPED_MANGROVE_WOOD, "mangrove", Blocks.MANGROVE_SLAB, MANGROVE_WOOD_SLAB);
+    public static final Block BONE_SLAB = registerFakeSlab(Blocks.BONE_BLOCK, null, "bone", NamespacedKeyWithoutIntention.minecraft("bone_block"), NamespacedKeyWithoutIntention.minecraft("bone_block_side"), NamespacedKeyWithoutIntention.minecraft("bone_block_top"), null, null, null, Blocks.SMOOTH_QUARTZ_SLAB, null).mineableWithPickaxe();//registerFakeSlabFromYPillarVanillaBlock(Blocks.BONE_BLOCK, null, "bone", "bone_block", Blocks.SMOOTH_QUARTZ_SLAB).mineableWithPickaxe();
+
+    /**
+     * Based on {@link Blocks#BONE_BLOCK}
+     */
+    public static final Block WITHER_BONE_BLOCK = register(
+        "wither_bone_block",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHosts()
+            .withFallback(Blocks.COAL_BLOCK)
+            .withDefaultModelCreationsForRotatedPillarBlock()
+            .withFullBlockBoundingBoxItem(),
+        new RotatedPillarBlock(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BLACK).strength(2.0F).sound(SoundType.BONE_BLOCK)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomFurnaceRecipe(Blocks.BONE_BLOCK, 0.1F, 200, false);
+
+    public static final Block WITHER_BONE_SLAB = registerFakeSlabFromYPillarCustomBlock(WITHER_BONE_BLOCK, null, "wither_bone", "wither_bone_block", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
+    public static final Block BASALT_SLAB = registerFakeSlab(Blocks.BASALT, null, "basalt", NamespacedKeyWithoutIntention.minecraft("basalt"), NamespacedKeyWithoutIntention.minecraft("basalt_side"), NamespacedKeyWithoutIntention.minecraft("basalt_top"), null, null, null, Blocks.COBBLESTONE_SLAB, null).mineableWithPickaxe();
+    public static final Block POLISHED_BASALT_SLAB = registerFakeSlab(Blocks.POLISHED_BASALT, null, "polished_basalt", NamespacedKeyWithoutIntention.minecraft("polished_basalt"), NamespacedKeyWithoutIntention.minecraft("polished_basalt_side"), NamespacedKeyWithoutIntention.minecraft("polished_basalt_top"), null, null, null, Blocks.STONE_SLAB, null).mineableWithPickaxe();
+    public static final Block SMOOTH_BASALT_SLAB = registerFakeSlab(Blocks.SMOOTH_BASALT, "smooth_basalt", Blocks.COBBLED_DEEPSLATE_SLAB);
+
+    /**
+     * Based on {@link Blocks#COAL_BLOCK}
+     */
+    public static final Block CHARCOAL_BLOCK = register(
+        "charcoal_block",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.COAL_BLOCK)
+            .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.COLOR_BLACK).strength(5.0F, 6.0F)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustom3x3SquareRecipe("charcoal_block", () -> Items.CHARCOAL, 1, false);
+
+    public static final Block CHARCOAL_SLAB = registerFakeSlab(CHARCOAL_BLOCK, "charcoal", null, Blocks.BLACKSTONE_SLAB);
+
+    /**
+     * Based on {@link Blocks#LIGHT_GRAY_CONCRETE_POWDER}
+     */
+    public static final Block GUNPOWDER_BLOCK = register(
+        "gunpowder_block",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.LIGHT_GRAY_CONCRETE_POWDER)
+            .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.SAND, DyeColor.LIGHT_GRAY).strength(0.5F).sound(SoundType.SAND))/*.breakBeforeClientKnowsToBreak()*/.mineableWithShovel(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustom2x2SquareRecipe("gunpowder_block", () -> Items.GUNPOWDER, 1, false);
+
+    public static final Block GUNPOWDER_SLAB = registerFakeSlab(GUNPOWDER_BLOCK, "gunpowder", null, Blocks.SMOOTH_STONE_SLAB);
+    public static final Block PEAT = registerPeat(null, false, null).withFutureCustomRecipe(() -> {
+        var leafIngredientChoice = StreamSupport.stream(Registry.BLOCK.getTagOrEmpty(BlockTags.LEAVES).spliterator(), false).map(holder -> holder.value()).map(block -> block.asItem()).toArray(ItemLike[]::new);
+        var recipeKey = ResourceLocation.sucraft("dirt_and_leaves_to_peat");
+        return new Item.CustomChoiceShapedRecipe(
+            recipeKey,
+            null,
+            false,
+            new Item.CustomChoiceShapedRecipeIngredientDefinition[]{
+                new Item.CustomChoiceShapedRecipeIngredientDefinition('$', leafIngredientChoice),
+                new Item.CustomChoiceShapedRecipeIngredientDefinition('%', new ItemLike[] {Items.DIRT})
+            },
+            new String[] {"$%", "%$"},
+            Arrays.stream(leafIngredientChoice).map(ingredient -> new Item.CustomRecipeUnlockByItem(() -> ingredient)).toArray(Item.CustomRecipeUnlock[]::new),
+            2
+        );
+    });
+    public static final Block SMOULDERING_PEAT = registerPeat("smouldering", true, PEAT);
+    public static final Block PEAT_SLAB = registerFakeSlab(PEAT, "peat", null, Blocks.MUD_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithShovel().peatSlab();
+    // Not included in initial release
+//    public static final Block SCULK_SLAB = registerFakeSlab(Blocks.SCULK, "sculk", Blocks.BLACKSTONE_SLAB).breakBeforeClientKnowsToBreak().mineableWithHoe();
+    public static final Block CHISELED_QUARTZ_SLAB = registerFakeSlabFromYPillarVanillaBlock(Blocks.CHISELED_QUARTZ_BLOCK, null, "chiseled_quartz", "chiseled_quartz_block", Blocks.QUARTZ_SLAB).mineableWithPickaxe();
+    public static final Block QUARTZ_PILLAR_SLAB = registerFakeVanillaStonePillarSlab(Blocks.QUARTZ_PILLAR, "quartz", Blocks.QUARTZ_SLAB);
+    public static final Block QUARTZ_BRICK_SLAB = registerFakeVanillaBrickSlab(Blocks.QUARTZ_BRICKS, "quartz", Blocks.QUARTZ_SLAB);
+    // Not included in initial release
+//    public static final Block DRIED_KELP_SLAB = registerFakeSlab(Blocks.DRIED_KELP_BLOCK, null, "dried_kelp", NamespacedKeyWithoutIntention.minecraft("dried_kelp_block"), NamespacedKeyWithoutIntention.minecraft("dried_kelp_side"), NamespacedKeyWithoutIntention.minecraft("dried_kelp_bottom"), NamespacedKeyWithoutIntention.minecraft("dried_kelp_top"), NamespacedKeyWithoutIntention.minecraft("dried_kelp_bottom"), NamespacedKeyWithoutIntention.minecraft("dried_kelp_top"), Blocks.DARK_PRISMARINE_SLAB, null).mineableWithHoe();
+    public static final Block RED_FIRE = registerFire("red", Blocks.FIRE, DyeColor.RED.getMaterialColor());
+    public static final Block ORANGE_FIRE = registerFire("orange", Blocks.FIRE, DyeColor.ORANGE.getMaterialColor());
+    public static final Block YELLOW_FIRE = registerFire("yellow", Blocks.FIRE, DyeColor.YELLOW.getMaterialColor());
+    public static final Block LIME_FIRE = registerFire("lime", Blocks.SOUL_FIRE, DyeColor.LIME.getMaterialColor());
+    public static final Block GREEN_FIRE = registerFire("green", Blocks.SOUL_FIRE, DyeColor.GREEN.getMaterialColor());
+    public static final Block CYAN_FIRE = registerFire("cyan", Blocks.SOUL_FIRE, DyeColor.CYAN.getMaterialColor());
+    public static final Block LIGHT_BLUE_FIRE = registerFire("light_blue", Blocks.SOUL_FIRE, DyeColor.LIGHT_BLUE.getMaterialColor());
+    public static final Block BLUE_FIRE = registerFire("blue", Blocks.SOUL_FIRE, DyeColor.BLUE.getMaterialColor());
+    public static final Block BLACK_FIRE = registerFire("black", Blocks.SOUL_FIRE, DyeColor.BLACK.getMaterialColor());
+    public static final Block GRAY_FIRE = registerFire("gray", Blocks.SOUL_FIRE, DyeColor.GRAY.getMaterialColor());
+    public static final Block LIGHT_GRAY_FIRE = registerFire("light_gray", Blocks.SOUL_FIRE, DyeColor.LIGHT_GRAY.getMaterialColor());
+    public static final Block WHITE_FIRE = registerFire("white", Blocks.SOUL_FIRE, DyeColor.WHITE.getMaterialColor());
+    public static final Block BROWN_FIRE = registerFire("brown", Blocks.FIRE, DyeColor.BROWN.getMaterialColor());
+    public static final Block PURPLE_FIRE = registerFire("purple", Blocks.SOUL_FIRE, DyeColor.PURPLE.getMaterialColor());
+    public static final Block MAGENTA_FIRE = registerFire("magenta", Blocks.SOUL_FIRE, DyeColor.MAGENTA.getMaterialColor());
+    public static final Block PINK_FIRE = registerFire("pink", Blocks.FIRE, DyeColor.PINK.getMaterialColor());
+    public static final Block PAPER_BLOCK = register(
+        "paper_block",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.WHITE_WOOL)
+            .withModelCreation(Model.YPillarCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.WOOL, DyeColor.WHITE).strength(0.5F).sound(SoundType.SNOW))/*.breakBeforeClientKnowsToBreak()*/.mineableWithAxe(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustom3x3SquareRecipe("paper_block", () -> Items.PAPER, 1, false);
+    public static final Block PAPER_SLAB = registerFakeSlabFromYPillarCustomBlock(PAPER_BLOCK, null, "paper", "paper_block", Blocks.SMOOTH_QUARTZ_SLAB).breakBeforeClientKnowsToBreak().mineableWithAxe();
+
+    /**
+     * Based on {@link Blocks#CHISELED_QUARTZ_BLOCK}
+     */
+    public static final Block QUARTZ_SPIRAL_MEANDER = register(
+        "quartz_spiral_meander",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.CHISELED_QUARTZ_BLOCK)
+            .withModelCreation(Model.creation(ModelContent.OneTextureCube.creation(new Texture(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("chiseled_quartz_block_top"), TextureContent.Existing.getInstance()))).withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.STONE, MaterialColor.QUARTZ).strength(0.8F)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    );
+
+    public static final Block QUARTZ_SPIRAL_MEANDER_SLAB = registerFakeSlab(QUARTZ_SPIRAL_MEANDER, null, "quartz_spiral_meander", NamespacedKeyWithoutIntention.sucraft("quartz_spiral_meander"), NamespacedKeyWithoutIntention.minecraft("chiseled_quartz_block_top"), null, null, null, null, Blocks.QUARTZ_SLAB, null).mineableWithPickaxe();
+    // Not included in initial release
+//    public static final Block ENDER_PEARL_BLOCK = register(
+//        "ender_pearl_block",
+//        new SingleMultiStateRealBlockReplacementRuleBuilder()
+//            .withNoteBlockHost()
+//            .withFallback(Blocks.WARPED_PLANKS)
+//            .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+//            .withFullBlockBoundingBoxItem(),
+//        new Block(BlockBehaviour.Properties.of(Material.METAL, MaterialColor.COLOR_CYAN).strength(1.5F, 3.0F)).mineableWithPickaxe(),
+//        SuCraftBlockLoot::dropSelf
+//    ).withCustom2x2SquareRecipe("ender_pearl_block", () -> Items.ENDER_PEARL, 1);
+    public static final Block FLINT_BLOCK = register(
+        "flint_block",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.DEEPSLATE_TILES)
+            .withModelCreation(Model.YPillarCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.METAL, MaterialColor.COLOR_GRAY).strength(3.5F, 6.0F)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustom2x2SquareRecipe("flint_block", () -> Items.FLINT, 1, false);
+    public static final Block FLINT_PILLAR = register(
+        "flint_pillar",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHosts()
+            .withDirectionalAnalogousPillarFallbacks(Blocks.POLISHED_BASALT)
+            .withDefaultModelCreationsForDirectionalBlock()
+            .withFullBlockBoundingBoxItem(),
+        new ConcreteDirectionalBlock(BlockBehaviour.Properties.of(Material.METAL, MaterialColor.COLOR_GRAY).strength(3.5F, 6.0F)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomOneToOneStonecutterRecipe(FLINT_BLOCK).withCustom2VerticalChoiceRecipe("flint_blocks_to_flint_pillar", () -> new ItemLike[] {SuCraftItems.FLINT_BLOCK}, 2, true);
+    public static final Block FLINT_PILLAR_SLAB = registerFakeSlabFromYPillarCustomBlock(FLINT_PILLAR, null, "flint_pillar", Blocks.DEEPSLATE_TILE_SLAB).mineableWithPickaxe();
+    public static final Block FLINT_TILES = register(
+        "flint_tiles",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHost()
+            .withFallback(Blocks.DEEPSLATE_TILES)
+            .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+            .withFullBlockBoundingBoxItem(),
+        new Block(BlockBehaviour.Properties.of(Material.METAL, MaterialColor.COLOR_GRAY).strength(3.5F, 6.0F)).mineableWithPickaxe(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustomOneToOneStonecutterRecipe(FLINT_BLOCK).withCustom2x2SquareRecipe("flint_tiles", FLINT_BLOCK, 4, true);
+    public static final Block FLINT_TILE_SLAB = registerFakeSlab(FLINT_TILES, "flint_tile", null, Blocks.DEEPSLATE_TILE_SLAB).mineableWithPickaxe();
+    public static final Block OBSIDIAN_SLAB = registerFakeSlab(Blocks.OBSIDIAN, "obsidian", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
+    public static final Block CRYING_OBSIDIAN_SLAB = registerFakeSlab(Blocks.CRYING_OBSIDIAN, "crying_obsidian", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
+    public static final Block GILDED_BLACKSTONE_SLAB = registerFakeSlab(Blocks.GILDED_BLACKSTONE, "gilded_blackstone", Blocks.BLACKSTONE_SLAB).mineableWithPickaxe();
+    public static final Block SNOWY_STONE_BRICK_STAIRS = registerFakeStairs(SNOWY_STONE_BRICKS, "snowy_stone_brick", null, Blocks.STONE_BRICK_STAIRS).stoneBrickStairs();
+    public static final Block DIRTY_STONE_BRICK_STAIRS = registerFakeStairs(DIRTY_STONE_BRICKS, "dirty_stone_brick", null, Blocks.STONE_BRICK_STAIRS).stoneBrickStairs();
+    public static final Block CRACKED_STONE_BRICK_STAIRS = registerFakeStairs(Blocks.CRACKED_STONE_BRICKS, "cracked_stone_brick", "cracked_stone_bricks", Blocks.STONE_BRICK_STAIRS).stoneBrickStairs();
+    public static final Block AMETHYST_STAIRS = registerFakeStairs(Blocks.AMETHYST_BLOCK, "amethyst", "amethyst_block", Blocks.PURPUR_STAIRS).mineableWithPickaxe().crystalSound();
+    public static final Block COAL_STAIRS = registerFakeStairs(Blocks.COAL_BLOCK, "coal", "coal_block", Blocks.BLACKSTONE_STAIRS).mineableWithPickaxe();
+    public static final Block DRIPSTONE_STAIRS = registerFakeStairs(Blocks.DRIPSTONE_BLOCK, "dripstone", "dripstone_block", Blocks.GRANITE_STAIRS).mineableWithPickaxe();
+    public static final Block DIRT_BRICK_STAIRS = registerFakeStairs(DIRT_BRICKS, "dirt_brick", null, Blocks.MUD_BRICK_STAIRS).breakBeforeClientKnowsToBreak().mineableWithShovel().dirt();
+    public static final Block CHARCOAL_STAIRS = registerFakeStairs(CHARCOAL_BLOCK, "charcoal", null, Blocks.BLACKSTONE_STAIRS);
+    public static final Block GUNPOWDER_STAIRS = registerFakeStairs(GUNPOWDER_BLOCK, "gunpowder", null, Blocks.ANDESITE_STAIRS);
+    public static final Block PEAT_STAIRS = registerFakeStairs(PEAT, "peat", null, Blocks.MUD_BRICK_STAIRS).breakBeforeClientKnowsToBreak().mineableWithShovel().peatStairs();
+    public static final Block FLINT_TILE_STAIRS = registerFakeStairs(FLINT_TILES, "flint_tile", null, Blocks.DEEPSLATE_TILE_STAIRS).mineableWithPickaxe();
+    public static final Block BLACK_PLANK_STAIRS = registerFakeDyedPlankStairs(BLACK_PLANKS, "black", Blocks.DARK_OAK_STAIRS, () -> Items.BLACK_DYE);
+    public static final Block BLUE_PLANK_STAIRS = registerFakeDyedPlankStairs(BLUE_PLANKS, "blue", Blocks.WARPED_STAIRS, () -> Items.BLUE_DYE);
+    public static final Block BROWN_PLANK_STAIRS = registerFakeDyedPlankStairs(BROWN_PLANKS, "brown", Blocks.SPRUCE_STAIRS, () -> Items.BROWN_DYE);
+    public static final Block CYAN_PLANK_STAIRS = registerFakeDyedPlankStairs(CYAN_PLANKS, "cyan", Blocks.WARPED_STAIRS, () -> Items.CYAN_DYE);
+    public static final Block GRAY_PLANK_STAIRS = registerFakeDyedPlankStairs(GRAY_PLANKS, "gray", Blocks.SPRUCE_STAIRS, () -> Items.GRAY_DYE);
+    public static final Block GREEN_PLANK_STAIRS = registerFakeDyedPlankStairs(GREEN_PLANKS, "green", Blocks.WARPED_STAIRS, () -> Items.GREEN_DYE);
+    public static final Block LIGHT_BLUE_PLANK_STAIRS = registerFakeDyedPlankStairs(LIGHT_BLUE_PLANKS, "light_blue", Blocks.WARPED_STAIRS, () -> Items.LIGHT_BLUE_DYE);
+    public static final Block LIGHT_GRAY_PLANK_STAIRS = registerFakeDyedPlankStairs(LIGHT_GRAY_PLANKS, "light_gray", Blocks.OAK_STAIRS, () -> Items.LIGHT_GRAY_DYE);
+    public static final Block LIME_PLANK_STAIRS = registerFakeDyedPlankStairs(LIME_PLANKS, "lime", Blocks.WARPED_STAIRS, () -> Items.LIME_DYE);
+    public static final Block MAGENTA_PLANK_STAIRS = registerFakeDyedPlankStairs(MAGENTA_PLANKS, "magenta", Blocks.CRIMSON_STAIRS, () -> Items.MAGENTA_DYE);
+    public static final Block ORANGE_PLANK_STAIRS = registerFakeDyedPlankStairs(ORANGE_PLANKS, "orange", Blocks.ACACIA_STAIRS, () -> Items.ORANGE_DYE);
+    public static final Block PINK_PLANK_STAIRS = registerFakeDyedPlankStairs(PINK_PLANKS, "pink", Blocks.JUNGLE_STAIRS, () -> Items.PINK_DYE);
+    public static final Block PURPLE_PLANK_STAIRS = registerFakeDyedPlankStairs(PURPLE_PLANKS, "purple", Blocks.CRIMSON_STAIRS, () -> Items.PURPLE_DYE);
+    public static final Block RED_PLANK_STAIRS = registerFakeDyedPlankStairs(RED_PLANKS, "red", Blocks.MANGROVE_STAIRS, () -> Items.RED_DYE);
+    public static final Block WHITE_PLANK_STAIRS = registerFakeDyedPlankStairs(WHITE_PLANKS, "white", Blocks.BIRCH_STAIRS, () -> Items.WHITE_DYE);
+    public static final Block YELLOW_PLANK_STAIRS = registerFakeDyedPlankStairs(YELLOW_PLANKS, "yellow", Blocks.BIRCH_STAIRS, () -> Items.YELLOW_DYE);
+    public static final Block BLACK_WOOL_STAIRS = registerFakeWoolStairs(Blocks.BLACK_WOOL, "black", Blocks.BLACKSTONE_STAIRS);
+    public static final Block BLUE_WOOL_STAIRS = registerFakeWoolStairs(Blocks.BLUE_WOOL, "blue", Blocks.WARPED_STAIRS);
+    public static final Block BROWN_WOOL_STAIRS = registerFakeWoolStairs(Blocks.BROWN_WOOL, "brown", Blocks.SPRUCE_STAIRS);
+    public static final Block CYAN_WOOL_STAIRS = registerFakeWoolStairs(Blocks.CYAN_WOOL, "cyan", Blocks.WARPED_STAIRS);
+    public static final Block GRAY_WOOL_STAIRS = registerFakeWoolStairs(Blocks.GRAY_WOOL, "gray", Blocks.STONE_STAIRS);
+    public static final Block GREEN_WOOL_STAIRS = registerFakeWoolStairs(Blocks.GREEN_WOOL, "green", Blocks.DARK_PRISMARINE_STAIRS);
+    public static final Block LIGHT_BLUE_WOOL_STAIRS = registerFakeWoolStairs(Blocks.LIGHT_BLUE_WOOL, "light_blue", Blocks.PRISMARINE_BRICK_STAIRS);
+    public static final Block LIGHT_GRAY_WOOL_STAIRS = registerFakeWoolStairs(Blocks.LIGHT_GRAY_WOOL, "light_gray", Blocks.ANDESITE_STAIRS);
+    public static final Block LIME_WOOL_STAIRS = registerFakeWoolStairs(Blocks.LIME_WOOL, "lime", Blocks.OXIDIZED_CUT_COPPER_STAIRS);
+    public static final Block MAGENTA_WOOL_STAIRS = registerFakeWoolStairs(Blocks.MAGENTA_WOOL, "magenta", Blocks.PURPUR_STAIRS);
+    public static final Block ORANGE_WOOL_STAIRS = registerFakeWoolStairs(Blocks.ORANGE_WOOL, "orange", Blocks.SMOOTH_RED_SANDSTONE_STAIRS);
+    public static final Block PINK_WOOL_STAIRS = registerFakeWoolStairs(Blocks.PINK_WOOL, "pink", Blocks.PURPUR_STAIRS);
+    public static final Block PURPLE_WOOL_STAIRS = registerFakeWoolStairs(Blocks.PURPLE_WOOL, "purple", Blocks.PURPUR_STAIRS);
+    public static final Block RED_WOOL_STAIRS = registerFakeWoolStairs(Blocks.RED_WOOL, "red", Blocks.MANGROVE_STAIRS);
+    public static final Block WHITE_WOOL_STAIRS = registerFakeWoolStairs(Blocks.WHITE_WOOL, "white", Blocks.SMOOTH_QUARTZ_STAIRS);
+    public static final Block YELLOW_WOOL_STAIRS = registerFakeWoolStairs(Blocks.YELLOW_WOOL, "yellow", Blocks.BIRCH_STAIRS);
+    public static final Block BLACK_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.BLACK_CONCRETE, "black", Blocks.BLACKSTONE_STAIRS);
+    public static final Block BLUE_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.BLUE_CONCRETE, "blue", Blocks.WARPED_STAIRS);
+    public static final Block BROWN_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.BROWN_CONCRETE, "brown", Blocks.SPRUCE_STAIRS);
+    public static final Block CYAN_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.CYAN_CONCRETE, "cyan", Blocks.WARPED_STAIRS);
+    public static final Block GRAY_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.GRAY_CONCRETE, "gray", Blocks.STONE_STAIRS);
+    public static final Block GREEN_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.GREEN_CONCRETE, "green", Blocks.DARK_PRISMARINE_STAIRS);
+    public static final Block LIGHT_BLUE_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.LIGHT_BLUE_CONCRETE, "light_blue", Blocks.PRISMARINE_BRICK_STAIRS);
+    public static final Block LIGHT_GRAY_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.LIGHT_GRAY_CONCRETE, "light_gray", Blocks.ANDESITE_STAIRS);
+    public static final Block LIME_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.LIME_CONCRETE, "lime", Blocks.OXIDIZED_CUT_COPPER_STAIRS);
+    public static final Block MAGENTA_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.MAGENTA_CONCRETE, "magenta", Blocks.PURPUR_STAIRS);
+    public static final Block ORANGE_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.ORANGE_CONCRETE, "orange", Blocks.SMOOTH_RED_SANDSTONE_STAIRS);
+    public static final Block PINK_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.PINK_CONCRETE, "pink", Blocks.PURPUR_STAIRS);
+    public static final Block PURPLE_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.PURPLE_CONCRETE, "purple", Blocks.PURPUR_STAIRS);
+    public static final Block RED_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.RED_CONCRETE, "red", Blocks.MANGROVE_STAIRS);
+    public static final Block WHITE_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.WHITE_CONCRETE, "white", Blocks.SMOOTH_QUARTZ_STAIRS);
+    public static final Block YELLOW_CONCRETE_STAIRS = registerFakeConcreteStairs(Blocks.YELLOW_CONCRETE, "yellow", Blocks.BIRCH_STAIRS);
+    public static final Block BLACK_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.BLACK_CONCRETE_POWDER, "black", Blocks.BLACKSTONE_STAIRS);
+    public static final Block BLUE_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.BLUE_CONCRETE_POWDER, "blue", Blocks.WARPED_STAIRS);
+    public static final Block BROWN_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.BROWN_CONCRETE_POWDER, "brown", Blocks.SPRUCE_STAIRS);
+    public static final Block CYAN_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.CYAN_CONCRETE_POWDER, "cyan", Blocks.WARPED_STAIRS);
+    public static final Block GRAY_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.GRAY_CONCRETE_POWDER, "gray", Blocks.STONE_STAIRS);
+    public static final Block GREEN_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.GREEN_CONCRETE_POWDER, "green", Blocks.DARK_PRISMARINE_STAIRS);
+    public static final Block LIGHT_BLUE_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.LIGHT_BLUE_CONCRETE_POWDER, "light_blue", Blocks.PRISMARINE_BRICK_STAIRS);
+    public static final Block LIGHT_GRAY_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.LIGHT_GRAY_CONCRETE_POWDER, "light_gray", Blocks.ANDESITE_STAIRS);
+    public static final Block LIME_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.LIME_CONCRETE_POWDER, "lime", Blocks.OXIDIZED_CUT_COPPER_STAIRS);
+    public static final Block MAGENTA_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.MAGENTA_CONCRETE_POWDER, "magenta", Blocks.PURPUR_STAIRS);
+    public static final Block ORANGE_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.ORANGE_CONCRETE_POWDER, "orange", Blocks.SMOOTH_RED_SANDSTONE_STAIRS);
+    public static final Block PINK_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.PINK_CONCRETE_POWDER, "pink", Blocks.PURPUR_STAIRS);
+    public static final Block PURPLE_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.PURPLE_CONCRETE_POWDER, "purple", Blocks.PURPUR_STAIRS);
+    public static final Block RED_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.RED_CONCRETE_POWDER, "red", Blocks.MANGROVE_STAIRS);
+    public static final Block WHITE_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.WHITE_CONCRETE_POWDER, "white", Blocks.SMOOTH_QUARTZ_STAIRS);
+    public static final Block YELLOW_CONCRETE_POWDER_STAIRS = registerFakeConcretePowderStairs(Blocks.YELLOW_CONCRETE_POWDER, "yellow", Blocks.BIRCH_STAIRS);
+    public static final Block BLACK_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.BLACK_TERRACOTTA, "black", Blocks.BLACKSTONE_STAIRS);
+    public static final Block BLUE_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.BLUE_TERRACOTTA, "blue", Blocks.POLISHED_BLACKSTONE_STAIRS);
+    public static final Block BROWN_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.BROWN_TERRACOTTA, "brown", Blocks.DARK_OAK_STAIRS);
+    public static final Block CYAN_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.CYAN_TERRACOTTA, "cyan", Blocks.STONE_STAIRS);
+    public static final Block GRAY_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.GRAY_TERRACOTTA, "gray", Blocks.DARK_OAK_STAIRS);
+    public static final Block GREEN_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.GREEN_TERRACOTTA, "green", Blocks.DARK_PRISMARINE_STAIRS);
+    public static final Block LIGHT_BLUE_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.LIGHT_BLUE_TERRACOTTA, "light_blue", Blocks.STONE_STAIRS);
+    public static final Block LIGHT_GRAY_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.LIGHT_GRAY_TERRACOTTA, "light_gray", Blocks.JUNGLE_STAIRS);
+    public static final Block LIME_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.LIME_TERRACOTTA, "lime", Blocks.DARK_PRISMARINE_STAIRS);
+    public static final Block MAGENTA_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.MAGENTA_TERRACOTTA, "magenta", Blocks.PURPUR_STAIRS);
+    public static final Block ORANGE_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.ORANGE_TERRACOTTA, "orange", Blocks.SMOOTH_RED_SANDSTONE_STAIRS);
+    public static final Block PINK_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.PINK_TERRACOTTA, "pink", Blocks.MANGROVE_STAIRS);
+    public static final Block PURPLE_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.PURPLE_TERRACOTTA, "purple", Blocks.PURPUR_STAIRS);
+    public static final Block RED_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.RED_TERRACOTTA, "red", Blocks.MANGROVE_STAIRS);
+    public static final Block WHITE_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.WHITE_TERRACOTTA, "white", Blocks.SMOOTH_QUARTZ_STAIRS);
+    public static final Block YELLOW_TERRACOTTA_STAIRS = registerFakeTerracottaStairs(Blocks.YELLOW_TERRACOTTA, "yellow", Blocks.OAK_STAIRS);
+    public static final Block POLISHED_CALCITE_STAIRS = registerFakePolishedStairs(POLISHED_CALCITE, "calcite", Blocks.QUARTZ_STAIRS);
+    public static final Block POLISHED_DRIPSTONE_STAIRS = registerFakePolishedStairs(POLISHED_DRIPSTONE, "dripstone", Blocks.POLISHED_GRANITE_STAIRS);
+    public static final Block POLISHED_TUFF_STAIRS = registerFakePolishedStairs(POLISHED_TUFF, "tuff", Blocks.ANDESITE_STAIRS);
+    public static final Block ANDESITE_BRICK_STAIRS = registerFakeCustomBrickStairs(ANDESITE_BRICKS, "andesite", Blocks.POLISHED_ANDESITE_STAIRS);
+    public static final Block CALCITE_BRICK_STAIRS = registerFakeCustomBrickStairs(CALCITE_BRICKS, "calcite", Blocks.QUARTZ_STAIRS);
+    public static final Block DIORITE_BRICK_STAIRS = registerFakeCustomBrickStairs(DIORITE_BRICKS, "diorite", Blocks.POLISHED_DIORITE_STAIRS);
+    public static final Block DRIPSTONE_BRICK_STAIRS = registerFakeCustomBrickStairs(DRIPSTONE_BRICKS, "dripstone", Blocks.POLISHED_GRANITE_STAIRS);
+    public static final Block GRANITE_BRICK_STAIRS = registerFakeCustomBrickStairs(GRANITE_BRICKS, "granite", Blocks.POLISHED_GRANITE_STAIRS);
+    public static final Block TUFF_BRICK_STAIRS = registerFakeCustomBrickStairs(TUFF_BRICKS, "tuff", Blocks.STONE_BRICK_STAIRS);
+    public static final Block QUARTZ_BRICK_STAIRS = registerFakeVanillaBrickStairs(Blocks.QUARTZ_BRICKS, "quartz", Blocks.QUARTZ_STAIRS);
+    public static final Block SANDSTONE_BRICK_STAIRS = registerFakeSandstoneBrickStairs(SANDSTONE_BRICKS, null, Blocks.SANDSTONE_STAIRS);
+    public static final Block RED_SANDSTONE_BRICK_STAIRS = registerFakeSandstoneBrickStairs(RED_SANDSTONE_BRICKS, "red", Blocks.RED_SANDSTONE_STAIRS);
+    public static final Block SOUL_SANDSTONE_BRICK_STAIRS = registerFakeSandstoneBrickStairs(SOUL_SANDSTONE_BRICKS, "soul", Blocks.DARK_OAK_STAIRS).soulSpeed().soulFireBase();
+    public static final Block RAW_COPPER_STAIRS = registerFakeRawMetalStairs(Blocks.RAW_COPPER_BLOCK, "copper", Blocks.CUT_COPPER_STAIRS);
+    public static final Block RAW_GOLD_STAIRS = registerFakeRawMetalStairs(Blocks.RAW_GOLD_BLOCK, "gold", Blocks.OAK_STAIRS).guardedByPiglins();
+    public static final Block RAW_IRON_STAIRS = registerFakeRawMetalStairs(Blocks.RAW_IRON_BLOCK, "iron", Blocks.JUNGLE_STAIRS);
+    public static final Block DIRT_STAIRS = registerFakeStairs(Blocks.DIRT, "dirt", Blocks.MUD_BRICK_STAIRS).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block COARSE_DIRT_STAIRS = registerFakeStairs(Blocks.COARSE_DIRT, "coarse_dirt", Blocks.MUD_BRICK_STAIRS).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block SAND_STAIRS = registerFakeFallingStairs(Blocks.SAND, null, "sand", "sand", Blocks.SANDSTONE_STAIRS, null).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block RED_SAND_STAIRS = registerFakeFallingStairs(Blocks.RED_SAND, null, "red_sand", "red_sand", Blocks.RED_SANDSTONE_STAIRS, null).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block CLAY_STAIRS = registerFakeStairs(Blocks.CLAY, "clay", Blocks.ANDESITE_STAIRS).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block MUD_STAIRS = registerFakeStairs(Blocks.MUD, "mud", Blocks.POLISHED_BLACKSTONE_STAIRS).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block PACKED_MUD_STAIRS = registerFakeStairs(Blocks.PACKED_MUD, "packed_mud", Blocks.MUD_BRICK_STAIRS).breakBeforeClientKnowsToBreak().mineableWithPickaxe();
+    public static final Block CALCITE_STAIRS = registerFakeStairs(Blocks.CALCITE, "calcite", Blocks.SMOOTH_QUARTZ_STAIRS).mineableWithPickaxe();
+    public static final Block TUFF_STAIRS = registerFakeStairs(Blocks.TUFF, "tuff", Blocks.COBBLESTONE_STAIRS).mineableWithPickaxe();
+    public static final Block GRAVEL_STAIRS = registerFakeFallingStairs(Blocks.GRAVEL, null, "gravel", "gravel", Blocks.ANDESITE_STAIRS, null).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    public static final Block NETHERRACK_STAIRS = registerFakeStairs(Blocks.NETHERRACK, "netherrack", Blocks.RED_NETHER_BRICK_STAIRS).breakBeforeClientKnowsToBreak().mineableWithPickaxe();
+    public static final Block SOUL_SOIL_STAIRS = registerFakeStairs(Blocks.SOUL_SOIL, "soul_soil", Blocks.DARK_OAK_STAIRS).breakBeforeClientKnowsToBreak().mineableWithShovel().soulSpeed().soulFireBase();
+    public static final Block SMOOTH_BASALT_STAIRS = registerFakeStairs(Blocks.SMOOTH_BASALT, "smooth_basalt", Blocks.COBBLED_DEEPSLATE_STAIRS);
+    // Not included in initial release
+//    public static final Block SCULK_STAIRS = registerFakeStairs(Blocks.SCULK, "sculk", Blocks.BLACKSTONE_STAIRS).breakBeforeClientKnowsToBreak().mineableWithHoe();
+    public static final Block OBSIDIAN_STAIRS = registerFakeStairs(Blocks.OBSIDIAN, "obsidian", Blocks.BLACKSTONE_STAIRS).mineableWithPickaxe();
+    public static final Block CRYING_OBSIDIAN_STAIRS = registerFakeStairs(Blocks.CRYING_OBSIDIAN, "crying_obsidian", Blocks.BLACKSTONE_STAIRS).mineableWithPickaxe();
+    public static final Block GILDED_BLACKSTONE_STAIRS = registerFakeStairs(Blocks.GILDED_BLACKSTONE, "gilded_blackstone", Blocks.BLACKSTONE_STAIRS).mineableWithPickaxe();
+    public static final Block SOUL_SANDSTONE_STAIRS = registerFakeStairs(SOUL_SANDSTONE, null, "soul_sandstone", NamespacedKeyWithoutIntention.sucraft("soul_sandstone"), null, NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), Blocks.DARK_OAK_STAIRS, null).mineableWithPickaxe().soulSpeed().soulFireBase();
+    public static final Block SMOOTH_SOUL_SANDSTONE_STAIRS = registerFakeStairs(SMOOTH_SOUL_SANDSTONE, null, "smooth_soul_sandstone", NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), null, null, Blocks.DARK_OAK_STAIRS, null).mineableWithPickaxe().soulSpeed().soulFireBase();
+    public static final Block CUT_SOUL_SANDSTONE_STAIRS = registerFakeStairs(CUT_SOUL_SANDSTONE, null, "cut_soul_sandstone", NamespacedKeyWithoutIntention.sucraft("cut_soul_sandstone"), NamespacedKeyWithoutIntention.sucraft("soul_sandstone_top"), null, Blocks.DARK_OAK_STAIRS, null).mineableWithPickaxe().soulSpeed().soulFireBase();
+    public static final Block ANCIENT_DEBRIS_STAIRS = registerFakeStairs(Blocks.ANCIENT_DEBRIS, null, "ancient_debris", NamespacedKeyWithoutIntention.minecraft("ancient_debris_side"), NamespacedKeyWithoutIntention.minecraft("ancient_debris_top"), null, Blocks.POLISHED_GRANITE_STAIRS, null).mineableWithPickaxe();
+    public static final Block QUARTZ_SPIRAL_MEANDER_STAIRS = registerFakeStairs(QUARTZ_SPIRAL_MEANDER, null, "quartz_spiral_meander", NamespacedKeyWithoutIntention.minecraft("chiseled_quartz_block_top"), null, null, Blocks.QUARTZ_STAIRS, null).mineableWithPickaxe();
+    public static final Block CHISELED_QUARTZ_STAIRS = registerFakeStairsFromYPillarVanillaBlock(Blocks.CHISELED_QUARTZ_BLOCK, null, "chiseled_quartz", "chiseled_quartz_block", Blocks.QUARTZ_STAIRS).mineableWithPickaxe();
+    public static final Block WITHER_BONE_STAIRS = registerFakeStairsFromYPillarCustomBlock(WITHER_BONE_BLOCK, null, "wither_bone", "wither_bone_block", Blocks.BLACKSTONE_STAIRS).mineableWithPickaxe();
+    public static final Block PAPER_STAIRS = registerFakeStairsFromYPillarCustomBlock(PAPER_BLOCK, null, "paper", "paper_block", Blocks.SMOOTH_QUARTZ_STAIRS).breakBeforeClientKnowsToBreak().mineableWithAxe();
+    public static final Block FLINT_PILLAR_STAIRS = registerFakeStairsFromYPillarCustomBlock(FLINT_PILLAR, null, "flint_pillar", Blocks.DEEPSLATE_TILE_STAIRS).mineableWithPickaxe();
+    public static final Block OAK_BOOKSHELF_STAIRS = registerFakeBookshelfStairs(Blocks.BOOKSHELF, "oak", Blocks.OAK_STAIRS);
+    public static final Block SPRUCE_BOOKSHELF_STAIRS = registerFakeBookshelfStairs(SPRUCE_BOOKSHELF, "spruce", Blocks.SPRUCE_STAIRS);
+    public static final Block BIRCH_BOOKSHELF_STAIRS = registerFakeBookshelfStairs(BIRCH_BOOKSHELF, "birch", Blocks.BIRCH_STAIRS);
+    public static final Block JUNGLE_BOOKSHELF_STAIRS = registerFakeBookshelfStairs(JUNGLE_BOOKSHELF, "jungle", Blocks.JUNGLE_STAIRS);
+    public static final Block OAK_LOG_STAIRS = registerFakeLogStairs(Blocks.OAK_LOG, "oak", Blocks.OAK_STAIRS);
+    public static final Block SPRUCE_LOG_STAIRS = registerFakeLogStairs(Blocks.SPRUCE_LOG, "spruce", Blocks.SPRUCE_STAIRS);
+    public static final Block BIRCH_LOG_STAIRS = registerFakeLogStairs(Blocks.BIRCH_LOG, "birch", Blocks.BIRCH_STAIRS);
+    public static final Block JUNGLE_LOG_STAIRS = registerFakeLogStairs(Blocks.JUNGLE_LOG, "jungle", Blocks.JUNGLE_STAIRS);
+    public static final Block ACACIA_LOG_STAIRS = registerFakeLogStairs(Blocks.ACACIA_LOG, "acacia", Blocks.ACACIA_STAIRS);
+    public static final Block DARK_OAK_LOG_STAIRS = registerFakeLogStairs(Blocks.DARK_OAK_LOG, "dark_oak", Blocks.DARK_OAK_STAIRS);
+    public static final Block WARPED_STEM_STAIRS = registerFakeStemStairs(Blocks.WARPED_STEM, "warped", Blocks.WARPED_STAIRS);
+    public static final Block CRIMSON_STEM_STAIRS = registerFakeStemStairs(Blocks.CRIMSON_STEM, "crimson", Blocks.CRIMSON_STAIRS);
+    public static final Block MANGROVE_LOG_STAIRS = registerFakeLogStairs(Blocks.MANGROVE_LOG, "mangrove", Blocks.MANGROVE_STAIRS);
+    public static final Block STRIPPED_OAK_LOG_STAIRS = registerFakeStrippedLogStairs(Blocks.STRIPPED_OAK_LOG, "oak", Blocks.OAK_STAIRS, OAK_LOG_STAIRS);
+    public static final Block STRIPPED_SPRUCE_LOG_STAIRS = registerFakeStrippedLogStairs(Blocks.STRIPPED_SPRUCE_LOG, "spruce", Blocks.SPRUCE_STAIRS, SPRUCE_LOG_STAIRS);
+    public static final Block STRIPPED_BIRCH_LOG_STAIRS = registerFakeStrippedLogStairs(Blocks.STRIPPED_BIRCH_LOG, "birch", Blocks.BIRCH_STAIRS, BIRCH_LOG_STAIRS);
+    public static final Block STRIPPED_JUNGLE_LOG_STAIRS = registerFakeStrippedLogStairs(Blocks.STRIPPED_JUNGLE_LOG, "jungle", Blocks.JUNGLE_STAIRS, JUNGLE_LOG_STAIRS);
+    public static final Block STRIPPED_ACACIA_LOG_STAIRS = registerFakeStrippedLogStairs(Blocks.STRIPPED_ACACIA_LOG, "acacia", Blocks.ACACIA_STAIRS, ACACIA_LOG_STAIRS);
+    public static final Block STRIPPED_DARK_OAK_LOG_STAIRS = registerFakeStrippedLogStairs(Blocks.STRIPPED_DARK_OAK_LOG, "dark_oak", Blocks.DARK_OAK_STAIRS, DARK_OAK_LOG_STAIRS);
+    public static final Block STRIPPED_WARPED_STEM_STAIRS = registerFakeStrippedStemStairs(Blocks.STRIPPED_WARPED_STEM, "warped", Blocks.WARPED_STAIRS, WARPED_STEM_STAIRS);
+    public static final Block STRIPPED_CRIMSON_STEM_STAIRS = registerFakeStrippedStemStairs(Blocks.STRIPPED_CRIMSON_STEM, "crimson", Blocks.CRIMSON_STAIRS, CRIMSON_STEM_STAIRS);
+    public static final Block STRIPPED_MANGROVE_LOG_STAIRS = registerFakeStrippedLogStairs(Blocks.STRIPPED_MANGROVE_LOG, "mangrove", Blocks.MANGROVE_STAIRS, MANGROVE_LOG_STAIRS);
+    public static final Block OAK_WOOD_STAIRS = registerFakeWoodStairs(Blocks.OAK_WOOD, "oak", Blocks.OAK_STAIRS);
+    public static final Block SPRUCE_WOOD_STAIRS = registerFakeWoodStairs(Blocks.SPRUCE_WOOD, "spruce", Blocks.SPRUCE_STAIRS);
+    public static final Block BIRCH_WOOD_STAIRS = registerFakeWoodStairs(Blocks.BIRCH_WOOD, "birch", Blocks.BIRCH_STAIRS);
+    public static final Block JUNGLE_WOOD_STAIRS = registerFakeWoodStairs(Blocks.JUNGLE_WOOD, "jungle", Blocks.JUNGLE_STAIRS);
+    public static final Block ACACIA_WOOD_STAIRS = registerFakeWoodStairs(Blocks.ACACIA_WOOD, "acacia", Blocks.ACACIA_STAIRS);
+    public static final Block DARK_OAK_WOOD_STAIRS = registerFakeWoodStairs(Blocks.DARK_OAK_WOOD, "dark_oak", Blocks.DARK_OAK_STAIRS);
+    public static final Block WARPED_HYPHAE_STAIRS = registerFakeHyphaeStairs(Blocks.WARPED_HYPHAE, "warped", Blocks.WARPED_STAIRS);
+    public static final Block CRIMSON_HYPHAE_STAIRS = registerFakeHyphaeStairs(Blocks.CRIMSON_HYPHAE, "crimson", Blocks.CRIMSON_STAIRS);
+    public static final Block MANGROVE_WOOD_STAIRS = registerFakeWoodStairs(Blocks.MANGROVE_WOOD, "mangrove", Blocks.MANGROVE_STAIRS);
+    public static final Block STRIPPED_OAK_WOOD_STAIRS = registerFakeStrippedWoodStairs(Blocks.STRIPPED_OAK_WOOD, "oak", Blocks.OAK_STAIRS, OAK_WOOD_STAIRS);
+    public static final Block STRIPPED_SPRUCE_WOOD_STAIRS = registerFakeStrippedWoodStairs(Blocks.STRIPPED_SPRUCE_WOOD, "spruce", Blocks.SPRUCE_STAIRS, SPRUCE_WOOD_STAIRS);
+    public static final Block STRIPPED_BIRCH_WOOD_STAIRS = registerFakeStrippedWoodStairs(Blocks.STRIPPED_BIRCH_WOOD, "birch", Blocks.BIRCH_STAIRS, BIRCH_WOOD_STAIRS);
+    public static final Block STRIPPED_JUNGLE_WOOD_STAIRS = registerFakeStrippedWoodStairs(Blocks.STRIPPED_JUNGLE_WOOD, "jungle", Blocks.JUNGLE_STAIRS, JUNGLE_WOOD_STAIRS);
+    public static final Block STRIPPED_ACACIA_WOOD_STAIRS = registerFakeStrippedWoodStairs(Blocks.STRIPPED_ACACIA_WOOD, "acacia", Blocks.ACACIA_STAIRS, ACACIA_WOOD_STAIRS);
+    public static final Block STRIPPED_DARK_OAK_WOOD_STAIRS = registerFakeStrippedWoodStairs(Blocks.STRIPPED_DARK_OAK_WOOD, "dark_oak", Blocks.DARK_OAK_STAIRS, DARK_OAK_WOOD_STAIRS);
+    public static final Block STRIPPED_WARPED_HYPHAE_STAIRS = registerFakeStrippedHyphaeStairs(Blocks.STRIPPED_WARPED_HYPHAE, "warped", Blocks.WARPED_STAIRS, WARPED_HYPHAE_STAIRS);
+    public static final Block STRIPPED_CRIMSON_HYPHAE_STAIRS = registerFakeStrippedHyphaeStairs(Blocks.STRIPPED_CRIMSON_HYPHAE, "crimson", Blocks.CRIMSON_STAIRS, CRIMSON_HYPHAE_STAIRS);
+    public static final Block STRIPPED_MANGROVE_WOOD_STAIRS = registerFakeStrippedWoodStairs(Blocks.STRIPPED_MANGROVE_WOOD, "mangrove", Blocks.MANGROVE_STAIRS, MANGROVE_WOOD_STAIRS);
+    public static final Block ANDESITE_PILLAR_STAIRS = registerFakeCustomStonePillarStairs(ANDESITE_PILLAR, "andesite", Blocks.POLISHED_ANDESITE_STAIRS);
+    public static final Block CALCITE_PILLAR_STAIRS = registerFakeCustomStonePillarStairs(CALCITE_PILLAR, "calcite", Blocks.QUARTZ_STAIRS);
+    public static final Block DIORITE_PILLAR_STAIRS = registerFakeCustomStonePillarStairs(DIORITE_PILLAR, "diorite", Blocks.POLISHED_DIORITE_STAIRS);
+    public static final Block DRIPSTONE_PILLAR_STAIRS = registerFakeCustomStonePillarStairs(DRIPSTONE_PILLAR, "dripstone", Blocks.POLISHED_GRANITE_STAIRS);
+    public static final Block GRANITE_PILLAR_STAIRS = registerFakeCustomStonePillarStairs(GRANITE_PILLAR, "granite", Blocks.POLISHED_GRANITE_STAIRS);
+    public static final Block TUFF_PILLAR_STAIRS = registerFakeCustomStonePillarStairs(TUFF_PILLAR, "tuff", Blocks.COBBLESTONE_STAIRS);
+    public static final Block MANGROVE_BOOKSHELF = registerBookshelf("mangrove");
+    public static final Block BONE_STAIRS = registerFakeStairs(Blocks.BONE_BLOCK, null, "bone", NamespacedKeyWithoutIntention.minecraft("bone_block_side"), NamespacedKeyWithoutIntention.minecraft("bone_block_top"), null, Blocks.SMOOTH_QUARTZ_STAIRS, null).mineableWithPickaxe();
+    public static final Block BASALT_STAIRS = registerFakeStairs(Blocks.BASALT, null, "basalt", NamespacedKeyWithoutIntention.minecraft("basalt_side"), NamespacedKeyWithoutIntention.minecraft("basalt_top"), null, Blocks.COBBLESTONE_STAIRS, null).mineableWithPickaxe();
+    public static final Block POLISHED_BASALT_STAIRS = registerFakeStairs(Blocks.POLISHED_BASALT, null, "polished_basalt", NamespacedKeyWithoutIntention.minecraft("polished_basalt_side"), NamespacedKeyWithoutIntention.minecraft("polished_basalt_top"), null, Blocks.STONE_STAIRS, null).mineableWithPickaxe();
+    public static final Block CUT_SANDSTONE_STAIRS = registerFakeStairs(Blocks.CUT_SANDSTONE, null, "cut_sandstone", NamespacedKeyWithoutIntention.minecraft("cut_sandstone"), NamespacedKeyWithoutIntention.minecraft("sandstone_top"), null, Blocks.SMOOTH_SANDSTONE_STAIRS, null).mineableWithPickaxe();
+    public static final Block CUT_RED_SANDSTONE_STAIRS = registerFakeStairs(Blocks.CUT_RED_SANDSTONE, null, "cut_red_sandstone", NamespacedKeyWithoutIntention.minecraft("cut_red_sandstone"), NamespacedKeyWithoutIntention.minecraft("red_sandstone_top"), null, Blocks.SMOOTH_RED_SANDSTONE_STAIRS, null).mineableWithPickaxe();
+    public static final Block QUARTZ_PILLAR_STAIRS = registerFakeVanillaStonePillarStairs(Blocks.QUARTZ_PILLAR, "quartz", Blocks.QUARTZ_STAIRS).mineableWithPickaxe();
+    public static final Block PURPUR_PILLAR_SLAB = registerFakeVanillaStonePillarSlab(Blocks.PURPUR_PILLAR, "purpur", Blocks.PURPUR_SLAB).mineableWithPickaxe();
+    public static final Block PURPUR_PILLAR_STAIRS = registerFakeVanillaStonePillarStairs(Blocks.PURPUR_PILLAR, "purpur", Blocks.PURPUR_STAIRS).mineableWithPickaxe();
+    public static final Block FLINT_SLAB = registerFakeSlabFromYPillarCustomBlock(FLINT_BLOCK, null, "flint", "flint_block", Blocks.DEEPSLATE_TILE_SLAB).mineableWithPickaxe();
+    public static final Block FLINT_STAIRS = registerFakeStairsFromYPillarCustomBlock(FLINT_BLOCK, null, "flint", "flint_block", Blocks.DEEPSLATE_TILE_STAIRS).mineableWithPickaxe();
+    public static final Block IRON_SLAB = registerFakeSlab(Blocks.IRON_BLOCK, "iron", "iron_block", Blocks.POLISHED_DIORITE_SLAB).mineableWithPickaxe();
+    public static final Block GOLD_SLAB = registerFakeSlab(Blocks.GOLD_BLOCK, "gold", "gold_block", Blocks.OAK_SLAB).mineableWithPickaxe();
+    public static final Block DIAMOND_SLAB = registerFakeSlab(Blocks.DIAMOND_BLOCK, "diamond", "diamond_block", Blocks.PRISMARINE_BRICK_SLAB).mineableWithPickaxe();
+    public static final Block EMERALD_SLAB = registerFakeSlab(Blocks.EMERALD_BLOCK, "emerald", "emerald_block", Blocks.OXIDIZED_CUT_COPPER_SLAB).mineableWithPickaxe();
+    public static final Block NETHERITE_SLAB = registerFakeSlab(Blocks.NETHERITE_BLOCK, "netherite", "netherite_block", Blocks.POLISHED_DEEPSLATE_SLAB).mineableWithPickaxe();
+    public static final Block LAPIS_SLAB = registerFakeSlab(Blocks.LAPIS_BLOCK, "lapis", "lapis_block", Blocks.DARK_PRISMARINE_SLAB).mineableWithPickaxe();
+    public static final Block IRON_STAIRS = registerFakeStairs(Blocks.IRON_BLOCK, "iron", "iron_block", Blocks.POLISHED_DIORITE_STAIRS).mineableWithPickaxe();
+    public static final Block GOLD_STAIRS = registerFakeStairs(Blocks.GOLD_BLOCK, "gold", "gold_block", Blocks.OAK_STAIRS).mineableWithPickaxe();
+    public static final Block DIAMOND_STAIRS = registerFakeStairs(Blocks.DIAMOND_BLOCK, "diamond", "diamond_block", Blocks.PRISMARINE_BRICK_STAIRS).mineableWithPickaxe();
+    public static final Block EMERALD_STAIRS = registerFakeStairs(Blocks.EMERALD_BLOCK, "emerald", "emerald_block", Blocks.OXIDIZED_CUT_COPPER_STAIRS).mineableWithPickaxe();
+    public static final Block NETHERITE_STAIRS = registerFakeStairs(Blocks.NETHERITE_BLOCK, "netherite", "netherite_block", Blocks.POLISHED_DEEPSLATE_STAIRS).mineableWithPickaxe();
+    public static final Block LAPIS_STAIRS = registerFakeStairs(Blocks.LAPIS_BLOCK, "lapis", "lapis_block", Blocks.DARK_PRISMARINE_STAIRS).mineableWithPickaxe();
+    public static final Block MOSS_SLAB = registerFakeSlab(Blocks.MOSS_BLOCK, "moss", "moss_block", Blocks.DARK_PRISMARINE_SLAB).breakBeforeClientKnowsToBreak().mineableWithHoe();
+    public static final Block MOSS_STAIRS = registerFakeStairs(Blocks.MOSS_BLOCK, "moss", "moss_block", Blocks.DARK_PRISMARINE_STAIRS).breakBeforeClientKnowsToBreak().mineableWithHoe();
+    public static final Block NETHER_WART_SLAB = registerFakeSlab(Blocks.NETHER_WART_BLOCK, "nether_wart", "nether_wart_block", Blocks.RED_NETHER_BRICK_SLAB).breakBeforeClientKnowsToBreak().mineableWithHoe();
+    public static final Block NETHER_WART_STAIRS = registerFakeStairs(Blocks.NETHER_WART_BLOCK, "nether_wart", "nether_wart_block", Blocks.RED_NETHER_BRICK_STAIRS).breakBeforeClientKnowsToBreak().mineableWithHoe();
+    public static final Block WARPED_WART_SLAB = registerFakeSlab(Blocks.WARPED_WART_BLOCK, "warped_wart", "warped_wart_block", Blocks.WARPED_SLAB).breakBeforeClientKnowsToBreak().mineableWithHoe();
+    public static final Block WARPED_WART_STAIRS = registerFakeStairs(Blocks.WARPED_WART_BLOCK, "warped_wart", "warped_wart_block", Blocks.WARPED_STAIRS).breakBeforeClientKnowsToBreak().mineableWithHoe();
+    public static final Block HAY_SLAB = registerFakeSlab(Blocks.HAY_BLOCK, null, "hay", NamespacedKeyWithoutIntention.minecraft("hay_block"), NamespacedKeyWithoutIntention.minecraft("hay_block_side"), NamespacedKeyWithoutIntention.minecraft("hay_block_top"), null, null, null, Blocks.OAK_SLAB, null).breakBeforeClientKnowsToBreak().mineableWithHoe();
+    public static final Block HAY_STAIRS = registerFakeStairs(Blocks.HAY_BLOCK, null, "hay", NamespacedKeyWithoutIntention.minecraft("hay_block_side"), NamespacedKeyWithoutIntention.minecraft("hay_block_top"), null, Blocks.OAK_STAIRS, null).breakBeforeClientKnowsToBreak().mineableWithHoe();
+
+    /**
+     * Based on {@link Blocks#HAY_BLOCK}
+     */
+    public static final Block THATCH = register(
+        "thatch",
+        new SingleMultiStateRealBlockReplacementRuleBuilder()
+            .withNoteBlockHosts()
+            .withAnalogousFallbacks(Blocks.HAY_BLOCK)
+            .withModelCreationsForRotatedPillarBlockPotentiallyWithAlternativeEndCreation(Texture.defaultCreation())
+            .withFullBlockBoundingBoxItem(),
+        new RotatedPillarBlock(BlockBehaviour.Properties.of(Material.GRASS, MaterialColor.COLOR_YELLOW).strength(0.5F).sound(SoundType.GRASS)).breakBeforeClientKnowsToBreak().mineableWithHoe(),
+        SuCraftBlockLoot::dropSelf
+    ).withCustom2x2SquareRecipe("thatch", () -> Items.WHEAT, 1, false);
+
+    public static final Block THATCH_SLAB = registerFakeSlab(THATCH, null, "thatch", NamespacedKeyWithoutIntention.sucraft("thatch"), null, null, null, null, null, Blocks.OAK_SLAB, null).breakBeforeClientKnowsToBreak().mineableWithHoe();
+    public static final Block THATCH_STAIRS = registerFakeStairs(THATCH, null, "thatch", NamespacedKeyWithoutIntention.sucraft("thatch"), null, null, Blocks.OAK_STAIRS, null).breakBeforeClientKnowsToBreak().mineableWithHoe();
+
+    private static @NotNull Block register(@NotNull String id, @NotNull BlockReplacementRuleBuilder<?, ?> replacementRuleBuilder, @NotNull Block block, @Nullable Supplier<@Nullable LootTable> lootTableSupplier) {
+        return register(id, replacementRuleBuilder, block, lootTableSupplier == null ? null : ($ -> lootTableSupplier.get()));
+    }
+
+    private static @NotNull Block register(@NotNull String id, @NotNull BlockReplacementRuleBuilder<?, ?> replacementRuleBuilder, @NotNull Block block, @Nullable Function<@NotNull Block, @Nullable LootTable> lootTableFunction) {
+        ResourceLocation key = ResourceLocation.sucraft(id);
+        block.id = key;
+        @NotNull Block registeredBlock = Registry.register(Registry.BLOCK, key, block);
+        registeredBlock.isVanilla = false;
+        registeredBlock.customKey = key;
+        registeredBlock.replacementRule = replacementRuleBuilder.withReal(registeredBlock).build();
+        // Patch the break time, because the vanilla client will assume its own breaking time and if we do not allow for it, we get desync in whether the block is finished being broken
+        registeredBlock.replacementRule.updateMinDestroyTimes();
+        registeredBlock.customLootTableSupplier = lootTableFunction == null ? null : () -> lootTableFunction.apply(registeredBlock);
+        return registeredBlock;
+    }
+
+    /**
+     * Based on {@link Blocks#STONE_BRICKS}
+     */
+    private static @NotNull Block registerStoneBricks(@NotNull String type, @NotNull Block host, @NotNull Block hostReplacement, @NotNull Block fallback) {
+        return register(
+            type + "_stone_bricks",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withHost(host)
+                .withHostReplacement(hostReplacement)
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem()
+                .withHostItemRuleFromHostBlockAndHostReplacementBlock(),
+            new Block(BlockBehaviour.Properties.of(Material.STONE).strength(1.5F, 6.0F)).mineableWithPickaxe().stoneBrickFullBlock(),
+            SuCraftBlockLoot::dropSelf
+        );
+    }
+
+    /**
+     * Based on {@link Blocks#INFESTED_STONE_BRICKS} and {@link #registerStoneBricks}
+     */
+    public static @NotNull Block registerInfested(@NotNull Block uninfested) {
+        if (uninfested.isVanilla) {
+            throw new IllegalArgumentException("registerInfestedStoneBricks works only on uninfested custom blocks");
+        }
+        BlockReplacementRule replacementRule = uninfested.replacementRule;
+        if (replacementRule == null) {
+            throw new IllegalStateException("registerInfestedStoneBricks was called with an uninfested custom block for which replacementRule was not initialized yet");
+        }
+        if (replacementRule instanceof SingleStateRealBlockReplacementRule singleStateReplacementRule) {
+            Block infestedBlock = new InfestedBlock(uninfested, BlockBehaviour.Properties.of(Material.CLAY), false).withAddedTagsLike(uninfested);
+            return register(
+                "infested_" + uninfested.customKey.getPath(),
+                new SingleMultiStateRealBlockReplacementRuleBuilder()
+                    .withHostSameAs(singleStateReplacementRule)
+                    .withHostReplacementSameAs(singleStateReplacementRule)
+                    .withFallbackSameAs(singleStateReplacementRule)
+                    .withModelSameAs(singleStateReplacementRule)
+                    .withFullBlockBoundingBoxItem()
+                    .withHostItemRuleFromHostBlockAndHostReplacementBlock(),
+                infestedBlock,
+                block -> SuCraftBlockLoot.dropSingleItemWhenSilkTouch(uninfested)
+            );
+        } else {
+            throw new IllegalArgumentException("registerInfestedStoneBricks works only on uninfested custom blocks with a replacement rule of type StatelessBlockReplacementRule");
+        }
+    }
+
+    /**
+     * Based on {@link Blocks#BOOKSHELF}
+     */
+    private static @NotNull Block registerBookshelf(@NotNull String idWoodType) {
+        return register(
+            idWoodType + "_bookshelf",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(Blocks.BOOKSHELF)
+                .withModelCreation(Model.YPillarCube.defaultCreationWithAlternativeEnd(new Texture(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft(idWoodType + "_planks"), TextureContent.Existing.getInstance())).withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.WOOD).strength(1.5F).sound(SoundType.WOOD)).mineableWithAxe().bookshelf(),
+            block -> SuCraftBlockLoot.dropSingleItemAndSingleItemWhenSilkTouch(Items.BOOK, ConstantValue.exactly(3.0F), block)
+        );
+    }
+
+    /**
+     * Based on {@link Blocks#OAK_PLANKS}
+     */
+    private static @NotNull Block registerDyedPlanks(@NotNull String description, @NotNull Block fallback, @NotNull MaterialColor materialColor, @NotNull Supplier<@NotNull ItemLike> dyeItemSupplier) {
+        return register(
+            description + "_planks",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.WOOD, materialColor).strength(2.0F, 3.0F).sound(SoundType.WOOD)).mineableWithAxe().dyedPlankFullBlock(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomDyedPlanksRecipe(description, dyeItemSupplier, false);
+    }
+
+    /**
+     * Based on {@link Blocks#POLISHED_ANDESITE}
+     */
+    private static @NotNull Block registerPolished(@NotNull Block originalBlock, @NotNull String unpolished, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        @NotNull String id = "polished_" + unpolished;
+        return register(
+            id,
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.STONE, materialColor).strength(1.5F, 6.0F)).mineableWithPickaxe(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(originalBlock).withCustom2x2SquareRecipe(id, originalBlock, 4, true);
+    }
+
+    /**
+     * Based on {@link Blocks#STONE_BRICKS}
+     */
+    private static @NotNull Block registerBricks(@NotNull Block originalBlock, @NotNull String type, @NotNull Block fallback, @NotNull MaterialColor materialColor, @Nullable Block additionalStonecuttingOriginalBlock, @Nullable Block craftIn2x2SquareBlock) {
+        @NotNull String id = type + "_bricks";
+        @NotNull Block block = register(
+            id,
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.STONE, materialColor).strength(1.5F, 6.0F)).mineableWithPickaxe(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(originalBlock);
+        if (additionalStonecuttingOriginalBlock != null) {
+            block = block.withCustomOneToOneStonecutterRecipe(additionalStonecuttingOriginalBlock);
+        }
+        if (craftIn2x2SquareBlock != null) {
+            block = block.withCustom2x2SquareRecipe(id, craftIn2x2SquareBlock, 4, additionalStonecuttingOriginalBlock != null);
+        }
+        return block;
+    }
+
+    private static @NotNull Block registerBricks(@NotNull Block originalBlock, @NotNull String type, @NotNull Block fallback, @NotNull MaterialColor materialColor, @Nullable Block additionalStonecuttingOriginalAndCraftIn2x2SquareBlock) {
+        return registerBricks(originalBlock, type, fallback, materialColor, additionalStonecuttingOriginalAndCraftIn2x2SquareBlock, additionalStonecuttingOriginalAndCraftIn2x2SquareBlock);
+    }
+
+    /**
+     * Based on {@link Blocks#CHISELED_STONE_BRICKS}
+     */
+    private static @NotNull Block registerChiseledBricks(@NotNull Block bricksBlock, @NotNull String type, @NotNull Block fallback, @NotNull MaterialColor materialColor, @Nullable Supplier<@NotNull ItemLike @NotNull []> slabItemSupplier) {
+        @NotNull String id = "chiseled_" + type + "_bricks";
+        @NotNull Block block = register(
+            id,
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.STONE, materialColor).strength(1.5F, 6.0F)).mineableWithPickaxe(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(bricksBlock);
+        if (slabItemSupplier != null) {
+            block = block.withCustom2VerticalChoiceRecipe(type + "slabs_to_" + id, slabItemSupplier, 1, true);
+        }
+        return block;
+    }
+
+    /**
+     * Based on {@link Blocks#COBBLESTONE}
+     */
+    private static @NotNull Block registerCobblestone(@NotNull Block regularBlock, @NotNull String type, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        return register(
+            type + "_cobblestone",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new Block(BlockBehaviour.Properties.of(Material.STONE, materialColor).strength(2.0F, 6.0F)).mineableWithPickaxe(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(regularBlock);
+    }
+
+    /**
+     * Based on {@link Blocks#QUARTZ_PILLAR}
+     */
+    private static @NotNull Block registerStonePillar(@NotNull Block originalBlock, @NotNull String stoneType, @NotNull Block fallback, @NotNull MaterialColor materialColor, @Nullable Supplier<@NotNull ItemLike @NotNull []> craftableFullBlockItemSupplier) {
+        @NotNull String id = stoneType + "_pillar";
+        @NotNull Block block = register(
+            id,
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHosts()
+                .withFallback(fallback)
+                .withDefaultModelCreationsForRotatedPillarBlock()
+                .withFullBlockBoundingBoxItem(),
+            new RotatedPillarBlock(BlockBehaviour.Properties.of(Material.STONE, materialColor).strength(1.5F, 6.0F)).mineableWithPickaxe(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(originalBlock);
+        if (craftableFullBlockItemSupplier != null) {
+            block = block.withCustom2VerticalChoiceRecipe(stoneType + "_full_blocks_to_" + id, craftableFullBlockItemSupplier, 2, true);
+        }
+        return block;
+    }
+
+    /**
+     * Based on {@link Blocks#BIRCH_LEAVES}
+     */
+    private static @NotNull Block registerLeaves(@NotNull String leavesType, @NotNull Block host, @NotNull Block saplingBlock, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        return register(
+            leavesType + "_leaves",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withOneNonWaterLoggedAndOneWaterLoggedHost(host)
+                .withAnalogousFallbacks(fallback)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new LeavesBlock(BlockBehaviour.Properties.of(Material.LEAVES, materialColor).strength(0.2F).randomTicks().sound(SoundType.GRASS).noOcclusion().isValidSpawn(Blocks::ocelotOrParrot).isSuffocating(Blocks::never).isViewBlocking(Blocks::never)).mineableWithHoe().leaves(),
+            block -> SuCraftBlockLoot.dropLeaves(block, saplingBlock)
+        );
+    }
+
+    /**
+     * Based on {@link Blocks#OAK_SLAB}
+     * @param textureBlock If null, will be the same as the given type, else it will be assumed to be a default Minecraft model as well as texture namespaced key path (for example 'dirt' will mean the model used as double slab is 'minecraft:block/dirt' and the texture used is 'minecraft:block/dirt')
+     */
+    private static @NotNull Block registerRealSlab(@NotNull Block fullBlock, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @NotNull Block hostReplacement, @NotNull Block fallback, @NotNull BlockBehaviour.Properties properties) {
+        if (textureBlock == null) {
+            textureBlock = type;
+        }
+        return register(
+            type + "_slab",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withAnalogousHosts(host, hostReplacement)
+                .withAnalogousFallbacks(fallback)
+                .withDefaultModelCreationsForSlabReplacedBySlabAndDoubleSlabRenderedAsBlockEntityIfItNormallyWould(NamespacedKeyWithoutIntention.minecraft(textureBlock), ModelContent.Existing.ExistingModelContentOutwardExpansionType.CUBE)
+                .withRealItemRuleFromHostBlock()
+                .withHostItemRuleFromHostBlockAndHostReplacementBlock(),
+            new SlabBlock(properties).slab(),
+            SuCraftBlockLoot::dropSingleOrDoubleSlabSelf
+        ).withCustomSlabStonecutterRecipe(fullBlock).withCustomSlabCraftingRecipe(fullBlock);
+    }
+
+    /**
+     * For the double slab, this uses the full block host instead of a block entity
+     */
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull ModelCreation doubleSlabModelCreation, @NotNull Texture sideTexture, @Nullable Texture bottomHalfBottomTexture, @Nullable Texture bottomHalfTopTexture, @Nullable Texture topHalfBottomTexture, @Nullable Texture topHalfTopTexture, @NotNull Block host, @Nullable Block fallback) {
+        if (fallback == null) {
+            fallback = host;
+        }
+        var blockProperties = properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties;
+        @NotNull Block block;
+        if (fullBlock instanceof StrippedBlock) {
+            block = new StrippedSlabBlock(blockProperties);
+        } else {
+            block = new SlabBlock(blockProperties);
+        }
+        return register(
+            type + "_slab",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .rendersAsEntity(realState -> !realState.getValue(BlockStateProperties.SLAB_TYPE).equals(SlabType.DOUBLE))
+                .withBlockEntityModelVisualPropertiesUniverse(ProximityBlockEntityModelVisualPropertiesUniverse.getInstance())
+                .withAnalogousHosts(host)
+                .withAnalogousFallbacks(fallback)
+                .withDefaultModelCreationsForSlabReplacedBySlabAndDoubleSlabRenderedWithSameHostAsFullBlock(fullBlock.defaultBlockState(), sideTexture, bottomHalfBottomTexture, bottomHalfTopTexture, topHalfBottomTexture, topHalfTopTexture)
+//                .withDefaultModelCreationsForSlabReplacedBySlab(doubleSlabModelCreation, sideTexture, bottomHalfBottomTexture, bottomHalfTopTexture, topHalfBottomTexture, topHalfTopTexture)
+                .withRealItemRuleFromHostBlock(),
+            block.withAddedTagsLike(fullBlock).slab(),
+            SuCraftBlockLoot::dropSingleOrDoubleSlabSelf
+        ).withCustomSlabStonecutterRecipe(fullBlock).withCustomSlabCraftingRecipe(fullBlock);
+    }
+
+    private static @NotNull Block registerFakeStairs(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Texture sideTexture, @Nullable Texture bottomTexture, @Nullable Texture topTexture, @NotNull Block host, @Nullable Block fallback) {
+        if (fallback == null) {
+            fallback = host;
+        }
+        var blockProperties = properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties;
+        @NotNull Block block;
+        if (fullBlock instanceof StrippedBlock) {
+            block = new StrippedStairBlock(fullBlock.defaultBlockState(), blockProperties);
+        } else {
+            block = new StairBlock(fullBlock.defaultBlockState(), blockProperties);
+        }
+        return register(
+            type + "_stairs",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .rendersAsEntity(realState -> true)
+                .withBlockEntityModelVisualPropertiesUniverse(ProximityBlockEntityModelVisualPropertiesUniverse.getInstance())
+                .withAnalogousHosts(host)
+                .withAnalogousFallbacks(fallback)
+                .withDefaultModelCreationsForStairsReplacedByStairs(sideTexture, bottomTexture, topTexture)
+                .withRealItemRuleFromHostBlock(),
+            block.withAddedTagsLike(fullBlock).stairs(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(fullBlock).withCustomStairsCraftingRecipe(fullBlock);
+    }
+
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull NamespacedKeyWithoutIntention doubleSlabKey, @Nullable NamespacedKeyWithoutIntention sideTextureKey, @Nullable NamespacedKeyWithoutIntention bottomHalfBottomTextureKey, @Nullable NamespacedKeyWithoutIntention bottomHalfTopTextureKey, @Nullable NamespacedKeyWithoutIntention topHalfBottomTextureKey, @Nullable NamespacedKeyWithoutIntention topHalfTopTextureKey, @NotNull Block host, @Nullable Block fallback) {
+        if (sideTextureKey == null) {
+            sideTextureKey = doubleSlabKey;
+        }
+        return registerFakeSlab(
+            fullBlock,
+            properties,
+            type,
+            (intention, key) -> new Model(ResourcePackAssetIntention.BLOCK, doubleSlabKey, ModelContent.Existing.getInstance(ModelContent.Existing.ExistingModelContentOutwardExpansionType.CUBE)),
+            new Texture(ResourcePackAssetIntention.BLOCK, sideTextureKey, TextureContent.Existing.getInstance()),
+            bottomHalfBottomTextureKey == null ? null : new Texture(ResourcePackAssetIntention.BLOCK, bottomHalfBottomTextureKey, TextureContent.Existing.getInstance()),
+            bottomHalfTopTextureKey == null ? null : new Texture(ResourcePackAssetIntention.BLOCK, bottomHalfTopTextureKey, TextureContent.Existing.getInstance()),
+            topHalfBottomTextureKey == null ? null : new Texture(ResourcePackAssetIntention.BLOCK, topHalfBottomTextureKey, TextureContent.Existing.getInstance()),
+            topHalfTopTextureKey == null ? null : new Texture(ResourcePackAssetIntention.BLOCK, topHalfTopTextureKey, TextureContent.Existing.getInstance()),
+            host,
+            fallback
+        );
+    }
+
+    private static @NotNull Block registerFakeStairs(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull NamespacedKeyWithoutIntention sideTextureKey, @Nullable NamespacedKeyWithoutIntention bottomTextureKey, @Nullable NamespacedKeyWithoutIntention topTextureKey, @NotNull Block host, @Nullable Block fallback) {
+        return registerFakeStairs(
+            fullBlock,
+            properties,
+            type,
+            new Texture(ResourcePackAssetIntention.BLOCK, sideTextureKey, TextureContent.Existing.getInstance()),
+            bottomTextureKey == null ? null : new Texture(ResourcePackAssetIntention.BLOCK, bottomTextureKey, TextureContent.Existing.getInstance()),
+            topTextureKey == null ? null : new Texture(ResourcePackAssetIntention.BLOCK, topTextureKey, TextureContent.Existing.getInstance()),
+            host,
+            fallback
+        );
+    }
+
+    private static @NotNull Block registerFakeSlabFromYPillar(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull NamespacedKeyWithoutIntention doubleSlabNamespacedKey, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, properties, type, doubleSlabNamespacedKey, doubleSlabNamespacedKey, doubleSlabNamespacedKey.withKeySuffix("_top"), null, null, null, host, null);
+    }
+
+    private static @NotNull Block registerFakeStairsFromYPillar(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, NamespacedKeyWithoutIntention fullBlockNamespacedKey, @NotNull Block host) {
+        return registerFakeStairs(fullBlock, properties, type, fullBlockNamespacedKey, fullBlockNamespacedKey.withKeySuffix("_top"), null, host, null);
+    }
+
+    private static @NotNull Block registerFakeStairsFromYPillar(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairsFromYPillar(fullBlock, properties, type, NamespacedKeyWithoutIntention.forMinecraft(fullBlock.id), host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromYPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeSlabFromYPillar(fullVanillaBlock, properties, type, NamespacedKeyWithoutIntention.minecraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeStairsFromYPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeStairsFromYPillar(fullVanillaBlock, properties, type, NamespacedKeyWithoutIntention.minecraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromYPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromYPillarVanillaBlock(fullVanillaBlock, properties, type, type, host);
+    }
+
+    private static @NotNull Block registerFakeStairsFromYPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairsFromYPillar(fullVanillaBlock, properties, type, host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromYPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeSlabFromYPillar(fullCustomBlock, properties, type, NamespacedKeyWithoutIntention.sucraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeStairsFromYPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeStairsFromYPillar(fullCustomBlock, properties, type, NamespacedKeyWithoutIntention.sucraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromYPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromYPillarCustomBlock(fullCustomBlock, properties, type, type, host);
+    }
+
+    private static @NotNull Block registerFakeStairsFromYPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairsFromYPillar(fullCustomBlock, properties, type, host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromBottomTopPillar(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull NamespacedKeyWithoutIntention doubleSlabNamespacedKey, @NotNull Block host) {
+        NamespacedKeyWithoutIntention bottomKey = doubleSlabNamespacedKey.withKeySuffix("_bottom");
+        NamespacedKeyWithoutIntention topKey = doubleSlabNamespacedKey.withKeySuffix("_top");
+        return registerFakeSlab(fullBlock, properties, type, doubleSlabNamespacedKey, doubleSlabNamespacedKey, bottomKey, topKey, bottomKey, topKey, host, null);
+    }
+
+    private static @NotNull Block registerFakeStairsFromBottomTopPillar(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull NamespacedKeyWithoutIntention fullBlockNamespacedKey, @NotNull Block host) {
+        NamespacedKeyWithoutIntention bottomKey = fullBlockNamespacedKey.withKeySuffix("_bottom");
+        NamespacedKeyWithoutIntention topKey = fullBlockNamespacedKey.withKeySuffix("_top");
+        return registerFakeStairs(fullBlock, properties, type, fullBlockNamespacedKey, bottomKey, topKey, host, null);
+    }
+
+    private static @NotNull Block registerFakeStairsFromBottomTopPillar(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairsFromBottomTopPillar(fullBlock, properties, type, NamespacedKeyWithoutIntention.forMinecraft(fullBlock.id), host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromBottomTopPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeSlabFromBottomTopPillar(fullVanillaBlock, properties, type, NamespacedKeyWithoutIntention.minecraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeStairsFromBottomTopPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeStairsFromBottomTopPillar(fullVanillaBlock, properties, type, NamespacedKeyWithoutIntention.minecraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromBottomTopPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromBottomTopPillarVanillaBlock(fullVanillaBlock, properties, type, type, host);
+    }
+
+    private static @NotNull Block registerFakeStairsFromBottomTopPillarVanillaBlock(@NotNull Block fullVanillaBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairsFromBottomTopPillar(fullVanillaBlock, properties, type, host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromBottomTopPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeSlabFromBottomTopPillar(fullCustomBlock, properties, type, NamespacedKeyWithoutIntention.sucraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeStairsFromBottomTopPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        return registerFakeStairsFromBottomTopPillar(fullCustomBlock, properties, type, NamespacedKeyWithoutIntention.sucraft(textureType), host);
+    }
+
+    private static @NotNull Block registerFakeSlabFromBottomTopPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromBottomTopPillarCustomBlock(fullCustomBlock, properties, type, type, host);
+    }
+
+    private static @NotNull Block registerFakeStairsFromBottomTopPillarCustomBlock(@NotNull Block fullCustomBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairsFromBottomTopPillar(fullCustomBlock, properties, type, host);
+    }
+
+    private static @NotNull Block registerFakeBookshelfSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        String typedBookshelf = type + "_bookshelf";
+        String typedBookshelfIfNotOak = fullBlock.equals(Blocks.BOOKSHELF) ? "bookshelf" : typedBookshelf;
+        NamespacedKeyWithoutIntention doubleSlabNamespacedKey = fullBlock.equals(Blocks.BOOKSHELF) ? NamespacedKeyWithoutIntention.minecraft(typedBookshelfIfNotOak) : NamespacedKeyWithoutIntention.sucraft(typedBookshelfIfNotOak);
+        return registerFakeSlab(fullBlock, null, typedBookshelf, doubleSlabNamespacedKey, doubleSlabNamespacedKey,  NamespacedKeyWithoutIntention.minecraft(type + "_planks"), null, null, null, host, null).mineableWithAxe().bookshelfSlab();
+    }
+
+    private static @NotNull Block registerFakeBookshelfStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        String typedBookshelf = type + "_bookshelf";
+        String typedBookshelfIfNotOak = fullBlock.equals(Blocks.BOOKSHELF) ? "bookshelf" : typedBookshelf;
+        NamespacedKeyWithoutIntention fullBlockNamespacedKey = fullBlock.equals(Blocks.BOOKSHELF) ? NamespacedKeyWithoutIntention.minecraft(typedBookshelfIfNotOak) : NamespacedKeyWithoutIntention.sucraft(typedBookshelfIfNotOak);
+        return registerFakeStairs(fullBlock, null, typedBookshelf, fullBlockNamespacedKey, NamespacedKeyWithoutIntention.minecraft(type + "_planks"), null, host, null).mineableWithAxe().bookshelfStairs();
+    }
+
+    private static @NotNull Block registerFakeCustomStonePillarSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromYPillarCustomBlock(fullBlock, null, type + "_pillar", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeCustomStonePillarStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairsFromYPillarCustomBlock(fullBlock, null, type + "_pillar", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeVanillaStonePillarSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromYPillarVanillaBlock(fullBlock, null, type + "_pillar", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeVanillaStonePillarStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairsFromYPillarVanillaBlock(fullBlock, null, type + "_pillar", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeLogOrStemSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlabFromYPillarVanillaBlock(fullBlock, BlockBehaviour.Properties.of(Material.WOOD, fullBlock.defaultMaterialColor()).strength(2.0F, 3.0F).sound(SoundType.WOOD), type, host).mineableWithAxe().logSlab();
+    }
+
+    private static @NotNull Block registerFakeLogOrStemStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairsFromYPillarVanillaBlock(fullBlock, BlockBehaviour.Properties.of(Material.WOOD, fullBlock.defaultMaterialColor()).strength(2.0F, 3.0F).sound(SoundType.WOOD), type, host).mineableWithAxe().logStairs();
+    }
+
+    private static @NotNull Block registerFakeLogSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeLogOrStemSlab(fullBlock, type + "_log", host);
+    }
+
+    private static @NotNull Block registerFakeLogStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeLogOrStemStairs(fullBlock, type + "_log", host);
+    }
+
+    private static @NotNull Block registerFakeStemSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeLogOrStemSlab(fullBlock, type + "_stem", host);
+    }
+
+    private static @NotNull Block registerFakeStemStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeLogOrStemStairs(fullBlock, type + "_stem", host);
+    }
+
+    private static @NotNull Block registerFakeStrippedLogOrStemSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Block unstripped) {
+        return ((StrippedSlabBlock) registerFakeLogOrStemSlab(fullBlock, "stripped_" + type, host)).withUnstrippedBlock(unstripped);
+    }
+
+    private static @NotNull Block registerFakeStrippedLogOrStemStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Block unstripped) {
+        return ((StrippedStairBlock) registerFakeLogOrStemStairs(fullBlock, "stripped_" + type, host)).withUnstrippedBlock(unstripped);
+    }
+
+    private static @NotNull Block registerFakeStrippedLogSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Block unstripped) {
+        return registerFakeStrippedLogOrStemSlab(fullBlock, type + "_log", host, unstripped);
+    }
+
+    private static @NotNull Block registerFakeStrippedLogStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Block unstripped) {
+        return registerFakeStrippedLogOrStemStairs(fullBlock, type + "_log", host, unstripped);
+    }
+
+    private static @NotNull Block registerFakeStrippedStemSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Block unstripped) {
+        return  registerFakeStrippedLogOrStemSlab(fullBlock, type + "_stem", host, unstripped);
+    }
+
+    private static @NotNull Block registerFakeStrippedStemStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Block unstripped) {
+        return registerFakeStrippedLogOrStemStairs(fullBlock, type + "_stem", host, unstripped);
+    }
+
+    private static @NotNull Block registerFakeWoodOrHyphaeSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        NamespacedKeyWithoutIntention doubleSlabKey = NamespacedKeyWithoutIntention.minecraft(type);
+        NamespacedKeyWithoutIntention textureKey = NamespacedKeyWithoutIntention.minecraft(textureType);
+        return registerFakeSlab(fullBlock, BlockBehaviour.Properties.of(Material.WOOD, fullBlock.defaultMaterialColor()).strength(2.0F, 3.0F).sound(SoundType.WOOD), type, doubleSlabKey, textureKey, null, null, null, null, host, null).mineableWithAxe().logSlab();
+    }
+
+    private static @NotNull Block registerFakeWoodOrHyphaeStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull String textureType, @NotNull Block host) {
+        NamespacedKeyWithoutIntention textureKey = NamespacedKeyWithoutIntention.minecraft(textureType);
+        return registerFakeStairs(fullBlock, BlockBehaviour.Properties.of(Material.WOOD, fullBlock.defaultMaterialColor()).strength(2.0F, 3.0F).sound(SoundType.WOOD), type, textureKey, null, null, host, null).mineableWithAxe().logStairs();
+    }
+
+    private static @NotNull Block registerFakeWoodSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeWoodOrHyphaeSlab(fullBlock, type + "_wood", type + "_log", host);
+    }
+
+    private static @NotNull Block registerFakeWoodStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeWoodOrHyphaeStairs(fullBlock, type + "_wood", type + "_log", host);
+    }
+
+    private static @NotNull Block registerFakeHyphaeSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeWoodOrHyphaeSlab(fullBlock, type + "_hyphae", type + "_stem", host);
+    }
+
+    private static @NotNull Block registerFakeHyphaeStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeWoodOrHyphaeStairs(fullBlock, type + "_hyphae", type + "_stem", host);
+    }
+
+    private static @NotNull Block registerFakeStrippedWoodOrHyphaeSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull String textureType, @NotNull Block host, @NotNull Block unstripped) {
+        return ((StrippedSlabBlock) registerFakeWoodOrHyphaeSlab(fullBlock, "stripped_" + type, "stripped_" + textureType, host)).withUnstrippedBlock(unstripped);
+    }
+
+    private static @NotNull Block registerFakeStrippedWoodOrHyphaeStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull String textureType, @NotNull Block host, @NotNull Block unstripped) {
+        return ((StrippedStairBlock) registerFakeWoodOrHyphaeStairs(fullBlock, "stripped_" + type, "stripped_" + textureType, host)).withUnstrippedBlock(unstripped);
+    }
+
+    private static @NotNull Block registerFakeStrippedWoodSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Block unstripped) {
+        return registerFakeStrippedWoodOrHyphaeSlab(fullBlock, type + "_wood", type + "_log", host, unstripped);
+    }
+
+    private static @NotNull Block registerFakeStrippedWoodStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Block unstripped) {
+        return registerFakeStrippedWoodOrHyphaeStairs(fullBlock, type + "_wood", type + "_log", host, unstripped);
+    }
+
+    private static @NotNull Block registerFakeStrippedHyphaeSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Block unstripped) {
+        return registerFakeStrippedWoodOrHyphaeSlab(fullBlock, type + "_hyphae", type + "_stem", host, unstripped);
+    }
+
+    private static @NotNull Block registerFakeStrippedHyphaeStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Block unstripped) {
+        return registerFakeStrippedWoodOrHyphaeStairs(fullBlock, type + "_hyphae", type + "_stem", host, unstripped);
+    }
+
+    /**
+     * Based on {@link Blocks#OAK_SLAB}
+     * <br>
+     * For the double slab, this uses the full block host instead of a block entity
+     *
+     * @param textureBlock If null, will be the based on the model of the full block, else it will be assumed to be a default Minecraft model as well as texture namespaced key path (for example 'dirt' will mean the model used as double slab is 'minecraft:block/dirt' and the texture used is 'minecraft:block/dirt')
+     * @param fallback If null, will be the same as host
+     */
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
+        if (fallback == null) {
+            fallback = host;
+        }
+        return register(
+            type + "_slab",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .rendersAsEntity(realState -> !realState.getValue(BlockStateProperties.SLAB_TYPE).equals(SlabType.DOUBLE))
+                .withBlockEntityModelVisualPropertiesUniverse(ProximityBlockEntityModelVisualPropertiesUniverse.getInstance())
+                .withAnalogousHosts(host)
+                .withAnalogousFallbacks(fallback)
+                .withDefaultModelCreationsForSlabReplacedBySlabAndDoubleSlabRenderedWithSameHostAsFullBlock(textureBlock != null ? NamespacedKeyWithoutIntention.minecraft(textureBlock) : fullBlock.replacementRule.getModel(fullBlock.defaultBlockState()).model().getKey(), fullBlock.defaultBlockState())
+//                .withDefaultModelCreationsForSlabReplacedBySlab(textureBlock != null ? NamespacedKeyWithoutIntention.minecraft(textureBlock) : fullBlock.replacementRule.getModel(fullBlock.defaultBlockState()).model().getKey(), ModelContent.Existing.ExistingModelContentOutwardExpansionType.CUBE)
+                .withRealItemRuleFromHostBlock(),
+            new SlabBlock(properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties).withAddedTagsLike(fullBlock).slab(),
+            SuCraftBlockLoot::dropSingleOrDoubleSlabSelf
+        ).withCustomSlabStonecutterRecipe(fullBlock).withCustomSlabCraftingRecipe(fullBlock);
+    }
+
+    /**
+     * Based on {@link Blocks#OAK_STAIRS}
+     * @param textureBlock If null, will be the based on the model of the full block, else it will be assumed to be a default Minecraft model as well as texture namespaced key path (for example 'dirt' will mean the texture used is 'minecraft:block/dirt')
+     * @param fallback If null, will be the same as host
+     */
+    private static @NotNull Block registerFakeStairs(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
+        if (fallback == null) {
+            fallback = host;
+        }
+        return register(
+            type + "_stairs",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .rendersAsEntity(realState -> true)
+                .withBlockEntityModelVisualPropertiesUniverse(ProximityBlockEntityModelVisualPropertiesUniverse.getInstance())
+                .withAnalogousHosts(host)
+                .withAnalogousFallbacks(fallback)
+                .withDefaultModelCreationsForStairsReplacedByStairs(textureBlock != null ? NamespacedKeyWithoutIntention.minecraft(textureBlock) : fullBlock.replacementRule.getModel(fullBlock.defaultBlockState()).model().getKey())
+                .withRealItemRuleFromHostBlock(),
+            new StairBlock(fullBlock.defaultBlockState(), properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties).withAddedTagsLike(fullBlock).stairs(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(fullBlock).withCustomStairsCraftingRecipe(fullBlock);
+    }
+
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
+        return registerFakeSlab(fullBlock, null, type, textureBlock, host, fallback);
+    }
+
+    private static @NotNull Block registerFakeStairs(@NotNull Block fullBlock, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
+        return registerFakeStairs(fullBlock, null, type, textureBlock, host, fallback);
+    }
+
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @NotNull String type, @Nullable String textureBlock, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type, textureBlock, host, null);
+    }
+
+    private static @NotNull Block registerFakeStairs(@NotNull Block fullBlock, @NotNull String type, @Nullable String textureBlock, @NotNull Block host) {
+        return registerFakeStairs(fullBlock, type, textureBlock, host, null);
+    }
+
+    private static @NotNull Block registerFakeSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type, type, host, null);
+    }
+
+    private static @NotNull Block registerFakeStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairs(fullBlock, type, type, host, null);
+    }
+
+    private static @NotNull Block registerFakeDyedPlankSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Supplier<@NotNull ItemLike> dyeItemSupplier) {
+        return registerFakeSlab(fullBlock, type + "_plank", null, host).breakBeforeClientKnowsToBreak().mineableWithAxe().dyedPlankSlab().withCustomDyedPlankSlabsRecipe(type, dyeItemSupplier, true);
+    }
+
+    private static @NotNull Block registerFakeDyedPlankStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host, @NotNull Supplier<@NotNull ItemLike> dyeItemSupplier) {
+        return registerFakeStairs(fullBlock, type + "_plank", null, host).breakBeforeClientKnowsToBreak().mineableWithAxe().dyedPlankStairs().withCustomDyedPlankStairsRecipe(type, dyeItemSupplier, true);
+    }
+
+    private static @NotNull Block registerFakeWoolSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_wool", type + "_wool", host).breakBeforeClientKnowsToBreak().wool().woolSlab();
+    }
+
+    private static @NotNull Block registerFakeWoolStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairs(fullBlock, type + "_wool", type + "_wool", host).breakBeforeClientKnowsToBreak().wool().woolStairs();
+    }
+
+    private static @NotNull Block registerFakeConcreteSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_concrete", type + "_concrete", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeConcreteStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairs(fullBlock, type + "_concrete", type + "_concrete", host).mineableWithPickaxe();
+    }
+
+    /**
+     * @see #registerFakeSlab
+     */
+    private static @NotNull Block registerFakeFallingSlab(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
+        if (fallback == null) {
+            fallback = host;
+        }
+        return register(
+            type + "_slab",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .rendersAsEntity(realState -> !realState.getValue(BlockStateProperties.SLAB_TYPE).equals(SlabType.DOUBLE))
+                .withBlockEntityModelVisualPropertiesUniverse(ProximityBlockEntityModelVisualPropertiesUniverse.getInstance())
+                .withAnalogousHosts(host)
+                .withAnalogousFallbacks(fallback)
+                .withDefaultModelCreationsForSlabReplacedBySlabAndDoubleSlabRenderedWithSameHostAsFullBlock(textureBlock != null ? NamespacedKeyWithoutIntention.minecraft(textureBlock) : fullBlock.replacementRule.getModel(fullBlock.defaultBlockState()).model().getKey(), fullBlock.defaultBlockState())
+//                .withDefaultModelCreationsForSlabReplacedBySlab(textureBlock != null ? NamespacedKeyWithoutIntention.minecraft(textureBlock) : fullBlock.replacementRule.getModel(fullBlock.defaultBlockState()).model().getKey(), ModelContent.Existing.ExistingModelContentOutwardExpansionType.CUBE)
+                .withRealItemRuleFromHostBlock(),
+            new FallingSlabBlock(properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties).withAddedTagsLike(fullBlock).slab(),
+            SuCraftBlockLoot::dropSingleOrDoubleSlabSelf
+        ).withCustomSlabStonecutterRecipe(fullBlock);
+    }
+
+    /**
+     * @see #registerFakeStairs
+     */
+    private static @NotNull Block registerFakeFallingStairs(@NotNull Block fullBlock, @Nullable BlockBehaviour.Properties properties, @NotNull String type, @Nullable String textureBlock, @NotNull Block host, @Nullable Block fallback) {
+        if (fallback == null) {
+            fallback = host;
+        }
+        return register(
+            type + "_stairs",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .rendersAsEntity(realState -> true)
+                .withBlockEntityModelVisualPropertiesUniverse(ProximityBlockEntityModelVisualPropertiesUniverse.getInstance())
+                .withAnalogousHosts(host)
+                .withAnalogousFallbacks(fallback)
+                .withDefaultModelCreationsForStairsReplacedByStairs(textureBlock != null ? NamespacedKeyWithoutIntention.minecraft(textureBlock) : fullBlock.replacementRule.getModel(fullBlock.defaultBlockState()).model().getKey())
+                .withRealItemRuleFromHostBlock(),
+            new FallingStairBlock(fullBlock.defaultBlockState(), properties == null ? BlockBehaviour.Properties.copy(fullBlock).doesNotRequireCorrectToolForDrops() : properties).withAddedTagsLike(fullBlock).stairs(),
+            SuCraftBlockLoot::dropSelf
+        ).withCustomOneToOneStonecutterRecipe(fullBlock);
+    }
+
+    private static @NotNull Block registerFakeConcretePowderSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeFallingSlab(fullBlock, null, type + "_concrete_powder", type + "_concrete_powder", host, null).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    }
+
+    private static @NotNull Block registerFakeConcretePowderStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeFallingStairs(fullBlock, null, type + "_concrete_powder", type + "_concrete_powder", host, null).breakBeforeClientKnowsToBreak().mineableWithShovel();
+    }
+
+    private static @NotNull Block registerFakeTerracottaSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_terracotta", type + "_terracotta", host).mineableWithPickaxe().terracottaSlab();
+    }
+
+    private static @NotNull Block registerFakeTerracottaStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairs(fullBlock, type + "_terracotta", type + "_terracotta", host).mineableWithPickaxe().terracottaStairs();
+    }
+
+    private static @NotNull Block registerFakePolishedSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, "polished_" + type, null, host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakePolishedStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairs(fullBlock, "polished_" + type, null, host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeCustomBrickSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_brick", null, host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeCustomBrickStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairs(fullBlock, type + "_brick", null, host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeVanillaBrickSlab(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, type + "_brick", type + "_bricks", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeVanillaBrickStairs(@NotNull Block fullBlock, @NotNull String type, @NotNull Block host) {
+        return registerFakeStairs(fullBlock, type + "_brick", type + "_bricks", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeSandstoneBrickSlab(@NotNull Block fullBlock, @Nullable String type, @NotNull Block host) {
+        return registerFakeCustomBrickSlab(fullBlock, (type == null ? "" : type + "_") + "sandstone", host);
+    }
+
+    private static @NotNull Block registerFakeSandstoneBrickStairs(@NotNull Block fullBlock, @Nullable String type, @NotNull Block host) {
+        return registerFakeCustomBrickStairs(fullBlock, (type == null ? "" : type + "_") + "sandstone", host);
+    }
+
+    private static @NotNull Block registerFakeRawMetalSlab(@NotNull Block fullBlock, @Nullable String type, @NotNull Block host) {
+        return registerFakeSlab(fullBlock, "raw_" + type, "raw_" + type + "_block", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerFakeRawMetalStairs(@NotNull Block fullBlock, @Nullable String type, @NotNull Block host) {
+        return registerFakeStairs(fullBlock, "raw_" + type, "raw_" + type + "_block", host).mineableWithPickaxe();
+    }
+
+    private static @NotNull Block registerPeat(@NotNull String type, boolean lit, @Nullable Block dropWithoutSilkTouch) {
+        return register(
+            (type == null ? "" : type + "_") + "peat",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withNoteBlockHost()
+                .withFallback(Blocks.COARSE_DIRT)
+                .withModelCreation(Model.OneTextureCube.defaultCreation().withNoParameters())
+                .withFullBlockBoundingBoxItem(),
+            new PeatBlock(BlockBehaviour.Properties.of(Material.DIRT, MaterialColor.DIRT).strength(1.0F, 2.0F).sound(SoundType.GRAVEL), lit)/*.breakBeforeClientKnowsToBreak()*/.mineableWithShovel().peatFullBlock(),
+            dropWithoutSilkTouch == null ? SuCraftBlockLoot::dropSelf : block -> SuCraftBlockLoot.dropSingleItemAndSingleItemWhenSilkTouch(dropWithoutSilkTouch, block)
+        );
+    }
+
+    /**
+     * Based on {@link Blocks#FIRE}
+     */
+    private static @NotNull Block registerFire(@NotNull String fireType, @NotNull Block fallback, @NotNull MaterialColor materialColor) {
+        @NotNull Block block = register(
+            fireType + "_fire",
+            new SingleMultiStateRealBlockReplacementRuleBuilder()
+                .withFireHost()
+                .withFallback(fallback),
+            new SoulFireBlock(BlockBehaviour.Properties.of(Material.FIRE, materialColor).noCollission().instabreak().sound(SoundType.WOOL).lightLevel(state -> 10)).coloredFire(),
+            () -> null
+        );
+        block.customFireType = fireType;
+        return block;
+    }
+
+    public static Block bootstrap() {
+        SNOWY_STONE_BRICKS.toString();
+        return SNOWY_STONE_BRICKS;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/SuCraftObservableBlockTagsSpreader.java b/src/main/java/org/sucraft/suki/block/SuCraftObservableBlockTagsSpreader.java
new file mode 100644
index 0000000000000000000000000000000000000000..c08a9b2a4cb77b06a83fbf1104c83928f469600d
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/SuCraftObservableBlockTagsSpreader.java
@@ -0,0 +1,65 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import org.sucraft.suki.block.replacementrule.BlockReplacementRule;
+import org.sucraft.suki.data.SuCraftTagsProvider;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * Based on {@link net.minecraft.data.tags.BlockTagsProvider}
+ */
+public class SuCraftObservableBlockTagsSpreader extends SuCraftTagsProvider<Block> {
+
+    public SuCraftObservableBlockTagsSpreader(Registry<Block> registry) {
+        super(registry);
+    }
+
+    @Override
+    protected void addTags(Map<TagKey<Block>, List<Holder<Block>>> existingRegistryTagEntries) {
+        MinecraftServer.LOGGER.info("Inheriting mineable with tool tags for custom blocks...");
+        final List<TagKey<Block>> tagsToSpread = List.of(BlockTags.MINEABLE_WITH_AXE, BlockTags.MINEABLE_WITH_HOE, BlockTags.MINEABLE_WITH_PICKAXE, BlockTags.MINEABLE_WITH_SHOVEL, BlockTags.LEAVES /* To allow custom leaves to inherit being broken by shears fast */, BlockTags.WOOL /* To allow custom wool-like blocks such as wool slabs to inherit being broken by shears fast */);
+        for (boolean observationReplacementToOriginal : new boolean[] {false, true}) {
+            for (Block block : Registry.BLOCK) {
+                BlockReplacementRule blockReplacementRule = block.replacementRule;
+                if (blockReplacementRule != null) {
+                    for (@NotNull Pair<@NotNull Block, @NotNull Block> observationReplacement : blockReplacementRule.getPotentialBlockReplacementPairs()) {
+                        var observationOriginalKey = this.registry.getResourceKey(observationReplacement.first()).get();
+                        var observationOriginalHolder = this.registry.getHolderOrThrow(observationOriginalKey);
+                        var observationReplacementKey = this.registry.getResourceKey(observationReplacement.second()).get();
+                        var observationReplacementHolder = this.registry.getHolderOrThrow(observationReplacementKey);
+                        for (TagKey<Block> tag : tagsToSpread) {
+                            if (observationReplacementToOriginal) {
+                                // From observation replacement block to original block
+                                if (existingRegistryTagEntries.getOrDefault(tag, Collections.emptyList()).contains(observationReplacementHolder)) {
+                                    this.tag(tag).add(observationOriginalKey);
+                                }
+                            } else {
+                                // From original block to observation replacement block
+                                if (existingRegistryTagEntries.getOrDefault(tag, Collections.emptyList()).contains(observationOriginalHolder)) {
+                                    this.tag(tag).add(observationReplacementKey);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/UsedHostBlockStates.java b/src/main/java/org/sucraft/suki/block/UsedHostBlockStates.java
new file mode 100644
index 0000000000000000000000000000000000000000..bb75c63ba741461c9287eb96dd84bb0f92a14a4e
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/UsedHostBlockStates.java
@@ -0,0 +1,116 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block;
+
+import it.unimi.dsi.fastutil.Pair;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.BaseFireBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.FireBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * A utility class that keeps track of used block states in block replacement hosts
+ */
+public final class UsedHostBlockStates {
+
+    private UsedHostBlockStates() {}
+
+    private static final @NotNull Set<@NotNull BlockState> usedBlockStates = new HashSet<>(0);
+
+    private static @NotNull BlockState getHostReplacement(@NotNull BlockState host) {
+        // Block tags cannot be used in this method yet since it will be called before they are assigned
+        Block block = host.getBlock();
+        if (block.equals(Blocks.NOTE_BLOCK)) {
+            return block.getStateDefinition().getPossibleStates().get(0);
+        } else if (
+            block.equals(Blocks.OAK_LEAVES) ||
+                block.equals(Blocks.SPRUCE_LEAVES) ||
+                block.equals(Blocks.BIRCH_LEAVES) ||
+                block.equals(Blocks.JUNGLE_LEAVES) ||
+                block.equals(Blocks.ACACIA_LEAVES) ||
+                block.equals(Blocks.DARK_OAK_LEAVES) ||
+                block.equals(Blocks.AZALEA_LEAVES) ||
+                block.equals(Blocks.FLOWERING_AZALEA_LEAVES) ||
+                block.equals(Blocks.MANGROVE_LEAVES)
+        ) {
+            return host.getBlock().withPropertiesOf(host).setValue(BlockStateProperties.DISTANCE, 1).setValue(BlockStateProperties.PERSISTENT, true);
+        }
+        throw new IllegalArgumentException("Called UsedHostBlockStates.getHostReplacement with a host for which host replacements were not defined yet: " + host);
+    }
+
+    private static final @NotNull Map<@NotNull Block, @NotNull List<@NotNull BlockState>> defaultPossibleBlockStatesByBlock = new HashMap<>(0);
+
+    private static @NotNull List<@NotNull BlockState> getDefaultPossibleBlockStatesForBlock(@NotNull Block block) {
+        return defaultPossibleBlockStatesByBlock.computeIfAbsent(block, $ -> {
+            @NotNull List<@NotNull BlockState> allBlockStates = new ArrayList<>(block.getStateDefinition().getPossibleStates());
+            @NotNull List<@NotNull BlockState> hostReplacements = allBlockStates.stream().map(UsedHostBlockStates::getHostReplacement).distinct().toList();
+            allBlockStates.removeAll(hostReplacements);
+            return allBlockStates;
+        });
+    }
+
+    public static @NotNull Pair<@NotNull BlockState, @NotNull BlockState> generateUnusedHostAndReplacement(@NotNull Block block) {
+        return generateUnusedHostAndReplacement(getDefaultPossibleBlockStatesForBlock(block));
+    }
+
+    public static @NotNull Pair<@NotNull BlockState, @NotNull BlockState> generateUnusedHostAndReplacement(@NotNull List<@NotNull BlockState> possibleBlockStates) {
+        @NotNull List<@NotNull BlockState> possibleBlockStatesWithoutReplacements = new ArrayList<>(possibleBlockStates);
+        possibleBlockStates.stream().map(UsedHostBlockStates::getHostReplacement).distinct().forEach(possibleBlockStatesWithoutReplacements::remove);
+        for (@NotNull BlockState possibleBlockState : possibleBlockStatesWithoutReplacements) {
+            if (usedBlockStates.add(possibleBlockState)) {
+                return Pair.of(possibleBlockState, getHostReplacement(possibleBlockState));
+            }
+        }
+        throw new IllegalStateException("Tried to generate unused host block state, but all possible block states (" + possibleBlockStates + ") are already in use");
+    }
+
+    public static @NotNull BlockState generateUnusedFireState() {
+        @NotNull List<@NotNull BlockState> unusedStates = Blocks.FIRE
+            .getStateDefinition()
+            .getPossibleStates().stream()
+            .filter(state -> !usedBlockStates.contains(state) // Must not be in use yet
+                && state.getValue(BlockStateProperties.AGE_15) != 0) // Must not have an age of 0 (this is the host replacement for all fire hosts)
+            .toList();
+        if (unusedStates.isEmpty()) {
+            throw new IllegalStateException("Tried to generated unused fire host block state, but all possible acceptable block states are already in use");
+        }
+        @Nullable BlockState stateToUse = unusedStates.stream()
+            .filter(state -> !state.getValue(BlockStateProperties.UP) && !state.getValue(BlockStateProperties.EAST) && !state.getValue(BlockStateProperties.WEST) && !state.getValue(BlockStateProperties.NORTH) && !state.getValue(BlockStateProperties.SOUTH)) // This has a nice hitbox of the bottom
+            .findAny().orElse(
+                unusedStates.stream()
+                    .filter(state -> state.getValue(BlockStateProperties.EAST) && state.getValue(BlockStateProperties.WEST) && state.getValue(BlockStateProperties.NORTH) && state.getValue(BlockStateProperties.SOUTH)) // This has an acceptable hitbox of all 4 sides (both including and excluding the top)
+                    .findAny().get()
+            );
+        usedBlockStates.add(stateToUse);
+        return stateToUse;
+//        int hostAge = 1;
+//        while (usedBlockStates.contains(block.defaultBlockState().setValue(BlockStateProperties.AGE_15, hostAge))) {
+//            hostAge++;
+//            if (hostAge > 15) {
+//                throw new IllegalStateException("Tried to generate unused fire host age for block " + block + ", but all possible ages are already in use");
+//            }
+//        }
+//        for (BlockState fireState : block.getStateDefinition().getPossibleStates()) {
+//            if (fireState.getValue(BlockStateProperties.AGE_15) == hostAge) {
+//                usedBlockStates.add(fireState);
+//            }
+//        }
+//        return hostAge;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/replacementrule/BlockEntityItemMappingsForVersionCompatability.java b/src/main/java/org/sucraft/suki/block/replacementrule/BlockEntityItemMappingsForVersionCompatability.java
new file mode 100644
index 0000000000000000000000000000000000000000..290956124269742f0c04f4083894df6fe8c1b43b
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/replacementrule/BlockEntityItemMappingsForVersionCompatability.java
@@ -0,0 +1,526 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block.replacementrule;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+
+import java.util.ArrayList;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+
+public final class BlockEntityItemMappingsForVersionCompatability {
+
+    private BlockEntityItemMappingsForVersionCompatability() {}
+
+    // A faster version of the below array, in dictionary form
+    private static List<Map<Item, Item>> blockEntityItemMappingsForVersionCompatibilityList = null;
+    public static List<Map<Item, Item>> getBlockEntityItemMappingsForVersionCompatibilityList() {
+        if (blockEntityItemMappingsForVersionCompatibilityList == null) {
+            // Based on https://github.com/ViaVersion/ViaBackwards/tree/master/common/src/main/resources/assets/viabackwards/data
+            Item[][][] blockEntityItemMappingsForVersionCompatibility = {
+                {
+                    // 1.19 -> 1.18
+                    {Items.WARDEN_SPAWN_EGG, Items.GLOW_SQUID_SPAWN_EGG},
+                    {Items.SCULK_VEIN, Items.GLOW_LICHEN},
+                    {Items.SCULK_CATALYST, Items.END_STONE},
+                    {Items.SCULK, Items.BLACK_CONCRETE_POWDER},
+                    {Items.SCULK_SHRIEKER, Items.END_PORTAL_FRAME},
+                    {Items.MUD, Items.COARSE_DIRT},
+                    {Items.MANGROVE_PLANKS, Items.ACACIA_PLANKS},
+                    {Items.MANGROVE_PROPAGULE, Items.FERN},
+                    {Items.MANGROVE_LOG, Items.ACACIA_LOG},
+                    {Items.MANGROVE_ROOTS, Items.OAK_WOOD},
+                    {Items.MUDDY_MANGROVE_ROOTS, Items.COARSE_DIRT},
+                    {Items.STRIPPED_MANGROVE_LOG, Items.STRIPPED_ACACIA_LOG},
+                    {Items.STRIPPED_MANGROVE_WOOD, Items.STRIPPED_ACACIA_WOOD},
+                    {Items.MANGROVE_WOOD, Items.ACACIA_WOOD},
+                    {Items.MANGROVE_LEAVES, Items.ACACIA_LEAVES},
+                    {Items.MANGROVE_SLAB, Items.ACACIA_SLAB},
+                    {Items.MUD_BRICK_SLAB, Items.BRICK_SLAB},
+                    {Items.MANGROVE_FENCE, Items.ACACIA_FENCE},
+                    {Items.PACKED_MUD, Items.BRICKS},
+                    {Items.MUD_BRICKS, Items.BRICKS},
+                    {Items.MUD_BRICK_STAIRS, Items.BRICK_STAIRS},
+                    {Items.MUD_BRICK_WALL, Items.BRICK_WALL},
+                    {Items.MANGROVE_STAIRS, Items.ACACIA_STAIRS},
+                    {Items.MANGROVE_BUTTON, Items.ACACIA_BUTTON},
+                    {Items.MANGROVE_PRESSURE_PLATE, Items.ACACIA_PRESSURE_PLATE},
+                    {Items.MANGROVE_DOOR, Items.ACACIA_DOOR},
+                    {Items.MANGROVE_TRAPDOOR, Items.ACACIA_TRAPDOOR},
+                    {Items.MANGROVE_FENCE_GATE, Items.ACACIA_FENCE_GATE},
+                    {Items.MANGROVE_BOAT, Items.ACACIA_BOAT},
+                    {Items.MANGROVE_SIGN, Items.ACACIA_SIGN},
+                    {Items.TADPOLE_BUCKET, Items.PUFFERFISH_BUCKET},
+                    {Items.FROG_SPAWN_EGG, Items.TROPICAL_FISH_SPAWN_EGG},
+                    {Items.TADPOLE_SPAWN_EGG, Items.DONKEY_SPAWN_EGG},
+                    {Items.OCHRE_FROGLIGHT, Items.SEA_LANTERN},
+                    {Items.VERDANT_FROGLIGHT, Items.SEA_LANTERN},
+                    {Items.PEARLESCENT_FROGLIGHT, Items.SEA_LANTERN},
+                    {Items.FROGSPAWN, Items.GLOW_LICHEN},
+                    {Items.ACACIA_CHEST_BOAT, Items.ACACIA_BOAT},
+                    {Items.DARK_OAK_CHEST_BOAT, Items.DARK_OAK_BOAT},
+                    {Items.MANGROVE_CHEST_BOAT, Items.ACACIA_BOAT},
+                    {Items.JUNGLE_CHEST_BOAT, Items.JUNGLE_BOAT},
+                    {Items.SPRUCE_CHEST_BOAT, Items.SPRUCE_BOAT},
+                    {Items.OAK_CHEST_BOAT, Items.OAK_BOAT},
+                    {Items.BIRCH_CHEST_BOAT, Items.BIRCH_BOAT},
+                    {Items.ALLAY_SPAWN_EGG, Items.ZOMBIE_SPAWN_EGG},
+                    {Items.REINFORCED_DEEPSLATE, Items.OBSIDIAN},
+                    {Items.ECHO_SHARD, Items.PRISMARINE_SHARD},
+                    {Items.RECOVERY_COMPASS, Items.COMPASS},
+                    {Items.MUSIC_DISC_5, Items.MUSIC_DISC_13},
+                    {Items.DISC_FRAGMENT_5, Items.MUSIC_DISC_13},
+                    {Items.GOAT_HORN, Items.DEAD_HORN_CORAL}
+                },
+                // 1.18 -> 1.17
+                {
+                    {Items.MUSIC_DISC_OTHERSIDE, Items.MUSIC_DISC_WARD}
+                },
+                // 1.17 -> 1.16.2
+                {
+                    {Items.DIRT_PATH, Items.GRASS_BLOCK}, // Would be GRASS_PATH, which no longer exists
+                    {Items.CALCITE, Items.POLISHED_DIORITE},
+                    {Items.TUFF, Items.COBBLESTONE},
+                    {Items.COPPER_ORE, Items.IRON_ORE},
+                    {Items.TINTED_GLASS, Items.BLACK_STAINED_GLASS},
+                    {Items.COPPER_INGOT, Items.BRICK},
+                    {Items.BUNDLE, Items.RABBIT_HIDE},
+                    {Items.CANDLE, Items.SEA_PICKLE},
+                    {Items.WHITE_CANDLE, Items.SEA_PICKLE},
+                    {Items.ORANGE_CANDLE, Items.SEA_PICKLE},
+                    {Items.MAGENTA_CANDLE, Items.SEA_PICKLE},
+                    {Items.LIGHT_BLUE_CANDLE, Items.SEA_PICKLE},
+                    {Items.YELLOW_CANDLE, Items.SEA_PICKLE},
+                    {Items.LIME_CANDLE, Items.SEA_PICKLE},
+                    {Items.PINK_CANDLE, Items.SEA_PICKLE},
+                    {Items.GRAY_CANDLE, Items.SEA_PICKLE},
+                    {Items.LIGHT_GRAY_CANDLE, Items.SEA_PICKLE},
+                    {Items.CYAN_CANDLE, Items.SEA_PICKLE},
+                    {Items.PURPLE_CANDLE, Items.SEA_PICKLE},
+                    {Items.BLUE_CANDLE, Items.SEA_PICKLE},
+                    {Items.BROWN_CANDLE, Items.SEA_PICKLE},
+                    {Items.GREEN_CANDLE, Items.SEA_PICKLE},
+                    {Items.RED_CANDLE, Items.SEA_PICKLE},
+                    {Items.BLACK_CANDLE, Items.SEA_PICKLE},
+                    {Items.AMETHYST_SHARD, Items.PRISMARINE_SHARD},
+                    {Items.AMETHYST_BLOCK, Items.PURPUR_BLOCK},
+                    {Items.BUDDING_AMETHYST, Items.PURPUR_PILLAR},
+                    {Items.SMALL_AMETHYST_BUD, Items.BUBBLE_CORAL_FAN},
+                    {Items.MEDIUM_AMETHYST_BUD, Items.BUBBLE_CORAL_FAN},
+                    {Items.LARGE_AMETHYST_BUD, Items.BUBBLE_CORAL_FAN},
+                    {Items.AMETHYST_CLUSTER, Items.BUBBLE_CORAL_FAN},
+                    {Items.SPYGLASS, Items.STICK},
+                    {Items.COPPER_BLOCK, Items.IRON_BLOCK},
+                    {Items.LIGHTNING_ROD, Items.END_ROD},
+                    {Items.POWDER_SNOW_BUCKET, Items.SNOW_BLOCK},
+                    {Items.DRIPSTONE_BLOCK, Items.GRANITE},
+                    {Items.POINTED_DRIPSTONE, Items.DEAD_BUSH},
+                    {Items.SCULK_SENSOR, Items.DARK_PRISMARINE_SLAB},
+                    {Items.AXOLOTL_BUCKET, Items.TROPICAL_FISH_BUCKET},
+                    {Items.AXOLOTL_SPAWN_EGG, Items.SHULKER_SPAWN_EGG},
+                    {Items.GLOW_ITEM_FRAME, Items.ITEM_FRAME},
+                    {Items.GLOW_LICHEN, Items.VINE},
+                    {Items.GLOW_INK_SAC, Items.INK_SAC},
+                    {Items.GLOW_SQUID_SPAWN_EGG, Items.SQUID_SPAWN_EGG},
+                    {Items.AZALEA_LEAVES, Items.JUNGLE_LEAVES},
+                    {Items.FLOWERING_AZALEA_LEAVES, Items.JUNGLE_LEAVES},
+                    {Items.AZALEA, Items.JUNGLE_LEAVES},
+                    {Items.FLOWERING_AZALEA, Items.JUNGLE_LEAVES},
+                    {Items.SPORE_BLOSSOM, Items.BUBBLE_CORAL_FAN},
+                    {Items.MOSS_CARPET, Items.GREEN_CARPET},
+                    {Items.MOSS_BLOCK, Items.GRASS_BLOCK},
+                    {Items.ROOTED_DIRT, Items.COARSE_DIRT},
+                    {Items.HANGING_ROOTS, Items.VINE},
+                    {Items.BIG_DRIPLEAF, Items.TALL_GRASS},
+                    {Items.SMALL_DRIPLEAF, Items.LARGE_FERN},
+                    {Items.GLOW_BERRIES, Items.SWEET_BERRIES},
+                    {Items.EXPOSED_COPPER, Items.BRICKS},
+                    {Items.WEATHERED_COPPER, Items.BRICKS},
+                    {Items.OXIDIZED_COPPER, Items.BRICKS},
+                    {Items.CUT_COPPER, Items.BRICKS},
+                    {Items.EXPOSED_CUT_COPPER, Items.BRICKS},
+                    {Items.WEATHERED_CUT_COPPER, Items.BRICKS},
+                    {Items.OXIDIZED_CUT_COPPER, Items.BRICKS},
+                    {Items.CUT_COPPER_STAIRS, Items.BRICK_STAIRS},
+                    {Items.EXPOSED_CUT_COPPER_STAIRS, Items.BRICK_STAIRS},
+                    {Items.WEATHERED_CUT_COPPER_STAIRS, Items.BRICK_STAIRS},
+                    {Items.OXIDIZED_CUT_COPPER_STAIRS, Items.BRICK_STAIRS},
+                    {Items.WAXED_OXIDIZED_CUT_COPPER_STAIRS, Items.BRICK_STAIRS},
+                    {Items.WAXED_OXIDIZED_CUT_COPPER_SLAB, Items.BRICK_SLAB},
+                    {Items.CUT_COPPER_SLAB, Items.BRICK_SLAB},
+                    {Items.EXPOSED_CUT_COPPER_SLAB, Items.BRICK_SLAB},
+                    {Items.WEATHERED_CUT_COPPER_SLAB, Items.BRICK_SLAB},
+                    {Items.OXIDIZED_CUT_COPPER_SLAB, Items.BRICK_SLAB},
+                    {Items.WAXED_COPPER_BLOCK, Items.BRICKS},
+                    {Items.WAXED_EXPOSED_COPPER, Items.BRICKS},
+                    {Items.WAXED_OXIDIZED_CUT_COPPER, Items.BRICKS},
+                    {Items.WAXED_OXIDIZED_COPPER, Items.BRICKS},
+                    {Items.WAXED_WEATHERED_COPPER, Items.BRICKS},
+                    {Items.WAXED_CUT_COPPER, Items.BRICKS},
+                    {Items.WAXED_EXPOSED_CUT_COPPER, Items.BRICKS},
+                    {Items.WAXED_WEATHERED_CUT_COPPER, Items.BRICKS},
+                    {Items.WAXED_CUT_COPPER_STAIRS, Items.BRICK_STAIRS},
+                    {Items.WAXED_EXPOSED_CUT_COPPER_STAIRS, Items.BRICK_STAIRS},
+                    {Items.WAXED_WEATHERED_CUT_COPPER_STAIRS, Items.BRICK_STAIRS},
+                    {Items.WAXED_CUT_COPPER_SLAB, Items.BRICK_SLAB},
+                    {Items.WAXED_EXPOSED_CUT_COPPER_SLAB, Items.BRICK_SLAB},
+                    {Items.WAXED_WEATHERED_CUT_COPPER_SLAB, Items.BRICK_SLAB},
+                    {Items.DEEPSLATE, Items.BLACKSTONE},
+                    {Items.POLISHED_DEEPSLATE, Items.POLISHED_BLACKSTONE},
+                    {Items.DEEPSLATE_BRICKS, Items.POLISHED_BLACKSTONE_BRICKS},
+                    {Items.DEEPSLATE_TILES, Items.BLACKSTONE},
+                    {Items.CHISELED_DEEPSLATE, Items.CHISELED_POLISHED_BLACKSTONE},
+                    {Items.COBBLED_DEEPSLATE, Items.POLISHED_BLACKSTONE},
+                    {Items.POLISHED_DEEPSLATE_WALL, Items.POLISHED_BLACKSTONE_WALL},
+                    {Items.DEEPSLATE_TILE_WALL, Items.POLISHED_BLACKSTONE_WALL},
+                    {Items.DEEPSLATE_BRICK_WALL, Items.POLISHED_BLACKSTONE_BRICK_WALL},
+                    {Items.COBBLED_DEEPSLATE_WALL, Items.POLISHED_BLACKSTONE_WALL},
+                    {Items.POLISHED_DEEPSLATE_STAIRS, Items.POLISHED_BLACKSTONE_BRICK_STAIRS},
+                    {Items.DEEPSLATE_TILE_STAIRS, Items.POLISHED_BLACKSTONE_STAIRS},
+                    {Items.DEEPSLATE_BRICK_STAIRS, Items.POLISHED_BLACKSTONE_BRICK_STAIRS},
+                    {Items.COBBLED_DEEPSLATE_STAIRS, Items.POLISHED_BLACKSTONE_STAIRS},
+                    {Items.POLISHED_DEEPSLATE_SLAB, Items.POLISHED_BLACKSTONE_BRICK_SLAB},
+                    {Items.DEEPSLATE_TILE_SLAB, Items.POLISHED_BLACKSTONE_SLAB},
+                    {Items.DEEPSLATE_BRICK_SLAB, Items.POLISHED_BLACKSTONE_BRICK_SLAB},
+                    {Items.COBBLED_DEEPSLATE_SLAB, Items.POLISHED_BLACKSTONE_SLAB},
+                    {Items.SMOOTH_BASALT, Items.BASALT},
+                    {Items.DEEPSLATE_REDSTONE_ORE, Items.REDSTONE_ORE},
+                    {Items.DEEPSLATE_IRON_ORE, Items.IRON_ORE},
+                    {Items.DEEPSLATE_DIAMOND_ORE, Items.DIAMOND_ORE},
+                    {Items.DEEPSLATE_GOLD_ORE, Items.GOLD_ORE},
+                    {Items.DEEPSLATE_LAPIS_ORE, Items.LAPIS_ORE},
+                    {Items.DEEPSLATE_COPPER_ORE, Items.IRON_ORE},
+                    {Items.DEEPSLATE_COAL_ORE, Items.COAL_ORE},
+                    {Items.INFESTED_DEEPSLATE, Items.BLACKSTONE},
+                    {Items.CRACKED_DEEPSLATE_BRICKS, Items.BLACKSTONE},
+                    {Items.CRACKED_DEEPSLATE_TILES, Items.BLACKSTONE},
+                    {Items.DEEPSLATE_EMERALD_ORE, Items.EMERALD_ORE},
+                    {Items.LIGHT, Items.BARRIER},
+                    {Items.RAW_GOLD, Items.GOLD_ORE},
+                    {Items.RAW_IRON, Items.IRON_ORE},
+                    {Items.RAW_COPPER, Items.IRON_ORE},
+                    {Items.GOAT_SPAWN_EGG, Items.SILVERFISH_SPAWN_EGG},
+                    {Items.RAW_IRON_BLOCK, Items.IRON_BLOCK},
+                    {Items.RAW_COPPER_BLOCK, Items.IRON_BLOCK},
+                    {Items.RAW_GOLD_BLOCK, Items.GOLD_BLOCK}
+                },
+                // 1.16.2 -> 1.16
+                {
+                    {Items.PIGLIN_BRUTE_SPAWN_EGG, Items.PIGLIN_SPAWN_EGG}
+                },
+                // 1.16 -> 1.15
+                {
+                    {Items.CRIMSON_NYLIUM, Items.MYCELIUM},
+                    {Items.WARPED_NYLIUM, Items.MYCELIUM},
+                    {Items.CRIMSON_PLANKS, Items.ACACIA_PLANKS},
+                    {Items.WARPED_PLANKS, Items.DARK_OAK_PLANKS},
+                    {Items.CRIMSON_STEM, Items.ACACIA_LOG},
+                    {Items.WARPED_STEM, Items.DARK_OAK_LOG},
+                    {Items.STRIPPED_CRIMSON_STEM, Items.STRIPPED_ACACIA_LOG},
+                    {Items.STRIPPED_WARPED_STEM, Items.STRIPPED_DARK_OAK_LOG},
+                    {Items.CRIMSON_FUNGUS, Items.RED_MUSHROOM},
+                    {Items.WARPED_FUNGUS, Items.BROWN_MUSHROOM},
+                    {Items.CRIMSON_ROOTS, Items.GRASS},
+                    {Items.WARPED_ROOTS, Items.GRASS},
+                    {Items.NETHER_SPROUTS, Items.GRASS},
+                    {Items.WEEPING_VINES, Items.VINE},
+                    {Items.CRIMSON_SLAB, Items.ACACIA_SLAB},
+                    {Items.WARPED_SLAB, Items.DARK_OAK_SLAB},
+                    {Items.CRIMSON_PRESSURE_PLATE, Items.ACACIA_PRESSURE_PLATE},
+                    {Items.WARPED_PRESSURE_PLATE, Items.DARK_OAK_PRESSURE_PLATE},
+                    {Items.CRIMSON_FENCE, Items.ACACIA_FENCE},
+                    {Items.WARPED_FENCE, Items.DARK_OAK_FENCE},
+                    {Items.SOUL_SOIL, Items.SOUL_SAND},
+                    {Items.BASALT, Items.GRAY_GLAZED_TERRACOTTA},
+                    {Items.SOUL_TORCH, Items.TORCH},
+                    {Items.CRIMSON_TRAPDOOR, Items.ACACIA_TRAPDOOR},
+                    {Items.WARPED_TRAPDOOR, Items.DARK_OAK_TRAPDOOR},
+                    {Items.CRIMSON_FENCE_GATE, Items.ACACIA_FENCE_GATE},
+                    {Items.WARPED_FENCE_GATE, Items.DARK_OAK_FENCE_GATE},
+                    {Items.CRIMSON_STAIRS, Items.ACACIA_STAIRS},
+                    {Items.WARPED_STAIRS, Items.DARK_OAK_STAIRS},
+                    {Items.CRIMSON_BUTTON, Items.ACACIA_BUTTON},
+                    {Items.WARPED_BUTTON, Items.DARK_OAK_BUTTON},
+                    {Items.WARPED_WART_BLOCK, Items.CYAN_WOOL},
+                    {Items.CRIMSON_DOOR, Items.ACACIA_DOOR},
+                    {Items.WARPED_DOOR, Items.DARK_OAK_DOOR},
+                    {Items.CRIMSON_SIGN, Items.ACACIA_SIGN},
+                    {Items.WARPED_SIGN, Items.DARK_OAK_SIGN},
+                    {Items.HOGLIN_SPAWN_EGG, Items.ZOMBIE_SPAWN_EGG}, // Would be ZOMBIE_PIGMAN_SPAWN_EGG, which no longer exists
+                    {Items.ZOGLIN_SPAWN_EGG, Items.ZOMBIE_SPAWN_EGG}, // Would be ZOMBIE_PIGMAN_SPAWN_EGG, which no longer exists
+                    {Items.PIGLIN_SPAWN_EGG, Items.ZOMBIE_SPAWN_EGG}, // Would be ZOMBIE_PIGMAN_SPAWN_EGG, which no longer exists
+                    {Items.STRIDER_SPAWN_EGG, Items.SALMON_SPAWN_EGG},
+                    {Items.SOUL_LANTERN, Items.LANTERN},
+                    {Items.SHROOMLIGHT, Items.GLOWSTONE},
+                    {Items.NETHERITE_BLOCK, Items.IRON_BLOCK},
+                    {Items.ANCIENT_DEBRIS, Items.OBSIDIAN},
+                    {Items.NETHERITE_INGOT, Items.IRON_INGOT},
+                    {Items.NETHERITE_SCRAP, Items.BRICK},
+                    {Items.NETHERITE_SWORD, Items.DIAMOND_SWORD},
+                    {Items.NETHERITE_SHOVEL, Items.DIAMOND_SHOVEL},
+                    {Items.NETHERITE_PICKAXE, Items.DIAMOND_PICKAXE},
+                    {Items.NETHERITE_AXE, Items.DIAMOND_AXE},
+                    {Items.NETHERITE_HOE, Items.DIAMOND_HOE},
+                    {Items.NETHERITE_HELMET, Items.DIAMOND_HELMET},
+                    {Items.NETHERITE_CHESTPLATE, Items.DIAMOND_CHESTPLATE},
+                    {Items.NETHERITE_LEGGINGS, Items.DIAMOND_LEGGINGS},
+                    {Items.NETHERITE_BOOTS, Items.DIAMOND_BOOTS},
+                    {Items.CRYING_OBSIDIAN, Items.OBSIDIAN},
+                    {Items.TARGET, Items.HAY_BLOCK},
+                    {Items.STRIPPED_WARPED_HYPHAE, Items.STRIPPED_DARK_OAK_WOOD},
+                    {Items.STRIPPED_CRIMSON_HYPHAE, Items.STRIPPED_ACACIA_WOOD},
+                    {Items.WARPED_HYPHAE, Items.DARK_OAK_WOOD},
+                    {Items.CRIMSON_HYPHAE, Items.ACACIA_WOOD},
+                    {Items.ZOMBIFIED_PIGLIN_SPAWN_EGG, Items.ZOMBIE_SPAWN_EGG}, // Would be ZOMBIE_PIGMAN_SPAWN_EGG, which no longer exists
+                    {Items.NETHER_GOLD_ORE, Items.GOLD_ORE},
+                    {Items.TWISTING_VINES, Items.VINE},
+                    {Items.RESPAWN_ANCHOR, Items.OBSIDIAN},
+                    {Items.POLISHED_BASALT, Items.GRAY_GLAZED_TERRACOTTA},
+                    {Items.LODESTONE, Items.CHISELED_QUARTZ_BLOCK},
+                    {Items.WARPED_FUNGUS_ON_A_STICK, Items.CARROT_ON_A_STICK},
+                    {Items.CRACKED_NETHER_BRICKS, Items.NETHER_BRICKS},
+                    {Items.CHISELED_NETHER_BRICKS, Items.NETHER_BRICKS},
+                    {Items.QUARTZ_BRICKS, Items.QUARTZ_BLOCK},
+                    {Items.PIGLIN_BANNER_PATTERN, Items.FLOWER_BANNER_PATTERN},
+                    {Items.SOUL_CAMPFIRE, Items.CAMPFIRE},
+                    {Items.BLACKSTONE, Items.NETHER_BRICKS},
+                    {Items.BLACKSTONE_SLAB, Items.NETHER_BRICK_SLAB},
+                    {Items.BLACKSTONE_STAIRS, Items.NETHER_BRICK_STAIRS},
+                    {Items.BLACKSTONE_WALL, Items.NETHER_BRICK_WALL},
+                    {Items.GILDED_BLACKSTONE, Items.RED_NETHER_BRICKS},
+                    {Items.POLISHED_BLACKSTONE, Items.RED_NETHER_BRICKS},
+                    {Items.POLISHED_BLACKSTONE_SLAB, Items.RED_NETHER_BRICK_SLAB},
+                    {Items.POLISHED_BLACKSTONE_STAIRS, Items.RED_NETHER_BRICK_STAIRS},
+                    {Items.POLISHED_BLACKSTONE_WALL, Items.RED_NETHER_BRICK_WALL},
+                    {Items.POLISHED_BLACKSTONE_BUTTON, Items.STONE_BUTTON},
+                    {Items.POLISHED_BLACKSTONE_PRESSURE_PLATE, Items.STONE_PRESSURE_PLATE},
+                    {Items.CHISELED_POLISHED_BLACKSTONE, Items.RED_NETHER_BRICKS},
+                    {Items.POLISHED_BLACKSTONE_BRICKS, Items.RED_NETHER_BRICKS},
+                    {Items.POLISHED_BLACKSTONE_BRICK_SLAB, Items.RED_NETHER_BRICK_SLAB},
+                    {Items.POLISHED_BLACKSTONE_BRICK_STAIRS, Items.RED_NETHER_BRICK_STAIRS},
+                    {Items.POLISHED_BLACKSTONE_BRICK_WALL, Items.RED_NETHER_BRICK_WALL},
+                    {Items.CRACKED_POLISHED_BLACKSTONE_BRICKS, Items.RED_NETHER_BRICKS},
+                    {Items.CHAIN, Items.IRON_BARS},
+                    {Items.MUSIC_DISC_PIGSTEP, Items.MUSIC_DISC_13}
+                },
+                // 1.15 -> 1.14
+                {
+                    {Items.HONEY_BOTTLE, Items.DRAGON_BREATH},
+                    {Items.HONEYCOMB, Items.SUNFLOWER},
+                    {Items.HONEYCOMB_BLOCK, Items.HORN_CORAL_BLOCK},
+                    {Items.BEE_NEST, Items.YELLOW_SHULKER_BOX},
+                    {Items.BEEHIVE, Items.BARREL},
+                    {Items.HONEY_BLOCK, Items.SLIME_BLOCK},
+                    {Items.BEE_SPAWN_EGG, Items.OCELOT_SPAWN_EGG}
+                },
+                // 1.14 -> 1.13
+                {
+                    {Items.BRICK_WALL, Items.COBBLESTONE_WALL},
+                    {Items.PRISMARINE_WALL, Items.COBBLESTONE_WALL},
+                    {Items.RED_SANDSTONE_WALL, Items.COBBLESTONE_WALL},
+                    {Items.MOSSY_STONE_BRICK_WALL, Items.MOSSY_COBBLESTONE_WALL},
+                    {Items.GRANITE_WALL, Items.COBBLESTONE_WALL},
+                    {Items.STONE_BRICK_WALL, Items.COBBLESTONE_WALL},
+                    {Items.NETHER_BRICK_WALL, Items.COBBLESTONE_WALL},
+                    {Items.ANDESITE_WALL, Items.COBBLESTONE_WALL},
+                    {Items.RED_NETHER_BRICK_WALL, Items.COBBLESTONE_WALL},
+                    {Items.SANDSTONE_WALL, Items.COBBLESTONE_WALL},
+                    {Items.END_STONE_BRICK_WALL, Items.COBBLESTONE_WALL},
+                    {Items.DIORITE_WALL, Items.COBBLESTONE_WALL},
+                    {Items.STONE_SLAB, Items.COBBLESTONE_SLAB},
+                    {Items.CUT_SANDSTONE_SLAB, Items.SANDSTONE_SLAB},
+                    {Items.CUT_RED_SANDSTONE_SLAB, Items.RED_SANDSTONE_SLAB},
+                    {Items.POLISHED_GRANITE_SLAB, Items.COBBLESTONE_SLAB},
+                    {Items.SMOOTH_RED_SANDSTONE_SLAB, Items.RED_SANDSTONE_SLAB},
+                    {Items.MOSSY_STONE_BRICK_SLAB, Items.COBBLESTONE_SLAB},
+                    {Items.POLISHED_DIORITE_SLAB, Items.COBBLESTONE_SLAB},
+                    {Items.MOSSY_COBBLESTONE_SLAB, Items.COBBLESTONE_SLAB},
+                    {Items.END_STONE_BRICK_SLAB, Items.SANDSTONE_SLAB},
+                    {Items.SMOOTH_SANDSTONE_SLAB, Items.SANDSTONE_SLAB},
+                    {Items.SMOOTH_QUARTZ_SLAB, Items.QUARTZ_SLAB},
+                    {Items.GRANITE_SLAB, Items.COBBLESTONE_SLAB},
+                    {Items.ANDESITE_SLAB, Items.COBBLESTONE_SLAB},
+                    {Items.RED_NETHER_BRICK_SLAB, Items.NETHER_BRICK_SLAB},
+                    {Items.POLISHED_ANDESITE_SLAB, Items.COBBLESTONE_SLAB},
+                    {Items.DIORITE_SLAB, Items.COBBLESTONE_SLAB},
+                    {Items.POLISHED_GRANITE_STAIRS, Items.COBBLESTONE_STAIRS},
+                    {Items.SMOOTH_RED_SANDSTONE_STAIRS, Items.RED_SANDSTONE_STAIRS},
+                    {Items.MOSSY_STONE_BRICK_STAIRS, Items.COBBLESTONE_STAIRS},
+                    {Items.POLISHED_DIORITE_STAIRS, Items.COBBLESTONE_STAIRS},
+                    {Items.MOSSY_COBBLESTONE_STAIRS, Items.COBBLESTONE_STAIRS},
+                    {Items.END_STONE_BRICK_STAIRS, Items.SANDSTONE_STAIRS},
+                    {Items.STONE_STAIRS, Items.COBBLESTONE_STAIRS},
+                    {Items.SMOOTH_SANDSTONE_STAIRS, Items.SANDSTONE_STAIRS},
+                    {Items.SMOOTH_QUARTZ_STAIRS, Items.QUARTZ_STAIRS},
+                    {Items.GRANITE_STAIRS, Items.COBBLESTONE_STAIRS},
+                    {Items.ANDESITE_STAIRS, Items.COBBLESTONE_STAIRS},
+                    {Items.RED_NETHER_BRICK_STAIRS, Items.NETHER_BRICK_STAIRS},
+                    {Items.POLISHED_ANDESITE_STAIRS, Items.COBBLESTONE_STAIRS},
+                    {Items.DIORITE_STAIRS, Items.COBBLESTONE_STAIRS},
+                    {Items.CORNFLOWER, Items.BROWN_MUSHROOM},
+                    {Items.LILY_OF_THE_VALLEY, Items.WHITE_TULIP},
+                    {Items.WITHER_ROSE, Items.BLUE_ORCHID},
+                    {Items.BAMBOO, Items.SUGAR_CANE},
+                    {Items.SUSPICIOUS_STEW, Items.MUSHROOM_STEW},
+                    {Items.LEATHER_HORSE_ARMOR, Items.GOLDEN_HORSE_ARMOR},
+                    {Items.BLUE_DYE, Items.LAPIS_LAZULI},
+                    {Items.BROWN_DYE, Items.COCOA_BEANS},
+                    {Items.BLACK_DYE, Items.INK_SAC},
+                    {Items.WHITE_DYE, Items.BONE_MEAL},
+                    {Items.SCAFFOLDING, Items.HAY_BLOCK},
+                    {Items.JIGSAW, Items.STRUCTURE_BLOCK},
+                    {Items.COMPOSTER, Items.CAULDRON},
+                    {Items.BARREL, Items.CHEST},
+                    {Items.LOOM, Items.CRAFTING_TABLE},
+                    {Items.SMOKER, Items.FURNACE},
+                    {Items.BLAST_FURNACE, Items.FURNACE},
+                    {Items.CARTOGRAPHY_TABLE, Items.CRAFTING_TABLE},
+                    {Items.FLETCHING_TABLE, Items.CRAFTING_TABLE},
+                    {Items.GRINDSTONE, Items.ANVIL},
+                    {Items.LECTERN, Items.BOOKSHELF},
+                    {Items.SMITHING_TABLE, Items.CRAFTING_TABLE},
+                    {Items.STONECUTTER, Items.CRAFTING_TABLE},
+                    {Items.FLOWER_BANNER_PATTERN, Items.PAPER},
+                    {Items.CREEPER_BANNER_PATTERN, Items.PAPER},
+                    {Items.SKULL_BANNER_PATTERN, Items.PAPER},
+                    {Items.MOJANG_BANNER_PATTERN, Items.PAPER},
+                    {Items.GLOBE_BANNER_PATTERN, Items.PAPER},
+                    {Items.BELL, Items.GOLD_BLOCK},
+                    {Items.LANTERN, Items.REDSTONE_LAMP},
+                    {Items.SWEET_BERRIES, Items.BEETROOT},
+                    {Items.CAMPFIRE, Items.TORCH},
+                    {Items.SPRUCE_SIGN, Items.OAK_SIGN},
+                    {Items.BIRCH_SIGN, Items.OAK_SIGN},
+                    {Items.JUNGLE_SIGN, Items.OAK_SIGN},
+                    {Items.ACACIA_SIGN, Items.OAK_SIGN},
+                    {Items.DARK_OAK_SIGN, Items.OAK_SIGN},
+                    {Items.CROSSBOW, Items.BOW},
+                    {Items.CAT_SPAWN_EGG, Items.OCELOT_SPAWN_EGG},
+                    {Items.FOX_SPAWN_EGG, Items.PIG_SPAWN_EGG},
+                    {Items.PANDA_SPAWN_EGG, Items.SKELETON_SPAWN_EGG},
+                    {Items.PILLAGER_SPAWN_EGG, Items.ZOMBIE_VILLAGER_SPAWN_EGG},
+                    {Items.RAVAGER_SPAWN_EGG, Items.SILVERFISH_SPAWN_EGG},
+                    {Items.TRADER_LLAMA_SPAWN_EGG, Items.BLAZE_SPAWN_EGG},
+                    {Items.WANDERING_TRADER_SPAWN_EGG, Items.SQUID_SPAWN_EGG}
+                },
+                // 1.13 -> 1.12
+                {
+                    {Items.ACACIA_BUTTON, Items.OAK_BUTTON},
+                    {Items.BIRCH_BUTTON, Items.OAK_BUTTON},
+                    {Items.SPRUCE_BUTTON, Items.OAK_BUTTON},
+                    {Items.JUNGLE_BUTTON, Items.OAK_BUTTON},
+                    {Items.DARK_OAK_BUTTON, Items.OAK_BUTTON},
+                    {Items.ACACIA_TRAPDOOR, Items.OAK_TRAPDOOR},
+                    {Items.BIRCH_TRAPDOOR, Items.OAK_TRAPDOOR},
+                    {Items.SPRUCE_TRAPDOOR, Items.OAK_TRAPDOOR},
+                    {Items.JUNGLE_TRAPDOOR, Items.OAK_TRAPDOOR},
+                    {Items.DARK_OAK_TRAPDOOR, Items.OAK_TRAPDOOR},
+                    {Items.ACACIA_PRESSURE_PLATE, Items.OAK_TRAPDOOR},
+                    {Items.BIRCH_PRESSURE_PLATE, Items.OAK_TRAPDOOR},
+                    {Items.SPRUCE_PRESSURE_PLATE, Items.OAK_TRAPDOOR},
+                    {Items.JUNGLE_PRESSURE_PLATE, Items.OAK_TRAPDOOR},
+                    {Items.DARK_OAK_PRESSURE_PLATE, Items.OAK_TRAPDOOR},
+                    {Items.ACACIA_BOAT, Items.OAK_BOAT},
+                    {Items.BIRCH_BOAT, Items.OAK_BOAT},
+                    {Items.SPRUCE_BOAT, Items.OAK_BOAT},
+                    {Items.JUNGLE_BOAT, Items.OAK_BOAT},
+                    {Items.DARK_OAK_BOAT, Items.OAK_BOAT},
+                    {Items.BLUE_ICE, Items.PACKED_ICE},
+                    {Items.PUFFERFISH_BUCKET, Items.WATER_BUCKET},
+                    {Items.SALMON_BUCKET, Items.WATER_BUCKET},
+                    {Items.COD_BUCKET, Items.WATER_BUCKET},
+                    {Items.TROPICAL_FISH_BUCKET, Items.WATER_BUCKET},
+                    {Items.HEART_OF_THE_SEA, Items.SNOWBALL},
+                    {Items.NAUTILUS_SHELL, Items.BONE_MEAL},
+                    {Items.PHANTOM_MEMBRANE, Items.LEATHER},
+                    {Items.TURTLE_HELMET, Items.LEATHER_HELMET},
+                    {Items.TURTLE_EGG, Items.EGG},
+                    {Items.SCUTE, Items.LIME_DYE},
+                    {Items.TRIDENT, Items.DIAMOND_SWORD},
+                    {Items.SEA_PICKLE, Items.EGG},
+                    {Items.SEAGRASS, Items.GRASS},
+                    {Items.CONDUIT, Items.BEACON},
+                    {Items.KELP, Items.GRASS},
+                    {Items.DRIED_KELP, Items.WHEAT},
+                    {Items.DRIED_KELP_BLOCK, Items.HAY_BLOCK},
+                    {Items.STRIPPED_OAK_LOG, Items.OAK_LOG},
+                    {Items.STRIPPED_ACACIA_LOG, Items.ACACIA_LOG},
+                    {Items.STRIPPED_BIRCH_LOG, Items.BIRCH_LOG},
+                    {Items.STRIPPED_SPRUCE_LOG, Items.SPRUCE_LOG},
+                    {Items.STRIPPED_JUNGLE_LOG, Items.JUNGLE_LOG},
+                    {Items.STRIPPED_DARK_OAK_LOG, Items.DARK_OAK_LOG},
+                    {Items.STRIPPED_OAK_WOOD, Items.OAK_LOG},
+                    {Items.STRIPPED_ACACIA_WOOD, Items.ACACIA_LOG},
+                    {Items.STRIPPED_BIRCH_WOOD, Items.BIRCH_LOG},
+                    {Items.STRIPPED_SPRUCE_WOOD, Items.SPRUCE_LOG},
+                    {Items.STRIPPED_JUNGLE_WOOD, Items.JUNGLE_LOG},
+                    {Items.STRIPPED_DARK_OAK_WOOD, Items.DARK_OAK_LOG},
+                    {Items.OAK_WOOD, Items.OAK_LOG},
+                    {Items.SPRUCE_WOOD, Items.SPRUCE_LOG},
+                    {Items.BIRCH_WOOD, Items.BIRCH_LOG},
+                    {Items.JUNGLE_WOOD, Items.JUNGLE_LOG},
+                    {Items.ACACIA_WOOD, Items.ACACIA_LOG},
+                    {Items.DARK_OAK_WOOD, Items.DARK_OAK_LOG},
+                    {Items.PRISMARINE_SLAB, Items.COBBLESTONE_SLAB},
+                    {Items.PRISMARINE_BRICK_SLAB, Items.BRICK_SLAB},
+                    {Items.DARK_PRISMARINE_SLAB, Items.STONE_BRICK_SLAB},
+                    {Items.PRISMARINE_STAIRS, Items.COBBLESTONE_STAIRS},
+                    {Items.PRISMARINE_BRICK_STAIRS, Items.BRICK_STAIRS},
+                    {Items.DARK_PRISMARINE_STAIRS, Items.STONE_BRICK_STAIRS},
+                    {Items.DROWNED_SPAWN_EGG, Items.RABBIT_SPAWN_EGG},
+                    {Items.PHANTOM_SPAWN_EGG, Items.RABBIT_SPAWN_EGG},
+                    {Items.DOLPHIN_SPAWN_EGG, Items.RABBIT_SPAWN_EGG},
+                    {Items.TURTLE_SPAWN_EGG, Items.RABBIT_SPAWN_EGG},
+                    {Items.COD_SPAWN_EGG, Items.RABBIT_SPAWN_EGG},
+                    {Items.SALMON_SPAWN_EGG, Items.RABBIT_SPAWN_EGG},
+                    {Items.PUFFERFISH_SPAWN_EGG, Items.RABBIT_SPAWN_EGG},
+                    {Items.TROPICAL_FISH_SPAWN_EGG, Items.RABBIT_SPAWN_EGG},
+                    {Items.TUBE_CORAL, Items.BLUE_ORCHID},
+                    {Items.BRAIN_CORAL, Items.PINK_TULIP},
+                    {Items.BUBBLE_CORAL, Items.ALLIUM},
+                    {Items.FIRE_CORAL, Items.RED_TULIP},
+                    {Items.HORN_CORAL, Items.DANDELION},
+                    {Items.TUBE_CORAL_FAN, Items.BLUE_ORCHID},
+                    {Items.BRAIN_CORAL_FAN, Items.PINK_TULIP},
+                    {Items.BUBBLE_CORAL_FAN, Items.ALLIUM},
+                    {Items.FIRE_CORAL_FAN, Items.RED_TULIP},
+                    {Items.HORN_CORAL_FAN, Items.DANDELION},
+                    {Items.DEAD_TUBE_CORAL_FAN, Items.DEAD_BUSH},
+                    {Items.DEAD_BRAIN_CORAL_FAN, Items.DEAD_BUSH},
+                    {Items.DEAD_BUBBLE_CORAL_FAN, Items.DEAD_BUSH},
+                    {Items.DEAD_FIRE_CORAL_FAN, Items.DEAD_BUSH},
+                    {Items.DEAD_HORN_CORAL_FAN, Items.DEAD_BUSH},
+                    {Items.DEAD_TUBE_CORAL_BLOCK, Items.LIGHT_GRAY_WOOL},
+                    {Items.DEAD_BRAIN_CORAL_BLOCK, Items.LIGHT_GRAY_WOOL},
+                    {Items.DEAD_BUBBLE_CORAL_BLOCK, Items.LIGHT_GRAY_WOOL},
+                    {Items.DEAD_FIRE_CORAL_BLOCK, Items.LIGHT_GRAY_WOOL},
+                    {Items.DEAD_HORN_CORAL_BLOCK, Items.LIGHT_GRAY_WOOL},
+                    {Items.TUBE_CORAL_BLOCK, Items.BLUE_WOOL},
+                    {Items.BRAIN_CORAL_BLOCK, Items.PINK_WOOL},
+                    {Items.BUBBLE_CORAL_BLOCK, Items.PURPLE_WOOL},
+                    {Items.FIRE_CORAL_BLOCK, Items.RED_WOOL},
+                    {Items.HORN_CORAL_BLOCK, Items.YELLOW_WOOL},
+                    {Items.SMOOTH_QUARTZ, Items.QUARTZ},
+                    {Items.SMOOTH_RED_SANDSTONE, Items.RED_SANDSTONE},
+                    {Items.SMOOTH_SANDSTONE, Items.SANDSTONE},
+                    {Items.SMOOTH_STONE, Items.STONE_SLAB},
+                    {Items.PUMPKIN, Items.CARVED_PUMPKIN},
+                    {Items.MUSHROOM_STEM, Items.LIGHT_GRAY_WOOL},
+                    {Items.DEBUG_STICK, Items.STICK}
+                }
+            };
+            blockEntityItemMappingsForVersionCompatibilityList = new ArrayList<>(blockEntityItemMappingsForVersionCompatibility.length);
+            for (Item[][] mappingsFromVersionToVersion : blockEntityItemMappingsForVersionCompatibility) {
+                Map<Item, Item> mappingsFromVersionToVersionMap = new IdentityHashMap<>(mappingsFromVersionToVersion.length);
+                for (Item[] mapping : mappingsFromVersionToVersion) {
+                    mappingsFromVersionToVersionMap.put(mapping[0], mapping[1]);
+                }
+                blockEntityItemMappingsForVersionCompatibilityList.add(mappingsFromVersionToVersionMap);
+            }
+        }
+        return blockEntityItemMappingsForVersionCompatibilityList;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/replacementrule/BlockReplacementRule.java b/src/main/java/org/sucraft/suki/block/replacementrule/BlockReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..b82ace58d0e595e1f815af12ad3fddea22643ab9
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/replacementrule/BlockReplacementRule.java
@@ -0,0 +1,475 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block.replacementrule;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import org.sucraft.suki.block.UsedHostBlockStates;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelVisualProperties;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelVisualPropertiesUniverse;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.blockanditemdata.model.ModelContent;
+import org.sucraft.suki.blockanditemdata.model.ModelCreation;
+import org.sucraft.suki.blockanditemdata.model.ModelParameters;
+import org.sucraft.suki.blockanditemdata.model.ModelWithParameters;
+import org.sucraft.suki.blockanditemdata.texture.TextureContent;
+import org.sucraft.suki.item.ItemReplacementRule;
+import org.sucraft.suki.resourcepack.MutableResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.blockstates.MutableResourcePackBlockStates;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.sucraft.suki.resourcepack.asset.model.MutableResourcePackModel;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * A rule that is fully responsible for exactly 1 real block,
+ * and replaces each of its state with some host (multiple real states may have the same host state when the difference between those real states is not important to be observable) (multiple other replacement rules may use the same hosts),
+ * and replaces each host with some host replacement state that is a good observable alternative to the host state (multiple hosts may have the same host replacement state) (when another replacement rule uses a same host as well, it should have the same host replacement for that host (this is not checked at runtime!))
+ */
+public interface BlockReplacementRule {
+
+    @NotNull Block getReal();
+
+    boolean hasAsReal(@NotNull Block potentialReal);
+
+    boolean isFire();
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    boolean rendersAsEntity(@NotNull BlockState realState);
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     * <br>
+     * Returns null if and only if the given real state does not render as an entity
+     */
+    @Nullable BlockEntityModelVisualPropertiesUniverse<?> getEntityRenderModelVisualPropertiesUniverse(@NotNull BlockState realState);
+
+    /**
+     * Returns true if and only if {@link #rendersAsEntity(BlockState)} returns true for some state of this rule's real block
+     */
+    boolean rendersSomeStatesAsEntity();
+
+    /**
+     * Contains no duplicates
+     */
+    @NotNull List<@NotNull BlockState> getHosts();
+
+    boolean hasAsHost(@NotNull BlockState potentialHost);
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    @NotNull BlockState getHost(@NotNull BlockState realState);
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a host of this rule
+     * <br>
+     * Returns null if @{link #rendersAsEntity} is true
+     */
+    @Nullable BlockState getHostReplacement(@NotNull BlockState host);
+
+    /**
+     * Contains no duplicates
+     */
+    @NotNull List<@NotNull BlockState> getFallbacks();
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    @NotNull BlockState getFallback(@NotNull BlockState realState);
+
+    /**
+     * All blocks that serve as a host or fallback, without duplicates
+     */
+    @NotNull List<@NotNull Block> getHostAndFallbackBlocks();
+
+    /**
+     * All blocks that may potentially be observed as another block
+     * <br>
+     * Represented by an iterable of pairs, where each pair holds first a block type that may be presented as something different when sent, and second the block type that can be observed by the user instead of the first block
+     * <br>
+     * Contains no duplicates, and contains no pairs where the first and second element are equal
+     */
+    @NotNull List<@NotNull Pair<@NotNull Block, @NotNull Block>> getPotentialBlockReplacementPairs();
+
+    /**
+     * Returns a replacement state (either real to host, or host to host replacement) for the given state, if this rule is applicable
+     * <br>
+     * Returns null if this rule does not apply to the given state
+     */
+    default @Nullable BlockState replace(@NotNull BlockState state, boolean hasResourcePack) {
+        if (state.is(this.getReal())) {
+            return hasResourcePack ? this.getHost(state) : this.getFallback(state);
+        } else if (hasResourcePack && this.hasAsHost(state)) {
+            if (!this.rendersSomeStatesAsEntity()) {
+                return this.getHostReplacement(state);
+            }
+        }
+        return null;
+    }
+
+    default void writeToStateIdReplacementArrays() {
+        for (@NotNull BlockState realState : this.getReal().getStateDefinition().getPossibleStates()) {
+            int realStateId = Block.BLOCK_STATE_REGISTRY.getId(realState);
+            int hostId = Block.BLOCK_STATE_REGISTRY.getId(this.getHost(realState));
+            int fallbackId = Block.BLOCK_STATE_REGISTRY.getId(this.getFallback(realState));
+            Block.stateIdReplacementArrayWithResourcePack[realStateId] = hostId;
+            Block.stateIdReplacementArrayWithoutResourcePack[realStateId] = fallbackId;
+            Block.addRealStateToPlayerObservableStates(realStateId, hostId);
+            Block.addRealStateToPlayerObservableStates(realStateId, fallbackId);
+        }
+        if (!this.rendersSomeStatesAsEntity()) {
+            for (@NotNull BlockState host : this.getHosts()) {
+                int hostId = Block.BLOCK_STATE_REGISTRY.getId(host);
+                int hostReplacementId = Block.BLOCK_STATE_REGISTRY.getId(this.getHostReplacement(host));
+                Block.stateIdReplacementArrayWithResourcePack[hostId] = hostReplacementId;
+                Block.addRealStateToPlayerObservableStates(hostId, hostReplacementId);
+            }
+        }
+    }
+
+    default void updateMinDestroyTimes() {
+        this.updateMinDestroyTimeOfReal(); // Some will see it as the host, others as the fallback
+        this.updateMinDestroyTimeOfHosts(); // Some may see it as the host replacement
+    }
+
+    default void updateMinDestroyTimeOfReal() {
+        this.getReal().updateDestroyTime(Math.min(
+            this.getReal().properties.destroyTime,
+            this.getMinDestroyTimeOfHostsAndFallbacks()
+        ));
+    }
+
+    default void updateMinDestroyTimeOfHosts() {
+        if (!this.rendersSomeStatesAsEntity()) {
+            for (@NotNull BlockState host : this.getHosts()) {
+                host.getBlock().updateDestroyTime(this.getMinDestroyTimeOfHostAndHostReplacement(host));
+            }
+        }
+    }
+
+    default float getMinDestroyTimeOfHostsAndFallbacks() {
+        return Stream.concat(this.getHosts().stream(), this.getFallbacks().stream()).map(state -> state.getBlock().properties.destroyTime).min(Float::compareTo).get();
+    }
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a host of this rule
+     */
+    default float getMinDestroyTimeOfHostAndHostReplacement(@NotNull BlockState host) {
+//        System.out.println("TEMP DEBUG - Of: " + this.getReal() + " renders as entity: " + this.rendersSomeStatesAsEntity() + " with host " + host.getBlock() + " = " + host.toVariantString());
+        if (this.rendersSomeStatesAsEntity()) {
+            return host.getBlock().properties.destroyTime;
+        }
+        return Math.min(
+            host.getBlock().properties.destroyTime,
+            this.getHostReplacement(host).getBlock().properties.destroyTime
+        );
+    }
+
+    /**
+     * This method will assume (not verify) that the given state is in fact a host of this rule
+     * <br>
+     * This method will be called multiple times, so it should never compute anything twice
+     * <br>
+     * May or may not return null if {@link #rendersAsEntity} is true and the given {@param host} is not the host for the default state of the real block
+     * @throw IllegalStateException If this rule is for fire
+     */
+    @Nullable ModelWithParameters getModel(@NotNull BlockState host);
+
+    @Nullable RealItemReplacementRule getRealItemRule();
+
+    @NotNull List<@NotNull HostItemReplacementRule> getHostItemRules();
+
+    /**
+     * Returns whether this item, when placing it as a block, would place a block state that serves as a host in this replacement rule
+     */
+    boolean isHostPlacingItem(@NotNull Item item);
+
+    /**
+     * Returns all items for which {@link #isHostPlacingItem} is true, without duplicates
+     */
+    @NotNull List<@NotNull Item> getHostPlacingItems();
+
+    /**
+     * Returns the item we would like to replace a host placing item by
+     * <br>
+     * Returns null if the item given is not a host placing item
+     */
+    @Nullable Item getHostPlacingItemReplacement(@NotNull Item item);
+
+    /**
+     * Returns a state of the real block that is representative of the real block (by default, this is the default state of the real block, which should be appropriate in most cases, but we may wish to override it in the future)
+     * <br>
+     * This is currently used as the item model if this real block has a corresponding block item
+     *
+     * @see #getRealItemModel
+     */
+    default @NotNull BlockState getRepresentativeRealState() {
+        return this.getReal().defaultBlockState();
+    }
+
+    /**
+     * Returns the model for the real block item of this block
+     * <br>
+     * Returns null or an arbitrary meaning less value if the real block does not have a corresponding block item
+     */
+    default @Nullable Model getRealItemModel() {
+        return this.getModel(this.getHost(this.getRepresentativeRealState())).model().getReference(ResourcePackAssetIntention.ITEM);
+    }
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    default <P extends BlockEntityModelVisualProperties> @Nullable Model getBlockEntityItemModel(@NotNull BlockState realState, @NotNull P properties) {
+        BlockEntityModelVisualPropertiesUniverse<P> universe = (BlockEntityModelVisualPropertiesUniverse<P>) this.getEntityRenderModelVisualPropertiesUniverse(realState);
+        Model[] models = this.getBlockEntityItemModels(realState);
+        return models[universe.getIndex(properties)];
+    }
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    @NotNull Model @Nullable [] getBlockEntityItemModels(@NotNull BlockState realState);
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    default @NotNull Model @Nullable [] computeBlockEntityItemModels(@NotNull BlockState realState) {
+        var base = this.getBlockEntityItemModelBase(realState);
+        if (base == null) {
+            return null;
+        }
+        BlockEntityModelVisualPropertiesUniverse<?> universe = this.getEntityRenderModelVisualPropertiesUniverse(realState);
+        return Arrays.stream(universe.getValues()).map(base::getBlockEntityVersion).toArray(Model[]::new);
+    }
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    @Nullable Model getBlockEntityItemModelBase(@NotNull BlockState realState);
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    default <P extends BlockEntityModelVisualProperties> @Nullable Integer getBlockEntityItemCustomModelData(@NotNull BlockState realState, @NotNull P properties) {
+        int[] customModelData = this.getBlockEntityItemCustomModelData(realState);
+        if (customModelData == null) {
+            return null;
+        }
+        BlockEntityModelVisualPropertiesUniverse<P> universe = (BlockEntityModelVisualPropertiesUniverse<P>) this.getEntityRenderModelVisualPropertiesUniverse(realState);
+        return customModelData[universe.getIndex(properties)];
+    }
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    int @Nullable [] getBlockEntityItemCustomModelData(@NotNull BlockState realState);
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    default <P extends BlockEntityModelVisualProperties> @Nullable ItemStack getBlockEntityItemStack(@NotNull BlockState realState, @NotNull P properties) {
+        var itemStack = this.getBlockEntityItemStack(realState);
+        if (itemStack == null) {
+            return null;
+        }
+        BlockEntityModelVisualPropertiesUniverse<P> universe = (BlockEntityModelVisualPropertiesUniverse<P>) this.getEntityRenderModelVisualPropertiesUniverse(realState);
+        return itemStack.getForContext(properties, universe);
+    }
+
+    default @NotNull Item computeBlockEntityItem() {
+        // Get the host of the default real state as an item
+        @NotNull Item item = Validate.notNull(this.getHost(this.getReal().defaultBlockState()).getBlock().asItem());
+        // Replace the item by a similar item that exists in Minecraft 1.12 to allow it to be displayed on any version including and after that
+        for (Map<Item, Item> mappingsFromVersionToVersion : BlockEntityItemMappingsForVersionCompatability.getBlockEntityItemMappingsForVersionCompatibilityList()) {
+            Item mapped = mappingsFromVersionToVersion.get(item);
+            if (mapped != null) {
+                item = mapped;
+            }
+        }
+        return item;
+    }
+
+    class BlockEntityItemStack {
+
+        private @Nullable Function<@NotNull BlockEntityModelVisualProperties, @NotNull ItemStack> forContextFunction;
+
+        /**
+         * Only null while not initialized yet
+         */
+        private @NotNull ItemStack @Nullable [] forContext;
+
+        public <P extends BlockEntityModelVisualProperties> @NotNull ItemStack getForContext(@NotNull P properties, @NotNull BlockEntityModelVisualPropertiesUniverse<P> universe) {
+            if (this.forContext == null) {
+                this.forContext = Arrays.stream(universe.getValues()).map(this.forContextFunction).toArray(ItemStack[]::new);
+                this.forContextFunction = null;
+            }
+            return this.forContext[universe.getIndex(properties)];
+        }
+
+        public BlockEntityItemStack(@NotNull Function<@NotNull BlockEntityModelVisualProperties, @NotNull ItemStack> forContextFunction) {
+            this.forContextFunction = forContextFunction;
+        }
+
+        public BlockEntityItemStack(@NotNull Supplier<@NotNull Item> itemSupplier, @NotNull Function<@NotNull BlockEntityModelVisualProperties, @NotNull Integer> customModelDataForContextFunction) {
+            this(properties -> {
+                var item = itemSupplier.get();
+                ItemStack itemStack = new ItemStack(item, 1);
+                itemStack.getOrCreateTag().putInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT, ItemReplacementRule.minifiedCustomModelData.get(item).get(customModelDataForContextFunction.apply(properties)));
+                return itemStack;
+            });
+        }
+
+    }
+
+    /**
+     * Non-null if {@link #rendersAsEntity} is true, null otherwise
+     * <br>
+     * This method will assume (not verify) that the given state is in fact a state of this rule's real block
+     */
+    @Nullable BlockEntityItemStack getBlockEntityItemStack(@NotNull BlockState realState);
+
+    default @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> addBlockEntityItemToResourcePack(@NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+        if (!this.rendersSomeStatesAsEntity()) {
+            return Collections.emptyList();
+        }
+        @NotNull Item itemHost = this.computeBlockEntityItem();
+        @NotNull NamespacedKeyWithoutIntention itemHostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(itemHost));
+        @NotNull MutableResourcePackModel itemHostKeyMinecraftItemModel = resourcePack.getModel(ResourcePackAssetIntention.ITEM, itemHostKey);
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> assetLocations = new ArrayList<>();
+        assetLocations.add(Pair.of(ResourcePackAssetType.MODEL, itemHostKey.withIntention(ResourcePackAssetIntention.ITEM)));
+        for (@NotNull BlockState realState : this.getReal().getStateDefinition().getPossibleStates()) {
+            if (this.rendersAsEntity(realState)) {
+                BlockEntityModelVisualPropertiesUniverse<?> universe = this.getEntityRenderModelVisualPropertiesUniverse(realState);
+                for (@NotNull BlockEntityModelVisualProperties properties : universe.getValues()) {
+                    int customModelData = Validate.notNull(this.getBlockEntityItemCustomModelData(realState, properties));
+                    var model = Validate.notNull(this.getBlockEntityItemModel(realState, properties));
+                    assetLocations.addAll(itemHostKeyMinecraftItemModel.addModelOverride(customModelData, model, resourcePack, false, actuallyAdd));
+                }
+            }
+        }
+        return assetLocations;
+    }
+
+    /**
+     * Returns the asset locations that were/would be added by adding everything in this rule to the resource pack
+     * @param actuallyAdd If false, will not be added to the resource pack, but will correctly return the asset locations that would be added
+     */
+    default @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> addToResourcePack(@NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> assetLocations = new ArrayList<>(0);
+        if (this.isFire()) {
+            @NotNull BlockState host = this.getHost(this.getReal().defaultBlockState());
+            // Add the fire blockstates override
+            var blockStateKey = NamespacedKeyWithoutIntention.minecraft("fire").withEmptyIntention();
+            assetLocations.add(Pair.of(ResourcePackAssetType.BLOCK_STATES, blockStateKey));
+            if (actuallyAdd) {
+                resourcePack.getAsset(ResourcePackAssetType.BLOCK_STATES, blockStateKey, MutableResourcePackBlockStates.class).addFireModels(host, this.getReal().customFireType);
+            }
+            // Add the block models
+            for (int textureVariant = 0; textureVariant <= 1; textureVariant++) {
+                for (@NotNull String modelLocation : new String[] {"floor", "side", "side_alt"}) {
+                    var blockModelKey = NamespacedKeyWithoutIntention.sucraft(this.getReal().customFireType + "_fire_" + modelLocation + textureVariant);
+                    assetLocations.addAll(new Model(
+                        ResourcePackAssetIntention.BLOCK,
+                        blockModelKey,
+                        ModelContent.Fire.defaultCreation(modelLocation).create(
+                            ResourcePackAssetIntention.BLOCK,
+                            ResourceLocation.sucraft(this.getReal().customFireType + "_fire_" + textureVariant)
+                        )
+                    ).addToResourcePack(resourcePack, false, actuallyAdd));
+                }
+            }
+            return assetLocations;
+        }
+        assetLocations.addAll(this.addBlockEntityItemToResourcePack(resourcePack, actuallyAdd));
+        @NotNull List<@NotNull BlockState> hosts = this.getHosts();
+        @NotNull List<@NotNull Block> hostBlocks = hosts.stream().map(BlockState::getBlock).distinct().toList();
+        boolean everyStateOfTheHostBlockHasTheSameModel =
+            hostBlocks.size() == 1 // All host states have the same block
+                && (
+                hostBlocks.get(0).getStateDefinition().getPossibleStates().size() == 1 // The host block has only one state
+                    || (
+                    hostBlocks.get(0).getStateDefinition().getPossibleStates().size() == hosts.size() // All host block states are hosts of this rule
+                        && hosts.stream().map(this::getModel).distinct().count() == 1 && hosts.stream().map(this::getModel).distinct().toList().get(0) != null // All hosts of this rule have the same model
+                )
+            );
+        if (actuallyAdd) {
+            // We don't need to do this for blocks rendered partially as entities since they will only use entities (and therefore not have to change the blockstates of their host) or existing hosts now
+            if (!this.rendersSomeStatesAsEntity()) {
+                forEachHostBlock:
+                for (@NotNull Block hostBlock : hostBlocks) {
+                    for (@NotNull BlockState hostBlockState : hostBlock.getStateDefinition().getPossibleStates()) {
+                        if (!hosts.contains(hostBlockState)) {
+                            continue forEachHostBlock;
+                        }
+                    }
+                    // We now know all host block states are hosts of this rule
+                    // We clear any existing variant strings because we know we will be writing all new ones anyway
+                    @NotNull NamespacedKeyWithIntention hostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.BLOCK.getKey(hostBlock)).withEmptyIntention();
+                    @NotNull MutableResourcePackBlockStates minecraftBlockStates = resourcePack.getBlockStates(hostKey);
+                    minecraftBlockStates.clearVariants();
+                }
+            }
+        }
+        for (@NotNull BlockState host : hosts) {
+            @NotNull NamespacedKeyWithIntention hostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.BLOCK.getKey(host.getBlock())).withEmptyIntention();
+            @NotNull MutableResourcePackBlockStates minecraftBlockStates = resourcePack.getBlockStates(hostKey);
+            @Nullable ModelWithParameters model = this.getModel(host);
+            if (!this.rendersSomeStatesAsEntity()) {
+                if (everyStateOfTheHostBlockHasTheSameModel) {
+                    assetLocations.addAll(minecraftBlockStates.setNoVariantModel(model, resourcePack, false, actuallyAdd));
+                } else {
+                    assetLocations.addAll(minecraftBlockStates.setModel(host, model, resourcePack, false, actuallyAdd));
+                }
+            } else if (model != null) {
+                assetLocations.addAll(model.model().addToResourcePack(resourcePack, false, actuallyAdd));
+            }
+        }
+
+        return assetLocations;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/replacementrule/BlockReplacementRuleBase.java b/src/main/java/org/sucraft/suki/block/replacementrule/BlockReplacementRuleBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..010fe6077c20d7950c14edd51bc5cbddfdaa0e6b
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/replacementrule/BlockReplacementRuleBase.java
@@ -0,0 +1,151 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block.replacementrule;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.BaseFireBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.FireBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelVisualPropertiesUniverse;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * Shared implementation of {@link SingleStateRealBlockReplacementRule} and {@link MultiStateRealBlockReplacementRule}
+ */
+public abstract class BlockReplacementRuleBase implements BlockReplacementRule {
+
+    protected final @NotNull Block real;
+    protected final boolean isFire;
+    protected final @Nullable RealItemReplacementRule realItemRule;
+
+    /**
+     * Can be null instead of an empty set
+     */
+    protected final @Nullable Set<@NotNull BlockState> realStatesRenderedAsEntity;
+
+    /**
+     * Can be null instead of an empty map
+     */
+    protected final @Nullable Map<@NotNull BlockState, @NotNull BlockEntityModelVisualPropertiesUniverse<?>> modelVisualPropertiesUniverseByRealState;
+
+    protected final boolean rendersSomeStatesAsEntity;
+    protected final @NotNull List<@NotNull HostItemReplacementRule> hostItemRules;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getHostPlacingItems}
+     * <br>
+     * Is null only when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    protected @Nullable List<@NotNull Item> hostPlacingItemList;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #isHostPlacingItem} and {@link #getHostPlacingItemReplacement}
+     * <br>
+     * Is null only when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    protected @Nullable Map<@NotNull Item, @NotNull Item> replacementByHostPlacingItem;
+
+    protected BlockReplacementRuleBase(@NotNull Block real, @Nullable RealItemReplacementRule realItemRule, @Nullable Set<@NotNull BlockState> realStatesRenderedAsEntity, @Nullable Map<@NotNull BlockState, @NotNull BlockEntityModelVisualPropertiesUniverse<?>> modelVisualPropertiesUniverseByRealState, boolean rendersSomeStatesAsEntity, @NotNull List<@NotNull HostItemReplacementRule> hostItemRules) {
+        this.real = real;
+        this.isFire = this.real instanceof BaseFireBlock;
+        this.realItemRule = realItemRule;
+        this.realStatesRenderedAsEntity = realStatesRenderedAsEntity;
+        this.modelVisualPropertiesUniverseByRealState = modelVisualPropertiesUniverseByRealState;
+        this.rendersSomeStatesAsEntity = rendersSomeStatesAsEntity;
+        this.hostItemRules = Collections.unmodifiableList(hostItemRules);
+    }
+
+    @Override
+    public @NotNull Block getReal() {
+        return this.real;
+    }
+
+    @Override
+    public boolean hasAsReal(@NotNull Block potentialReal) {
+        return this.real.equals(potentialReal);
+    }
+
+    @Override
+    public boolean isFire() {
+        return this.isFire;
+    }
+
+    @Override
+    public @Nullable RealItemReplacementRule getRealItemRule() {
+        return this.realItemRule;
+    }
+
+    @Override
+    public boolean rendersAsEntity(@NotNull BlockState realState) {
+        if (this.realStatesRenderedAsEntity == null) {
+            return false;
+        }
+        return this.realStatesRenderedAsEntity.contains(realState);
+    }
+
+    @Override
+    public @Nullable BlockEntityModelVisualPropertiesUniverse<?> getEntityRenderModelVisualPropertiesUniverse(@NotNull BlockState realState) {
+        if (this.modelVisualPropertiesUniverseByRealState == null) {
+            return null;
+        }
+        return this.modelVisualPropertiesUniverseByRealState.get(realState);
+    }
+
+    @Override
+    public boolean rendersSomeStatesAsEntity() {
+        return this.rendersSomeStatesAsEntity;
+    }
+
+    @Override
+    public @NotNull List<@NotNull HostItemReplacementRule> getHostItemRules() {
+        return this.hostItemRules;
+    }
+
+    @Override
+    public boolean isHostPlacingItem(@NotNull Item item) {
+        return this.getHostPlacingItemReplacement(item) != null;
+    }
+
+    @Override
+    public @NotNull List<@NotNull Item> getHostPlacingItems() {
+        if (this.hostPlacingItemList == null) {
+            this.hostPlacingItemList = this.getReplacementByHostPlacingItems().keySet().stream().toList();
+        }
+        return this.hostPlacingItemList;
+    }
+
+    private @NotNull Map<@NotNull Item, @NotNull Item> getReplacementByHostPlacingItems() {
+        if (this.replacementByHostPlacingItem == null) {
+            this.replacementByHostPlacingItem = new IdentityHashMap<>(this.hostItemRules.stream().collect(Collectors.toMap(HostItemReplacementRule::getHostPlacingItem, HostItemReplacementRule::getHostPlacingItemReplacement)));
+        }
+        return this.replacementByHostPlacingItem;
+    }
+
+    @Override
+    public @Nullable Item getHostPlacingItemReplacement(@Nullable Item item) {
+        return this.getReplacementByHostPlacingItems().get(item);
+    }
+
+    protected @NotNull BlockEntityItemStack computeBlockEntityItemStack(@NotNull BlockState realState) {
+        // Get the item
+        @NotNull Item item = this.computeBlockEntityItem();
+        // Return the BlockEntityItemStack
+        return new BlockEntityItemStack(() -> item, properties -> this.getBlockEntityItemCustomModelData(realState, properties));
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/replacementrule/BlockReplacementRuleBuilder.java b/src/main/java/org/sucraft/suki/block/replacementrule/BlockReplacementRuleBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..533e1b16e2c1ddd631fb7fab682650d2d6cc9740
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/replacementrule/BlockReplacementRuleBuilder.java
@@ -0,0 +1,582 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block.replacementrule;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Direction;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.StairBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.level.block.state.properties.StairsShape;
+import org.sucraft.suki.block.UsedHostBlockStates;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelVisualPropertiesUniverse;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.blockanditemdata.model.ModelContent;
+import org.sucraft.suki.blockanditemdata.model.ModelCreation;
+import org.sucraft.suki.blockanditemdata.model.ModelCreationWithParameters;
+import org.sucraft.suki.blockanditemdata.model.ModelParameters;
+import org.sucraft.suki.blockanditemdata.model.ModelWithParameters;
+import org.sucraft.suki.blockanditemdata.texture.Texture;
+import org.sucraft.suki.blockanditemdata.texture.TextureContent;
+import org.sucraft.suki.blockanditemdata.texture.TextureCreation;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+
+public interface BlockReplacementRuleBuilder<R extends BlockReplacementRule, B extends BlockReplacementRuleBuilder<R, B>> {
+
+    @NotNull B withReal(@NotNull Block real);
+
+    @NotNull B rendersAsEntity(@NotNull BlockState realState);
+
+    @NotNull B rendersAsEntity(@NotNull Predicate<@NotNull BlockState> realStatePredicate);
+
+    /**
+     * One block entity model visual properties universe for all real block states
+     */
+    @NotNull B withBlockEntityModelVisualPropertiesUniverse(@NotNull BlockEntityModelVisualPropertiesUniverse<?> universe);
+
+    @NotNull B withBlockEntityModelVisualPropertiesUniverseForRealState(@NotNull Function<@NotNull BlockState, @Nullable BlockEntityModelVisualPropertiesUniverse<?>> blockEntityModelVisualPropertiesUniverseForRealState);
+
+    /**
+     * One host for all real block states
+     */
+    @NotNull B withHost(@NotNull BlockState host);
+
+    /**
+     * One host for all real block states
+     * <br>
+     * (Takes the default state of the given block)
+     */
+    default @NotNull B withHost(@NotNull Block hostBlock) {
+        return this.withHost(hostBlock.defaultBlockState());
+    }
+
+    /**
+     * Sets the output of the given function as the host for a given real block state,
+     * but takes the host for that real block state already existing in this builder if the function returns null
+     */
+    @NotNull B withHostForRealState(@NotNull Function<@NotNull BlockState, @Nullable BlockState> hostForRealState);
+
+    /**
+     * One host for all real block states: the same one as the given rule
+     */
+    default @NotNull B withHostSameAs(@NotNull SingleStateRealBlockReplacementRule singleStateReplacementRule) {
+        return this.withHost(singleStateReplacementRule.getHost());
+    }
+
+    /**
+     * Sets the hosts based automatically on the real state's properties, assuming the properties of the real block and the host block are exactly the same (for example, both are slabs, or both are leaves)
+     */
+    default @NotNull B withAnalogousHosts(@NotNull Block hostBlock) {
+        return this.withHostForRealState(hostBlock::withPropertiesOf);
+    }
+
+    /**
+     * One host replacement for all hosts
+     */
+    @NotNull B withHostReplacement(@NotNull BlockState hostReplacement);
+
+    /**
+     * One host replacement for all hosts
+     * <br>
+     * (Takes the default state of the given block)
+     */
+    default @NotNull B withHostReplacement(@NotNull Block hostReplacementBlock) {
+        return this.withHostReplacement(hostReplacementBlock.defaultBlockState());
+    }
+
+    /**
+     * Sets the output of the given function as the host replacement for a given host,
+     * but takes the host replacement for that host already existing in this builder if the function returns null
+     */
+    @NotNull B withHostReplacementForHost(@NotNull Function<@NotNull BlockState, @Nullable BlockState> hostReplacementForHost);
+
+    /**
+     * One host replacement for all hosts: the same one as the given rule
+     */
+    default @NotNull B withHostReplacementSameAs(@NotNull SingleStateRealBlockReplacementRule singleStateReplacementRule) {
+        return this.withHostReplacement(singleStateReplacementRule.getHostReplacement());
+    }
+
+    /**
+     * Sets the hosts and their host replacements based automatically on the real state's properties, assuming the properties of the real block, the host block and the host replacement block are exactly the same (for example, all three are slabs)
+     */
+    default @NotNull B withAnalogousHosts(@NotNull Block hostBlock, @NotNull Block hostReplacementBlock) {
+        return this.withAnalogousHosts(hostBlock).withHostReplacementForHost(hostReplacementBlock::withPropertiesOf);
+    }
+
+    /**
+     * Sets the host and host replacement based automatically on the next unused state out of the given states
+     */
+    default @NotNull B withNextUnusedStateAsHost(@NotNull List<@NotNull BlockState> possibleBlockStates) {
+        @NotNull Pair<@NotNull BlockState, @NotNull BlockState> hostAndHostReplacement = UsedHostBlockStates.generateUnusedHostAndReplacement(possibleBlockStates);
+        return this.withHost(hostAndHostReplacement.left())
+            .withHostReplacement(hostAndHostReplacement.right());
+    }
+
+    /**
+     * Sets a single host and host replacement based automatically on the next unused state of the given block
+     */
+    default @NotNull B withNextUnusedStateOfHostBlock(@NotNull Block hostBlock) {
+        @NotNull Pair<@NotNull BlockState, @NotNull BlockState> hostAndHostReplacement = UsedHostBlockStates.generateUnusedHostAndReplacement(hostBlock);
+        return this.withHost(hostAndHostReplacement.left())
+            .withHostReplacement(hostAndHostReplacement.right());
+    }
+
+    /**
+     * Sets a single host and host replacement based automatically on the next unused note block state
+     */
+    default @NotNull B withNoteBlockHost() {
+        return this.withNextUnusedStateOfHostBlock(Blocks.NOTE_BLOCK);
+    }
+
+    /**
+     * Sets a host and host replacement for each real block state based automatically on the next unused state of the given block
+     */
+    default @NotNull B withNextUnusedStatesOfHostBlock(@NotNull Block hostBlock) {
+        @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostByRealState = new IdentityHashMap<>();
+        @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostReplacementByHost = new IdentityHashMap<>();
+        return this.withHostForRealState(realState -> {
+            if (hostByRealState.isEmpty()) {
+                for (@NotNull BlockState someRealState : realState.getBlock().getStateDefinition().getPossibleStates()) {
+                    @NotNull Pair<@NotNull BlockState, @NotNull BlockState> hostAndHostReplacement = UsedHostBlockStates.generateUnusedHostAndReplacement(hostBlock);
+                    hostByRealState.put(someRealState, hostAndHostReplacement.left());
+                    hostReplacementByHost.put(hostAndHostReplacement.left(), hostAndHostReplacement.right());
+                }
+            }
+            return hostByRealState.get(realState);
+        }).withHostReplacementForHost(host -> {
+            if (hostReplacementByHost.isEmpty()) {
+                throw new IllegalStateException("Host for real state function should be called before host replacement for host function, when using automatically generated unused state of a host block for a multi-state real block");
+            }
+            return hostReplacementByHost.get(host);
+        });
+    }
+
+    /**
+     * Sets a host and host replacement for each real block state based automatically on the next unused note block state
+     */
+    default @NotNull B withNoteBlockHosts() {
+        return this.withNextUnusedStatesOfHostBlock(Blocks.NOTE_BLOCK);
+    }
+
+    /**
+     * Takes an unused state of the host block that is not waterlogged, and sets it as the host for all real block states that are not waterlogged,
+     * and takes an unused state of the host block that is waterlogged, and sets it as the host for all real block states that are waterlogged,
+     * and also sets the host replacements appropriately
+     */
+    default @NotNull B withOneNonWaterLoggedAndOneWaterLoggedHost(@NotNull Block hostBlock) {
+        @NotNull List<@NotNull BlockState> hostBlockStates = hostBlock.getStateDefinition().getPossibleStates();
+        @NotNull List<@NotNull BlockState> nonWaterloggedHostBlockStates = hostBlockStates.stream().filter(potentialHost -> !potentialHost.getValue(BlockStateProperties.WATERLOGGED)).toList();
+        @NotNull List<@NotNull BlockState> waterloggedHostBlockStates = hostBlockStates.stream().filter(potentialHost -> potentialHost.getValue(BlockStateProperties.WATERLOGGED)).toList();
+        @NotNull Pair<@NotNull BlockState, @NotNull BlockState> nonWaterloggedHostAndReplacement = UsedHostBlockStates.generateUnusedHostAndReplacement(nonWaterloggedHostBlockStates);
+        @NotNull Pair<@NotNull BlockState, @NotNull BlockState> waterloggedHostAndReplacement = UsedHostBlockStates.generateUnusedHostAndReplacement(waterloggedHostBlockStates);
+        return this
+            .withHostForRealState(realState -> (realState.getValue(BlockStateProperties.WATERLOGGED) ? waterloggedHostAndReplacement : nonWaterloggedHostAndReplacement).left())
+            .withHostReplacementForHost(host -> {
+                if (host.equals(nonWaterloggedHostAndReplacement.left())) {
+                    return nonWaterloggedHostAndReplacement.right();
+                } else if (host.equals(waterloggedHostAndReplacement.left())) {
+                    return waterloggedHostAndReplacement.right();
+                }
+                return null;
+            });
+    }
+
+    /**
+     * Takes an unused state of the host block for every combination of east, north, south, up and west (only disregarding age),
+     * and sets the host replacements to remove the age information of the host
+     */
+    default @NotNull B withFireHost() {
+        BlockState hostToUse = UsedHostBlockStates.generateUnusedFireState();
+        return this
+            .withHostForRealState(realState -> hostToUse)
+            .withHostReplacementForHost(host -> {
+                if (host.getValue(BlockStateProperties.AGE_15) > 0) {
+                    return Blocks.FIRE.withPropertiesOf(host).setValue(BlockStateProperties.AGE_15, 0);
+                }
+                return null;
+            });
+    }
+
+    /**
+     * One fallback for all real block states
+     */
+    @NotNull B withFallback(@NotNull BlockState fallback);
+
+    /**
+     * One fallback for all real block states
+     * <br>
+     * (Takes the default state of the given block)
+     */
+    default @NotNull B withFallback(@NotNull Block fallbackBlock) {
+        return this.withFallback(fallbackBlock.defaultBlockState());
+    }
+
+    /**
+     * Sets the output of the given function as the fallback for a given real block state,
+     * but takes the fallback for that real block state already existing in this builder if the function returns null
+     */
+    @NotNull B withFallbackForRealState(@NotNull Function<@NotNull BlockState, @Nullable BlockState> fallbackForRealState);
+
+    /**
+     * One fallback for all real block states: the same one as the given rule
+     */
+    default @NotNull B withFallbackSameAs(@NotNull SingleStateRealBlockReplacementRule singleStateReplacementRule) {
+        return this.withFallback(singleStateReplacementRule.getFallback());
+    }
+
+    /**
+     * Sets the fallbacks based automatically on the real state's properties, assuming the properties of the real block and the fallback block are exactly the same (for example, both are slabs, or both are leaves)
+     */
+    default @NotNull B withAnalogousFallbacks(@NotNull Block fallbackBlock) {
+        return this.withFallbackForRealState(fallbackBlock::withPropertiesOf);
+    }
+
+    /**
+     * Sets a pillar fallback based on the directional state of this real block
+     */
+    default @NotNull B withDirectionalAnalogousPillarFallbacks(@NotNull Block fallbackBlock) {
+        return this.withFallbackForRealState(realState -> fallbackBlock.defaultBlockState().setValue(BlockStateProperties.AXIS, switch (realState.getValue(BlockStateProperties.FACING)) {
+            case NORTH, SOUTH -> Direction.Axis.Z;
+            case EAST, WEST -> Direction.Axis.X;
+            case UP, DOWN -> Direction.Axis.Y;
+        }));
+    }
+
+    /**
+     * One host overriding model for all real states
+     */
+    @NotNull B withModel(@NotNull ModelWithParameters model);
+
+    /**
+     * Sets the output of the given function as the host overriding model for a given real state,
+     * but takes the host overriding model for that real state already existing in this builder if the function returns null
+     */
+    @NotNull B withModelForRealState(@NotNull Function<@NotNull BlockState, @Nullable ModelWithParameters> modelForRealState);
+
+    /**
+     * One host overriding model for all real states
+     */
+    @NotNull B withModelCreation(@NotNull ModelCreationWithParameters modelCreation);
+
+    /**
+     * Sets the output of the given function as the host overriding model for a given real state,
+     * but takes the host overriding model for that real state already existing in this builder if the function returns null
+     */
+    @NotNull B withModelCreationForRealState(@NotNull Function<@NotNull BlockState, @Nullable ModelCreationWithParameters> modelCreationForRealState);
+
+    /**
+     * One host overriding model for all real states: the same one as the given rule
+     */
+    default @NotNull B withModelSameAs(@NotNull SingleStateRealBlockReplacementRule singleStateReplacementRule) {
+        return this.withModel(singleStateReplacementRule.getModel());
+    }
+
+    /**
+     * Sets the host overriding models to a model with parameters specifically for a rotated pillar block, using the default texture names
+     */
+    default @NotNull B withDefaultModelCreationsForRotatedPillarBlock() {
+        return this.withModelCreationsForRotatedPillarBlockPotentiallyWithAlternativeEndCreation(null);
+    }
+
+    /**
+     * Sets the host overriding models to a model with parameters specifically for a rotated pillar block, using the alternative textures names where non-null
+     */
+    default @NotNull B withModelCreationsForRotatedPillarBlockPotentiallyWithAlternativeEnd(@Nullable Texture endTexture) {
+        return this.withModelCreationsForRotatedPillarBlockPotentiallyWithAlternativeEndCreation((intention, key) -> endTexture);
+    }
+
+    /**
+     * Sets the host overriding models to a model with parameters specifically for a rotated pillar block, using the alternative textures names where non-null
+     */
+    default @NotNull B withModelCreationsForRotatedPillarBlockPotentiallyWithAlternativeEndCreation(@Nullable TextureCreation endTextureCreation) {
+        @NotNull ModelCreation vertical = endTextureCreation == null ? Model.YPillarCube.defaultCreation() : Model.YPillarCube.defaultCreationWithAlternativeEnd(endTextureCreation);
+        @NotNull ModelCreation horizontal = endTextureCreation == null ? Model.HorizontalYPillarCube.defaultCreation() : Model.HorizontalYPillarCube.defaultCreationWithAlternativeEnd(endTextureCreation);
+        @NotNull ModelCreationWithParameters xAxisModel = horizontal.withParameters(new ModelParameters(json -> {
+            json.addProperty("x", 90);
+            json.addProperty("y", 90);
+        }));
+        @NotNull ModelCreationWithParameters yAxisModel = vertical.withNoParameters();
+        @NotNull ModelCreationWithParameters zAxisModel = horizontal.withParameters(new ModelParameters(json -> json.addProperty("x", 90)));
+        return this.withModelCreationForRealState(realState ->
+            switch (realState.getValue(BlockStateProperties.AXIS)) {
+                case X -> xAxisModel;
+                case Y -> yAxisModel;
+                case Z -> zAxisModel;
+            }
+        );
+    }
+
+    /**
+     * Sets the host overriding models to a model with parameters specifically for a directional block (that can face any of the 6 orthogonal directions), using the default texture names
+     */
+    default @NotNull B withDefaultModelCreationsForDirectionalBlock() {
+        @NotNull ModelCreation vertical = Model.YPillarCube.defaultCreation();
+        @NotNull ModelCreationWithParameters facingDownModel = vertical.withNoParameters();
+        @NotNull ModelCreationWithParameters facingEastModel = vertical.withParameters(new ModelParameters(json -> {
+            json.addProperty("x", 270);
+            json.addProperty("y", 90);
+        }));
+        @NotNull ModelCreationWithParameters facingNorthModel = vertical.withParameters(new ModelParameters(json -> json.addProperty("x", 270)));
+        @NotNull ModelCreationWithParameters facingSouthModel = vertical.withParameters(new ModelParameters(json -> {
+            json.addProperty("x", 270);
+            json.addProperty("y", 180);
+        }));
+        @NotNull ModelCreationWithParameters facingUpModel = vertical.withParameters(new ModelParameters(json -> {
+            json.addProperty("x", 180);
+            json.addProperty("y", 180);
+        }));
+        @NotNull ModelCreationWithParameters facingWestModel = vertical.withParameters(new ModelParameters(json -> {
+            json.addProperty("x", 270);
+            json.addProperty("y", 270);
+        }));
+        return this.withModelCreationForRealState(realState ->
+            switch (realState.getValue(BlockStateProperties.FACING)) {
+                case DOWN -> facingDownModel;
+                case EAST -> facingEastModel;
+                case NORTH -> facingNorthModel;
+                case SOUTH -> facingSouthModel;
+                case UP -> facingUpModel;
+                case WEST -> facingWestModel;
+            }
+        );
+    }
+
+    /**
+     * @param fullBlockTextureAndModelKey A key pointing to the full block texture (used as texture basis for the top and bottom slabs), and also pointing to the full block model (used directly as the model for the double slab)
+     * @see #withDefaultModelCreationsForSlabReplacedBySlab
+     */
+    default @NotNull B withDefaultModelCreationsForSlabReplacedBySlabAndDoubleSlabRenderedAsBlockEntityIfItNormallyWould(@NotNull NamespacedKeyWithoutIntention fullBlockTextureAndModelKey, @NotNull ModelContent.Existing.ExistingModelContentOutwardExpansionType doubleSlabExistingModelContentOutwardExpansionType) {
+        return this.withDefaultModelCreationsForSlabReplacedBySlab((intention, key) -> new Model(ResourcePackAssetIntention.BLOCK, fullBlockTextureAndModelKey, ModelContent.Existing.getInstance(doubleSlabExistingModelContentOutwardExpansionType)), null, new Texture(ResourcePackAssetIntention.BLOCK, fullBlockTextureAndModelKey, TextureContent.Existing.getInstance()), null, null, null, null);
+    }
+
+    /**
+     * @param fullBlockTextureAndModelKey A key pointing to the full block texture (used as texture basis for the top and bottom slabs)
+     * @see #withDefaultModelCreationsForSlabReplacedBySlab
+     */
+    default @NotNull B withDefaultModelCreationsForSlabReplacedBySlabAndDoubleSlabRenderedWithSameHostAsFullBlock(@NotNull NamespacedKeyWithoutIntention fullBlockTextureAndModelKey, @NotNull BlockState fullBlockRealState) {
+        @NotNull BlockState doubleSlabHost;
+        var doubleSlabRealBlockReplacementRule = fullBlockRealState.getBlock().replacementRule;
+        if (doubleSlabRealBlockReplacementRule != null && doubleSlabRealBlockReplacementRule.hasAsReal(fullBlockRealState.getBlock())) {
+            doubleSlabHost = doubleSlabRealBlockReplacementRule.getHost(fullBlockRealState);
+        } else {
+            doubleSlabHost = fullBlockRealState;
+        }
+        return this.withDefaultModelCreationsForSlabReplacedBySlabAndDoubleSlabRenderedWithGivenHost(fullBlockTextureAndModelKey, doubleSlabHost);
+    }
+
+    /**
+     * @param fullBlockTextureAndModelKey A key pointing to the full block texture (used as texture basis for the top and bottom slabs)
+     * @see #withDefaultModelCreationsForSlabReplacedBySlab
+     */
+    default @NotNull B withDefaultModelCreationsForSlabReplacedBySlabAndDoubleSlabRenderedWithGivenHost(@NotNull NamespacedKeyWithoutIntention fullBlockTextureAndModelKey, @NotNull BlockState doubleSlabHost) {
+        return this.withDefaultModelCreationsForSlabReplacedBySlab(null, doubleSlabHost, new Texture(ResourcePackAssetIntention.BLOCK, fullBlockTextureAndModelKey, TextureContent.Existing.getInstance()), null, null, null, null);
+    }
+
+    default @NotNull B withDefaultModelCreationsForSlabReplacedBySlabAndDoubleSlabRenderedWithSameHostAsFullBlock(@Nullable BlockState fullBlockRealState, @NotNull Texture sideTexture, @Nullable Texture bottomHalfBottomTexture, @Nullable Texture bottomHalfTopTexture, @Nullable Texture topHalfBottomTexture, @Nullable Texture topHalfTopTexture) {
+        @NotNull BlockState doubleSlabHost;
+        var doubleSlabRealBlockReplacementRule = fullBlockRealState.getBlock().replacementRule;
+        if (doubleSlabRealBlockReplacementRule != null && doubleSlabRealBlockReplacementRule.hasAsReal(fullBlockRealState.getBlock())) {
+            doubleSlabHost = doubleSlabRealBlockReplacementRule.getHost(fullBlockRealState);
+        } else {
+            doubleSlabHost = fullBlockRealState;
+        }
+        return this.withDefaultModelCreationsForSlabReplacedBySlabAndDoubleSlabRenderedWithGivenHost(doubleSlabHost, sideTexture, bottomHalfBottomTexture, bottomHalfTopTexture, topHalfBottomTexture, topHalfTopTexture);
+    }
+
+    default @NotNull B withDefaultModelCreationsForSlabReplacedBySlabAndDoubleSlabRenderedWithGivenHost(@Nullable BlockState doubleSlabHost, @NotNull Texture sideTexture, @Nullable Texture bottomHalfBottomTexture, @Nullable Texture bottomHalfTopTexture, @Nullable Texture topHalfBottomTexture, @Nullable Texture topHalfTopTexture) {
+        return this.withDefaultModelCreationsForSlabReplacedBySlab(null, doubleSlabHost, sideTexture, bottomHalfBottomTexture, bottomHalfTopTexture, topHalfBottomTexture, topHalfTopTexture);
+    }
+
+    /**
+     * Set a single host overriding model for the host block, that as a single model encapsulates a slab: the mechanism for this is provided by the parent model alread)
+     *
+     * Either {@param doubleSlabModelCreation} or {@param doubleSlabHost} must be non-null
+     *
+     * @param sideTexture             A texture of a block that will be used as the texture of this slab (the mechanism for this is provided by the parent model already)
+     * @param bottomHalfBottomTexture Will be {@param sideTexture} if null
+     * @param bottomHalfTopTexture    Will be {@param bottomHalfBottomTexture} if null
+     * @param topHalfBottomTexture    Will be {@param bottomHalfTopTexture} if null
+     * @param topHalfTopTexture       Will be {@param bottomHalfBottomTexture} if null
+     */
+    default @NotNull B withDefaultModelCreationsForSlabReplacedBySlab(@Nullable ModelCreation doubleSlabModelCreation, @Nullable BlockState doubleSlabHost, @NotNull Texture sideTexture, @Nullable Texture bottomHalfBottomTexture, @Nullable Texture bottomHalfTopTexture, @Nullable Texture topHalfBottomTexture, @Nullable Texture topHalfTopTexture) {
+        if (bottomHalfBottomTexture == null) {
+            bottomHalfBottomTexture = sideTexture;
+        }
+        if (bottomHalfTopTexture == null) {
+            bottomHalfTopTexture = bottomHalfBottomTexture;
+        }
+        if (topHalfBottomTexture == null) {
+            topHalfBottomTexture = bottomHalfTopTexture;
+        }
+        if (topHalfTopTexture == null) {
+            topHalfTopTexture = bottomHalfBottomTexture;
+        }
+        final @NotNull Texture finalBottomHalfBottomTexture = bottomHalfBottomTexture;
+        final @NotNull Texture finalBottomHalfTopTexture = bottomHalfTopTexture;
+        final @NotNull Texture finalTopHalfBottomTexture = topHalfBottomTexture;
+        final @NotNull Texture finalTopHalfTopTexture = topHalfTopTexture;
+        var builder = this.withModelCreationForRealState(realState ->
+            switch (realState.getValue(BlockStateProperties.SLAB_TYPE)) {
+//                case BOTTOM, DOUBLE, TOP -> {
+//                    return ((ModelCreation) (intention, key) -> {
+//                        System.out.println("Creating model for intention and key: " + intention + " and " + key);
+//                        var toReturn = Model.creation(ModelContent.BottomSlab.creationCompanion.creation(finalBottomHalfBottomTexture, sideTexture, finalBottomHalfTopTexture)).create(intention, key);
+//                        System.out.println("Got: " + toReturn.getKeyWithIntention());
+//                        var modelCreation = (ModelContent.BottomSlab) ModelContent.BottomSlab.creationCompanion.creation(finalBottomHalfBottomTexture, sideTexture, finalBottomHalfTopTexture).create(intention, key);
+//                        System.out.println("Based on content: " + modelCreation.bottomTexture.getKeyWithIntention() + " , " + modelCreation.sideTexture.getKeyWithIntention() + " , " + modelCreation.topTexture.getKeyWithIntention());
+//                        return toReturn;
+//                    }).withNoParameters();
+//                }
+                case BOTTOM ->
+                    Model.creation(ModelContent.BottomSlab.creationCompanion.creation(finalBottomHalfBottomTexture, sideTexture, finalBottomHalfTopTexture)).withNoParameters();
+                case DOUBLE ->
+                    doubleSlabModelCreation == null ? null : doubleSlabModelCreation.withNoParameters();
+                case TOP ->
+                    ((ModelCreation) (intention, key) -> Model.creation(ModelContent.TopSlab.creationCompanion.creation(finalTopHalfBottomTexture, sideTexture, finalTopHalfTopTexture)).create(intention, key.withPathSuffix("_top"))).withNoParameters();
+                default ->
+                    throw new IllegalStateException("Unknown slab type: " + realState.getValue(BlockStateProperties.SLAB_TYPE));
+            }
+        );
+        if (doubleSlabHost != null) {
+            builder = builder.withHostForRealState(realState -> realState.getValue(BlockStateProperties.SLAB_TYPE) == SlabType.DOUBLE ? doubleSlabHost : null);
+        }
+        return builder;
+    }
+
+    /**
+     * @param fullBlockTextureKey A key pointing to the full block texture (used as texture basis for the stairs)
+     * @see #withDefaultModelCreationsForStairsReplacedByStairs
+     */
+    default @NotNull B withDefaultModelCreationsForStairsReplacedByStairs(@NotNull NamespacedKeyWithoutIntention fullBlockTextureKey) {
+        return this.withDefaultModelCreationsForStairsReplacedByStairs(new Texture(ResourcePackAssetIntention.BLOCK, fullBlockTextureKey, TextureContent.Existing.getInstance()), null, null);
+    }
+
+    /**
+     * Set a single host overriding model for the host block, that as a single model encapsulates stairs: the mechanism for this is provided by the parent model already
+     *
+     * @param sideTexture             A texture of a block that will be used as the texture of these stairs (the mechanism for this is provided by the parent model already)
+     * @param bottomTexture Will be {@param sideTexture} if null
+     * @param topTexture    Will be {@param bottomTexture} if null
+     */
+    default @NotNull B withDefaultModelCreationsForStairsReplacedByStairs(@NotNull Texture sideTexture, @Nullable Texture bottomTexture, @Nullable Texture topTexture) {
+        if (bottomTexture == null) {
+            bottomTexture = sideTexture;
+        }
+        if (topTexture == null) {
+            topTexture = bottomTexture;
+        }
+        final @NotNull Texture finalBottomTexture = bottomTexture;
+        final @NotNull Texture finalTopTexture = topTexture;
+        return this.withModelCreationForRealState(realState -> {
+
+            var shape = realState.getValue(StairBlock.SHAPE);
+            var half = realState.getValue(StairBlock.HALF);
+            var facing = realState.getValue(StairBlock.FACING);
+
+            // Outer stairs look the same as a different direction of inner stairs, so we create only a model for inner stairs, and replace the outer stairs by the right inner stairs
+            if (shape == StairsShape.INNER_RIGHT || shape == StairsShape.OUTER_RIGHT) {
+                shape = shape == StairsShape.INNER_RIGHT ? StairsShape.INNER_LEFT : StairsShape.OUTER_LEFT;
+            } else if (shape == StairsShape.INNER_LEFT || shape == StairsShape.OUTER_LEFT) {
+                facing = switch (facing) {
+                    case NORTH -> Direction.WEST;
+                    case WEST -> Direction.SOUTH;
+                    case EAST -> Direction.NORTH;
+                    case SOUTH -> Direction.EAST;
+                    case DOWN, UP -> throw new IllegalStateException("Illegal stairs direction: " + facing);
+                };
+            }
+
+            String stateSuffix = "_" + switch (shape) {
+                case STRAIGHT -> "a";
+                case INNER_LEFT -> "i";
+                case OUTER_LEFT -> "o";
+                case INNER_RIGHT, OUTER_RIGHT -> throw new IllegalStateException("Shape without model: " + shape);
+            } + switch (half) {
+                case TOP -> "t";
+                case BOTTOM -> "b";
+            } + switch (facing) {
+                case NORTH -> "n";
+                case WEST -> "w";
+                case EAST -> "e";
+                case SOUTH -> "s";
+                case DOWN, UP -> throw new IllegalStateException("Illegal stairs direction: " + facing);
+            };
+            final var finalFacing = facing;
+            final var creationCompanion = switch (shape) {
+                case STRAIGHT ->
+                    ModelContent.StraightStairs.creationCompanion;
+                case INNER_LEFT ->
+                    ModelContent.InnerLeftStairs.creationCompanion;
+                case OUTER_LEFT ->
+                    ModelContent.OuterLeftStairs.creationCompanion;
+                default ->
+                    throw new IllegalStateException("Unknown or illegal stairs shape: " + realState.getValue(BlockStateProperties.STAIRS_SHAPE));
+            };
+            return ((ModelCreation) (intention, key) -> Model.creation(creationCompanion.creation(finalBottomTexture, sideTexture, finalTopTexture, half, finalFacing)).create(intention, key.withPathSuffix(stateSuffix))).withNoParameters();
+
+        });
+    }
+
+    /**
+     * Sets the given real item rule as the real item rule of this builder
+     */
+    @NotNull B withRealItemRule(@NotNull RealItemReplacementRule realItemRule);
+
+    /**
+     * Removes the real item rule of this builder
+     */
+    @NotNull B withoutRealItemRule();
+
+    /**
+     * Sets the given real item rule of this builder to a rule for a full block bounding,
+     * with the high ping host being as given,
+     * and with the fallback being the item form of the fallback's block for the real block's default state
+     */
+    @NotNull B withFullBlockBoundingBoxItem(@NotNull Supplier<@NotNull Item> highPingHostSupplier);
+
+    /**
+     * Sets the given real item rule of this builder to a rule for a full block bounding,
+     * with the fallback being the item form of the fallback's block for the real block's default state,
+     * and with the high ping host being the same as the fallback
+     */
+    @NotNull B withFullBlockBoundingBoxItem();
+
+    /**
+     * Sets the given real item rule of this builder to a rule with the fallback being the item form of the fallback's block for the real block's default state,
+     * and with the low and high ping host being the item form of the host's block for the real block's default state
+     */
+    @NotNull B withRealItemRuleFromHostBlock();
+
+    /**
+     * Adds the given host item rule to the host item rules in this builder
+     */
+    @NotNull B withHostItemRule(@NotNull HostItemReplacementRule hostItemRule);
+
+    /**
+     * Resmoves all host item rules of this builder
+     */
+    @NotNull B withoutHostItemRules();
+
+    /**
+     * Adds a host item rule for when the item form of the block of the real block's default state's host would place it, and the item form of that host's replacement's block is a good replacement for the host item
+     */
+    @NotNull B withHostItemRuleFromHostBlockAndHostReplacementBlock();
+
+    @NotNull R build();
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/replacementrule/HostItemReplacementRule.java b/src/main/java/org/sucraft/suki/block/replacementrule/HostItemReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..edfcd7e3db38f4ac0e754d8200c3970fe5b4fc27
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/replacementrule/HostItemReplacementRule.java
@@ -0,0 +1,64 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block.replacementrule;
+
+import net.minecraft.world.item.Item;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.function.Supplier;
+
+/**
+ * Potentially, if a directly placeable state (using a block item) of a block is used a host, its item form, if any, possibly multiple, may also need to be replaced (but only for players with the resource pack of course, since this is only relevant to hosts - not a fallbacks)
+ * <br>
+ * This class is not (and does not need to be) aware of the host it concerns
+ * <br>
+ * This class uses late initialization internally so that items are not referenced before block bootstrapping is finished
+ */
+public class HostItemReplacementRule {
+
+    private final @NotNull Supplier<@NotNull Item> hostPlacingItemSupplier;
+    private final @NotNull Supplier<@NotNull Item> hostPlacingItemReplacementSupplier;
+
+    /**
+     * The block item of the host block, that would place the host state if used
+     * <br>
+     * Is null only when not initialized yet
+     * @see #hostPlacingItemSupplier
+     */
+    private @Nullable Item hostPlacingItem;
+
+    /**
+     * The item we would like to replace the {@link #hostPlacingItem} by
+     * <br>
+     * Is null only when not initialized yet
+     * @see #hostPlacingItemReplacementSupplier
+     */
+    private @Nullable Item hostPlacingItemReplacement;
+
+    public HostItemReplacementRule(@NotNull Supplier<@NotNull Item> hostPlacingItemSupplier, @NotNull Supplier<@NotNull Item> hostPlacingItemReplacementSupplier) {
+        this.hostPlacingItemSupplier = hostPlacingItemSupplier;
+        this.hostPlacingItemReplacementSupplier = hostPlacingItemReplacementSupplier;
+    }
+
+    /**
+     * This must not be called before all block bootstrapping has finished
+     */
+    public @NotNull Item getHostPlacingItem() {
+        if (this.hostPlacingItem == null) {
+            this.hostPlacingItem = this.hostPlacingItemSupplier.get();
+        }
+        return this.hostPlacingItem;
+    }
+
+    /**
+     * This must not be called before all block bootstrapping has finished
+     */
+    public @NotNull Item getHostPlacingItemReplacement() {
+        if (this.hostPlacingItemReplacement == null) {
+            this.hostPlacingItemReplacement = this.hostPlacingItemReplacementSupplier.get();
+        }
+        return this.hostPlacingItemReplacement;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/replacementrule/MultiStateRealBlockReplacementRule.java b/src/main/java/org/sucraft/suki/block/replacementrule/MultiStateRealBlockReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..8465f3ee51ad2e7092cbbe0bb0e2969f5b327dcf
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/replacementrule/MultiStateRealBlockReplacementRule.java
@@ -0,0 +1,206 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block.replacementrule;
+
+import com.google.common.collect.Streams;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelVisualProperties;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelVisualPropertiesUniverse;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.blockanditemdata.model.ModelWithParameters;
+import org.sucraft.suki.item.UsedHostCustomModelData;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class MultiStateRealBlockReplacementRule extends BlockReplacementRuleBase {
+
+    private final @NotNull List<@NotNull BlockState> hostList;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #hasAsHost}
+     */
+    private final @NotNull Set<@NotNull BlockState> hostSet;
+
+    private final @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostPerRealState;
+    private final @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostReplacementPerHost;
+    private final @NotNull List<@NotNull BlockState> fallbackList;
+    private final @NotNull Map<@NotNull BlockState, @NotNull BlockState> fallbackPerRealState;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getHostAndFallbackBlocks}
+     */
+    private final @NotNull List<@NotNull Block> hostAndFallbackBlocks;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getPotentialBlockReplacementPairs}
+     */
+    private final @NotNull List<@NotNull Pair<@NotNull Block, @NotNull Block>> potentialBlockReplacementPairs;
+
+    private final @NotNull Map<@NotNull BlockState, @NotNull ModelWithParameters> modelPerHost;
+
+    private final @Nullable Map<@NotNull BlockState, @NotNull Model> blockEntityItemModelBasePerRealState;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private @Nullable Map<@NotNull BlockState, @NotNull Model @NotNull []> blockEntityItemModelsPerRealState;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private @Nullable Map<@NotNull BlockState, int @NotNull []> blockEntityItemCustomModelDataPerRealState;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private @Nullable Map<@NotNull BlockState, @NotNull BlockEntityItemStack> blockEntityItemStackPerRealState;
+
+    public MultiStateRealBlockReplacementRule(@NotNull Block real, @Nullable RealItemReplacementRule realItemRule, @Nullable Set<@NotNull BlockState> realStatesRenderedAsEntity, @Nullable Map<@NotNull BlockState, @NotNull BlockEntityModelVisualPropertiesUniverse<?>> modelVisualPropertiesUniverseByRealState, boolean rendersSomeStatesAsEntity, @NotNull List<@NotNull BlockState> hosts, @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostPerRealState, @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostReplacementPerHost, @NotNull List<@NotNull BlockState> fallbacks, @NotNull Map<@NotNull BlockState, @NotNull BlockState> fallbackPerRealState, @NotNull Map<@NotNull BlockState, @NotNull ModelWithParameters> modelPerHost, List<@NotNull HostItemReplacementRule> hostItemRules, @Nullable Map<@NotNull BlockState, @NotNull Model> blockEntityItemModelBasePerRealState) {
+        super(real, realItemRule, realStatesRenderedAsEntity, modelVisualPropertiesUniverseByRealState, rendersSomeStatesAsEntity, hostItemRules);
+        this.hostSet = Collections.newSetFromMap(new IdentityHashMap<>());
+        this.hostSet.addAll(hosts);
+        this.hostList = List.copyOf(hosts);
+        this.hostPerRealState = new IdentityHashMap<>(hostPerRealState);
+        this.hostReplacementPerHost = new IdentityHashMap<>(hostReplacementPerHost);
+        this.fallbackList = fallbacks;
+        this.fallbackPerRealState = new IdentityHashMap<>(fallbackPerRealState);
+        this.hostAndFallbackBlocks = Stream.of(this.hostList, this.fallbackList).flatMap(List::stream).map(BlockState::getBlock).distinct().toList();
+        this.potentialBlockReplacementPairs = Stream.of(this.hostPerRealState, this.hostReplacementPerHost, this.fallbackPerRealState)
+            .flatMap(map -> map.entrySet().stream().map(entry -> Pair.of(entry.getKey().getBlock(), entry.getValue().getBlock())))
+            .filter(pair -> !pair.left().equals(pair.right()))
+            .distinct()
+            .toList();
+        this.modelPerHost = new IdentityHashMap<>(modelPerHost);
+        this.blockEntityItemModelBasePerRealState = blockEntityItemModelBasePerRealState;
+    }
+
+    @Override
+    public @NotNull List<@NotNull BlockState> getHosts() {
+        return this.hostList;
+    }
+
+    @Override
+    public boolean hasAsHost(@NotNull BlockState potentialHost) {
+        return this.hostSet.contains(potentialHost);
+    }
+
+    @Override
+    public @NotNull BlockState getHost(@NotNull BlockState realState) {
+        return this.hostPerRealState.get(realState);
+    }
+
+    @Override
+    public @NotNull BlockState getHostReplacement(@NotNull BlockState host) {
+        return this.hostReplacementPerHost.get(host);
+    }
+
+    @Override
+    public @NotNull List<@NotNull BlockState> getFallbacks() {
+        return this.fallbackList;
+    }
+
+    @Override
+    public @NotNull BlockState getFallback(@NotNull BlockState realState) {
+        return this.fallbackPerRealState.get(realState);
+    }
+
+    @Override
+    public @NotNull List<@NotNull Block> getHostAndFallbackBlocks() {
+        return this.hostAndFallbackBlocks;
+    }
+
+    @Override
+    public @NotNull List<@NotNull Pair<@NotNull Block, @NotNull Block>> getPotentialBlockReplacementPairs() {
+        return this.potentialBlockReplacementPairs;
+    }
+
+    @Override
+    public @Nullable ModelWithParameters getModel(@NotNull BlockState host) {
+        if (this.isFire) {
+            throw new IllegalStateException("Cannot call BlockReplacementRule.getModel for fire");
+        }
+        return this.modelPerHost.get(host);
+    }
+
+    @Override
+    public @Nullable Model getBlockEntityItemModelBase(@NotNull BlockState realState) {
+        return this.blockEntityItemModelBasePerRealState == null ? null : this.blockEntityItemModelBasePerRealState.get(realState);
+    }
+
+    @Override
+    public @NotNull Model @Nullable [] getBlockEntityItemModels(@NotNull BlockState realState) {
+        if (this.blockEntityItemModelsPerRealState == null) {
+            if (this.rendersSomeStatesAsEntity) {
+                this.blockEntityItemModelsPerRealState = new IdentityHashMap<>(0);
+                for (@NotNull BlockState possibleRealState : this.getReal().getStateDefinition().getPossibleStates()) {
+                    if (this.rendersAsEntity(possibleRealState)) {
+                        this.blockEntityItemModelsPerRealState.put(possibleRealState, this.computeBlockEntityItemModels(possibleRealState));
+                    }
+                }
+            } else {
+                return null;
+            }
+        }
+        return this.blockEntityItemModelsPerRealState.get(realState);
+    }
+
+    @Override
+    public int @Nullable [] getBlockEntityItemCustomModelData(@NotNull BlockState realState) {
+        if (this.blockEntityItemCustomModelDataPerRealState == null) {
+            if (this.rendersSomeStatesAsEntity) {
+                this.blockEntityItemCustomModelDataPerRealState = new IdentityHashMap<>(0);
+                @NotNull Item item = this.computeBlockEntityItem();
+                for (@NotNull BlockState possibleRealState : this.getReal().getStateDefinition().getPossibleStates()) {
+                    if (this.rendersAsEntity(possibleRealState)) {
+                        var universe = this.getEntityRenderModelVisualPropertiesUniverse(possibleRealState);
+                        int[] customModelData = new int[universe.getValues().length];
+                        for (int i = 0; i < customModelData.length; i++) {
+                            customModelData[i] = UsedHostCustomModelData.generateUnusedHostCustomModelData(item);
+                        }
+                        this.blockEntityItemCustomModelDataPerRealState.put(possibleRealState, customModelData);
+                    }
+                }
+            } else {
+                return null;
+            }
+        }
+        return this.blockEntityItemCustomModelDataPerRealState.get(realState);
+    }
+
+    @Override
+    public @Nullable BlockEntityItemStack getBlockEntityItemStack(@NotNull BlockState realState) {
+        if (this.blockEntityItemStackPerRealState == null) {
+            if (this.rendersSomeStatesAsEntity) {
+                this.blockEntityItemStackPerRealState = new IdentityHashMap<>(0);
+                for (@NotNull BlockState possibleRealState : this.real.getStateDefinition().getPossibleStates()) {
+                    if (this.rendersAsEntity(possibleRealState)) {
+                        this.blockEntityItemStackPerRealState.put(possibleRealState, this.computeBlockEntityItemStack(possibleRealState));
+                    }
+                }
+            } else {
+                return null;
+            }
+        }
+        return this.blockEntityItemStackPerRealState.get(realState);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/replacementrule/RealItemReplacementRule.java b/src/main/java/org/sucraft/suki/block/replacementrule/RealItemReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..ea81e504a7f3d104e96d1997ae79bc2e0e78c451
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/replacementrule/RealItemReplacementRule.java
@@ -0,0 +1,102 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block.replacementrule;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.function.Supplier;
+
+/**
+ * The information about a custom item for the real block of a {@link BlockReplacementRule}
+ * (note that each item can only represent one real block)
+ * <br>
+ * This class uses late initialization internally so that items are not referenced before block bootstrapping is finished
+ */
+public class RealItemReplacementRule {
+
+    private final @NotNull Supplier<@NotNull Item> lowPingHostSupplier;
+    private final @NotNull Supplier<@NotNull Item> highPingHostSupplier;
+    private final @NotNull Supplier<@NotNull Item> fallbackSupplier;
+
+    /**
+     * Is null only when not initialized yet
+     * @see #lowPingHostSupplier
+     */
+    private @Nullable Item lowPingHost;
+
+    /**
+     * Is null only when not initialized yet
+     * @see #highPingHostSupplier
+     */
+    private @Nullable Item highPingHost;
+
+    /**
+     * Is null only when not initialized yet
+     * @see #fallbackSupplier
+     */
+    private @Nullable Item fallback;
+
+    public RealItemReplacementRule(@NotNull Supplier<@NotNull Item> lowPingHostSupplier, @NotNull Supplier<@NotNull Item> highPingHostSupplier, @NotNull Supplier<@NotNull Item> fallbackSupplier) {
+        this.lowPingHostSupplier = lowPingHostSupplier;
+        this.highPingHostSupplier = highPingHostSupplier;
+        this.fallbackSupplier = fallbackSupplier;
+    }
+
+    /**
+     * This must not be called before all block bootstrapping has finished
+     * <br>
+     * This should be an item that would normally let the player place a block state with a (nearly) identical collision bounding box to the real state placed by the real item, and that is invisible
+     */
+    public @NotNull Item getLowPingHost() {
+        if (this.lowPingHost == null) {
+            this.lowPingHost = this.lowPingHostSupplier.get();
+        }
+        return this.lowPingHost;
+    }
+
+    /**
+     * This must not be called before all block bootstrapping has finished
+     * <br>
+     * This should be an item that would normally let the player place a block state with a (nearly) identical collision bounding box to the real state placed by the real item, and that looks as similar to the real state placed by the real item as possible
+     */
+    public @NotNull Item getHighPingHost() {
+        if (this.highPingHost == null) {
+            this.highPingHost = this.highPingHostSupplier.get();
+        }
+        return this.highPingHost;
+    }
+
+    /**
+     * This must not be called before all block bootstrapping has finished
+     * <br>
+     * This should be an item that would normally let the player place the block state that is the fallback for the real state placed by the real item
+     */
+    public @NotNull Item getFallback() {
+        if (this.fallback == null) {
+            this.fallback = this.fallbackSupplier.get();
+        }
+        return this.fallback;
+    }
+
+    /**
+     * Creates a {@link RealItemReplacementRule} for a real block that has a full block bounding box
+     * <br>
+     * The low ping host will be {@link Items#BARRIER}
+     */
+    public static @NotNull RealItemReplacementRule forFullBlockBoundingBox(@NotNull Supplier<@NotNull Item> highPingHostSupplier, @NotNull Supplier<@NotNull Item> fallbackSupplier) {
+        return new RealItemReplacementRule(() -> Items.BARRIER, highPingHostSupplier, fallbackSupplier);
+    }
+
+    /**
+     * Creates a {@link RealItemReplacementRule} for a real block that has a full block bounding box
+     * <br>
+     * The low ping host will be {@link Items#BARRIER}, and the high ping host will be the same as the fallback (since we already assume it looks similar)
+     */
+    public static @NotNull RealItemReplacementRule forFullBlockBoundingBox(@NotNull Supplier<@NotNull Item> fallbackSupplier) {
+        return forFullBlockBoundingBox(fallbackSupplier, fallbackSupplier);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/replacementrule/SingleMultiStateRealBlockReplacementRuleBuilder.java b/src/main/java/org/sucraft/suki/block/replacementrule/SingleMultiStateRealBlockReplacementRuleBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..6739560568b20d94d4bca2c5867581f2630fd69d
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/replacementrule/SingleMultiStateRealBlockReplacementRuleBuilder.java
@@ -0,0 +1,314 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block.replacementrule;
+
+import com.google.common.collect.Sets;
+import net.minecraft.core.Registry;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.BaseFireBlock;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.FireBlock;
+import net.minecraft.world.level.block.state.BlockState;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelVisualPropertiesUniverse;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.blockanditemdata.model.ModelCreation;
+import org.sucraft.suki.blockanditemdata.model.ModelCreationWithParameters;
+import org.sucraft.suki.blockanditemdata.model.ModelWithParameters;
+import org.sucraft.suki.item.UsedHostCustomModelData;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+
+/**
+ * Concrete implementation of a builder for {@link SingleStateRealBlockReplacementRule} and {@link MultiStateRealBlockReplacementRule}
+ */
+public class SingleMultiStateRealBlockReplacementRuleBuilder implements BlockReplacementRuleBuilder<BlockReplacementRuleBase, SingleMultiStateRealBlockReplacementRuleBuilder> {
+
+    protected @Nullable Block real = null;
+    protected @NotNull Supplier<@Nullable RealItemReplacementRule> justInTimeRealItemRuleSupplier = () -> null;
+    private @NotNull Predicate<@NotNull BlockState> rendersAsEntityForRealState = $ -> false;
+    private @NotNull Function<@NotNull BlockState, @Nullable BlockEntityModelVisualPropertiesUniverse<?>> blockEntityModelVisualPropertiesUniverseForRealState = $ -> null;
+    private @NotNull Function<@NotNull BlockState, @Nullable BlockState> hostForRealState = $ -> null;
+    private @NotNull Function<@NotNull BlockState, @Nullable BlockState> hostReplacementForHost = $ -> null;
+    private @NotNull Function<@NotNull BlockState, @Nullable BlockState> fallbackForRealState = $ -> null;
+    private @NotNull Function<@NotNull BlockState, @Nullable ModelWithParameters> modelForRealState = $ -> null;
+    private @NotNull List<@NotNull Supplier<@NotNull HostItemReplacementRule>> justInTimeHostItemRuleSuppliers = new ArrayList<>(0);
+
+    public SingleMultiStateRealBlockReplacementRuleBuilder() {}
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withReal(@NotNull Block real) {
+        this.real = real;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder rendersAsEntity(@NotNull BlockState realState) {
+        @NotNull Predicate<@NotNull BlockState> existingRendersAsEntityForRealState = this.rendersAsEntityForRealState;
+        this.rendersAsEntityForRealState = someRealState -> someRealState.equals(realState) || existingRendersAsEntityForRealState.test(someRealState);
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder rendersAsEntity(@NotNull Predicate<@NotNull BlockState> realStatePredicate) {
+        @NotNull Predicate<@NotNull BlockState> existingRendersAsEntityForRealState = this.rendersAsEntityForRealState;
+        this.rendersAsEntityForRealState = someRealState -> realStatePredicate.test(someRealState) || existingRendersAsEntityForRealState.test(someRealState);
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withBlockEntityModelVisualPropertiesUniverse(@NotNull BlockEntityModelVisualPropertiesUniverse<?> universe) {
+        this.blockEntityModelVisualPropertiesUniverseForRealState = $ -> universe;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withBlockEntityModelVisualPropertiesUniverseForRealState(@NotNull Function<@NotNull BlockState, @Nullable BlockEntityModelVisualPropertiesUniverse<?>> blockEntityModelVisualPropertiesUniverseForRealState) {
+        @NotNull Function<@NotNull BlockState, @Nullable BlockEntityModelVisualPropertiesUniverse<?>> existingBlockEntityModelVisualPropertiesUniverseForRealState = this.blockEntityModelVisualPropertiesUniverseForRealState;
+        this.blockEntityModelVisualPropertiesUniverseForRealState = realState -> {
+            @Nullable BlockEntityModelVisualPropertiesUniverse<?> universe = blockEntityModelVisualPropertiesUniverseForRealState.apply(realState);
+            return universe != null ? universe : existingBlockEntityModelVisualPropertiesUniverseForRealState.apply(realState);
+        };
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHost(@NotNull BlockState host) {
+        this.hostForRealState = $ -> host;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHostForRealState(@NotNull Function<@NotNull BlockState, @Nullable BlockState> hostForRealState) {
+        @NotNull Function<@NotNull BlockState, @Nullable BlockState> existingHostForRealState = this.hostForRealState;
+        this.hostForRealState = realState -> {
+            @Nullable BlockState host = hostForRealState.apply(realState);
+            return host != null ? host : existingHostForRealState.apply(realState);
+        };
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHostReplacement(@NotNull BlockState hostReplacement) {
+        this.hostReplacementForHost = $ -> hostReplacement;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHostReplacementForHost(@NotNull Function<@NotNull BlockState, @Nullable BlockState> hostReplacementForHost) {
+        @NotNull Function<@NotNull BlockState, @Nullable BlockState> existingHostReplacementForHost = this.hostReplacementForHost;
+        this.hostReplacementForHost = host -> {
+            @Nullable BlockState hostReplacement = hostReplacementForHost.apply(host);
+            return hostReplacement != null ? hostReplacement : existingHostReplacementForHost.apply(host);
+        };
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withFallback(@NotNull BlockState fallback) {
+        this.fallbackForRealState = $ -> fallback;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withFallbackForRealState(@NotNull Function<@NotNull BlockState, @Nullable BlockState> fallbackForRealState) {
+        @NotNull Function<@NotNull BlockState, @Nullable BlockState> existingFallbackForRealState = this.fallbackForRealState;
+        this.fallbackForRealState = realState -> {
+            @Nullable BlockState host = fallbackForRealState.apply(realState);
+            return host != null ? host : existingFallbackForRealState.apply(realState);
+        };
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withModel(@NotNull ModelWithParameters model) {
+        this.modelForRealState = $ -> model;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withModelForRealState(@NotNull Function<@NotNull BlockState, @Nullable ModelWithParameters> modelForRealState) {
+        @NotNull Function<@NotNull BlockState, @Nullable ModelWithParameters> existingModelForRealState = this.modelForRealState;
+        this.modelForRealState = realState -> {
+            @Nullable ModelWithParameters model = modelForRealState.apply(realState);
+            return model != null ? model : existingModelForRealState.apply(realState);
+        };
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withModelCreation(@NotNull ModelCreationWithParameters modelCreation) {
+        this.modelForRealState = $ -> modelCreation.create(ResourcePackAssetIntention.BLOCK, Registry.BLOCK.getKey(this.real));
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withModelCreationForRealState(@NotNull Function<@NotNull BlockState, @Nullable ModelCreationWithParameters> modelCreationForRealState) {
+        return this.withModelForRealState(realState -> {
+            @Nullable ModelCreationWithParameters modelCreation = modelCreationForRealState.apply(realState);
+            return modelCreation == null ? null : modelCreation.create(ResourcePackAssetIntention.BLOCK, Registry.BLOCK.getKey(this.real));
+        });
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withRealItemRule(@NotNull RealItemReplacementRule realItemRule) {
+        this.justInTimeRealItemRuleSupplier = () -> realItemRule;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withoutRealItemRule() {
+        this.justInTimeRealItemRuleSupplier = () -> null;
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withFullBlockBoundingBoxItem(@NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        this.justInTimeRealItemRuleSupplier = () -> RealItemReplacementRule.forFullBlockBoundingBox(highPingHostSupplier, () -> this.fallbackForRealState.apply(this.real.defaultBlockState()).getBlock().asItem());
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withFullBlockBoundingBoxItem() {
+        this.justInTimeRealItemRuleSupplier = () -> RealItemReplacementRule.forFullBlockBoundingBox(() -> this.fallbackForRealState.apply(this.real.defaultBlockState()).getBlock().asItem());
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withRealItemRuleFromHostBlock() {
+        @NotNull Supplier<@NotNull Item> hostSupplier = () -> this.hostForRealState.apply(this.real.defaultBlockState()).getBlock().asItem();
+        @NotNull Supplier<@NotNull Item> fallbackSupplier = () -> this.fallbackForRealState.apply(this.real.defaultBlockState()).getBlock().asItem();
+        this.justInTimeRealItemRuleSupplier = () -> new RealItemReplacementRule(hostSupplier, hostSupplier, fallbackSupplier);
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHostItemRule(@NotNull HostItemReplacementRule hostItemRule) {
+        this.justInTimeHostItemRuleSuppliers.add(() -> hostItemRule);
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withoutHostItemRules() {
+        this.justInTimeHostItemRuleSuppliers.clear();
+        return this;
+    }
+
+    @Override
+    public @NotNull SingleMultiStateRealBlockReplacementRuleBuilder withHostItemRuleFromHostBlockAndHostReplacementBlock() {
+        this.justInTimeHostItemRuleSuppliers.add(() -> {
+            @NotNull BlockState host = Validate.notNull(this.hostForRealState.apply(this.real.defaultBlockState()));
+            return new HostItemReplacementRule(() -> host.getBlock().asItem(), () -> this.hostReplacementForHost.apply(host).getBlock().asItem());
+        });
+        return this;
+    }
+
+    /**
+     * May return a {@link SingleStateRealBlockReplacementRule} if possible
+     */
+    @Override
+    public @NotNull BlockReplacementRuleBase build() {
+        Validate.notNull(this.real);
+        boolean isFire = this.real instanceof BaseFireBlock;
+        @Nullable RealItemReplacementRule realItemRule = this.justInTimeRealItemRuleSupplier.get();
+        @NotNull List<@NotNull HostItemReplacementRule> hostItemRules = this.justInTimeHostItemRuleSuppliers.stream().map(Supplier::get).toList();
+        var realStates = this.real.getStateDefinition().getPossibleStates();
+        if (realStates.size() == 1) {
+            @NotNull BlockState realState = Validate.notNull(this.real.defaultBlockState());
+            @NotNull BlockState host = Validate.notNull(this.hostForRealState.apply(realState));
+            @NotNull BlockState hostReplacement = Validate.notNull(this.hostReplacementForHost.apply(host));
+            @NotNull BlockState fallback = Validate.notNull(this.fallbackForRealState.apply(realState));
+            @Nullable ModelWithParameters model = isFire ? null : Validate.notNull(this.modelForRealState.apply(realState));
+            boolean rendersAsEntity = this.rendersAsEntityForRealState.test(realState);
+            @Nullable Model blockEntityItemModelBase = !rendersAsEntity ? null : model.model();
+            return new SingleStateRealBlockReplacementRule(
+                this.real,
+                realItemRule,
+                rendersAsEntity ? this.blockEntityModelVisualPropertiesUniverseForRealState.apply(realState) : null,
+                rendersAsEntity,
+                host,
+                hostReplacement,
+                fallback,
+                model,
+                hostItemRules,
+                blockEntityItemModelBase
+            );
+        }
+        @NotNull List<@NotNull BlockState> hosts = new ArrayList<>();
+        @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostPerRealState = new IdentityHashMap<>(0);
+        @NotNull Map<@NotNull BlockState, @NotNull BlockState> hostReplacementPerHost = new IdentityHashMap<>(0);
+        @NotNull List<@NotNull BlockState> fallbacks = new ArrayList<>();
+        @NotNull Map<@NotNull BlockState, @NotNull BlockState> fallbackPerRealState = new IdentityHashMap<>(0);
+        @NotNull Map<@NotNull BlockState, @NotNull ModelWithParameters> modelPerHost = new IdentityHashMap<>(0);
+        boolean rendersSomeStatesAsEntity = realStates.stream().anyMatch(this.rendersAsEntityForRealState);
+        @Nullable Map<@NotNull BlockState, @NotNull Model> blockEntityItemModelBasePerRealState = rendersSomeStatesAsEntity ? new IdentityHashMap<>(1) : null;
+        @Nullable Set<@NotNull BlockState> realStatesRenderedAsEntity = rendersSomeStatesAsEntity ? Collections.newSetFromMap(new IdentityHashMap<>(1)) : null;
+        @Nullable Map<@NotNull BlockState, @NotNull BlockEntityModelVisualPropertiesUniverse<?>> modelVisualPropertiesUniverseByRealState = rendersSomeStatesAsEntity ? new IdentityHashMap<>(1) : null;
+        for (@NotNull BlockState realState : realStates) {
+            @NotNull BlockState host = Validate.notNull(this.hostForRealState.apply(realState));
+            if (!hosts.contains(host)) {
+                hosts.add(host);
+            }
+            hostPerRealState.put(realState, host);
+            @NotNull BlockState fallback = Validate.notNull(this.fallbackForRealState.apply(realState));
+            if (!fallbacks.contains(fallback)) {
+                fallbacks.add(fallback);
+            }
+            fallbackPerRealState.put(realState, fallback);
+            if (!isFire && !modelPerHost.containsKey(host)) {
+                @Nullable ModelWithParameters model = this.modelForRealState.apply(realState);
+                if (!rendersSomeStatesAsEntity) {
+                    Validate.notNull(model);
+                }
+                if (model != null) {
+                    modelPerHost.put(host, model);
+                }
+            }
+        }
+        if (!rendersSomeStatesAsEntity) {
+            for (@NotNull BlockState host : hosts) {
+                @NotNull BlockState hostReplacement = Validate.notNull(this.hostReplacementForHost.apply(host));
+                hostReplacementPerHost.put(host, hostReplacement);
+            }
+        }
+        if (rendersSomeStatesAsEntity) {
+            for (@NotNull BlockState realState : realStates) {
+                if (this.rendersAsEntityForRealState.test(realState)) {
+                    blockEntityItemModelBasePerRealState.put(realState, modelPerHost.get(hostPerRealState.get(realState)).model());
+                    realStatesRenderedAsEntity.add(realState);
+                    modelVisualPropertiesUniverseByRealState.put(realState, this.blockEntityModelVisualPropertiesUniverseForRealState.apply(realState));
+                }
+            }
+        }
+        return new MultiStateRealBlockReplacementRule(
+            this.real,
+            realItemRule,
+            realStatesRenderedAsEntity,
+            modelVisualPropertiesUniverseByRealState,
+            rendersSomeStatesAsEntity,
+            hosts,
+            hostPerRealState,
+            hostReplacementPerHost,
+            fallbacks,
+            fallbackPerRealState,
+            modelPerHost,
+            hostItemRules,
+            blockEntityItemModelBasePerRealState
+        );
+    }
+
+
+}
diff --git a/src/main/java/org/sucraft/suki/block/replacementrule/SingleStateRealBlockReplacementRule.java b/src/main/java/org/sucraft/suki/block/replacementrule/SingleStateRealBlockReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..840fcff7406f223207d9decc652e56e7fa56ed77
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/block/replacementrule/SingleStateRealBlockReplacementRule.java
@@ -0,0 +1,240 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.block.replacementrule;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Registry;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelVisualProperties;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelVisualPropertiesUniverse;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.blockanditemdata.model.ModelWithParameters;
+import org.sucraft.suki.item.UsedHostCustomModelData;
+import org.sucraft.suki.resourcepack.MutableResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.blockstates.MutableResourcePackBlockStates;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Single-state real blocks could be managed by a {@link MultiStateRealBlockReplacementRule} rule as well, but this implementation is slightly more efficient
+ */
+public class SingleStateRealBlockReplacementRule extends BlockReplacementRuleBase {
+
+    private final @NotNull BlockState host;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getHosts}
+     */
+    private final @NotNull List<@NotNull BlockState> hosts;
+
+    private final @NotNull BlockState hostReplacement;
+    private final @NotNull BlockState fallback;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getFallbacks}
+     */
+    private final @NotNull List<@NotNull BlockState> fallbacks;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getHostAndFallbackBlocks()}
+     */
+    private final @NotNull List<@NotNull Block> hostAndFallbackBlocks;
+
+    /**
+     * This is simply a backing field for quickly returning {@link #getPotentialBlockReplacementPairs}
+     */
+    private final @NotNull List<@NotNull Pair<@NotNull Block, @NotNull Block>> potentialBlockReplacementPairs;
+
+    /**
+     * Nullable only if {@link #isFire} is true
+     */
+    private final @Nullable ModelWithParameters model;
+
+    private final @Nullable Model blockEntityItemModelBase;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private @NotNull Model @Nullable [] blockEntityItemModels;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private int @Nullable [] blockEntityItemCustomModelData;
+
+    /**
+     * Is at least null when not initialized yet:
+     * late initialization is used so that items are not referenced before block bootstrapping is finished
+     */
+    private @Nullable BlockEntityItemStack blockEntityItemStack;
+
+    public SingleStateRealBlockReplacementRule(@NotNull Block real, @Nullable RealItemReplacementRule realItemRule, @Nullable BlockEntityModelVisualPropertiesUniverse<?> modelVisualPropertiesUniverse, boolean rendersAsEntity, @NotNull BlockState host, @NotNull BlockState hostReplacement, @NotNull BlockState fallback, @Nullable ModelWithParameters model, @NotNull List<@NotNull HostItemReplacementRule> hostItemRules, @Nullable Model blockEntityItemModelBase) {
+        super(real, realItemRule, rendersAsEntity ? Collections.singleton(real.defaultBlockState()) : null, rendersAsEntity ? Map.of(real.defaultBlockState(), modelVisualPropertiesUniverse) : null, rendersAsEntity, hostItemRules);
+        this.host = host;
+        this.hosts = Collections.singletonList(this.host);
+        this.hostReplacement = hostReplacement;
+        this.fallback = fallback;
+        this.fallbacks = Collections.singletonList(this.fallback);
+        this.hostAndFallbackBlocks = Stream.of(this.host.getBlock(), this.fallback.getBlock()).distinct().toList();
+        this.potentialBlockReplacementPairs = Stream.of(
+            Pair.of(this.real, this.host.getBlock()),
+            Pair.of(this.host.getBlock(), this.hostReplacement.getBlock()),
+            Pair.of(this.real, this.fallback.getBlock())
+        ).filter(pair -> !pair.left().equals(pair.right())).distinct().toList();
+        this.model = model;
+        this.blockEntityItemModelBase = blockEntityItemModelBase;
+    }
+
+    @Override
+    public boolean rendersAsEntity(@NotNull BlockState realState) {
+        // Tiny optimization: no need for set check as done in BlockReplacementRuleBase
+        return this.rendersSomeStatesAsEntity;
+    }
+
+    @Override
+    public @NotNull List<@NotNull BlockState> getHosts() {
+        return this.hosts;
+    }
+
+    @Override
+    public boolean hasAsHost(@NotNull BlockState potentialHost) {
+        return this.host.equals(potentialHost);
+    }
+
+    public @NotNull BlockState getHost() {
+        return this.host;
+    }
+
+    @Override
+    public @NotNull BlockState getHost(@NotNull BlockState realState) {
+        return this.host;
+    }
+
+    @Override
+    public @NotNull BlockState getHostReplacement(@NotNull BlockState host) {
+        return this.hostReplacement;
+    }
+
+    public @NotNull BlockState getHostReplacement() {
+        return this.hostReplacement;
+    }
+
+    @Override
+    public @NotNull List<@NotNull BlockState> getFallbacks() {
+        return this.fallbacks;
+    }
+
+    @Override
+    public @NotNull BlockState getFallback(@NotNull BlockState realState) {
+        return this.fallback;
+    }
+
+    public @NotNull BlockState getFallback() {
+        return this.fallback;
+    }
+
+    @Override
+    public @NotNull List<@NotNull Block> getHostAndFallbackBlocks() {
+        return this.hostAndFallbackBlocks;
+    }
+
+    @Override
+    public @NotNull List<@NotNull Pair<@NotNull Block, @NotNull Block>> getPotentialBlockReplacementPairs() {
+        return this.potentialBlockReplacementPairs;
+    }
+
+    @Override
+    public @Nullable ModelWithParameters getModel(@NotNull BlockState host) {
+        return this.getModel();
+    }
+
+    public @Nullable ModelWithParameters getModel() {
+        if (this.isFire) {
+            throw new IllegalStateException("Cannot call BlockReplacementRule.getModel for fire");
+        }
+        return this.model;
+    }
+
+    @Override
+    public @Nullable Model getBlockEntityItemModelBase(@NotNull BlockState realState) {
+        return this.blockEntityItemModelBase;
+    }
+
+    @Override
+    public @NotNull Model @Nullable [] getBlockEntityItemModels(@NotNull BlockState realState) {
+        if (this.blockEntityItemModels == null) {
+            if (this.rendersSomeStatesAsEntity) {
+                this.blockEntityItemModels = this.computeBlockEntityItemModels(realState);
+            }
+        }
+        return this.blockEntityItemModels;
+    }
+
+    @Override
+    public int @Nullable [] getBlockEntityItemCustomModelData(@NotNull BlockState realState) {
+        if (this.blockEntityItemCustomModelData == null) {
+            if (this.rendersSomeStatesAsEntity) {
+                @NotNull Item item = this.computeBlockEntityItem();
+                var universe = this.getEntityRenderModelVisualPropertiesUniverse(realState);
+                this.blockEntityItemCustomModelData = new int[universe.getValues().length];
+                for (int i = 0; i < blockEntityItemCustomModelData.length; i++) {
+                    this.blockEntityItemCustomModelData[i] = UsedHostCustomModelData.generateUnusedHostCustomModelData(item);
+                }
+            } else {
+                return null;
+            }
+        }
+        return this.blockEntityItemCustomModelData;
+    }
+
+    @Override
+    public @Nullable BlockEntityItemStack getBlockEntityItemStack(@NotNull BlockState realState) {
+        if (this.blockEntityItemStack == null) {
+            if (this.rendersSomeStatesAsEntity) {
+                this.blockEntityItemStack = this.computeBlockEntityItemStack(realState);
+            } else {
+                return null;
+            }
+        }
+        return this.blockEntityItemStack;
+    }
+
+    @Override
+    public @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> addToResourcePack(@NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+        if (this.isFire) {
+            return super.addToResourcePack(resourcePack, actuallyAdd);
+        }
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> assetLocations = new ArrayList<>(0);
+        assetLocations.addAll(this.addBlockEntityItemToResourcePack(resourcePack, actuallyAdd));
+        @NotNull NamespacedKeyWithIntention hostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.BLOCK.getKey(this.host.getBlock())).withEmptyIntention();
+        @NotNull MutableResourcePackBlockStates minecraftBlockStates = resourcePack.getBlockStates(hostKey);
+        if (this.host.getBlock().getStateDefinition().getPossibleStates().size() == 1) {
+//            System.out.println("TEMP DEBUG - Set no variant model of " + this.host.getBlock() + " for " + this.getReal() + " to " + this.model.model().getKeyWithIntention());
+            assetLocations.addAll(minecraftBlockStates.setNoVariantModel(this.model, resourcePack, false, actuallyAdd));
+        } else {
+            assetLocations.addAll(minecraftBlockStates.setModel(this.host, this.model, resourcePack, false, actuallyAdd));
+        }
+        return assetLocations;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/BaseBlockEntityModelVisualProperties.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/BaseBlockEntityModelVisualProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..c57e44f1d69cce297b7f86ef88edca3aefad7f1c
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/BaseBlockEntityModelVisualProperties.java
@@ -0,0 +1,50 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+
+public class BaseBlockEntityModelVisualProperties implements TypicalBlockEntityModelVisualProperties {
+
+    public final @NotNull BlockEntityModelPosition position;
+    public final @NotNull BlockEntityModelProximity proximity;
+
+    public BaseBlockEntityModelVisualProperties(@NotNull BlockEntityModelPosition position, @NotNull BlockEntityModelProximity proximity) {
+        this.position = position;
+        this.proximity = proximity;
+    }
+
+    @Override
+    public @NotNull String getBlockEntityModelFileSuffix() {
+        return this.position.blockEntityModelFileSuffix + this.proximity.blockEntityModelFileSuffix;
+    }
+
+    @Override
+    public @NotNull BlockEntityModelPosition getPosition() {
+        return this.position;
+    }
+
+    @Override
+    public @NotNull BlockEntityModelProximity getProximity() {
+        return this.proximity;
+    }
+
+    @Override
+    public @NotNull TypicalBlockEntityModelVisualProperties cloneWithProximity(@NotNull BlockEntityModelProximity proximity) {
+        return new BaseBlockEntityModelVisualProperties(this.position, proximity);
+    }
+
+    @Override
+    public int hashCode() {
+        return this.position.ordinal() + BlockEntityModelPosition.values().length * this.proximity.ordinal();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof BaseBlockEntityModelVisualProperties properties) {
+            return properties.position.equals(this.position) && properties.proximity.equals(this.proximity);
+        }
+        return false;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelPosition.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..05d8c68af6d08f77c422d2b87a79fe4e1add53f9
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelPosition.java
@@ -0,0 +1,31 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+
+public enum BlockEntityModelPosition {
+
+    POSITIVE_XZ("p", 1.6F * 16 / 2, 0.5F),
+    CENTER("c", 0, 0),
+    NEGATIVE_XZ("n", -POSITIVE_XZ.displayTranslationX, -POSITIVE_XZ.armorStandPhysicalTranslationX);
+
+    public final @NotNull String blockEntityModelFileSuffix;
+    public final float displayTranslationX;
+    public final float displayTranslationZ;
+    public final float armorStandPhysicalTranslationX;
+    public final float armorStandPhysicalTranslationZ;
+
+    BlockEntityModelPosition(@NotNull String blockEntityModelFileSuffix, float displayTranslationX, float displayTranslationZ, float armorStandPhysicalTranslationX, float armorStandPhysicalTranslationZ) {
+        this.blockEntityModelFileSuffix = blockEntityModelFileSuffix;
+        this.displayTranslationX = displayTranslationX;
+        this.displayTranslationZ = displayTranslationZ;
+        this.armorStandPhysicalTranslationX = armorStandPhysicalTranslationX;
+        this.armorStandPhysicalTranslationZ = armorStandPhysicalTranslationZ;
+    }
+
+    BlockEntityModelPosition(@NotNull String blockEntityModelFileSuffix, float displayTranslationXZ, float armorStandPhysicalTranslationXZ) {
+        this(blockEntityModelFileSuffix, displayTranslationXZ, displayTranslationXZ, armorStandPhysicalTranslationXZ, armorStandPhysicalTranslationXZ);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelProximity.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelProximity.java
new file mode 100644
index 0000000000000000000000000000000000000000..8c75fec0c981c361a8e308685f611bb87d02d819
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelProximity.java
@@ -0,0 +1,26 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+
+public enum BlockEntityModelProximity {
+
+    NOT_EXPANDED("v", 0.0F),
+    NEIGHBOR_BLOCK("b", 0.005F),
+    SAME_CHUNK("s", 0.01F),
+    NEIGHBOR_CHUNK("n", 0.03F),
+    FAR("f", 0.21F);
+
+    public final @NotNull String blockEntityModelFileSuffix;
+    public final float outwardExpandedElementDistance;
+
+    BlockEntityModelProximity(@NotNull String blockEntityModelFileSuffix, float outwardExpandedElementDistance) {
+        this.blockEntityModelFileSuffix = blockEntityModelFileSuffix;
+        this.outwardExpandedElementDistance = outwardExpandedElementDistance;
+    }
+
+    public static final int maxBlockDistanceForNeighbors = 2;
+    public static final int maxSectionDistanceForNeighbors = 1;
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelVisualProperties.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelVisualProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..1386f319fbfc0280ad5ae6cbe1a2dce6e6d535a8
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelVisualProperties.java
@@ -0,0 +1,14 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public interface BlockEntityModelVisualProperties {
+
+    @NotNull String getBlockEntityModelFileSuffix();
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelVisualPropertiesUniverse.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelVisualPropertiesUniverse.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b76f950400619582f21dd30382b9c045178731b
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/BlockEntityModelVisualPropertiesUniverse.java
@@ -0,0 +1,17 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+
+public interface BlockEntityModelVisualPropertiesUniverse<P extends BlockEntityModelVisualProperties> {
+
+    @NotNull P @NotNull [] getValues();
+
+    int getIndex(@NotNull P properties);
+
+    boolean caresAboutPosition();
+
+    boolean caresAboutProximity();
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/Model.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/Model.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc1e0a78a7c914a60e5f3f3dc8d0bebff945db7a
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/Model.java
@@ -0,0 +1,278 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Direction;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.block.state.properties.Half;
+import org.sucraft.suki.blockanditemdata.texture.Texture;
+import org.sucraft.suki.blockanditemdata.texture.TextureContent;
+import org.sucraft.suki.blockanditemdata.texture.TextureContentCreation;
+import org.sucraft.suki.blockanditemdata.texture.TextureCreation;
+import org.sucraft.suki.resourcepack.MutableResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.model.MutableResourcePackModel;
+import org.sucraft.suki.resourcepack.asset.ResourcePackIntentionedAssetDataByContent;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.function.Function;
+
+/**
+ * An immutable item or block model
+ */
+public class Model extends ResourcePackIntentionedAssetDataByContent<ModelContent> {
+
+    public Model(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key, @NotNull ModelContent content) {
+       super(intention, key, content);
+    }
+
+    public @NotNull ModelWithParameters withParameters(@NotNull ModelParameters parameters) {
+        return new ModelWithParameters(this, parameters);
+    }
+
+    public @NotNull ModelWithParameters withNoParameters() {
+        return new ModelWithParameters(this, null);
+    }
+
+    public @NotNull Model getReference(@NotNull ResourcePackAssetIntention newIntention) {
+        return new Model(newIntention, this.key, new ModelContent.Reference(this));
+    }
+
+    public @NotNull Model getBlockEntityVersion(@NotNull BlockEntityModelVisualProperties properties) {
+        return new Model(ResourcePackAssetIntention.ITEM, new NamespacedKeyWithoutIntention(this.key.namespace(), this.key.keyWithoutIntention() + "_e" + properties.getBlockEntityModelFileSuffix()), this.content.getBlockEntityVersion(this, properties));
+    }
+
+    public @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> addToResourcePack(@NotNull MutableResourcePack resourcePack, boolean overwriteExisting, boolean actuallyAdd) {
+        @NotNull MutableResourcePackModel resourcePackModel = resourcePack.getOrCreateModel(this.intention, this.key);
+        if (!resourcePackModel.isJsonEmpty() && !overwriteExisting) {
+            return Collections.emptyList();
+        }
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> assetLocations = new ArrayList<>(1);
+        assetLocations.add(Pair.of(ResourcePackAssetType.MODEL, this.getKeyWithIntention()));
+        if (!resourcePackModel.isJsonEmpty()) {
+            resourcePackModel.clearJson();
+        }
+        assetLocations.addAll(this.content.writeToClearResourcePackModel(resourcePackModel, resourcePack, actuallyAdd));
+        return assetLocations;
+    }
+
+    // Convenience methods for replacement rule builders
+
+    public static @NotNull Model create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull ModelContent content) {
+        return new Model(intention, NamespacedKeyWithoutIntention.forMinecraft(key), content);
+    }
+
+    public static @NotNull Model create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull ModelContentCreation content) {
+        return create(intention, key, content.create(intention, key));
+    }
+
+    public static @NotNull ModelCreation creation(@NotNull ModelContent content) {
+        return (intention, key) -> create(intention, key, content);
+    }
+
+    public static @NotNull ModelCreation creation(@NotNull ModelContentCreation content) {
+        return (intention, key) -> create(intention, key, content);
+    }
+
+    /**
+     * @see ModelContent.OneTextureCube
+     */
+    public static final class OneTextureCube {
+
+        private OneTextureCube() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.OneTextureCube.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+    }
+
+    /**
+     * @see ModelContent.YPillarCube
+     */
+    public static final class YPillarCube {
+
+        private YPillarCube() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.YPillarCube.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeEnd(@NotNull Texture endTexture) {
+            return creation(ModelContent.YPillarCube.defaultCreationWithAlternativeEnd(endTexture));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeEnd(@NotNull TextureCreation endTexture) {
+            return creation(ModelContent.YPillarCube.defaultCreationWithAlternativeEnd(endTexture));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.HorizontalYPillarCube
+     */
+    public static final class HorizontalYPillarCube {
+
+        private HorizontalYPillarCube() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.HorizontalYPillarCube.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeEnd(@NotNull Texture endTexture) {
+            return creation(ModelContent.HorizontalYPillarCube.defaultCreationWithAlternativeEnd(endTexture));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeEnd(@NotNull TextureCreation endTexture) {
+            return creation(ModelContent.HorizontalYPillarCube.defaultCreationWithAlternativeEnd(endTexture));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.BottomTopPillarCube
+     */
+    public static final class BottomTopPillarCube {
+
+        private BottomTopPillarCube() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.BottomTopPillarCube.creationCompanion.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture) {
+            return creation(ModelContent.BottomTopPillarCube.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture) {
+            return creation(ModelContent.BottomTopPillarCube.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.BottomSlab
+     */
+    public static final class BottomSlab {
+
+        private BottomSlab() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.BottomSlab.creationCompanion.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture) {
+            return creation(ModelContent.BottomSlab.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture) {
+            return creation(ModelContent.BottomSlab.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.TopSlab
+     */
+    public static final class TopSlab {
+
+        private TopSlab() {}
+
+        private static final @NotNull ModelCreation DEFAULT_CREATION = creation(ModelContent.TopSlab.creationCompanion.defaultCreation());
+
+        public static @NotNull ModelCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture) {
+            return creation(ModelContent.TopSlab.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture) {
+            return creation(ModelContent.TopSlab.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.StraightStairs
+     */
+    public static final class StraightStairs {
+
+        private StraightStairs() {}
+
+        public static @NotNull ModelCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.StraightStairs.creationCompanion.defaultCreation(half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.StraightStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.StraightStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.InnerLeftStairs
+     */
+    public static final class InnerLeftStairs {
+
+        private InnerLeftStairs() {}
+
+        public static @NotNull ModelCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.InnerLeftStairs.creationCompanion.defaultCreation(half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.InnerLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.InnerLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+    }
+
+    /**
+     * @see ModelContent.OuterLeftStairs
+     */
+    public static final class OuterLeftStairs {
+
+        private OuterLeftStairs() {}
+
+        public static @NotNull ModelCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.OuterLeftStairs.creationCompanion.defaultCreation(half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.OuterLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+        public static @NotNull ModelCreation defaultCreationWithAlternativeTopBottom(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+            return creation(ModelContent.OuterLeftStairs.creationCompanion.defaultCreationWithAlternativeBottomTop(bottomTexture, topTexture, half, facing));
+        }
+
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelContent.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..0413d8e9c72192817d1fe1b7b305449325ce1265
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelContent.java
@@ -0,0 +1,1371 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import it.unimi.dsi.fastutil.Pair;
+import it.unimi.dsi.fastutil.floats.Float2ObjectMap;
+import it.unimi.dsi.fastutil.floats.Float2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import net.minecraft.core.Direction;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.block.state.properties.Half;
+import org.sucraft.suki.blockanditemdata.texture.Texture;
+import org.sucraft.suki.blockanditemdata.texture.TextureContent;
+import org.sucraft.suki.blockanditemdata.texture.TextureContentCreation;
+import org.sucraft.suki.blockanditemdata.texture.TextureCreation;
+import org.sucraft.suki.resourcepack.MutableResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.model.MutableResourcePackModel;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetDataContent;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.sucraft.suki.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.sucraft.suki.resourcepack.sucraft.CreateSuCraftResourcePack;
+import org.apache.commons.lang3.tuple.Triple;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.json.simple.JSONObject;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+/**
+ * The immutable content of a model: a {@link Model} without any information about its appropriate location in a resource pack
+ */
+public abstract class ModelContent implements ResourcePackAssetDataContent {
+
+    protected ModelContent() {}
+
+    public @NotNull Model asModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return new Model(intention, key, this);
+    }
+
+    /**
+     * Note that this method will attempt to add any used textures to the resource pack, but will not overwrite any existing ones
+     */
+    abstract @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack, boolean actuallyAdd);
+
+    public @NotNull ModelContent getBlockEntityVersion(@NotNull Model myOwningModel, @NotNull BlockEntityModelVisualProperties properties) throws UnsupportedOperationException {
+        return new ModelContent.AsBlockEntityReference(myOwningModel, properties instanceof TypicalBlockEntityModelVisualProperties typicalProperties ? typicalProperties.getPosition() : BlockEntityModelPosition.CENTER, () -> this.getOutwardExpandedElements(properties));
+    }
+
+    abstract @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelVisualProperties properties) throws UnsupportedOperationException;
+
+    // Interfaces and classes that help with caching the JSON array containing the outward expanded elements for reference model content for block entities
+
+    static abstract class ModelContentWithCachedOutwardExpandedElementsForProximity extends ModelContent {
+
+        abstract @NotNull OutwardExpandedElementsForProximityCache getCache();
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelVisualProperties properties) {
+            return this.getCache().getOutwardExpandedElements(properties instanceof TypicalBlockEntityModelVisualProperties typicalProperties ? typicalProperties.getProximity() : BlockEntityModelProximity.NOT_EXPANDED);
+        }
+
+    }
+
+    interface OutwardExpandedElementsForPropertiesCache {
+
+        @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelVisualProperties properties);
+
+    }
+
+    interface OutwardExpandedElementsForProximityCache extends OutwardExpandedElementsForPropertiesCache {
+
+        @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelProximity proximity);
+
+        @Override
+        default @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelVisualProperties properties) {
+            return this.getOutwardExpandedElements(properties instanceof TypicalBlockEntityModelVisualProperties typicalProperties ? typicalProperties.getProximity() : BlockEntityModelProximity.NOT_EXPANDED);
+        }
+
+    }
+
+    static class SimpleOutwardExpandedElementsForProximityCache implements OutwardExpandedElementsForProximityCache {
+
+        private final @NotNull OutwardExpandedElementsForProximityCache computeFunction;
+        private final @Nullable JsonArray @NotNull [] cache = new JsonArray[BlockEntityModelProximity.values().length];
+
+        public SimpleOutwardExpandedElementsForProximityCache(@NotNull OutwardExpandedElementsForProximityCache computeFunction) {
+            this.computeFunction = computeFunction;
+        }
+
+        @Override
+        public @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelProximity proximity) {
+            int cacheKey = proximity.ordinal();
+            if (this.cache[cacheKey] == null) {
+                this.cache[cacheKey] = this.computeFunction.getOutwardExpandedElements(proximity);
+            }
+            return this.cache[cacheKey];
+        }
+
+        public static @NotNull SimpleOutwardExpandedElementsForProximityCache forFloat(@NotNull Function<@NotNull Float, @NotNull JsonArray> computeFunction) {
+            return new SimpleOutwardExpandedElementsForProximityCache(proximity -> computeFunction.apply(proximity.outwardExpandedElementDistance));
+        }
+
+    }
+
+    interface OutwardExpandedElementsForDistanceAndStairsStateCache {
+
+        @NotNull JsonArray getOutwardExpandedElements(float outwardDistance, @NotNull Half half, @NotNull Direction facing);
+
+    }
+
+    interface OutwardExpandedElementsForProximityAndStairsStateCache {
+
+        @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelProximity proximity, @NotNull Half half, @NotNull Direction facing);
+
+    }
+
+    static class SimpleOutwardExpandedElementsForProximityAndStairsStateCache implements OutwardExpandedElementsForProximityAndStairsStateCache {
+
+        private final @NotNull OutwardExpandedElementsForProximityAndStairsStateCache computeFunction;
+        private final @Nullable JsonArray @NotNull [] cache = new JsonArray[BlockEntityModelProximity.values().length * Half.values().length * Direction.values().length];
+
+        public SimpleOutwardExpandedElementsForProximityAndStairsStateCache(@NotNull OutwardExpandedElementsForProximityAndStairsStateCache computeFunction) {
+            this.computeFunction = computeFunction;
+        }
+
+        @Override
+        public @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelProximity proximity, @NotNull Half half, @NotNull Direction facing) {
+            int cacheKey = proximity.ordinal() + half.ordinal() * BlockEntityModelProximity.values().length + facing.ordinal() * BlockEntityModelProximity.values().length * Half.values().length;
+            if (this.cache[cacheKey] == null) {
+                this.cache[cacheKey] = this.computeFunction.getOutwardExpandedElements(proximity, half, facing);
+            }
+            return this.cache[cacheKey];
+        }
+
+        public static @NotNull SimpleOutwardExpandedElementsForProximityAndStairsStateCache forFloat(@NotNull OutwardExpandedElementsForDistanceAndStairsStateCache computeFunction) {
+            return new SimpleOutwardExpandedElementsForProximityAndStairsStateCache((proximity, half, facing) -> computeFunction.getOutwardExpandedElements(proximity.outwardExpandedElementDistance, half, facing));
+        }
+
+    }
+
+    // Convenience methods for replacement rule builders
+
+    /**
+     * A basic form of {@link ModelContent}: a full cube with the same texture on all 6 sides
+     */
+    public static final class OneTextureCube extends ModelContentWithCachedOutwardExpandedElementsForProximity {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("cube_all"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/cube.json
+        public static @NotNull SimpleOutwardExpandedElementsForProximityCache cubeOutwardExpandedElements = SimpleOutwardExpandedElementsForProximityCache.forFloat(outwardDistance -> {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            return JsonParser.parseString("""
+                [
+                    {   "from": [ %1$f, %1$f, %1$f ],
+                        "to": [ %2$f, %2$f, %2$f ],
+                        "faces": {
+                            "down":  { "texture": "#down", "cullface": "down" },
+                            "up":    { "texture": "#up", "cullface": "up" },
+                            "north": { "texture": "#north", "cullface": "north" },
+                            "south": { "texture": "#south", "cullface": "south" },
+                            "west":  { "texture": "#west", "cullface": "west" },
+                            "east":  { "texture": "#east", "cullface": "east" }
+                        }
+                    }
+                ]""".formatted(from, to)
+            ).getAsJsonArray();
+        });
+
+        private final @NotNull Texture texture;
+
+        public OneTextureCube(@NotNull Texture texture) {
+            super();
+            this.texture = texture;
+        }
+
+        @Override
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+            if (actuallyAdd) {
+                resourcePackModel.setParent(parent);
+                resourcePackModel.setAllTextures(this.texture);
+            }
+            return this.texture.addToResourcePack(resourcePack, false, actuallyAdd);
+        }
+
+        @Override
+        @NotNull OutwardExpandedElementsForProximityCache getCache() {
+            return cubeOutwardExpandedElements;
+        }
+
+        public static @NotNull OneTextureCube create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureCreation texture) {
+            return new OneTextureCube(texture.create(intention, key));
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull Texture texture) {
+            return (intention, key) -> new OneTextureCube(texture);
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull TextureCreation texture) {
+            return (intention, key) -> create(intention, key, texture);
+        }
+
+        private static final @NotNull ModelContentCreation DEFAULT_CREATION = creation(Texture.defaultCreation());
+
+        public static @NotNull ModelContentCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: a full cube with one texture for the y-oriented sides, and one texture for the x- and z-oriented sides
+     */
+    public static final class YPillarCube extends ModelContentWithCachedOutwardExpandedElementsForProximity {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("cube_column"), Existing.getInstance());
+
+        private final @NotNull Texture endTexture;
+        private final @NotNull Texture sideTexture;
+
+        public YPillarCube(@NotNull Texture endTexture, @NotNull Texture sideTexture) {
+            super();
+            this.endTexture = endTexture;
+            this.sideTexture = sideTexture;
+        }
+
+        @Override
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+            if (actuallyAdd) {
+                resourcePackModel.setParent(parent);
+                resourcePackModel.setColumnTextures(this.endTexture, this.sideTexture);
+            }
+            @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> assetLocations = new ArrayList<>(0);
+            assetLocations.addAll(this.endTexture.addToResourcePack(resourcePack, false, actuallyAdd));
+            assetLocations.addAll(this.sideTexture.addToResourcePack(resourcePack, false, actuallyAdd));
+            return assetLocations;
+        }
+
+        @Override
+        @NotNull OutwardExpandedElementsForProximityCache getCache() {
+            return OneTextureCube.cubeOutwardExpandedElements;
+        }
+
+        public static @NotNull YPillarCube create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureCreation endTexture, @NotNull TextureCreation sideTexture) {
+            return new YPillarCube(endTexture.create(intention, key), sideTexture.create(intention, key));
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull Texture endTexture, @NotNull Texture sideTexture) {
+            return (intention, key) -> new YPillarCube(endTexture, sideTexture);
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull TextureCreation endTexture, @NotNull TextureCreation sideTexture) {
+            return (intention, key) -> create(intention, key, endTexture, sideTexture);
+        }
+
+        private static final @NotNull ModelContentCreation DEFAULT_CREATION = creation(Texture.defaultEndCreation(), Texture.defaultCreation());
+
+        public static @NotNull ModelContentCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelContentCreation defaultCreationWithAlternativeEnd(@NotNull Texture endTexture) {
+            return defaultCreationWithAlternativeEnd((intention, key) -> endTexture);
+        }
+
+        public static @NotNull ModelContentCreation defaultCreationWithAlternativeEnd(@NotNull TextureCreation endTexture) {
+            return (intention, key) -> create(intention, key, endTexture, Texture.defaultCreation());
+        }
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: similar tp {@link YPillarCube}, but oriented horizontally
+     */
+    public static final class HorizontalYPillarCube extends ModelContentWithCachedOutwardExpandedElementsForProximity {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("cube_column_horizontal"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/cube_column_horizontal.json
+        public static @NotNull SimpleOutwardExpandedElementsForProximityCache horizontalColumnCubeOutwardExpandedElements = SimpleOutwardExpandedElementsForProximityCache.forFloat(outwardDistance -> {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            return JsonParser.parseString("""
+                [
+                    {   "from": [ %1$f, %1$f, %1$f ],
+                        "to": [ %2$f, %2$f, %2$f ],
+                        "faces": {
+                            "down":  { "texture": "#down", "cullface": "down" },
+                            "up":    { "texture": "#up", "rotation": 180, "cullface": "up" },
+                            "north": { "texture": "#north", "cullface": "north" },
+                            "south": { "texture": "#south", "cullface": "south" },
+                            "west":  { "texture": "#west", "cullface": "west" },
+                            "east":  { "texture": "#east", "cullface": "east" }
+                        }
+                    }
+                ]""".formatted(from, to)
+            ).getAsJsonArray();
+        });
+
+        private final @NotNull Texture endTexture;
+        private final @NotNull Texture sideTexture;
+
+        public HorizontalYPillarCube(@NotNull Texture endTexture, @NotNull Texture sideTexture) {
+            super();
+            this.endTexture = endTexture;
+            this.sideTexture = sideTexture;
+        }
+
+        @Override
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+            if (actuallyAdd) {
+                resourcePackModel.setParent(parent);
+                resourcePackModel.setColumnTextures(this.endTexture, this.sideTexture);
+            }
+            @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> assetLocations = new ArrayList<>(0);
+            assetLocations.addAll(this.endTexture.addToResourcePack(resourcePack, false, actuallyAdd));
+            assetLocations.addAll(this.sideTexture.addToResourcePack(resourcePack, false, actuallyAdd));
+            return assetLocations;
+        }
+
+        @Override
+        @NotNull OutwardExpandedElementsForProximityCache getCache() {
+            return horizontalColumnCubeOutwardExpandedElements;
+        }
+
+        public static @NotNull HorizontalYPillarCube create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureCreation endTexture, @NotNull TextureCreation sideTexture) {
+            return new HorizontalYPillarCube(endTexture.create(intention, key), sideTexture.create(intention, key));
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull Texture endTexture, @NotNull Texture sideTexture) {
+            return (intention, key) -> new YPillarCube(endTexture, sideTexture);
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull TextureCreation endTexture, @NotNull TextureCreation sideTexture) {
+            return (intention, key) -> create(intention, key, endTexture, sideTexture);
+        }
+
+        private static final @NotNull ModelContentCreation DEFAULT_CREATION = creation(Texture.defaultEndCreation(), Texture.defaultCreation());
+
+        public static @NotNull ModelContentCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+        public static @NotNull ModelContentCreation defaultCreationWithAlternativeEnd(@NotNull Texture endTexture) {
+            return defaultCreationWithAlternativeEnd((intention, key) -> endTexture);
+        }
+
+        public static @NotNull ModelContentCreation defaultCreationWithAlternativeEnd(@NotNull TextureCreation endTexture) {
+            return (intention, key) -> create(intention, key, endTexture, Texture.defaultCreation());
+        }
+
+    }
+
+    /**
+     * An abstract form of {@link ModelContent}: with one texture for the bottom, one textures for the x- and z-oriented sides, and one texture for the top
+     */
+    public static abstract class AbstractBottomTopPillarCube extends ModelContentWithCachedOutwardExpandedElementsForProximity {
+
+        public final @NotNull Texture bottomTexture;
+        public final @NotNull Texture sideTexture;
+        public final @NotNull Texture topTexture;
+
+        public AbstractBottomTopPillarCube(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+            super();
+            this.bottomTexture = bottomTexture;
+            this.sideTexture = sideTexture;
+            this.topTexture = topTexture;
+        }
+
+        protected abstract @NotNull Model getParent();
+
+        @Override
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+            if (actuallyAdd) {
+                resourcePackModel.setParent(getParent());
+                resourcePackModel.setBottomTopTextures(this.bottomTexture, this.sideTexture, this.topTexture);
+            }
+            @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> assetLocations = new ArrayList<>(0);
+            assetLocations.addAll(this.bottomTexture.addToResourcePack(resourcePack, false, actuallyAdd));
+            assetLocations.addAll(this.sideTexture.addToResourcePack(resourcePack, false, actuallyAdd));
+            assetLocations.addAll(this.topTexture.addToResourcePack(resourcePack, false, actuallyAdd));
+            return assetLocations;
+        }
+
+        public static abstract class CreationCompanion<M extends AbstractBottomTopPillarCube> {
+
+            protected abstract @NotNull M construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture);
+
+            public @NotNull M create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureCreation bottomTexture, @NotNull TextureCreation sideTexture, @NotNull TextureCreation topTexture) {
+                return this.construct(bottomTexture.create(intention, key), sideTexture.create(intention, key), topTexture.create(intention, key));
+            }
+
+            public @NotNull ModelContentCreation creation(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+                return (intention, key) -> this.construct(bottomTexture, sideTexture, topTexture);
+            }
+
+            public @NotNull ModelContentCreation creation(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation sideTexture, @NotNull TextureCreation topTexture) {
+                return (intention, key) -> this.create(intention, key, bottomTexture, sideTexture, topTexture);
+            }
+
+            private final @NotNull ModelContentCreation DEFAULT_CREATION = creation(Texture.defaultBottomCreation(), Texture.defaultCreation(), Texture.defaultTopCreation());
+
+            public @NotNull ModelContentCreation defaultCreation() {
+                return this.DEFAULT_CREATION;
+            }
+
+            public @NotNull ModelContentCreation defaultCreationWithAlternativeBottomTop(@NotNull Texture bottomTexture, @NotNull Texture topTexture) {
+                return this.defaultCreationWithAlternativeBottomTop((intention, key) -> bottomTexture, (intention, key) -> topTexture);
+            }
+
+            public @NotNull ModelContentCreation defaultCreationWithAlternativeBottomTop(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture) {
+                return (intention, key) -> this.create(intention, key, bottomTexture, Texture.defaultCreation(), topTexture);
+            }
+
+        }
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: a full cube with one texture for the bottom, one textures for the x- and z-oriented sides, and one texture for the top
+     */
+    public static final class BottomTopPillarCube extends AbstractBottomTopPillarCube {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("cube_bottom_top"), Existing.getInstance());
+
+        public BottomTopPillarCube(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+            super(bottomTexture, sideTexture, topTexture);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull OutwardExpandedElementsForProximityCache getCache() {
+            return OneTextureCube.cubeOutwardExpandedElements;
+        }
+
+        public static final @NotNull CreationCompanion<BottomTopPillarCube> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull BottomTopPillarCube construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+                return new BottomTopPillarCube(bottomTexture, sideTexture, topTexture);
+            }
+
+        };
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: a bottom half slab with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which the bottom half will be used), and one texture for the top
+     */
+    public static final class BottomSlab extends AbstractBottomTopPillarCube {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("slab"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/slab.json
+        public static @NotNull SimpleOutwardExpandedElementsForProximityCache bottomSlabOutwardExpandedElements = SimpleOutwardExpandedElementsForProximityCache.forFloat(outwardDistance -> {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            float toMiddleY = 8 + outwardDistance;
+            return JsonParser.parseString("""
+                [
+                    {   "from": [ %1$f, %1$f, %1$f ],
+                        "to": [ %2$f, %3$f, %2$f ],
+                        "faces": {
+                            "down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom", "cullface": "down" },
+                            "up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top" },
+                            "north": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "north" },
+                            "south": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "south" },
+                            "west":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "west" },
+                            "east":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "east" }
+                        }
+                    }
+                ]""".formatted(from, to, toMiddleY)
+            ).getAsJsonArray();
+        });
+
+        public BottomSlab(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+            super(bottomTexture, sideTexture, topTexture);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull OutwardExpandedElementsForProximityCache getCache() {
+            return bottomSlabOutwardExpandedElements;
+        }
+
+        public static final @NotNull CreationCompanion<BottomSlab> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull BottomSlab construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+                return new BottomSlab(bottomTexture, sideTexture, topTexture);
+            }
+
+        };
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: a top half slab with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which the top half will be used), and one texture for the top
+     */
+    public static final class TopSlab extends AbstractBottomTopPillarCube {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("slab_top"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/slab_top.json
+        public static @NotNull SimpleOutwardExpandedElementsForProximityCache topSlabOutwardExpandedElements = SimpleOutwardExpandedElementsForProximityCache.forFloat(outwardDistance -> {
+            float from = -outwardDistance;
+            float fromMiddleY = 8 - outwardDistance;
+            float to = 16 + outwardDistance;
+            return JsonParser.parseString("""
+                [
+                    {   "from": [ %1$f, %2$f, %1$f ],
+                        "to": [ %3$f, %3$f, %3$f ],
+                        "faces": {
+                            "down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom" },
+                            "up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top", "cullface": "up" },
+                            "north": { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "north" },
+                            "south": { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "south" },
+                            "west":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "west" },
+                            "east":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "east" }
+                        }
+                    }
+                ]""".formatted(from, fromMiddleY, to)
+            ).getAsJsonArray();
+        });
+
+        public TopSlab(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+            super(bottomTexture, sideTexture, topTexture);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull OutwardExpandedElementsForProximityCache getCache() {
+            return topSlabOutwardExpandedElements;
+        }
+
+        public static final @NotNull CreationCompanion<TopSlab> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull TopSlab construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+                return new TopSlab(bottomTexture, sideTexture, topTexture);
+            }
+
+        };
+
+    }
+
+    /**
+     * Utility class to help with models that have elements that may need to be transformed within the model (rotated or flipped)
+     */
+    public static class TransformableElement {
+
+        public static class TransformableEndpoint {
+
+            private float x, y, z;
+
+            public TransformableEndpoint(float x, float y, float z) {
+                this.x = x;
+                this.y = y;
+                this.z = z;
+            }
+
+            public @NotNull JsonArray toJson() {
+                @NotNull JsonArray json = new JsonArray(3);
+                json.add(this.x);
+                json.add(this.y);
+                json.add(this.z);
+                return json;
+            }
+
+            public void transformAccordingToState(@NotNull Half half, @NotNull Direction facing) {
+                float newX = switch (facing) {
+                    case EAST -> x;
+                    case NORTH -> z;
+                    case WEST -> 16 - x;
+                    case SOUTH -> 16 - z;
+                    default -> throw new IllegalArgumentException("Illegal stairs direction: " + facing);
+                };
+                float newY = switch (half) {
+                    case TOP -> 16 - y;
+                    case BOTTOM -> y;
+                };
+                float newZ = switch (facing) {
+                    case EAST -> z;
+                    case NORTH -> 16 - x;
+                    case WEST -> 16 - z;
+                    case SOUTH -> x;
+                    default -> throw new IllegalArgumentException("Illegal stairs direction: " + facing);
+                };
+                this.x = newX;
+                this.y = newY;
+                this.z = newZ;
+            }
+
+            private float getCoordinate(int axis) {
+                return switch (axis) {
+                    case 0 -> this.x;
+                    case 1 -> this.y;
+                    case 2 -> this.z;
+                    default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                };
+            }
+
+            private void setCoordinate(int axis, float coordinate) {
+                switch (axis) {
+                    case 0 -> this.x = coordinate;
+                    case 1 -> this.y = coordinate;
+                    case 2 -> this.z = coordinate;
+                    default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                };
+            }
+
+            public void swapCoordinatesAsFirstEndpoint(@NotNull TransformableEndpoint secondEndpoint) {
+                for (int axis = 0; axis < 3; axis++) {
+                    if (this.getCoordinate(axis) > secondEndpoint.getCoordinate(axis)) {
+                        float temp = this.getCoordinate(axis);
+                        this.setCoordinate(axis, secondEndpoint.getCoordinate(axis));
+                        secondEndpoint.setCoordinate(axis, temp);
+                    }
+                }
+            }
+
+        }
+
+        public static class TransformableFace {
+
+            public static class TransformableUV {
+
+                public static class TransformableUVEndpoint {
+
+                    private int x, y;
+
+                    public TransformableUVEndpoint(int x, int y) {
+                        this.x = x;
+                        this.y = y;
+                    }
+
+                    public @NotNull JsonArray toJson() {
+                        @NotNull JsonArray json = new JsonArray();
+                        json.add(this.x);
+                        json.add(this.y);
+                        return json;
+                    }
+
+                    public void rotate90DegreesAroundTangentAxis() {
+                        int newX = y;
+                        int newY = 16 - x;
+                        this.x = newX;
+                        this.y = newY;
+                    }
+
+                    public void flipInY() {
+                        this.y = 16 - y;
+                    }
+
+                    private int getCoordinate(int axis) {
+                        return switch (axis) {
+                            case 0 -> this.x;
+                            case 1 -> this.y;
+                            default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                        };
+                    }
+
+                    private void setCoordinate(int axis, int coordinate) {
+                        switch (axis) {
+                            case 0 -> this.x = coordinate;
+                            case 1 -> this.y = coordinate;
+                            default -> throw new IllegalArgumentException(("Invalid axis index: " + axis));
+                        };
+                    }
+
+                    public void swapCoordinatesAsFirstEndpoint(@NotNull TransformableUVEndpoint secondEndpoint) {
+                        for (int axis = 0; axis < 2; axis++) {
+                            if (this.getCoordinate(axis) > secondEndpoint.getCoordinate(axis)) {
+                                int temp = this.getCoordinate(axis);
+                                this.setCoordinate(axis, secondEndpoint.getCoordinate(axis));
+                                secondEndpoint.setCoordinate(axis, temp);
+                            }
+                        }
+                    }
+
+                }
+
+                private final @NotNull TransformableUVEndpoint from, to;
+
+                public TransformableUV(@NotNull TransformableUVEndpoint from, @NotNull TransformableUVEndpoint to) {
+                    this.from = from;
+                    this.to = to;
+                }
+
+                public TransformableUV(@NotNull JsonArray json) {
+                    this(new TransformableUVEndpoint(json.get(0).getAsInt(), json.get(1).getAsInt()), new TransformableUVEndpoint(json.get(2).getAsInt(), json.get(3).getAsInt()));
+                }
+
+                public @NotNull JsonArray toJson() {
+                    @NotNull JsonArray json = new JsonArray();
+                    json.addAll(this.from.toJson());
+                    json.addAll(this.to.toJson());
+                    return json;
+                }
+
+                public void rotate90DegreesAroundTangentAxis() {
+                    this.from.rotate90DegreesAroundTangentAxis();
+                    this.to.rotate90DegreesAroundTangentAxis();
+                    this.from.swapCoordinatesAsFirstEndpoint(this.to);
+                }
+
+                public void flipInY() {
+                    this.from.flipInY();
+                    this.to.flipInY();
+                    this.from.swapCoordinatesAsFirstEndpoint(this.to);
+                }
+
+            }
+
+            private @NotNull Direction facing;
+            private final @NotNull TransformableUV uv;
+            private final @NotNull String texture;
+            private final boolean cullable;
+
+            public TransformableFace(@NotNull Direction facing, @NotNull TransformableUV uv, @NotNull String texture, boolean cullable) {
+                this.facing = facing;
+                this.uv = uv;
+                this.texture = texture;
+                this.cullable = cullable;
+            }
+
+            public TransformableFace(@NotNull Direction facing, @NotNull JsonObject json) {
+                this(facing, new TransformableUV(json.getAsJsonArray("uv")), json.get("texture").getAsString(), json.has("cullface"));
+            }
+
+            public TransformableFace(@NotNull Map.Entry<@NotNull String, @NotNull JsonElement> jsonEntry) {
+                this(Direction.valueOf(jsonEntry.getKey().toUpperCase(Locale.ROOT)), jsonEntry.getValue().getAsJsonObject());
+            }
+
+            public @NotNull Direction getFacing() {
+                return this.facing;
+            }
+
+            public @NotNull JsonObject toJson() {
+                @NotNull JsonObject json = new JsonObject();
+                json.add("uv", uv.toJson());
+                json.addProperty("texture", this.texture);
+                if (this.cullable) {
+                    json.addProperty("cullface", this.facing.name().toLowerCase(Locale.ROOT));
+                }
+                return json;
+            }
+
+            public void transformAccordingToState(@NotNull Half half, @NotNull Direction facing) {
+//                if (half == Half.TOP && this.facing == Direction.UP) {
+//                    System.out.println("TEMP DEBUG - " + System.identityHashCode(this) + " - I'm originally upwards in top, and my uv is " + this.uv.toJson().toString());
+//                }
+                // For sides, we can just switch which face represents which direction based on facing, and keep the uv coordinates the same
+                int rotations = switch (facing) {
+                    case EAST -> 0;
+                    case SOUTH -> 3;
+                    case WEST -> 2;
+                    case NORTH -> 1;
+                    default -> throw new IllegalArgumentException("Illegal stairs direction: " + facing);
+                };
+                for (int rotation = 0; rotation < rotations; rotation++) {
+                    if (this.facing.getAxis().isHorizontal()) {
+                        this.facing = switch (this.facing) {
+                            case EAST -> Direction.NORTH;
+                            case SOUTH -> Direction.EAST;
+                            case WEST -> Direction.SOUTH;
+                            case NORTH -> Direction.WEST;
+                            default -> throw new IllegalStateException("Illegal stairs direction: " + this.facing);
+                        };
+                    } else {
+                        // Rotate the vertical faces simply by transforming the uv coordinates according to the rotation around the y axis, and then fix the coordinates to make the first endpoint coordinate in each axis smaller than the corresponding second endpoint coordinate
+                        uv.rotate90DegreesAroundTangentAxis();
+                    }
+                }
+//                if (half == Half.TOP && this.facing == Direction.UP) {
+//                    System.out.println("TEMP DEBUG - " + System.identityHashCode(this) + " - After " + rotations + " face rotations my uv is " + this.uv.toJson().toString());
+//                }
+                // Half-based changes are only needed for the top
+                if (half == Half.TOP) {
+                    // For the top and bottom, we switch which face represents which direction based on half
+                    if (this.facing.getAxis().isVertical()) {
+                        this.facing = this.facing == Direction.UP ? Direction.DOWN : Direction.UP;
+                        // Fix the uv for faces that now face downwards
+                        if (this.facing == Direction.DOWN) {
+                            if (facing == Direction.NORTH || facing == Direction.SOUTH) {
+                                this.uv.flipInY();
+                            }
+                        }
+                    } else {
+                        // Flip the horizontal faces simply by flipping the uv y coordinates , and then fix the coordinates to make the first endpoint coordinate in each axis smaller than the corresponding second endpoint coordinate
+                        this.uv.flipInY();
+                    }
+                }
+//                if (half == Half.TOP && this.facing == Direction.DOWN) {
+//                    System.out.println("TEMP DEBUG - " + System.identityHashCode(this) + " - Afterwards I'm downwards and my uv is " + this.uv.toJson().toString());
+//                }
+            }
+
+        }
+
+        private final @NotNull TransformableEndpoint from;
+        private final @NotNull TransformableEndpoint to;
+        private @NotNull TransformableFace @NotNull [] faces;
+
+        public TransformableElement(@NotNull TransformableEndpoint from, @NotNull TransformableEndpoint to, @NotNull TransformableFace @NotNull [] faces) {
+            this.from = from;
+            this.to = to;
+            this.faces = faces;
+        }
+
+        public TransformableElement(@NotNull TransformableEndpoint from, @NotNull TransformableEndpoint to, @NotNull String facesJsonString) {
+            this(from, to, JsonParser.parseString(facesJsonString).getAsJsonObject().entrySet().stream().map(TransformableFace::new).toArray(TransformableFace[]::new));
+        }
+
+        public @NotNull JsonObject toJson() {
+            @NotNull JsonObject json = new JsonObject();
+            json.add("from", this.from.toJson());
+            json.add("to", this.to.toJson());
+            @NotNull JsonObject facesJson = new JsonObject();
+            for (@NotNull TransformableFace face : this.faces) {
+                facesJson.add(face.getFacing().name().toLowerCase(Locale.ROOT), face.toJson());
+            }
+            json.add("faces", facesJson);
+            return json;
+        }
+
+        public void transformAccordingToState(@NotNull Half half, @NotNull Direction facing) {
+            // Transform the endpoints individually
+            this.from.transformAccordingToState(half, facing);
+            this.to.transformAccordingToState(half, facing);
+            // Flip coordinates where the from endpoint coordinate is greater than the to endpoint coordinate (which causes the texture to be rendered on the wrong side of the surface)
+            this.from.swapCoordinatesAsFirstEndpoint(this.to);
+            // Transform the faces
+            for (@NotNull TransformableFace face : this.faces) {
+                face.transformAccordingToState(half, facing);
+            }
+        }
+
+    }
+
+    public static abstract class AbstractStairs extends AbstractBottomTopPillarCube {
+
+        public final @NotNull Half half;
+        public final @NotNull Direction facing;
+
+        public AbstractStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture);
+            this.half = half;
+            this.facing = facing;
+        }
+
+        abstract @NotNull OutwardExpandedElementsForProximityAndStairsStateCache getStairsStateCache();
+
+        @Override
+        @NotNull OutwardExpandedElementsForProximityCache getCache() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelVisualProperties properties) {
+            return this.getStairsStateCache().getOutwardExpandedElements(properties instanceof TypicalBlockEntityModelVisualProperties typicalProperties ? typicalProperties.getProximity() : BlockEntityModelProximity.NOT_EXPANDED, this.half, this.facing);
+        }
+
+        public static abstract class CreationCompanion<M extends AbstractStairs> {
+
+            protected abstract @NotNull M construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing);
+
+            public @NotNull M create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureCreation bottomTexture, @NotNull TextureCreation sideTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return this.construct(bottomTexture.create(intention, key), sideTexture.create(intention, key), topTexture.create(intention, key), half, facing);
+            }
+
+            public @NotNull ModelContentCreation creation(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return (intention, key) -> this.construct(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+            public @NotNull ModelContentCreation creation(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation sideTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return (intention, key) -> this.create(intention, key, bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+            public @NotNull ModelContentCreation defaultCreation(@NotNull Half half, @NotNull Direction facing) {
+                return creation(Texture.defaultBottomCreation(), Texture.defaultCreation(), Texture.defaultTopCreation(), half, facing);
+            }
+
+            public @NotNull ModelContentCreation defaultCreationWithAlternativeBottomTop(@NotNull Texture bottomTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return this.defaultCreationWithAlternativeBottomTop((intention, key) -> bottomTexture, (intention, key) -> topTexture, half, facing);
+            }
+
+            public @NotNull ModelContentCreation defaultCreationWithAlternativeBottomTop(@NotNull TextureCreation bottomTexture, @NotNull TextureCreation topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return (intention, key) -> this.create(intention, key, bottomTexture, Texture.defaultCreation(), topTexture, half, facing);
+            }
+
+        }
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: straight (not inner or outer) stairs with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which a stair-shaped cut will be used), and one texture for the top
+     */
+    public static final class StraightStairs extends AbstractStairs {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("stairs"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/stairs.json
+        public static @NotNull SimpleOutwardExpandedElementsForProximityAndStairsStateCache straightStairsOutwardExpandedElements = SimpleOutwardExpandedElementsForProximityAndStairsStateCache.forFloat((outwardDistance, half, facing) -> {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            float afterMiddle = 8 + outwardDistance;
+            float beforeMiddle = 8 - outwardDistance;
+            // Initialize the physical coordinates as they would be before state modifications (so currently only the default coordinates with the outward distance applied)
+            TransformableElement[] elements = {
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, from, from),
+                    new TransformableElement.TransformableEndpoint(to, afterMiddle, to),
+                    """
+                        {
+                            "down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom", "cullface": "down" },
+                            "up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top" },
+                            "north": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "north" },
+                            "south": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "south" },
+                            "west":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "west" },
+                            "east":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "east" }
+                        }"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, afterMiddle, from),
+                    new TransformableElement.TransformableEndpoint(to, to, to),
+                    """
+                        {
+                            "up":    { "uv": [ 8, 0, 16, 16 ], "texture": "#top", "cullface": "up" },
+                            "north": { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "north" },
+                            "south": { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "south" },
+                            "west":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side" },
+                            "east":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "east" }
+                        }"""
+                )
+            };
+            // Transform the elements according to the state (half and facing)
+            for (TransformableElement element : elements) {
+                element.transformAccordingToState(half, facing);
+            }
+            // Return the elements
+            JsonArray elementsJson = new JsonArray();
+            for (TransformableElement element : elements) {
+                elementsJson.add(element.toJson());
+            }
+            return elementsJson;
+        });
+
+        public StraightStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture, half, facing);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull OutwardExpandedElementsForProximityAndStairsStateCache getStairsStateCache() {
+            return straightStairsOutwardExpandedElements;
+        }
+
+        public static final @NotNull CreationCompanion<StraightStairs> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull StraightStairs construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return new StraightStairs(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+        };
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: left inner stairs with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which a stair-shaped cut will be used), and one texture for the top
+     */
+    public static final class InnerLeftStairs extends AbstractStairs {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("inner_stairs"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/inner_stairs.json
+        public static @NotNull SimpleOutwardExpandedElementsForProximityAndStairsStateCache innerLeftStairsOutwardExpandedElements = SimpleOutwardExpandedElementsForProximityAndStairsStateCache.forFloat((outwardDistance, half, facing) -> {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            float afterMiddle = 8 + outwardDistance;
+            float beforeMiddle = 8 - outwardDistance;
+            // Initialize the physical coordinates as they would be before state modifications (so currently only the default coordinates with the outward distance applied)
+            TransformableElement[] elements = {
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, from, from),
+                    new TransformableElement.TransformableEndpoint(to, afterMiddle, to),
+                    """
+                        {
+                 			"down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom", "cullface": "down" },
+                 			"up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top" },
+                 			"north": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "north" },
+                 			"south": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "west" },
+                 			"east":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, afterMiddle, from),
+                    new TransformableElement.TransformableEndpoint(to, to, to),
+                    """
+                        {
+                 			"up":    { "uv": [ 8, 0, 16, 16 ], "texture": "#top", "cullface": "up" },
+                 			"north": { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "north" },
+                 			"south": { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side" },
+                 			"east":  { "uv": [ 0, 0, 16,  8 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, afterMiddle, beforeMiddle),
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, to, to),
+                    """
+                        {
+                 			"up":    { "uv": [ 0, 8,  8, 16 ], "texture": "#top", "cullface": "up" },
+                 			"north": { "uv": [ 8, 0, 16,  8 ], "texture": "#side" },
+                 			"south": { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "west" }
+                 		}"""
+                )
+            };
+            // Transform the elements according to the state (half and facing)
+            for (TransformableElement element : elements) {
+                element.transformAccordingToState(half, facing);
+            }
+            // Return the elements
+            JsonArray elementsJson = new JsonArray();
+            for (TransformableElement element : elements) {
+                elementsJson.add(element.toJson());
+            }
+            return elementsJson;
+        });
+
+        public InnerLeftStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture, half, facing);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull OutwardExpandedElementsForProximityAndStairsStateCache getStairsStateCache() {
+            return innerLeftStairsOutwardExpandedElements;
+        }
+
+        public static final @NotNull CreationCompanion<InnerLeftStairs> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull InnerLeftStairs construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return new InnerLeftStairs(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+        };
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: left outer stairs with one texture for the bottom, one textures for the x- and z-oriented sides (representing the texture along the entire face, of which a stair-shaped cut will be used), and one texture for the top
+     */
+    public static final class OuterLeftStairs extends AbstractStairs {
+
+        private static final @NotNull Model parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("outer_stairs"), Existing.getInstance());
+
+        // Based on vanilla Minecraft resource file /assets/minecraft/models/block/outer_stairs.json
+        public static @NotNull SimpleOutwardExpandedElementsForProximityAndStairsStateCache outerLeftStairsOutwardExpandedElements = SimpleOutwardExpandedElementsForProximityAndStairsStateCache.forFloat((outwardDistance, half, facing) -> {
+            float from = -outwardDistance;
+            float to = 16 + outwardDistance;
+            float afterMiddle = 8 + outwardDistance;
+            float beforeMiddle = 8 - outwardDistance;
+            // Initialize the physical coordinates as they would be before state modifications (so currently only the default coordinates with the outward distance applied)
+            TransformableElement[] elements = {
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(from, from, from),
+                    new TransformableElement.TransformableEndpoint(to, afterMiddle, to),
+                    """
+                        {
+                 			"down":  { "uv": [ 0, 0, 16, 16 ], "texture": "#bottom", "cullface": "down" },
+                 			"up":    { "uv": [ 0, 0, 16, 16 ], "texture": "#top" },
+                 			"north": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "north" },
+                 			"south": { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "west" },
+                 			"east":  { "uv": [ 0, 8, 16, 16 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                ),
+                new TransformableElement(
+                    new TransformableElement.TransformableEndpoint(beforeMiddle, afterMiddle, beforeMiddle),
+                    new TransformableElement.TransformableEndpoint(to, to, to),
+                    """
+                        {
+                 			"up":    { "uv": [ 8, 8, 16, 16 ], "texture": "#top", "cullface": "up" },
+                 			"north": { "uv": [ 0, 0,  8,  8 ], "texture": "#side" },
+                 			"south": { "uv": [ 8, 0, 16,  8 ], "texture": "#side", "cullface": "south" },
+                 			"west":  { "uv": [ 8, 0, 16,  8 ], "texture": "#side" },
+                 			"east":  { "uv": [ 0, 0,  8,  8 ], "texture": "#side", "cullface": "east" }
+                 		}"""
+                )
+            };
+            // Transform the elements according to the state (half and facing)
+            for (TransformableElement element : elements) {
+                element.transformAccordingToState(half, facing);
+            }
+            // Return the elements
+            JsonArray elementsJson = new JsonArray();
+            for (TransformableElement element : elements) {
+                elementsJson.add(element.toJson());
+            }
+            return elementsJson;
+        });
+
+        public OuterLeftStairs(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+            super(bottomTexture, sideTexture, topTexture, half, facing);
+        }
+
+        @Override
+        protected @NotNull Model getParent() {
+            return parent;
+        }
+
+        @Override
+        @NotNull OutwardExpandedElementsForProximityAndStairsStateCache getStairsStateCache() {
+            return outerLeftStairsOutwardExpandedElements;
+        }
+
+        public static final @NotNull CreationCompanion<OuterLeftStairs> creationCompanion = new CreationCompanion<>() {
+
+            @Override
+            protected @NotNull OuterLeftStairs construct(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture, @NotNull Half half, @NotNull Direction facing) {
+                return new OuterLeftStairs(bottomTexture, sideTexture, topTexture, half, facing);
+            }
+
+        };
+
+    }
+
+    /**
+     * A basic form of {@link ModelContent}: a fire model (which is one of several models displayed simultaneously in a fire block: see the fire blockstates)
+     */
+    public static final class Fire extends ModelContent {
+
+        private final @NotNull Model parent;
+        private final @NotNull Texture texture;
+
+        public Fire(@NotNull String modelLocation, @NotNull Texture texture) {
+            super();
+            this.parent = new Model(ResourcePackAssetIntention.BLOCK, NamespacedKeyWithoutIntention.minecraft("template_fire_" + modelLocation), Existing.getInstance());
+            this.texture = texture;
+        }
+
+        @Override
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+            if (actuallyAdd) {
+                resourcePackModel.setParent(parent);
+                resourcePackModel.setFireTexture(this.texture);
+            }
+            return this.texture.addToResourcePack(resourcePack, false, actuallyAdd);
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelVisualProperties properties) {
+            throw new UnsupportedOperationException("Cannot call getOutwardExpandedElements on ModelContent instance of type Fire");
+        }
+
+        public static @NotNull Fire create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull String modelLocation, @NotNull TextureCreation texture) {
+            return new Fire(modelLocation, texture.create(intention, key));
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull String modelLocation, @NotNull Texture texture) {
+            return (intention, key) -> new Fire(modelLocation, texture);
+        }
+
+        public static @NotNull ModelContentCreation creation(@NotNull String modelLocation, @NotNull TextureCreation texture) {
+            return (intention, key) -> create(intention, key, modelLocation, texture);
+        }
+
+        public static @NotNull ModelContentCreation defaultCreation(@NotNull String modelLocation) {
+            return creation(modelLocation, Texture.defaultCreation());
+        }
+
+    }
+
+    /**
+     * A reference to some model that is outside the scope of our own resource pack (for example a model already existing, for use as a parent)
+     */
+    public static final class Reference extends ModelContent {
+
+        private final @NotNull Model parent;
+
+        public Reference(@NotNull Model parent) {
+            super();
+            this.parent = parent;
+        }
+
+        @Override
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+            if (actuallyAdd) {
+                resourcePackModel.setParent(parent);
+            }
+            return Collections.emptyList();
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelVisualProperties properties) throws UnsupportedOperationException {
+            try {
+                return parent.getContent().getOutwardExpandedElements(properties);
+            } catch (UnsupportedOperationException e) {
+                throw new UnsupportedOperationException("Cannot call getOutwardExpandedElements on ModelContent instance of type Reference for which the parent model itself does not support a call of getOutwarExpandedElements", e);
+            }
+        }
+
+    }
+
+    /**
+     * A form of {@link ModelContent}: a model that refers to a parent, and is equal to it in every way except the size and position it appears with in an equipment head slot (to place it in the right position from the perspective of an armor stand positioned at one of the block corners), and also except for the elements the model is drawn with (which determine the surface), in order to expand them a little bit to draw over the underlying physical block, but under its block break animation
+     */
+    public static final class AsBlockEntityReference extends ModelContent {
+
+        private final @NotNull Model parent;
+        private final @NotNull BlockEntityModelPosition position;
+        private final @NotNull Supplier<@NotNull JsonArray> outwardExpandedElements;
+
+        public AsBlockEntityReference(@NotNull Model parent, @NotNull BlockEntityModelPosition position, @NotNull Supplier<@NotNull JsonArray> outwardExpandedElements) {
+            super();
+            this.parent = parent;
+            this.position = position;
+            this.outwardExpandedElements = outwardExpandedElements;
+        }
+
+        @Override
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+            if (actuallyAdd) {
+                resourcePackModel.setParent(this.parent);
+                resourcePackModel.setBlockEntityHeadDisplay(this.position);
+                resourcePackModel.setBlockEntityElements(this.outwardExpandedElements.get());
+            }
+            return this.parent.addToResourcePack(resourcePack, false, actuallyAdd);
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelVisualProperties properties) throws UnsupportedOperationException {
+            throw new UnsupportedOperationException("Cannot call getOutwardExpandedElements on ModelContent instance of type AsBlockEntityReference");
+        }
+
+    }
+
+//    /**
+//     * A form of {@link ModelContent}: a model that refers to a parent, and is equal to it in every way except the size and position it appears with in an equipment head slot
+//     */
+//    public static final class AsBlockEntityReference extends ModelContent {
+//
+//        private final @NotNull Model parent;
+//
+//        public AsBlockEntityReference(@NotNull Model parent) {
+//            super();
+//            this.parent = parent;
+//        }
+//
+//        @Override
+//        void writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack) {
+//            resourcePackModel.setParent(parent);
+//            resourcePackModel.setBlockEntityHeadDisplay();
+//            parent.addToResourcePack(resourcePack, false);
+//        }
+//
+//    }
+
+    /**
+     * A reference to some model that is outside the scope of our own resource pack (for example a model already existing) that we do not seek to modify
+     */
+    public static final class Existing extends ModelContent {
+
+        public enum ExistingModelContentOutwardExpansionType {
+
+            CUBE(() -> OneTextureCube.cubeOutwardExpandedElements),
+            HORIZONTAL_COLUMN_CUBE(() -> HorizontalYPillarCube.horizontalColumnCubeOutwardExpandedElements),
+            BOTTOM_SLAB(() -> BottomSlab.bottomSlabOutwardExpandedElements),
+            TOP_SLAB(() -> TopSlab.topSlabOutwardExpandedElements);
+
+            private final @NotNull Supplier<@NotNull OutwardExpandedElementsForPropertiesCache> outwardExpandedElementsFunction;
+
+            ExistingModelContentOutwardExpansionType(@NotNull Supplier<@NotNull OutwardExpandedElementsForPropertiesCache> outwardExpandedElementsFunction) {
+                this.outwardExpandedElementsFunction = outwardExpandedElementsFunction;
+            }
+
+        }
+
+        private final @Nullable ExistingModelContentOutwardExpansionType outwardExpansionType;
+
+        private Existing(@Nullable ExistingModelContentOutwardExpansionType outwardExpansionType) {
+            super();
+            this.outwardExpansionType = outwardExpansionType;
+        }
+
+        /**
+         * Since this is content that already exists, it does not need to be written
+         */
+        @Override
+        @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> writeToClearResourcePackModel(@NotNull MutableResourcePackModel resourcePackModel, @NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+            // We make sure it is written to the resource pack as a cached asset later,
+            // if we want this model to be visible to older Minecraft versions
+            // Edit: this is not a correct implementation TODO fix
+//            if (CreateSuCraftResourcePack.modelsToIncludeForOlderVersionVisibility.contains(resourcePackModel.getKey().keyWithoutIntention())) {
+//                resourcePackModel.setDirty();
+//            }
+            return Collections.emptyList();
+        }
+
+        @Override
+        @NotNull JsonArray getOutwardExpandedElements(@NotNull BlockEntityModelVisualProperties properties) throws UnsupportedOperationException {
+            if (this.outwardExpansionType != null) {
+                return this.outwardExpansionType.outwardExpandedElementsFunction.get().getOutwardExpandedElements(properties);
+            }
+            throw new UnsupportedOperationException("Cannot call getOutwardExpandedElements on ModelContent instance of type Existing that did not have an outwardExpansionType");
+        }
+
+        private static final @NotNull Existing INSTANCE = new Existing(null);
+
+        public static @NotNull Existing getInstance() {
+            return INSTANCE;
+        }
+
+        private static final @NotNull EnumMap<@NotNull ExistingModelContentOutwardExpansionType, @NotNull Existing> instancesWithOutwardExpansionType = new EnumMap<>(ExistingModelContentOutwardExpansionType.class);
+        static {
+            for (ExistingModelContentOutwardExpansionType type : ExistingModelContentOutwardExpansionType.values()) {
+                instancesWithOutwardExpansionType.put(type, new Existing(type));
+            }
+        }
+
+        public static @NotNull Existing getInstance(@NotNull ExistingModelContentOutwardExpansionType outwardExpansionType) {
+            return instancesWithOutwardExpansionType.get(outwardExpansionType);
+        }
+
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelContentCreation.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelContentCreation.java
new file mode 100644
index 0000000000000000000000000000000000000000..539254316f45d914733a38ca73ebe15ed3aa4927
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelContentCreation.java
@@ -0,0 +1,13 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import net.minecraft.resources.ResourceLocation;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public interface ModelContentCreation {
+
+    @NotNull ModelContent create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key);
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelCreation.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelCreation.java
new file mode 100644
index 0000000000000000000000000000000000000000..d8df63bc78f4a218828fb4e3d1ea737061914186
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelCreation.java
@@ -0,0 +1,21 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import net.minecraft.resources.ResourceLocation;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public interface ModelCreation {
+
+    @NotNull Model create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key);
+
+    default @NotNull ModelCreationWithParameters withParameters(@NotNull ModelParameters parameters) {
+        return new ModelCreationWithParameters(this, parameters);
+    }
+
+    default @NotNull ModelCreationWithParameters withNoParameters() {
+        return new ModelCreationWithParameters(this, null);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelCreationWithParameters.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelCreationWithParameters.java
new file mode 100644
index 0000000000000000000000000000000000000000..a488a217daa54eab6205faa54615c8ff7c7a4cb7
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelCreationWithParameters.java
@@ -0,0 +1,19 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import net.minecraft.resources.ResourceLocation;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A {@link ModelCreation}, optionally with accompanying {@link ModelParameters}
+ */
+public record ModelCreationWithParameters(@NotNull ModelCreation modelCreation, @Nullable ModelParameters parameters) {
+
+    public @NotNull ModelWithParameters create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key) {
+        return new ModelWithParameters(modelCreation.create(intention, key), parameters);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelParameters.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelParameters.java
new file mode 100644
index 0000000000000000000000000000000000000000..238374ca9e918323183cbff440e3a53f1b271571
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelParameters.java
@@ -0,0 +1,26 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import com.google.gson.JsonObject;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Map;
+import java.util.function.Consumer;
+
+/**
+ * Parameters that do not belong to a model, but go with it when setting the model as the model of a block state variant.
+ */
+public final class ModelParameters {
+
+    private final @NotNull JsonObject json = new JsonObject();
+
+    public ModelParameters(@NotNull Consumer<@NotNull JsonObject> jsonInitialization) {
+        jsonInitialization.accept(json);
+    }
+
+    public @NotNull JsonObject getJson() {
+        return this.json;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelWithParameters.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelWithParameters.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a45c27a570a958cd87565c160ecdc142ecb970b
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/ModelWithParameters.java
@@ -0,0 +1,11 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A {@link Model}, optionally with accompanying {@link ModelParameters}
+ */
+public record ModelWithParameters(@NotNull Model model, @Nullable ModelParameters parameters) {}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/PositionAndProximityBlockEntityModelVisualPropertiesUniverse.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/PositionAndProximityBlockEntityModelVisualPropertiesUniverse.java
new file mode 100644
index 0000000000000000000000000000000000000000..41ef731d70d70d48b2cf1b0ed827d9eab1426f3f
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/PositionAndProximityBlockEntityModelVisualPropertiesUniverse.java
@@ -0,0 +1,67 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public final class PositionAndProximityBlockEntityModelVisualPropertiesUniverse implements BlockEntityModelVisualPropertiesUniverse<TypicalBlockEntityModelVisualProperties> {
+
+    private PositionAndProximityBlockEntityModelVisualPropertiesUniverse() {}
+    private static @Nullable PositionAndProximityBlockEntityModelVisualPropertiesUniverse instance = null;
+    public static @NotNull PositionAndProximityBlockEntityModelVisualPropertiesUniverse getInstance() {
+        if (instance == null) {
+            instance = new PositionAndProximityBlockEntityModelVisualPropertiesUniverse();
+        }
+        return instance;
+    }
+
+    private final @NotNull TypicalBlockEntityModelVisualProperties @NotNull [] values;
+    {
+        @NotNull List<@NotNull TypicalBlockEntityModelVisualProperties> valuesList = new ArrayList<>(BlockEntityModelPosition.values().length * BlockEntityModelProximity.values().length);
+        for (BlockEntityModelPosition position : BlockEntityModelPosition.values()) {
+            for (BlockEntityModelProximity proximity : BlockEntityModelProximity.values()) {
+
+                // Continue if this is not a valid combination of values
+                if (proximity.equals(BlockEntityModelProximity.NOT_EXPANDED) && !position.equals(BlockEntityModelPosition.CENTER)) {
+                    continue;
+                }
+
+                TypicalBlockEntityModelVisualProperties properties = new BaseBlockEntityModelVisualProperties(position, proximity);
+                valuesList.add(properties);
+
+            }
+        }
+        this.values = valuesList.toArray(TypicalBlockEntityModelVisualProperties[]::new);
+    }
+    private final int @NotNull [] @NotNull [] ordinals;
+    {
+        this.ordinals = new int[BlockEntityModelPosition.values().length][BlockEntityModelProximity.values().length];
+        for (int i = 0; i < this.values.length; i++) {
+            this.ordinals[this.values[i].getPosition().ordinal()][this.values[i].getProximity().ordinal()] = i;
+        }
+    }
+
+    @Override
+    public @NotNull TypicalBlockEntityModelVisualProperties @NotNull [] getValues() {
+        return this.values;
+    }
+
+    @Override
+    public int getIndex(@NotNull TypicalBlockEntityModelVisualProperties properties) {
+        return this.ordinals[properties.getPosition().ordinal()][properties.getProximity().ordinal()];
+    }
+
+    @Override
+    public boolean caresAboutPosition() {
+        return true;
+    }
+
+    public boolean caresAboutProximity() {
+        return true;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/ProximityBlockEntityModelVisualPropertiesUniverse.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/ProximityBlockEntityModelVisualPropertiesUniverse.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7d12ee028bff43e0226c7702deddb35d75e601a
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/ProximityBlockEntityModelVisualPropertiesUniverse.java
@@ -0,0 +1,55 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Arrays;
+
+public final class ProximityBlockEntityModelVisualPropertiesUniverse implements BlockEntityModelVisualPropertiesUniverse<TypicalBlockEntityModelVisualProperties> {
+
+    private static final @NotNull BlockEntityModelPosition POSITION_USED = BlockEntityModelPosition.CENTER;
+
+    private ProximityBlockEntityModelVisualPropertiesUniverse() {}
+    private static @Nullable ProximityBlockEntityModelVisualPropertiesUniverse instance = null;
+    public static @NotNull ProximityBlockEntityModelVisualPropertiesUniverse getInstance() {
+        if (instance == null) {
+            instance = new ProximityBlockEntityModelVisualPropertiesUniverse();
+        }
+        return instance;
+    }
+
+    private final @NotNull TypicalBlockEntityModelVisualProperties @NotNull [] values;
+    {
+        this.values = Arrays.stream(BlockEntityModelProximity.values()).map(proximity -> new BaseBlockEntityModelVisualProperties(POSITION_USED, proximity)).toArray(TypicalBlockEntityModelVisualProperties[]::new);
+    }
+//    private final int @NotNull [] indices;
+//    {
+//        this.indices = new int[BlockEntityModelProximity.values().length];
+//        for (int i = 0; i < this.values.length; i++) {
+//            this.indices[this.values[i].getProximity().ordinal()] = i;
+//        }
+//    }
+
+    @Override
+    public @NotNull TypicalBlockEntityModelVisualProperties @NotNull [] getValues() {
+        return this.values;
+    }
+
+    @Override
+    public int getIndex(@NotNull TypicalBlockEntityModelVisualProperties properties) {
+//        return this.indices[properties.getProximity().ordinal()];
+        return properties.getProximity().ordinal();
+    }
+
+    @Override
+    public boolean caresAboutPosition() {
+        return false;
+    }
+
+    public boolean caresAboutProximity() {
+        return true;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/model/TypicalBlockEntityModelVisualProperties.java b/src/main/java/org/sucraft/suki/blockanditemdata/model/TypicalBlockEntityModelVisualProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..ac35f52591c351630d455cebcdb5ddbd6f79e2a5
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/model/TypicalBlockEntityModelVisualProperties.java
@@ -0,0 +1,15 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.model;
+
+import org.jetbrains.annotations.NotNull;
+
+public interface TypicalBlockEntityModelVisualProperties extends BlockEntityModelVisualProperties {
+
+    @NotNull BlockEntityModelPosition getPosition();
+
+    @NotNull BlockEntityModelProximity getProximity();
+
+    @NotNull TypicalBlockEntityModelVisualProperties cloneWithProximity(@NotNull BlockEntityModelProximity proximity);
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/texture/Texture.java b/src/main/java/org/sucraft/suki/blockanditemdata/texture/Texture.java
new file mode 100644
index 0000000000000000000000000000000000000000..a3ecc862d24ddb7480d7acb99ea0d2187e4a4ae1
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/texture/Texture.java
@@ -0,0 +1,94 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.texture;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.resources.ResourceLocation;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.blockanditemdata.model.ModelContentCreation;
+import org.sucraft.suki.blockanditemdata.model.ModelCreation;
+import org.sucraft.suki.resourcepack.MutableResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.ResourcePackIntentionedAssetDataByContent;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.sucraft.suki.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.function.Function;
+
+/**
+ * An immutable item or block texture
+ */
+public class Texture extends ResourcePackIntentionedAssetDataByContent<TextureContent> {
+
+    public static final @NotNull String TOP_SUFFIX = "_top";
+    public static final @NotNull String END_SUFFIX = TOP_SUFFIX;
+    public static final @NotNull String BOTTOM_SUFFIX = "_bottom";
+
+    public Texture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key, @NotNull TextureContent content) {
+        super(intention, key, content);
+    }
+
+    public @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> addToResourcePack(@NotNull MutableResourcePack resourcePack, boolean overwriteExisting, boolean actuallyAdd) {
+        if (actuallyAdd) {
+            @NotNull MutableResourcePackTexture resourcePackTexture = resourcePack.getOrCreateTexture(this.intention, this.key);
+            if (!resourcePackTexture.hasData() || overwriteExisting) {
+                this.content.writeToResourcePackTexture(resourcePackTexture);
+            }
+        }
+        return Collections.singletonList(Pair.of(ResourcePackAssetType.TEXTURE, this.getKeyWithIntention()));
+    }
+
+    // Convenience methods for replacement rule builders
+
+    public static @NotNull Texture create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureContent content) {
+        return new Texture(intention, NamespacedKeyWithoutIntention.forMinecraft(key), content);
+    }
+
+    public static @NotNull Texture create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key, @NotNull TextureContentCreation content) {
+        return create(intention, key, content.create(intention, key));
+    }
+
+    public static @NotNull TextureCreation creation(@NotNull TextureContent content) {
+        return (intention, key) -> create(intention, key, content);
+    }
+
+    public static @NotNull TextureCreation creation(@NotNull TextureContentCreation content) {
+        return (intention, key) -> create(intention, key, content);
+    }
+
+    public static @NotNull TextureCreation endCreation(@NotNull TextureContentCreation content) {
+        return (intention, key) -> create(intention, new ResourceLocation(key.getNamespace(), key.getPath() + END_SUFFIX), content);
+    }
+
+    public static @NotNull TextureCreation bottomCreation(@NotNull TextureContentCreation content) {
+        return (intention, key) -> create(intention, new ResourceLocation(key.getNamespace(), key.getPath() + BOTTOM_SUFFIX), content);
+    }
+
+    public static @NotNull TextureCreation topCreation(@NotNull TextureContentCreation content) {
+        return (intention, key) -> create(intention, new ResourceLocation(key.getNamespace(), key.getPath() + TOP_SUFFIX), content);
+    }
+
+    private static final @NotNull TextureCreation DEFAULT_CREATION = creation(TextureContent.ByFileToImportPath.defaultCreation());
+    private static final @NotNull TextureCreation DEFAULT_END_CREATION = endCreation(TextureContent.ByFileToImportPath.defaultCreation());
+    private static final @NotNull TextureCreation DEFAULT_BOTTOM_CREATION = bottomCreation(TextureContent.ByFileToImportPath.defaultCreation());
+    private static final @NotNull TextureCreation DEFAULT_TOP_CREATION = topCreation(TextureContent.ByFileToImportPath.defaultCreation());
+
+    public static @NotNull TextureCreation defaultCreation() {
+        return DEFAULT_CREATION;
+    }
+    public static @NotNull TextureCreation defaultEndCreation() {
+        return DEFAULT_END_CREATION;
+    }
+    public static @NotNull TextureCreation defaultBottomCreation() {
+        return DEFAULT_BOTTOM_CREATION;
+    }
+    public static @NotNull TextureCreation defaultTopCreation() {
+        return DEFAULT_TOP_CREATION;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureContent.java b/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..85bc23391ec2ac757ed2434b235649d9a41e98f6
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureContent.java
@@ -0,0 +1,95 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetDataContent;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.sucraft.suki.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.sucraft.suki.resourcepack.sucraft.CreateSuCraftResourcePack;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+
+/**
+ * The immutable content of a texture: a {@link Texture} without any information about its appropriate location in a resource pack
+ */
+public abstract class TextureContent implements ResourcePackAssetDataContent {
+
+    protected TextureContent() {}
+
+    public @NotNull Texture asTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return new Texture(intention, key, this);
+    }
+
+    abstract void writeToResourcePackTexture(@NotNull MutableResourcePackTexture resourcePackTexture);
+
+    // Convenience methods for replacement rule builders
+
+    /**
+     * A reference to some texture that is outside the scope of our own resource pack (for example a texture already existing)
+     */
+    public static final class Existing extends TextureContent {
+
+        private Existing() {
+            super();
+        }
+
+        /**
+         * Since this is content that already exists, it does not need to be written
+         */
+        @Override
+        void writeToResourcePackTexture(@NotNull MutableResourcePackTexture resourcePackTexture) {
+            // We make sure it is written to the resource pack as a cached asset later,
+            // if we want this texture to be visible to older Minecraft versions
+            // Edit: this is not a correct implementation TODO fix
+//            if (CreateSuCraftResourcePack.texturesToIncludeForOlderVersionVisibility.contains(resourcePackTexture.getKey().keyWithoutIntention())) {
+//                resourcePackTexture.setDirty();
+//            }
+        }
+
+        private static final @NotNull Existing INSTANCE = new Existing();
+
+        public static @NotNull Existing getInstance() {
+            return INSTANCE;
+        }
+
+    }
+
+    /**
+     * A basic form of {@link TextureContent}: whatever is in the file that the stored path points to
+     */
+    public static final class ByFileToImportPath extends TextureContent {
+
+        private final @NotNull String fileToImportPath;
+
+        public ByFileToImportPath(@NotNull String fileToImportPath) {
+            super();
+            this.fileToImportPath = fileToImportPath;
+        }
+
+        @Override
+        void writeToResourcePackTexture(@NotNull MutableResourcePackTexture resourcePackTexture) {
+            resourcePackTexture.setBasedOnFileToImport(this.fileToImportPath);
+        }
+
+        public static @NotNull TextureContentCreation creation(@NotNull String fileToImportPath) {
+            return (intention, key) -> new ByFileToImportPath(fileToImportPath);
+        }
+
+        public static @NotNull TextureContentCreation creationInDefaultFolder(@NotNull TextureFilenameCreation filename) {
+            return (intention, key) -> new ByFileToImportPath(Path.of(CreateSuCraftResourcePack.INPUT_TEXTURES_FOLDER_PATH, filename.create(intention, key)).toString());
+        }
+
+        private static final @NotNull TextureFilenameCreation DEFAULT_FILENAME = (intention, key) -> NamespacedKeyWithoutIntention.forMinecraft(key).withIntention(intention).keyWithIntention() + ResourcePackAssetType.TEXTURE.getDefaultFileExtension();
+        private static final @NotNull TextureContentCreation DEFAULT_CREATION = creationInDefaultFolder(DEFAULT_FILENAME);
+
+        public static @NotNull TextureContentCreation defaultCreation() {
+            return DEFAULT_CREATION;
+        }
+
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureContentCreation.java b/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureContentCreation.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb9b17182f9267a4ad68ffdb0285fd3400a840dd
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureContentCreation.java
@@ -0,0 +1,14 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import org.sucraft.suki.blockanditemdata.model.ModelContent;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public interface TextureContentCreation {
+
+    @NotNull TextureContent create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key);
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureCreation.java b/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureCreation.java
new file mode 100644
index 0000000000000000000000000000000000000000..a9166969d864dd46da6891cb8c646d472c2d1f09
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureCreation.java
@@ -0,0 +1,14 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public interface TextureCreation {
+
+    @NotNull Texture create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key);
+
+}
diff --git a/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureFilenameCreation.java b/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureFilenameCreation.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a788abbe81059fe2dd767c5f3daecdd148791ec
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/blockanditemdata/texture/TextureFilenameCreation.java
@@ -0,0 +1,13 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.blockanditemdata.texture;
+
+import net.minecraft.resources.ResourceLocation;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public interface TextureFilenameCreation {
+
+    @NotNull String create(@NotNull ResourcePackAssetIntention intention, @NotNull ResourceLocation key);
+
+}
diff --git a/src/main/java/org/sucraft/suki/command/CustomItemArgument.java b/src/main/java/org/sucraft/suki/command/CustomItemArgument.java
new file mode 100644
index 0000000000000000000000000000000000000000..1e4df1a6352ec2fac270fee29de325e3b6fe9c81
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/command/CustomItemArgument.java
@@ -0,0 +1,61 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.command;
+
+import com.mojang.brigadier.StringReader;
+import com.mojang.brigadier.arguments.ArgumentType;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.DynamicCommandExceptionType;
+import com.mojang.brigadier.suggestion.Suggestions;
+import com.mojang.brigadier.suggestion.SuggestionsBuilder;
+import net.minecraft.commands.CommandBuildContext;
+import net.minecraft.commands.SharedSuggestionProvider;
+import net.minecraft.commands.arguments.item.ItemArgument;
+import net.minecraft.commands.arguments.item.ItemInput;
+import net.minecraft.commands.arguments.item.ItemParser;
+import net.minecraft.core.HolderLookup;
+import net.minecraft.core.Registry;
+import net.minecraft.network.chat.Component;
+import net.minecraft.resources.ResourceKey;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+import org.apache.commons.lang3.Validate;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.concurrent.CompletableFuture;
+
+public class CustomItemArgument implements ArgumentType<ResourceLocation> {
+
+    private static final Collection<String> EXAMPLES = Arrays.asList("snowy_stone_bricks", "sucraft:snowy_stone_bricks");
+
+    public CustomItemArgument() {}
+
+    public static CustomItemArgument item() {
+        return new CustomItemArgument();
+    }
+
+    public static <S> ItemInput getItem(CommandContext<S> context, String name) {
+        return new ItemInput(Registry.ITEM.getHolderOrThrow(Registry.ITEM.getResourceKey(Registry.ITEM.get(context.getArgument(name, ResourceLocation.class))).get()), null);
+    }
+
+    public ResourceLocation parse(StringReader stringReader) throws CommandSyntaxException {
+        ResourceLocation location = ResourceLocation.read(stringReader);
+        try {
+            Validate.notNull(Registry.ITEM.getHolderOrThrow(Registry.ITEM.getResourceKey(Registry.ITEM.get(location)).get()));
+        } catch (Exception e) {
+            throw ItemParser.ERROR_UNKNOWN_ITEM.createWithContext(stringReader, location);
+        }
+        return location;
+    }
+
+    public <S> CompletableFuture<Suggestions> listSuggestions(CommandContext<S> commandContext, SuggestionsBuilder suggestionsBuilder) {
+        return commandContext.getSource() instanceof SharedSuggestionProvider ? SharedSuggestionProvider.suggestResource(Registry.ITEM.keySet(), suggestionsBuilder) : Suggestions.empty();
+    }
+
+    public Collection<String> getExamples() {
+        return EXAMPLES;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/data/BlackHoleCachedOutput.java b/src/main/java/org/sucraft/suki/data/BlackHoleCachedOutput.java
index 701c8dae3671343db0010c15bf0d01de7cf57b08..bd7e9388428ce9ca9b04479baf0aebbeefdeab56 100644
--- a/src/main/java/org/sucraft/suki/data/BlackHoleCachedOutput.java
+++ b/src/main/java/org/sucraft/suki/data/BlackHoleCachedOutput.java
@@ -4,8 +4,8 @@ package org.sucraft.suki.data;
 
 import com.google.common.hash.HashCode;
 import net.minecraft.data.CachedOutput;
+import org.jetbrains.annotations.NotNull;
 
-import java.io.IOException;
 import java.nio.file.Path;
 
 /**
@@ -14,6 +14,6 @@ import java.nio.file.Path;
 public class BlackHoleCachedOutput implements CachedOutput {
 
     @Override
-    public void writeIfNeeded(Path path, byte[] data, HashCode hashCode) {}
+    public void writeIfNeeded(@NotNull Path path, byte @NotNull [] data, @NotNull HashCode hashCode) {}
 
 }
diff --git a/src/main/java/org/sucraft/suki/data/SuCraftTagsProvider.java b/src/main/java/org/sucraft/suki/data/SuCraftTagsProvider.java
index 219c00b7e77691954e7f4a91fe3d19af901ab52a..cd63c39224d7098f070f0cb8f273594bf3f70535 100644
--- a/src/main/java/org/sucraft/suki/data/SuCraftTagsProvider.java
+++ b/src/main/java/org/sucraft/suki/data/SuCraftTagsProvider.java
@@ -5,18 +5,21 @@ package org.sucraft.suki.data;
 import com.google.common.collect.Maps;
 import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
+import net.minecraft.data.tags.TagsProvider;
 import net.minecraft.resources.ResourceKey;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.tags.TagBuilder;
 import net.minecraft.tags.TagEntry;
 import net.minecraft.tags.TagKey;
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.stream.Stream;
 
 /**
  * Based on {@link net.minecraft.data.tags.TagsProvider}
@@ -31,7 +34,7 @@ public abstract class SuCraftTagsProvider<T> {
         this.registry = registry;
     }
 
-    protected abstract void addTags();
+    protected abstract void addTags(Map<TagKey<T>, List<Holder<T>>> existingRegistryTagEntries);
 
     public Map<TagKey<T>, List<Holder<T>>> run(Map<TagKey<T>, List<Holder<T>>> existingRegistryTagEntries) {
 
@@ -43,13 +46,13 @@ public abstract class SuCraftTagsProvider<T> {
 
             @Nullable
             @Override
-            public T element(ResourceLocation elementId) {
+            public T element(@NotNull ResourceLocation elementId) {
                 return SuCraftTagsProvider.this.registry.get(elementId);
             }
 
             @Nullable
             @Override
-            public Collection<T> tag(ResourceLocation otherTagId) {
+            public Collection<T> tag(@NotNull ResourceLocation otherTagId) {
                 TagKey<T> otherTagKey = TagKey.create(SuCraftTagsProvider.this.registry.key(), otherTagId);
                 return updatedRegistryTagEntries.get(otherTagKey).stream().map(Holder::value).toList();
             }
@@ -57,16 +60,16 @@ public abstract class SuCraftTagsProvider<T> {
         };
 
         // Create the builders: done by running this method similar to TagsProvider.addTags, which defines the elements for each tag that we wish to add elements to (both elements for custom tags and extra elements for existing tags)
-        this.addTags();
+        this.addTags(existingRegistryTagEntries);
         // For each tag for which entries were added in addTags
         this.builders.forEach((tagId, builder) -> {
             TagKey<T> tagKey = TagKey.create(SuCraftTagsProvider.this.registry.key(), tagId);
             // Get the tag entries that were added for this tag in addTags
             List<TagEntry> tagEntriesToMerge = builder.build();
-            // Filter only thetag  entries that exist (i.e. elements that exist in the registry, or tags that were defined earlier)
+            // Filter only the tag entries that exist (i.e. elements that exist in the registry, or tags that were defined earlier)
             List<TagEntry> validTagEntriesToMerge = new ArrayList<>(tagEntriesToMerge.size());
             tagEntriesToMerge.forEach(tagEntry -> {
-                if (tagEntry.verifyIfPresent(this.registry::containsKey, this.builders::containsKey)) { // Actually using existingRegistryEntries instead of this.builders seems more logical but the vanilla code uses builders so we'll just go with that
+                if (tagEntry.verifyIfPresent(this.registry::containsKey, this.builders::containsKey)) { // Actually using existingRegistryEntries instead of this.builders seems more logical but the vanilla code uses builders, so we'll just go with that
                     validTagEntriesToMerge.add(tagEntry);
                 } else {
                     MinecraftServer.LOGGER.error(String.format("The tag definition %s could not be fully defined as it is missing following reference: %s", tagId, tagEntry));
@@ -76,7 +79,7 @@ public abstract class SuCraftTagsProvider<T> {
             validTagEntriesToMerge.forEach(tagEntry ->
                 tagEntry.build(
                     lookup,
-                    newElement -> {
+                    newElement ->
                         updatedRegistryTagEntries.compute(tagKey, (sameTagKey, elementsForTag) -> {
                             if (elementsForTag == null) {
                                 // Make sure the list of elements for this tag exists
@@ -90,8 +93,7 @@ public abstract class SuCraftTagsProvider<T> {
                             elementsForTag.add(holder);
                             // Return the new list of elements for this tag
                             return elementsForTag;
-                        });
-                    }
+                        })
                 )
             );
         });
@@ -102,20 +104,25 @@ public abstract class SuCraftTagsProvider<T> {
 
     protected TagAppender<T> tag(TagKey<T> tag) {
         TagBuilder tagBuilder = this.getOrCreateRawBuilder(tag);
-        return new TagAppender<>(tagBuilder);
+        return new TagAppender<>(tagBuilder, this.registry);
     }
 
     protected TagBuilder getOrCreateRawBuilder(TagKey<T> tag) {
-        return this.builders.computeIfAbsent(tag.location(), (id) -> {
-            return TagBuilder.create();
-        });
+        return this.builders.computeIfAbsent(tag.location(), (id) -> TagBuilder.create());
     }
 
     protected static class TagAppender<T> {
         private final TagBuilder builder;
+        private final Registry<T> registry;
 
-        TagAppender(TagBuilder builder) {
+        TagAppender(TagBuilder builder, Registry<T> registry) {
             this.builder = builder;
+            this.registry = registry;
+        }
+
+        public TagAppender<T> add(T element) {
+            this.builder.addElement(this.registry.getKey(element));
+            return this;
         }
 
         @SafeVarargs
@@ -141,6 +148,15 @@ public abstract class SuCraftTagsProvider<T> {
             this.builder.addOptionalTag(id);
             return this;
         }
+
+        @SafeVarargs
+        public final TagAppender<T> add(T... elements) {
+            Stream.<T>of(elements).map(this.registry::getKey).forEach((id) -> {
+                this.builder.addElement(id);
+            });
+            return this;
+        }
+
     }
 
 }
diff --git a/src/main/java/org/sucraft/suki/item/ItemReplacementRule.java b/src/main/java/org/sucraft/suki/item/ItemReplacementRule.java
new file mode 100644
index 0000000000000000000000000000000000000000..a162e2aed3c061c012872bfd834b1e2baca5ea2c
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/item/ItemReplacementRule.java
@@ -0,0 +1,541 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.item;
+
+import com.google.common.collect.Lists;
+import io.papermc.paper.adventure.PaperAdventure;
+import it.unimi.dsi.fastutil.Pair;
+import it.unimi.dsi.fastutil.ints.Int2IntAVLTreeMap;
+import it.unimi.dsi.fastutil.ints.Int2IntMap;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.minecraft.ChatFormatting;
+import net.minecraft.core.Registry;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.StringTag;
+import net.minecraft.nbt.Tag;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.Style;
+import net.minecraft.network.chat.TextColor;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Rarity;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.state.BlockState;
+import org.sucraft.suki.resourcepack.MutableResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.sucraft.suki.resourcepack.asset.model.MutableResourcePackModel;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.blockanditemdata.model.ModelContent;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.inventory.CraftMetaItem;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.IdentityHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+
+import static org.sucraft.suki.item.SuCraftItems.CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR;
+
+public interface ItemReplacementRule {
+
+    interface Builder {
+
+        @NotNull ItemReplacementRule.Builder withReal(@NotNull Item real);
+
+        @NotNull ItemReplacementRule build();
+
+    }
+
+    @Nullable ItemStack replace(ItemStack item, boolean hasResourcePack, boolean hasHighPing, boolean isStonecutterRecipeResult);
+
+    @NotNull Item getReal();
+
+//    @NotNull Model getModel();
+
+    @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> addToResourcePack(@NotNull MutableResourcePack resourcePack, boolean actuallyAdd);
+
+    /**
+     * @see SuCraftItems#bootstrap
+     */
+    void initializeOrderSensitiveLateInitializations();
+
+    void setStonecutterRecipeHost(Item item);
+
+    class SimpleItemReplacementRule implements ItemReplacementRule {
+
+        public static class Builder implements ItemReplacementRule.Builder {
+
+            private @Nullable Item real;
+            private @Nullable Supplier<@NotNull Item> lowPingHostSupplier;
+            private @Nullable Function<@NotNull Item, @NotNull Integer> computeLowPingHostCustomModelData;
+            private @Nullable Supplier<@NotNull Item> highPingHostSupplier;
+            private @Nullable Function<@NotNull Item, @NotNull Integer> computeHighPingHostCustomModelData;
+            private @Nullable Supplier<@NotNull Item> fallbackSupplier;
+            private @NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate = item -> false;
+            private @NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction = item -> null;
+            private @Nullable Supplier<@NotNull Model> modelSupplier;
+
+            @Override
+            public @NotNull SimpleItemReplacementRule.Builder withReal(@NotNull Item real) {
+                this.real = real;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withLowPingHost(@NotNull Supplier<@NotNull Item> lowPingHostSupplier) {
+                this.lowPingHostSupplier = lowPingHostSupplier;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withLowPingHostCustomModelData(int lowPingHostCustomModelData) {
+                this.computeLowPingHostCustomModelData = host -> lowPingHostCustomModelData;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withNextUnusedLowPingHostCustomModelData() {
+                this.computeLowPingHostCustomModelData = UsedHostCustomModelData::generateUnusedHostCustomModelData;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withHighPingHost(@NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+                this.highPingHostSupplier = highPingHostSupplier;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withHighPingHostCustomModelData(int highPingHostCustomModelData) {
+                this.computeHighPingHostCustomModelData = host -> highPingHostCustomModelData;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withNextUnusedHighPingHostCustomModelData() {
+                this.computeHighPingHostCustomModelData = UsedHostCustomModelData::generateUnusedHostCustomModelData;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withFallback(@NotNull Supplier<@NotNull Item> fallbackSupplier) {
+                this.fallbackSupplier = fallbackSupplier;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withIsBlockHostReplacing(@NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate) {
+                this.isBlockHostReplacingPredicate = isBlockHostReplacingPredicate;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withBlockHostReplacingItemReplacement(@NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction) {
+                this.blockHostReplacingItemReplacementFunction = blockHostReplacingItemReplacementFunction;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withModel(@NotNull Model model) {
+                this.modelSupplier = () -> model;
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder withModelContent(@NotNull ModelContent modelContent) {
+                this.modelSupplier = () -> {
+                    Validate.notNull(this.real);
+                    return modelContent.asModel(ResourcePackAssetIntention.ITEM, NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(this.real)));
+                };
+                return this;
+            }
+
+            public @NotNull SimpleItemReplacementRule.Builder forBlock(@NotNull Block block) {
+                return this
+                    .withLowPingHost(() -> block.replacementRule.getRealItemRule().getLowPingHost())
+                    .withHighPingHost(() -> block.replacementRule.getRealItemRule().getHighPingHost())
+                    .withNextUnusedLowPingHostCustomModelData()
+                    .withNextUnusedHighPingHostCustomModelData()
+                    .withFallback(() -> block.replacementRule.getRealItemRule().getFallback())
+                    .withModel(block.replacementRule.getRealItemModel())
+                    .withIsBlockHostReplacing(item -> block.replacementRule.isHostPlacingItem(item))
+                    .withBlockHostReplacingItemReplacement(item -> block.replacementRule.getHostPlacingItemReplacement(item));
+            }
+
+            @Override
+            public @NotNull SimpleItemReplacementRule build() {
+                Validate.notNull(this.real);
+                Validate.notNull(this.lowPingHostSupplier);
+                Validate.notNull(this.computeLowPingHostCustomModelData);
+                Validate.notNull(this.highPingHostSupplier);
+                Validate.notNull(this.computeHighPingHostCustomModelData);
+                Validate.notNull(this.fallbackSupplier);
+                Validate.notNull(this.modelSupplier);
+                return new SimpleItemReplacementRule(this.real, this.lowPingHostSupplier, this.computeLowPingHostCustomModelData, this.highPingHostSupplier, this.computeHighPingHostCustomModelData, this.fallbackSupplier, this.isBlockHostReplacingPredicate, this.blockHostReplacingItemReplacementFunction, this.modelSupplier.get());
+            }
+
+        }
+
+        /**
+         * @see SuCraftItems#bootstrap
+         */
+        private boolean orderSensitiveLateInitializationsHaveStarted = false;
+        private final @NotNull Item real;
+        private @Nullable Item lowPingHost = null;
+        private @Nullable Supplier<@NotNull Item> lowPingHostSupplier;
+        private int lowPingHostCustomModelData = -1;
+        private @Nullable Function<@NotNull Item, @NotNull Integer> computeLowPingHostCustomModelData;
+        private int minifiedLowPingHostCustomModelData = -1;
+        private @Nullable Item highPingHost = null;
+        private @Nullable Supplier<@NotNull Item> highPingHostSupplier;
+        private int highPingHostCustomModelData = -1;
+        private @Nullable Function<@NotNull Item, @NotNull Integer> computeHighPingHostCustomModelData;
+        private int minifiedHighPingHostCustomModelData = -1;
+        private @Nullable Item stonecutterRecipeHost = null;
+        private int stonecutterRecipeHostCustomModelData = -1;
+        private int minifiedStonecutterRecipeHostCustomModelData = -1;
+        private @Nullable Item fallback = null;
+        private @Nullable Supplier<@NotNull Item> fallbackSupplier;
+        private final @NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate;
+        private final @NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction;
+        private final @NotNull Model model;
+
+        private SimpleItemReplacementRule(@NotNull Item real, @NotNull Supplier<@NotNull Item> lowPingHostSupplier, @NotNull Function<@NotNull Item, @NotNull Integer> computeLowPingHostCustomModelData, @NotNull Supplier<@NotNull Item> highPingHostSupplier, @NotNull Function<@NotNull Item, @NotNull Integer> computeHighPingHostCustomModelData, @NotNull Supplier<@NotNull Item> fallbackSupplier, @NotNull Predicate<@NotNull Item> isBlockHostReplacingPredicate, @NotNull Function<@NotNull Item, @Nullable Item> blockHostReplacingItemReplacementFunction, @NotNull Model model) {
+            this.real = real;
+            this.lowPingHostSupplier = lowPingHostSupplier;
+            this.computeLowPingHostCustomModelData = computeLowPingHostCustomModelData;
+            this.highPingHostSupplier = highPingHostSupplier;
+            this.computeHighPingHostCustomModelData = computeHighPingHostCustomModelData;
+            this.fallbackSupplier = fallbackSupplier;
+            this.isBlockHostReplacingPredicate = isBlockHostReplacingPredicate;
+            this.blockHostReplacingItemReplacementFunction = blockHostReplacingItemReplacementFunction;
+            this.model = model;
+            Validate.isTrue(this.model.getIntention() == ResourcePackAssetIntention.ITEM);
+        }
+
+        /**
+         * Will set the display name if there is no custom display name set, and if a custom display name is set, will set the given string as a prefix line in lore (to avoid confusion, by avoiding players having to look at the namespaced key shown with F3+H, which would typically be wrong)
+         * @param tag Optional, just for convenience in case we already have it to avoid unnecessarily retrieving it twice
+         * @param rarity Optional as an override, will otherwise be retrieved from the item if needed
+         */
+        public static void replaceItemStackDisplayName(@NotNull ItemStack item, @Nullable CompoundTag tag, @Nullable Rarity rarity, @NotNull String displayNameJSON, @NotNull String displayNameInLoreJSON, boolean addRendersAsEntityLore, boolean addUnderlyingItemLoreIfRenamed) {
+            if (tag == null) {
+                tag = item.getOrCreateTag();
+            }
+            if (rarity == null) {
+                rarity = item.getRarity();
+            }
+            // Setting display name is based on CraftMetaItem.applyToItem(CompoundTag)
+            // Could potentially also be based on ItemStack.setHoverName(Component)
+            final CompoundTag display = tag.getCompound(CraftMetaItem.DISPLAY.NBT);
+            if (addRendersAsEntityLore) {
+                ListTag lore;
+                if (!display.contains(CraftMetaItem.LORE.NBT)) {
+                    lore = new ListTag();
+                    display.put(CraftMetaItem.LORE.NBT, lore);
+                } else {
+                    lore = display.getList(CraftMetaItem.LORE.NBT, 8);
+                }
+                lore.add(0, StringTag.valueOf(SuCraftItems.RENDERS_AS_ENTITY_LORE_ADDITION_JSON));
+            }
+            if (!tag.contains(CraftMetaItem.DISPLAY.NBT)) {
+                tag.put(CraftMetaItem.DISPLAY.NBT, display);
+            }
+            if (!display.contains(CraftMetaItem.NAME.NBT)) {
+                display.putString(CraftMetaItem.NAME.NBT, displayNameJSON);
+//                System.out.println("TEMP DEBUG - set display name directly");
+            } else {
+                display.putString(CraftMetaItem.NAME.NBT, Component.Serializer.toJson(Component.Serializer.fromJson(display.getString(CraftMetaItem.NAME.NBT)).withStyle(Style.EMPTY.withColor(rarity.color))));
+                if (addUnderlyingItemLoreIfRenamed) {
+                        ListTag lore;
+                    if (!display.contains(CraftMetaItem.LORE.NBT)) {
+                        lore = new ListTag();
+                        display.put(CraftMetaItem.LORE.NBT, lore);
+                    } else {
+                        lore = display.getList(CraftMetaItem.LORE.NBT, 8);
+                    }
+                    lore.add(0, StringTag.valueOf(displayNameInLoreJSON));
+                }
+            }
+        }
+
+        @Override
+        public @Nullable ItemStack replace(@NotNull ItemStack item, boolean hasResourcePack, boolean hasHighPing, boolean isStonecutterRecipeResult) {
+            if (item.is(this.getReal())) {
+                boolean rendersAsEntity = false;
+                @Nullable Block block = Registry.BLOCK.get(this.getReal().id);
+                if (block != null) {
+                    var blockReplacementRule = block.replacementRule;
+                    if (blockReplacementRule != null) {
+                        if (blockReplacementRule.hasAsReal(block)) {
+                            if (blockReplacementRule.rendersSomeStatesAsEntity()) {
+                                rendersAsEntity = true;
+                            }
+                        }
+                    }
+                }
+                @NotNull ItemStack clone = item.copy();
+                CompoundTag tag = clone.getOrCreateTag();
+                if (hasResourcePack) {
+                    if (isStonecutterRecipeResult) {
+                        clone.setItem(this.getStonecutterRecipeHost());
+                        // Setting custom model data is based on CraftMetaItem.applyToItem(CompoundTag)
+                        tag.putInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT, this.getMinifiedStonecutterRecipeHostCustomModelData());
+                    } else {
+                        clone.setItem(this.getHost(hasHighPing));
+                        // Setting custom model data is based on CraftMetaItem.applyToItem(CompoundTag)
+                        tag.putInt(CraftMetaItem.CUSTOM_MODEL_DATA.NBT, this.getMinifiedHostCustomModelData(hasHighPing));
+                    }
+                } else {
+                    clone.setItem(this.getFallback());
+                }
+                replaceItemStackDisplayName(clone, tag, item.getRarity(), this.real.customDisplayNameJSON, this.real.customDisplayNameInLoreJSON, rendersAsEntity && item.getAddTechnicalPropertiesLore(), item.getAddUnderlyingItemLoreIfRenamed());
+//                System.out.println("TEMP DEBUG - replaced item display name for " + item.getItem() + " with: " + this.real.customDisplayNameJSON);
+                storeOriginalItemInfoInItemStackNBT(clone, tag, item);
+                return clone;
+            } else if (this.isBlockHostReplacing(item.getItem()) && hasResourcePack) {
+                @NotNull ItemStack clone = item.copy();
+                clone.setItem(this.getBlockHostReplacingItemReplacement(item.getItem()));
+                var description = Component.translatable(item.getDescriptionId());
+                CompoundTag tag = clone.getOrCreateTag();
+                replaceItemStackDisplayName(clone, tag, item.getRarity(), Component.Serializer.toJson(description.withStyle(Style.EMPTY.withColor(clone.getRarity().color).withItalic(false))), Component.Serializer.toJson(description.withStyle(Style.EMPTY.withColor(CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR).withItalic(false))), false, item.getAddUnderlyingItemLoreIfRenamed());
+                storeOriginalItemInfoInItemStackNBT(clone, tag, item);
+                return clone;
+            }
+            return null;
+        }
+
+        @Override
+        public @NotNull Item getReal() {
+            return this.real;
+        }
+
+        public @NotNull Item getLowPingHost() {
+            if (!orderSensitiveLateInitializationsHaveStarted) {
+                throw new IllegalStateException("SimpleItemReplacementRule.getLowPingHost cannot be called before order-sensitive late initialization");
+            }
+            if (this.lowPingHost == null) {
+                this.lowPingHost = this.lowPingHostSupplier.get();
+                this.lowPingHostSupplier = null;
+            }
+            return this.lowPingHost;
+        }
+
+        public int getLowPingHostCustomModelData() {
+            if (!orderSensitiveLateInitializationsHaveStarted) {
+                throw new IllegalStateException("SimpleItemReplacementRule.getLowPingHostCustomModelData cannot be called before order-sensitive late initialization");
+            }
+            if (this.lowPingHostCustomModelData == -1) {
+                this.lowPingHostCustomModelData = this.computeLowPingHostCustomModelData.apply(this.getLowPingHost());
+                this.computeLowPingHostCustomModelData = null;
+            }
+            return this.lowPingHostCustomModelData;
+        }
+
+        public int getMinifiedLowPingHostCustomModelData() {
+            if (this.minifiedLowPingHostCustomModelData == -1) {
+                this.minifiedLowPingHostCustomModelData = minifiedCustomModelData.get(this.getLowPingHost()).get(this.getLowPingHostCustomModelData());
+            }
+            return this.minifiedLowPingHostCustomModelData;
+        }
+
+        public @NotNull Item getHighPingHost() {
+            if (!orderSensitiveLateInitializationsHaveStarted) {
+                throw new IllegalStateException("SimpleItemReplacementRule.getHighPingHost cannot be called before order-sensitive late initialization");
+            }
+            if (this.highPingHost == null) {
+                this.highPingHost = this.highPingHostSupplier.get();
+                this.highPingHostSupplier = null;
+            }
+            return this.highPingHost;
+        }
+
+        public int getHighPingHostCustomModelData() {
+            if (!orderSensitiveLateInitializationsHaveStarted) {
+                throw new IllegalStateException("SimpleItemReplacementRule.getHighPingHostCustomModelData cannot be called before order-sensitive late initialization");
+            }
+            if (this.highPingHostCustomModelData == -1) {
+                this.highPingHostCustomModelData = this.computeHighPingHostCustomModelData.apply(this.getHighPingHost());
+                this.computeHighPingHostCustomModelData = null;
+            }
+            return this.highPingHostCustomModelData;
+        }
+
+        public int getMinifiedHighPingHostCustomModelData() {
+            if (this.minifiedHighPingHostCustomModelData == -1) {
+                this.minifiedHighPingHostCustomModelData = minifiedCustomModelData.get(this.getHighPingHost()).get(this.getHighPingHostCustomModelData());
+            }
+            return this.minifiedHighPingHostCustomModelData;
+        }
+
+        public @NotNull Item getHost(boolean hasHighPing) {
+            return this.getLowPingHost();
+            //return hasHighPing ? this.getHighPingHost() : this.getLowPingHost();
+        }
+
+        /**
+         * @throws IllegalStateException If this rule's real does not require a stonecutter recipe host (i.e. it is not the result of any stonecutter recipe)
+         */
+        public @NotNull Item getStonecutterRecipeHost() {
+            if (this.stonecutterRecipeHost == null) {
+                throw new IllegalStateException("Called SimpleItemReplacementRule.getStonecutterRecipeHost for a rule (for " + this.getReal() + ") for which no such host is defined");
+            }
+            return this.stonecutterRecipeHost;
+        }
+
+        public int getHostCustomModelData(boolean hasHighPing) {
+            return this.getLowPingHostCustomModelData();
+            //return hasHighPing ? this.getHighPingHostCustomModelData() : this.getLowPingHostCustomModelData();
+        }
+
+        public int getMinifiedHostCustomModelData(boolean hasHighPing) {
+            return this.getMinifiedLowPingHostCustomModelData();
+            //return hasHighPing ? this.getMinifiedHighPingHostCustomModelData() : this.getMinifiedLowPingHostCustomModelData();
+        }
+
+        /**
+         * @throws IllegalStateException If this rule's real does not require a stonecutter recipe host (i.e. it is not the result of any stonecutter recipe)
+         */
+        public @NotNull int getStonecutterRecipeHostCustomModelData() {
+            if (this.stonecutterRecipeHostCustomModelData == -1) {
+                throw new IllegalStateException("Called SimpleItemReplacementRule.getStonecutterRecipeHostCustomModelData for a rule for which no such host is defined");
+            }
+            return this.stonecutterRecipeHostCustomModelData;
+        }
+
+        /**
+         * @throws IllegalStateException If this rule's real does not require a stonecutter recipe host (i.e. it is not the result of any stonecutter recipe)
+         */
+        public @NotNull int getMinifiedStonecutterRecipeHostCustomModelData() {
+            if (this.minifiedStonecutterRecipeHostCustomModelData == -1) {
+                this.minifiedStonecutterRecipeHostCustomModelData = minifiedCustomModelData.get(this.getStonecutterRecipeHost()).get(this.getStonecutterRecipeHostCustomModelData());
+            }
+//            if (this.getReal().equals(SuCraftItems.YELLOW_WOOL_STAIRS)) {
+//                System.out.println("TEMP DEBUG - Before was: " + this.getStonecutterRecipeHostCustomModelData());
+//                System.out.println("TEMP DEBUG - Now is: " + this.minifiedStonecutterRecipeHostCustomModelData);
+//            }
+            return this.minifiedStonecutterRecipeHostCustomModelData;
+        }
+
+        public @NotNull Item getFallback() {
+            if (this.fallback == null) {
+                this.fallback = this.fallbackSupplier.get();
+                this.fallbackSupplier = null;
+            }
+            return this.fallback;
+        }
+
+        /**
+         * Returns true if the given item is a block item that if placed by a player, would place a block in a state that serves as a host for this item's block,
+         * <br>
+         * or false if:
+         * <ul>
+         *     <li>this item is not for a block, or</li>
+         *     <li>if the block this item is for does not have any hosts that can be the state for a block to appear on using some host block's item to place it</li>
+         * </ul>
+         */
+        private boolean isBlockHostReplacing(@NotNull Item item) {
+            return this.isBlockHostReplacingPredicate.test(item);
+        }
+
+        private @Nullable Item getBlockHostReplacingItemReplacement(@NotNull Item item) {
+            return this.blockHostReplacingItemReplacementFunction.apply(item);
+        }
+
+//        @Override
+//        public @NotNull Model getModel() {
+//            return this.model;
+//        }
+
+        @Override
+        public @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> addToResourcePack(@NotNull MutableResourcePack resourcePack, boolean actuallyAdd) {
+
+            @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> assetLocations = new ArrayList<>(0);
+
+            @NotNull NamespacedKeyWithoutIntention lowPingHostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(this.getLowPingHost()));
+            @NotNull MutableResourcePackModel lowPingMinecraftItemModel = resourcePack.getModel(ResourcePackAssetIntention.ITEM, lowPingHostKey);
+            assetLocations.addAll(lowPingMinecraftItemModel.addModelOverride(this.getLowPingHostCustomModelData(), this.model, resourcePack, false, actuallyAdd));
+
+            @NotNull NamespacedKeyWithoutIntention highPingHostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(this.getHighPingHost()));
+            @NotNull MutableResourcePackModel highPingMinecraftItemModel = resourcePack.getModel(ResourcePackAssetIntention.ITEM, highPingHostKey);
+            assetLocations.addAll(highPingMinecraftItemModel.addModelOverride(this.getHighPingHostCustomModelData(), this.model, resourcePack, false, actuallyAdd));
+
+            if (this.stonecutterRecipeHost != null) {
+                @NotNull NamespacedKeyWithoutIntention stonecutterRecipeHostKey = NamespacedKeyWithoutIntention.forMinecraft(Registry.ITEM.getKey(this.stonecutterRecipeHost));
+                @NotNull MutableResourcePackModel stonecutterRecipeMinecraftItemModel = resourcePack.getModel(ResourcePackAssetIntention.ITEM, stonecutterRecipeHostKey);
+                assetLocations.addAll(stonecutterRecipeMinecraftItemModel.addModelOverride(this.stonecutterRecipeHostCustomModelData, this.model, resourcePack, false, actuallyAdd));
+            }
+
+            return assetLocations;
+
+        }
+
+        @Override
+        public void initializeOrderSensitiveLateInitializations() {
+            this.orderSensitiveLateInitializationsHaveStarted = true;
+            this.getLowPingHost();
+            this.getLowPingHostCustomModelData();
+            this.getHighPingHost();
+            this.getHighPingHostCustomModelData();
+        }
+
+        @Override
+        public void setStonecutterRecipeHost(Item item) {
+            this.stonecutterRecipeHost = item;
+            this.stonecutterRecipeHostCustomModelData = UsedHostCustomModelData.generateUnusedHostCustomModelData(this.stonecutterRecipeHost);
+//            MinecraftServer.LOGGER.info("TEMP DEBUG - Setting stonecutter host for " + this.getReal() + " to host " + item + " with custom model data " + this.stonecutterRecipeHostCustomModelData);
+        }
+
+    }
+
+    static @NotNull SimpleItemReplacementRule.Builder simple() {
+        return new SimpleItemReplacementRule.Builder();
+    }
+
+    @NotNull String ORIGINAL_ITEM_INFO_ITEM_STACK_KEY = "OriginalItem";
+
+    /**
+     * @param tag Optional, just for convenience in case we already have it to avoid unnecessarily retrieving it twice
+     */
+    static void storeOriginalItemInfoInItemStackNBT(@NotNull ItemStack itemStack, @Nullable CompoundTag tag, @NotNull ItemStack originalItemStack) {
+        if (tag == null) {
+            tag = itemStack.getOrCreateTag();
+        }
+        tag.put(ORIGINAL_ITEM_INFO_ITEM_STACK_KEY, originalItemStack.save(new CompoundTag()));
+    }
+
+    /**
+     * Reverses {@link #replace} for a given ItemStack, assuming that ItemStack originated from the client, which may send packets containing ItemStacks that are the fake versions that we sent it
+     * <br>
+     * Will return null if and only if given null
+     */
+    static @Nullable ItemStack reverseReplacement(@Nullable ItemStack itemStack) {
+        try {
+            if (itemStack == null) {
+                return null;
+            }
+            @Nullable CompoundTag tag = itemStack.getTag();
+            if (tag == null) {
+                return itemStack;
+            }
+            if (!tag.contains(ORIGINAL_ITEM_INFO_ITEM_STACK_KEY, Tag.TAG_COMPOUND)) {
+                return itemStack;
+            }
+            CompoundTag originalNBT = tag.getCompound(ORIGINAL_ITEM_INFO_ITEM_STACK_KEY);
+            ItemStack original = ItemStack.of(originalNBT);
+            // The intended amount is chosen by the client
+            original.setCount(itemStack.getCount());
+            return original;
+        } catch (Throwable e) {
+            return itemStack;
+        }
+    }
+
+    @NotNull Map<@NotNull Item, @NotNull Int2IntMap> minifiedCustomModelData = new IdentityHashMap<>();
+
+    static void addMinifiedCustomModelData(@NotNull Item item, int original, int minified) {
+        minifiedCustomModelData.computeIfAbsent(item, $ -> new Int2IntAVLTreeMap()).put(original, minified);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/item/SuCraftCraftingRecipeProvider.java b/src/main/java/org/sucraft/suki/item/SuCraftCraftingRecipeProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..6f394e6911d9ecf4dd8c8d06b4afe425bd924324
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/item/SuCraftCraftingRecipeProvider.java
@@ -0,0 +1,276 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.item;
+
+import com.google.common.collect.ImmutableMap;
+import it.unimi.dsi.fastutil.Pair;
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.item.crafting.Ingredient;
+import net.minecraft.world.item.crafting.Recipe;
+import net.minecraft.world.item.crafting.RecipeManager;
+import net.minecraft.world.item.crafting.RecipeType;
+import net.minecraft.world.item.crafting.StonecutterRecipe;
+import net.minecraft.world.level.ItemLike;
+import org.apache.commons.lang3.tuple.Triple;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.inventory.RecipeChoice;
+import org.bukkit.inventory.ShapedRecipe;
+import org.bukkit.inventory.ShapelessRecipe;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Stream;
+
+public final class SuCraftCraftingRecipeProvider {
+
+    private SuCraftCraftingRecipeProvider() {}
+
+    /**
+     * Used to disable crafting recipes when potential problems are expected: such as after the first release
+     * of a major change.
+     */
+    private static final boolean disableAddingCraftingRecipes = false;
+
+    private static void removeRecipe(@NotNull ResourceLocation resourceLocation) {
+        if (disableAddingCraftingRecipes) { // To make sure we don't remove crafting recipes that would otherwise be replaced by custom crafting recipes
+            return;
+        }
+        MinecraftServer.getServer().getRecipeManager().removeRecipe(resourceLocation);
+    }
+
+    /**
+     * Utility method (shorter)
+     */
+    private static void addRecipe(@NotNull org.bukkit.inventory.Recipe recipe, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        if (disableAddingCraftingRecipes) {
+            return;
+        }
+        Bukkit.addRecipe(recipe, isSkippableForPlayersThatCannotAcceptLargePackets);
+    }
+
+    /**
+     * Utility method (shorter)
+     */
+    private static void addRecipe(@NotNull Recipe<?> recipe, boolean isSkippableForPlayersThatCannotAcceptLargePackets) {
+        if (disableAddingCraftingRecipes) {
+            return;
+        }
+        MinecraftServer.getServer().getRecipeManager().addRecipe(recipe, isSkippableForPlayersThatCannotAcceptLargePackets);
+    }
+
+    private static void addStonecutterRecipe(@Nullable String key, @Nullable String group, @NotNull Item ingredient, @NotNull Item result, int resultAmount) {
+        if (disableAddingCraftingRecipes) {
+            return;
+        }
+        if (key == null) {
+            key = result.id.getPath() + "_from_" +  ingredient.id.getPath() + "_stonecutting";
+        }
+        var recipeIngredient = new Ingredient(Stream.of(new Ingredient.ItemValue(new ItemStack(ingredient))));
+        var recipeKey = ResourceLocation.sucraft(key);
+        var recipe = new StonecutterRecipe(recipeKey, group != null ? group : key, recipeIngredient, new ItemStack(result, resultAmount), true);
+        addRecipe(recipe, false);
+        Item.CustomRecipeUnlockByItem.register(ingredient, recipeKey);
+    }
+
+    private static void addStonecutterRecipe(@NotNull Item ingredient, @NotNull Item result, int resultAmount) {
+        addStonecutterRecipe(null, null, ingredient, result, resultAmount);
+    }
+
+    private static void addStonecutterRecipe(@NotNull Item ingredient, @NotNull Item result) {
+        addStonecutterRecipe(ingredient, result, 1);
+    }
+
+    public static void run() {
+
+        // Add recipes already defined in items
+
+        for (Item item : Registry.ITEM) {
+            // Add the custom recipes defined in items
+            item.invokeCustomRecipeSuppliers();
+            for (var customRecipe : item.customRecipes) {
+                if (customRecipe instanceof Item.CustomMinecraftRecipe customMinecraftRecipe) {
+                    var recipe = customMinecraftRecipe.build(item);
+                    addRecipe(recipe, customMinecraftRecipe.isSkippableForPlayersThatCannotAcceptLargePackets());
+                } else if (customRecipe instanceof Item.CustomBukkitRecipe customBukkitRecipe) {
+                    var recipe = customBukkitRecipe.build(item);
+                    addRecipe(recipe, customBukkitRecipe.isSkippableForPlayersThatCannotAcceptLargePackets());
+                } else {
+                    throw new IllegalStateException("Custom recipe of unknown type: " + customRecipe);
+                }
+                customRecipe.registerUnlocks();
+            }
+        }
+
+        // Add other recipes
+
+        // Working with wood in stonecutters
+        for (Item[] woodBlocks : new Item[][] {
+            {Items.OAK_PLANKS, Items.OAK_SLAB, Items.OAK_STAIRS, Items.OAK_LOG, Items.STRIPPED_OAK_LOG, Items.OAK_WOOD, Items.STRIPPED_OAK_WOOD, SuCraftItems.OAK_LOG_SLAB, SuCraftItems.STRIPPED_OAK_LOG_SLAB, SuCraftItems.OAK_WOOD_SLAB, SuCraftItems.STRIPPED_OAK_WOOD_SLAB},
+            {Items.SPRUCE_PLANKS, Items.SPRUCE_SLAB, Items.SPRUCE_STAIRS, Items.SPRUCE_LOG, Items.STRIPPED_SPRUCE_LOG, Items.SPRUCE_WOOD, Items.STRIPPED_SPRUCE_WOOD, SuCraftItems.SPRUCE_LOG_SLAB, SuCraftItems.STRIPPED_SPRUCE_LOG_SLAB, SuCraftItems.SPRUCE_WOOD_SLAB, SuCraftItems.STRIPPED_SPRUCE_WOOD_SLAB},
+            {Items.BIRCH_PLANKS, Items.BIRCH_SLAB, Items.BIRCH_STAIRS, Items.BIRCH_LOG, Items.STRIPPED_BIRCH_LOG, Items.BIRCH_WOOD, Items.STRIPPED_BIRCH_WOOD, SuCraftItems.BIRCH_LOG_SLAB, SuCraftItems.STRIPPED_BIRCH_LOG_SLAB, SuCraftItems.BIRCH_WOOD_SLAB, SuCraftItems.STRIPPED_BIRCH_WOOD_SLAB},
+            {Items.JUNGLE_PLANKS, Items.JUNGLE_SLAB, Items.JUNGLE_STAIRS, Items.JUNGLE_LOG, Items.STRIPPED_JUNGLE_LOG, Items.JUNGLE_WOOD, Items.STRIPPED_JUNGLE_WOOD, SuCraftItems.JUNGLE_LOG_SLAB, SuCraftItems.STRIPPED_JUNGLE_LOG_SLAB, SuCraftItems.JUNGLE_WOOD_SLAB, SuCraftItems.STRIPPED_JUNGLE_WOOD_SLAB},
+            {Items.ACACIA_PLANKS, Items.ACACIA_SLAB, Items.ACACIA_STAIRS, Items.ACACIA_LOG, Items.STRIPPED_ACACIA_LOG, Items.ACACIA_WOOD, Items.STRIPPED_ACACIA_WOOD, SuCraftItems.ACACIA_LOG_SLAB, SuCraftItems.STRIPPED_ACACIA_LOG_SLAB, SuCraftItems.ACACIA_WOOD_SLAB, SuCraftItems.STRIPPED_ACACIA_WOOD_SLAB},
+            {Items.DARK_OAK_PLANKS, Items.DARK_OAK_SLAB, Items.DARK_OAK_STAIRS, Items.DARK_OAK_LOG, Items.STRIPPED_DARK_OAK_LOG, Items.DARK_OAK_WOOD, Items.STRIPPED_DARK_OAK_WOOD, SuCraftItems.DARK_OAK_LOG_SLAB, SuCraftItems.STRIPPED_DARK_OAK_LOG_SLAB, SuCraftItems.DARK_OAK_WOOD_SLAB, SuCraftItems.STRIPPED_DARK_OAK_WOOD_SLAB},
+            {Items.WARPED_PLANKS, Items.WARPED_SLAB, Items.WARPED_STAIRS, Items.WARPED_STEM, Items.STRIPPED_WARPED_STEM, Items.WARPED_HYPHAE, Items.STRIPPED_WARPED_HYPHAE, SuCraftItems.WARPED_STEM_SLAB, SuCraftItems.STRIPPED_WARPED_STEM_SLAB, SuCraftItems.WARPED_HYPHAE_SLAB, SuCraftItems.STRIPPED_WARPED_HYPHAE_SLAB},
+            {Items.CRIMSON_PLANKS, Items.CRIMSON_SLAB, Items.CRIMSON_STAIRS, Items.CRIMSON_STEM, Items.STRIPPED_CRIMSON_STEM, Items.CRIMSON_HYPHAE, Items.STRIPPED_CRIMSON_HYPHAE, SuCraftItems.CRIMSON_STEM_SLAB, SuCraftItems.STRIPPED_CRIMSON_STEM_SLAB, SuCraftItems.CRIMSON_HYPHAE_SLAB, SuCraftItems.STRIPPED_CRIMSON_HYPHAE_SLAB},
+            {Items.MANGROVE_PLANKS, Items.MANGROVE_SLAB, Items.MANGROVE_STAIRS, Items.MANGROVE_LOG, Items.STRIPPED_MANGROVE_LOG, Items.MANGROVE_WOOD, Items.STRIPPED_MANGROVE_WOOD, SuCraftItems.MANGROVE_LOG_SLAB, SuCraftItems.STRIPPED_MANGROVE_LOG_SLAB, SuCraftItems.MANGROVE_WOOD_SLAB, SuCraftItems.STRIPPED_MANGROVE_WOOD_SLAB}
+        }) {
+            Item planks = woodBlocks[0];
+            Item slab = woodBlocks[1];
+            Item stairs = woodBlocks[2];
+            Item log = woodBlocks[3];
+            Item strippedLog = woodBlocks[4];
+            Item wood = woodBlocks[5];
+            Item strippedWood = woodBlocks[6];
+            Item logSlab = woodBlocks[7];
+            Item strippedLogSlab = woodBlocks[8];
+            Item woodSlab = woodBlocks[9];
+            Item strippedWoodSlab = woodBlocks[10];
+            // stonecutter: planks -> stairs, slab
+            addStonecutterRecipe(planks, stairs);
+            addStonecutterRecipe(planks, slab, 2);
+            // stonecutter: log, wood -> planks, stairs, slab
+            for (Item ingredient : new Item[] {log, wood, strippedLog, strippedWood}) {
+                addStonecutterRecipe(ingredient, planks, 4);
+                addStonecutterRecipe(ingredient, stairs, 4);
+                addStonecutterRecipe(ingredient, slab, 8);
+            }
+            // stonecutter: log slab, wood slab -> planks, stairs, slab
+            for (Item ingredient : new Item[] {logSlab, woodSlab, strippedLogSlab, strippedWoodSlab}) {
+                addStonecutterRecipe(ingredient, planks, 2);
+                addStonecutterRecipe(ingredient, stairs, 2);
+                addStonecutterRecipe(ingredient, slab, 4);
+            }
+            // crafting: log slab, wood slab -> planks
+            ItemLike[] craftingPlanksFromLogOrWoodSlabIngredients = {logSlab.asItem(), woodSlab.asItem(), strippedLogSlab.asItem(), strippedWoodSlab.asItem()};
+            var craftingPlanksFromLogOrWoodSlabRecipe = new Item.CustomChoiceShapelessRecipe(ResourceLocation.sucraft(planks.id.getPath() + "_from_log_or_wood_slab"), null, true, new ItemLike[][] {craftingPlanksFromLogOrWoodSlabIngredients}, Arrays.stream(craftingPlanksFromLogOrWoodSlabIngredients).map(ingredient -> new Item.CustomRecipeUnlockByItem(() -> ingredient)).toArray(Item.CustomRecipeUnlockByItem[]::new), 2);
+            addRecipe(craftingPlanksFromLogOrWoodSlabRecipe.build(planks), craftingPlanksFromLogOrWoodSlabRecipe.isSkippableForPlayersThatCannotAcceptLargePackets());
+            craftingPlanksFromLogOrWoodSlabRecipe.registerUnlocks();
+        }
+
+        // Shortcuts
+        addStonecutterRecipe(Items.BASALT, SuCraftItems.POLISHED_BASALT_SLAB, 2);
+        addStonecutterRecipe(Items.BASALT, SuCraftItems.POLISHED_BASALT_STAIRS);
+        addStonecutterRecipe(Items.QUARTZ_BLOCK, SuCraftItems.QUARTZ_PILLAR_SLAB, 2);
+        addStonecutterRecipe(Items.QUARTZ_BLOCK, SuCraftItems.QUARTZ_PILLAR_STAIRS);
+        addStonecutterRecipe(Items.PURPUR_BLOCK, SuCraftItems.PURPUR_PILLAR_SLAB, 2);
+        addStonecutterRecipe(Items.PURPUR_BLOCK, SuCraftItems.PURPUR_PILLAR_STAIRS);
+
+        // Quartz meander
+        Stream.of(Items.QUARTZ_BLOCK, Items.CHISELED_QUARTZ_BLOCK).forEach(ingredient -> {
+            addStonecutterRecipe(ingredient, SuCraftItems.QUARTZ_SPIRAL_MEANDER);
+            addStonecutterRecipe(ingredient, SuCraftItems.QUARTZ_SPIRAL_MEANDER_STAIRS);
+            addStonecutterRecipe(ingredient, SuCraftItems.QUARTZ_SPIRAL_MEANDER_SLAB, 2);
+        });
+
+        // Remove the default bookshelf recipe
+        removeRecipe(ResourceLocation.minecraft("bookshelf"));
+
+        // Add the custom bookshelf recipes (not done at the definition of the custom bookshelves so that we can include the oak bookshelf here too)
+        Item[] customBookshelfPlankIngredients = {
+            Items.OAK_PLANKS,
+            Items.SPRUCE_PLANKS,
+            Items.BIRCH_PLANKS,
+            Items.JUNGLE_PLANKS,
+            Items.ACACIA_PLANKS,
+            Items.DARK_OAK_PLANKS,
+            Items.WARPED_PLANKS,
+            Items.CRIMSON_PLANKS,
+            Items.MANGROVE_PLANKS
+        };
+        Item[] customBookshelfResults = {
+            Items.BOOKSHELF,
+            SuCraftItems.SPRUCE_BOOKSHELF,
+            SuCraftItems.BIRCH_BOOKSHELF,
+            SuCraftItems.JUNGLE_BOOKSHELF,
+            SuCraftItems.ACACIA_BOOKSHELF,
+            SuCraftItems.DARK_OAK_BOOKSHELF,
+            SuCraftItems.WARPED_BOOKSHELF,
+            SuCraftItems.CRIMSON_BOOKSHELF,
+            SuCraftItems.MANGROVE_BOOKSHELF
+        };
+        for (int i = 0; i < customBookshelfResults.length; i++) {
+            var plankIngredient = customBookshelfPlankIngredients[i];
+            var result = customBookshelfResults[i];
+            var recipeKeyPath = result.equals(Items.BOOKSHELF) ? "oak_bookshelf" : result.id.getPath();
+            var recipeMinecraftKey = ResourceLocation.sucraft(recipeKeyPath);
+            var recipeKey = recipeMinecraftKey.asBukkit();
+            var shapedRecipe = new ShapedRecipe(recipeKey, new org.bukkit.inventory.ItemStack(CraftMagicNumbers.getMaterial(result)));
+            shapedRecipe.setGroup(recipeKey.getKey());
+            shapedRecipe.shape("$$$", "%%%", "$$$");
+            shapedRecipe.setIngredient('$', CraftMagicNumbers.getMaterial(plankIngredient));
+            shapedRecipe.setIngredient('%', Material.BOOK);
+            addRecipe(shapedRecipe, false);
+            Item.CustomRecipeUnlockByItem.register(Items.BOOK, recipeMinecraftKey);
+        }
+
+        // Remove some existing vanilla chiseled block recipes (to be replaced by the new recipes below)
+        removeRecipe(ResourceLocation.minecraft("chiseled_stone_bricks"));
+        removeRecipe(ResourceLocation.minecraft("chiseled_sandstone"));
+        removeRecipe(ResourceLocation.minecraft("chiseled_red_sandstone"));
+        removeRecipe(ResourceLocation.minecraft("chiseled_quartz_block"));
+        removeRecipe(ResourceLocation.minecraft("quartz_pillar"));
+
+        // Allow crafting vanilla chiseled blocks with (combinations of) more types of slabs
+        // (And also allow crafting quartz pillars with more types of quartz)
+        for (Triple<String, Item, Item[]> triple : List.of(
+            Triple.of("stone_slabs_to_chiseled_stone_bricks", Items.CHISELED_STONE_BRICKS, new Item[] {Items.STONE_SLAB, Items.STONE_BRICK_SLAB}),
+            Triple.of("sandstone_slabs_to_chiseled_sandstone", Items.CHISELED_SANDSTONE, new Item[] {Items.SANDSTONE_SLAB, Items.CUT_SANDSTONE_SLAB, Items.SMOOTH_SANDSTONE_SLAB}),
+            Triple.of("red_sandstone_slabs_to_chiseled_red_sandstone", Items.CHISELED_RED_SANDSTONE, new Item[] {Items.RED_SANDSTONE_SLAB, Items.CUT_RED_SANDSTONE_SLAB, Items.SMOOTH_RED_SANDSTONE_SLAB}),
+            Triple.of("quartz_slabs_to_chiseled_quartz", Items.CHISELED_QUARTZ_BLOCK, new Item[] {Items.QUARTZ_SLAB, Items.SMOOTH_QUARTZ_SLAB, SuCraftItems.QUARTZ_BRICK_SLAB}),
+            Triple.of("quartz_to_quartz_pillar", Items.QUARTZ_PILLAR, new Item[] {Items.QUARTZ_BLOCK, Items.SMOOTH_QUARTZ})
+        )) {
+            String recipeKeyPath = triple.getLeft();
+            Item result = triple.getMiddle();
+            Item[] ingredients = triple.getRight();
+            var recipeMinecraftKey = ResourceLocation.sucraft(recipeKeyPath);
+            var recipeKey = recipeMinecraftKey.asBukkit();
+            var shapedRecipe = new ShapedRecipe(recipeKey, new org.bukkit.inventory.ItemStack(CraftMagicNumbers.getMaterial(result), result.equals(Items.QUARTZ_PILLAR) ? 2 : 1)); // For any pair of slabs, the result has amount 1, but for the quartz pillar (since the ingredients are full blocks) the result has amount 2
+            shapedRecipe.setGroup(recipeKey.getKey());
+            shapedRecipe.shape("$", "$");
+            shapedRecipe.setIngredient('$', new RecipeChoice.MaterialChoice(Arrays.stream(ingredients).map(ingredient -> CraftMagicNumbers.getMaterial(ingredient)).toArray(Material[]::new)));
+            addRecipe(shapedRecipe, false);
+            for (Item ingredient : ingredients) {
+                Item.CustomRecipeUnlockByItem.register(ingredient, recipeMinecraftKey);
+            }
+        }
+
+        // Deconstructing blocks
+        for (Triple<Item, Item, Integer> triple : List.of(
+            Triple.of(SuCraftItems.GUNPOWDER_BLOCK, Items.GUNPOWDER, 4),
+            // Not included in initial release
+//            Triple.of(SuCraftItems.ENDER_PEARL_BLOCK, Items.ENDER_PEARL, 4),
+            Triple.of(SuCraftItems.FLINT_BLOCK, Items.FLINT, 4),
+            Triple.of(SuCraftItems.THATCH, Items.WHEAT, 4),
+            Triple.of(SuCraftItems.CHARCOAL_BLOCK, Items.CHARCOAL, 9),
+            Triple.of(SuCraftItems.PAPER_BLOCK, Items.PAPER, 9)
+        )) {
+            Item ingredient = triple.getLeft();
+            Item result = triple.getMiddle();
+            int resultAmount = triple.getRight();
+            String recipeKeyPath = "deconstruct_" + ingredient.id.getPath();
+            var recipeMinecraftKey = ResourceLocation.sucraft(recipeKeyPath);
+            var recipeKey = recipeMinecraftKey.asBukkit();
+            var shapelessRecipe = new ShapelessRecipe(recipeKey, new org.bukkit.inventory.ItemStack(CraftMagicNumbers.getMaterial(result), resultAmount));
+            shapelessRecipe.setGroup(recipeKey.getKey());
+            shapelessRecipe.addIngredient(new org.bukkit.inventory.ItemStack(CraftMagicNumbers.getMaterial(ingredient)));
+            addRecipe(shapelessRecipe, false);
+            Item.CustomRecipeUnlockByItem.register(ingredient, recipeMinecraftKey);
+        }
+
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/item/SuCraftItemTags.java b/src/main/java/org/sucraft/suki/item/SuCraftItemTags.java
new file mode 100644
index 0000000000000000000000000000000000000000..5b8ac1a4dffcff588d9d4590b6a3246ac3901c91
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/item/SuCraftItemTags.java
@@ -0,0 +1,56 @@
+// Suki - custom resources
+
+package org.sucraft.suki.item;
+
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+
+/**
+ * Based on {@link net.minecraft.tags.ItemTags}
+ */
+public class SuCraftItemTags {
+
+    // Suki start - custom blocks and items
+    public static final TagKey<Item> BOOKSHELVES = bind("bookshelves");
+    public static final TagKey<Item> BOOKSHELF_FULL_BLOCKS = bind("bookshelf_full_blocks");
+    public static final TagKey<Item> BOOKSHELF_SLABS = bind("bookshelf_slabs");
+    public static final TagKey<Item> BOOKSHELF_STAIRS = bind("bookshelf_stairs");
+    public static final TagKey<Item> WOOL_FULL_BLOCKS = bind("wool_full_blocks");
+    public static final TagKey<Item> WOOL_SLABS = bind("wool_slabs");
+    public static final TagKey<Item> WOOL_STAIRS = bind("wool_stairs");
+    public static final TagKey<Item> LOG_FULL_BLOCKS = bind("log_full_blocks");
+    public static final TagKey<Item> LOG_SLABS = bind("log_slabs");
+    public static final TagKey<Item> LOG_STAIRS = bind("log_stairs");
+    public static final TagKey<Item> PLANK_FULL_BLOCKS = bind("plank_full_blocks");
+    public static final TagKey<Item> PLANK_SLABS = bind("plank_slabs");
+    public static final TagKey<Item> PLANK_STAIRS = bind("plank_stairs");
+    public static final TagKey<Item> DYED_PLANKS = bind("dyed_planks");
+    public static final TagKey<Item> DYED_PLANK_FULL_BLOCKS = bind("dyed_plank_full_blocks");
+    public static final TagKey<Item> DYED_PLANK_SLABS = bind("dyed_plank_slabs");
+    public static final TagKey<Item> DYED_PLANK_STAIRS = bind("dyed_plank_stairs");
+    public static final TagKey<Item> PEAT = bind("peat");
+    public static final TagKey<Item> PEAT_FULL_BLOCKS = bind("peat_full_blocks");
+    public static final TagKey<Item> PEAT_SLABS = bind("peat_slabs");
+    public static final TagKey<Item> PEAT_STAIRS = bind("peat_stairs");
+    public static final TagKey<Item> VANILLA_STONE_BRICKS = bind("vanilla_stone_bricks");
+    public static final TagKey<Item> VANILLA_PLANKS = bind("vanilla_planks");
+    public static final TagKey<Item> STONE_BRICK_FULL_BLOCKS = bind("stone_brick_full_blocks");
+    public static final TagKey<Item> STONE_BRICK_SLABS = bind("stone_brick_slabs");
+    public static final TagKey<Item> STONE_BRICK_STAIRS = bind("stone_brick_stairs");
+    public static final TagKey<Item> VANILLA_WOODEN_SLABS = bind("vanilla_wooden_slabs");
+    public static final TagKey<Item> VANILLA_WOODEN_STAIRS = bind("vanilla_wooden_stairs");
+    public static final TagKey<Item> VANILLA_LEAVES = bind("vanilla_leaves");
+    public static final TagKey<Item> VANILLA_DIRT = bind("vanilla_dirt");
+    public static final TagKey<Item> TERRACOTTA_FULL_BLOCKS = bind("terracotta_full_blocks");
+    public static final TagKey<Item> TERRACOTTA_SLABS = bind("terracotta_slabs");
+    public static final TagKey<Item> TERRACOTTA_STAIRS = bind("terracotta_stairs");
+    // Suki end - custom blocks and items
+
+    private static TagKey<Item> bind(String id) {
+        return TagKey.create(Registry.ITEM_REGISTRY, ResourceLocation.sucraft(id));
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/item/SuCraftItemTagsProvider.java b/src/main/java/org/sucraft/suki/item/SuCraftItemTagsProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..06b00cf921d89e2ba76508d3494b834cc6adec85
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/item/SuCraftItemTagsProvider.java
@@ -0,0 +1,79 @@
+// Suki - custom resources
+
+package org.sucraft.suki.item;
+
+import net.minecraft.core.Holder;
+import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.BlockTags;
+import net.minecraft.tags.ItemTags;
+import net.minecraft.tags.TagBuilder;
+import net.minecraft.tags.TagKey;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+import org.sucraft.suki.block.SuCraftBlockTags;
+import org.sucraft.suki.data.SuCraftTagsProvider;
+
+import java.util.List;
+import java.util.Map;
+import java.util.stream.StreamSupport;
+
+/**
+ * Based on {@link net.minecraft.data.tags.ItemTagsProvider}
+ */
+public class SuCraftItemTagsProvider extends SuCraftTagsProvider<Item> {
+
+    private Map<TagKey<Item>, List<Holder<Item>>> existingRegistryTagEntries = null;
+
+    public SuCraftItemTagsProvider(Registry<Item> registry) {
+        super(registry);
+    }
+
+
+    @Override
+    protected void addTags(Map<TagKey<Item>, List<Holder<Item>>> existingRegistryTagEntries) {
+        MinecraftServer.LOGGER.info("Adding onto existing item tags...");
+        this.existingRegistryTagEntries = existingRegistryTagEntries;
+
+        this.copy(SuCraftBlockTags.BOOKSHELVES, SuCraftItemTags.BOOKSHELVES);
+        this.copy(SuCraftBlockTags.BOOKSHELF_FULL_BLOCKS, SuCraftItemTags.BOOKSHELF_FULL_BLOCKS);
+        this.copy(SuCraftBlockTags.BOOKSHELF_SLABS, SuCraftItemTags.BOOKSHELF_SLABS);
+        this.copy(SuCraftBlockTags.BOOKSHELF_STAIRS, SuCraftItemTags.BOOKSHELF_STAIRS);
+        this.copy(SuCraftBlockTags.WOOL_FULL_BLOCKS, SuCraftItemTags.WOOL_FULL_BLOCKS);
+        this.copy(SuCraftBlockTags.WOOL_SLABS, SuCraftItemTags.WOOL_SLABS);
+        this.copy(SuCraftBlockTags.WOOL_STAIRS, SuCraftItemTags.WOOL_STAIRS);
+        this.copy(SuCraftBlockTags.LOG_FULL_BLOCKS, SuCraftItemTags.LOG_FULL_BLOCKS);
+        this.copy(SuCraftBlockTags.LOG_SLABS, SuCraftItemTags.LOG_SLABS);
+        this.copy(SuCraftBlockTags.LOG_STAIRS, SuCraftItemTags.LOG_STAIRS);
+        this.copy(SuCraftBlockTags.PLANK_FULL_BLOCKS, SuCraftItemTags.PLANK_FULL_BLOCKS);
+        this.copy(SuCraftBlockTags.PLANK_SLABS, SuCraftItemTags.PLANK_SLABS);
+        this.copy(SuCraftBlockTags.PLANK_STAIRS, SuCraftItemTags.PLANK_STAIRS);
+        this.copy(SuCraftBlockTags.DYED_PLANKS, SuCraftItemTags.DYED_PLANKS);
+        this.copy(SuCraftBlockTags.DYED_PLANK_FULL_BLOCKS, SuCraftItemTags.DYED_PLANK_FULL_BLOCKS);
+        this.copy(SuCraftBlockTags.DYED_PLANK_SLABS, SuCraftItemTags.DYED_PLANK_SLABS);
+        this.copy(SuCraftBlockTags.DYED_PLANK_STAIRS, SuCraftItemTags.DYED_PLANK_STAIRS);
+        this.copy(SuCraftBlockTags.PEAT, SuCraftItemTags.PEAT);
+        this.copy(SuCraftBlockTags.PEAT_FULL_BLOCKS, SuCraftItemTags.PEAT_FULL_BLOCKS);
+        this.copy(SuCraftBlockTags.PEAT_SLABS, SuCraftItemTags.PEAT_SLABS);
+        this.copy(SuCraftBlockTags.PEAT_STAIRS, SuCraftItemTags.PEAT_STAIRS);
+        this.copy(SuCraftBlockTags.VANILLA_STONE_BRICKS, SuCraftItemTags.VANILLA_STONE_BRICKS);
+        this.copy(SuCraftBlockTags.VANILLA_PLANKS, SuCraftItemTags.VANILLA_PLANKS);
+        this.copy(SuCraftBlockTags.STONE_BRICK_FULL_BLOCKS, SuCraftItemTags.STONE_BRICK_FULL_BLOCKS);
+        this.copy(SuCraftBlockTags.STONE_BRICK_SLABS, SuCraftItemTags.STONE_BRICK_SLABS);
+        this.copy(SuCraftBlockTags.STONE_BRICK_STAIRS, SuCraftItemTags.STONE_BRICK_STAIRS);
+        this.copy(SuCraftBlockTags.VANILLA_WOODEN_SLABS, SuCraftItemTags.VANILLA_WOODEN_SLABS);
+        this.copy(SuCraftBlockTags.VANILLA_WOODEN_STAIRS, SuCraftItemTags.VANILLA_WOODEN_STAIRS);
+        this.copy(SuCraftBlockTags.VANILLA_LEAVES, SuCraftItemTags.VANILLA_LEAVES);
+        this.copy(SuCraftBlockTags.VANILLA_DIRT, SuCraftItemTags.VANILLA_DIRT);
+        this.copy(SuCraftBlockTags.TERRACOTTA_FULL_BLOCKS, SuCraftItemTags.TERRACOTTA_FULL_BLOCKS);
+        this.copy(SuCraftBlockTags.TERRACOTTA_SLABS, SuCraftItemTags.TERRACOTTA_SLABS);
+        this.copy(SuCraftBlockTags.TERRACOTTA_STAIRS, SuCraftItemTags.TERRACOTTA_STAIRS);
+
+        this.existingRegistryTagEntries = null;
+    }
+
+    protected void copy(TagKey<Block> blockTag, TagKey<Item> itemTag) {
+        this.tag(itemTag).add(StreamSupport.stream(Registry.BLOCK.getTagOrEmpty(blockTag).spliterator(), false).map(holder -> holder.value().asItem()).toArray(Item[]::new));
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/item/SuCraftItems.java b/src/main/java/org/sucraft/suki/item/SuCraftItems.java
new file mode 100644
index 0000000000000000000000000000000000000000..e563e8bbcbaf887fe6a25f5c37d2385e92a8e9f4
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/item/SuCraftItems.java
@@ -0,0 +1,886 @@
+
+// Suki - custom blocks and items
+
+package org.sucraft.suki.item;
+
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.kyori.adventure.text.serializer.gson.GsonComponentSerializer;
+import net.minecraft.ChatFormatting;
+import net.minecraft.core.Registry;
+import net.minecraft.world.item.CreativeModeTab;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Blocks;
+import org.sucraft.suki.block.SuCraftBlocks;
+import org.sucraft.suki.block.replacementrule.BlockReplacementRule;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+/**
+ * Based on {@link net.minecraft.world.item.Items}
+ */
+public class SuCraftItems {
+
+    public static final @NotNull ChatFormatting CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR = ChatFormatting.DARK_GRAY;
+    public static final @Nullable TextColor RENDERS_AS_ENTITY_DISPLAY_NAME_COLOR = null;//TextColor.color(0xdddcf8);
+    public static final @Nullable TextColor RENDERS_AS_ENTITY_DISPLAY_NAME_IN_LORE_COLOR = null;//TextColor.color(0x7877a3);
+    public static final @NotNull TextColor RENDERS_AS_ENTITY_LORE_ADDITION_COLOR = NamedTextColor.DARK_GRAY;
+    public static final @NotNull String RENDERS_AS_ENTITY_LORE_ADDITION_TEXT = "Entity";
+    public static final @NotNull String RENDERS_AS_ENTITY_LORE_ADDITION_JSON = GsonComponentSerializer.gson().serialize(net.kyori.adventure.text.Component.text(SuCraftItems.RENDERS_AS_ENTITY_LORE_ADDITION_TEXT, SuCraftItems.RENDERS_AS_ENTITY_LORE_ADDITION_COLOR).decoration(TextDecoration.ITALIC, false));
+
+    public static final Item SNOWY_STONE_BRICKS = registerStoneBricks(SuCraftBlocks.SNOWY_STONE_BRICKS, "Snowy", () -> Items.STONE_BRICKS);
+    public static final Item DIRTY_STONE_BRICKS = registerStoneBricks(SuCraftBlocks.DIRTY_STONE_BRICKS, "Dirty", () -> Items.STONE_BRICKS);
+    public static final Item INFESTED_SNOWY_STONE_BRICKS = registerInfested(SuCraftBlocks.INFESTED_SNOWY_STONE_BRICKS, "Snowy Stone Bricks", () -> Items.STONE_BRICKS);
+    public static final Item INFESTED_DIRTY_STONE_BRICKS = registerInfested(SuCraftBlocks.INFESTED_DIRTY_STONE_BRICKS, "Dirty Stone Bricks", () -> Items.STONE_BRICKS);
+    public static final Item SPRUCE_BOOKSHELF = registerBookshelf(SuCraftBlocks.SPRUCE_BOOKSHELF, "Spruce", () -> Items.SPRUCE_PLANKS);
+    public static final Item BIRCH_BOOKSHELF = registerBookshelf(SuCraftBlocks.BIRCH_BOOKSHELF, "Birch", () -> Items.BIRCH_PLANKS);
+    public static final Item JUNGLE_BOOKSHELF = registerBookshelf(SuCraftBlocks.JUNGLE_BOOKSHELF, "Jungle", () -> Items.JUNGLE_PLANKS);
+    public static final Item ACACIA_BOOKSHELF = registerBookshelf(SuCraftBlocks.ACACIA_BOOKSHELF, "Acacia", () -> Items.ACACIA_PLANKS);
+    public static final Item DARK_OAK_BOOKSHELF = registerBookshelf(SuCraftBlocks.DARK_OAK_BOOKSHELF, "Dark Oak", () -> Items.DARK_OAK_PLANKS);
+    public static final Item WARPED_BOOKSHELF = registerBookshelf(SuCraftBlocks.WARPED_BOOKSHELF, "Warped", () -> Items.WARPED_PLANKS);
+    public static final Item CRIMSON_BOOKSHELF = registerBookshelf(SuCraftBlocks.CRIMSON_BOOKSHELF, "Crimson", () -> Items.CRIMSON_PLANKS);
+//    public static final Item MANGROVE_BOOKSHELF = registerBookshelf(SuCraftBlocks.MANGROVE_BOOKSHELF, "Mangrove", () -> Items.MANGROVE_PLANKS);
+    public static final Item BLACK_PLANKS = registerPlanks(SuCraftBlocks.BLACK_PLANKS, "Black", () -> Items.BLACK_CONCRETE);
+    public static final Item BLUE_PLANKS = registerPlanks(SuCraftBlocks.BLUE_PLANKS, "Blue", () -> Items.BLUE_CONCRETE);
+    public static final Item BROWN_PLANKS = registerPlanks(SuCraftBlocks.BROWN_PLANKS, "Brown", () -> Items.BROWN_CONCRETE);
+    public static final Item CYAN_PLANKS = registerPlanks(SuCraftBlocks.CYAN_PLANKS, "Cyan", () -> Items.CYAN_CONCRETE);
+    public static final Item GRAY_PLANKS = registerPlanks(SuCraftBlocks.GRAY_PLANKS, "Gray", () -> Items.GRAY_CONCRETE);
+    public static final Item GREEN_PLANKS = registerPlanks(SuCraftBlocks.GREEN_PLANKS, "Green", () -> Items.GREEN_CONCRETE);
+    public static final Item LIGHT_BLUE_PLANKS = registerPlanks(SuCraftBlocks.LIGHT_BLUE_PLANKS, "Light Blue", () -> Items.LIGHT_BLUE_CONCRETE);
+    public static final Item LIGHT_GRAY_PLANKS = registerPlanks(SuCraftBlocks.LIGHT_GRAY_PLANKS, "Light Gray", () -> Items.LIGHT_GRAY_CONCRETE);
+    public static final Item LIME_PLANKS = registerPlanks(SuCraftBlocks.LIME_PLANKS, "Lime", () -> Items.LIME_CONCRETE);
+    public static final Item MAGENTA_PLANKS = registerPlanks(SuCraftBlocks.MAGENTA_PLANKS, "Magenta", () -> Items.MAGENTA_CONCRETE);
+    public static final Item ORANGE_PLANKS = registerPlanks(SuCraftBlocks.ORANGE_PLANKS, "Orange", () -> Items.ORANGE_CONCRETE);
+    public static final Item PINK_PLANKS = registerPlanks(SuCraftBlocks.PINK_PLANKS, "Pink", () -> Items.PINK_CONCRETE);
+    public static final Item PURPLE_PLANKS = registerPlanks(SuCraftBlocks.PURPLE_PLANKS, "Purple", () -> Items.PURPLE_CONCRETE);
+    public static final Item RED_PLANKS = registerPlanks(SuCraftBlocks.RED_PLANKS, "Red", () -> Items.RED_CONCRETE);
+    public static final Item WHITE_PLANKS = registerPlanks(SuCraftBlocks.WHITE_PLANKS, "White", () -> Items.WHITE_CONCRETE);
+    public static final Item YELLOW_PLANKS = registerPlanks(SuCraftBlocks.YELLOW_PLANKS, "Yellow", () -> Items.YELLOW_CONCRETE);
+    public static final Item DIRT_BRICKS = registerBricks(SuCraftBlocks.DIRT_BRICKS, "Dirt", () -> Items.DIRT);
+    public static final Item POLISHED_CALCITE = registerPolished(SuCraftBlocks.POLISHED_CALCITE, "Calcite", () -> Items.CALCITE);
+    public static final Item POLISHED_DRIPSTONE = registerPolished(SuCraftBlocks.POLISHED_DRIPSTONE, "Dripstone", () -> Items.DRIPSTONE_BLOCK);
+    public static final Item POLISHED_TUFF = registerPolished(SuCraftBlocks.POLISHED_TUFF, "Tuff", () -> Items.TUFF);
+    public static final Item ANDESITE_BRICKS = registerBricks(SuCraftBlocks.ANDESITE_BRICKS, "Andesite", () -> Items.POLISHED_ANDESITE);
+    public static final Item CALCITE_BRICKS = registerBricks(SuCraftBlocks.CALCITE_BRICKS, "Calcite", () -> Items.CALCITE);
+    public static final Item DIORITE_BRICKS = registerBricks(SuCraftBlocks.DIORITE_BRICKS, "Diorite", () -> Items.POLISHED_DIORITE);
+    public static final Item DRIPSTONE_BRICKS = registerBricks(SuCraftBlocks.DRIPSTONE_BRICKS, "Dripstone", () -> Items.DRIPSTONE_BLOCK);
+    public static final Item GRANITE_BRICKS = registerBricks(SuCraftBlocks.GRANITE_BRICKS, "Granite", () -> Items.POLISHED_GRANITE);
+    public static final Item TUFF_BRICKS = registerBricks(SuCraftBlocks.TUFF_BRICKS, "Tuff", () -> Items.TUFF);
+    public static final Item CHISELED_ANDESITE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_ANDESITE_BRICKS, "Andesite", () -> Items.POLISHED_ANDESITE);
+    public static final Item CHISELED_CALCITE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_CALCITE_BRICKS, "Calcite", () -> Items.CALCITE);
+    public static final Item CHISELED_DIORITE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_DIORITE_BRICKS, "Diorite", () -> Items.POLISHED_DIORITE);
+    public static final Item CHISELED_DRIPSTONE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_DRIPSTONE_BRICKS, "Dripstone", () -> Items.DRIPSTONE_BLOCK);
+    public static final Item CHISELED_GRANITE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_GRANITE_BRICKS, "Granite", () -> Items.POLISHED_GRANITE);
+    public static final Item CHISELED_TUFF_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_TUFF_BRICKS, "Tuff", () -> Items.TUFF);
+
+    /**
+     * Based on {@link Items#SANDSTONE}
+     */
+    public static final Item SOUL_SANDSTONE = registerBlock(SuCraftBlocks.SOUL_SANDSTONE, "Soul Sandstone", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.SOUL_SOIL));
+
+    public static final Item SANDSTONE_BRICKS = registerBricks(SuCraftBlocks.SANDSTONE_BRICKS, "Sandstone", () -> Items.SANDSTONE);
+    public static final Item RED_SANDSTONE_BRICKS = registerBricks(SuCraftBlocks.RED_SANDSTONE_BRICKS, "Red Sandstone", () -> Items.RED_SANDSTONE);
+
+    /**
+     * Based on {@link Items#CHISELED_SANDSTONE}
+     */
+    public static final Item CHISELED_SOUL_SANDSTONE = registerBlock(SuCraftBlocks.CHISELED_SOUL_SANDSTONE, "Chiseled Soul Sandstone", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.SOUL_SOIL));
+
+    /**
+     * Based on {@link Items#CUT_SANDSTONE}
+     */
+    public static final Item CUT_SOUL_SANDSTONE = registerBlock(SuCraftBlocks.CUT_SOUL_SANDSTONE, "Cut Soul Sandstone", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.SOUL_SOIL));
+
+    public static final Item SOUL_SANDSTONE_BRICKS = registerBricks(SuCraftBlocks.SOUL_SANDSTONE_BRICKS, "Soul Sandstone", () -> Items.SOUL_SOIL);
+    // Not included in initial release
+//    public static final Item ANDESITE_COBBLESTONE = registerCobblestone(SuCraftBlocks.ANDESITE_COBBLESTONE, "Andesite", () -> Items.ANDESITE);
+//    public static final Item DIORITE_COBBLESTONE = registerCobblestone(SuCraftBlocks.DIORITE_COBBLESTONE, "Diorite", () -> Items.DIORITE);
+//    public static final Item GRANITE_COBBLESTONE = registerCobblestone(SuCraftBlocks.GRANITE_COBBLESTONE, "Granite", () -> Items.GRANITE);
+    public static final Item CHISELED_PRISMARINE_BRICKS = registerChiseledBricks(SuCraftBlocks.CHISELED_PRISMARINE_BRICKS, "Prismarine", () -> Items.PRISMARINE_BRICKS);
+    public static final Item ANDESITE_PILLAR = registerPillar(SuCraftBlocks.ANDESITE_PILLAR, "Andesite", () -> Items.POLISHED_ANDESITE);
+    public static final Item CALCITE_PILLAR = registerPillar(SuCraftBlocks.CALCITE_PILLAR, "Calcite", () -> Items.CALCITE);
+    public static final Item DIORITE_PILLAR = registerPillar(SuCraftBlocks.DIORITE_PILLAR, "Diorite", () -> Items.POLISHED_DIORITE);
+    public static final Item DRIPSTONE_PILLAR = registerPillar(SuCraftBlocks.DRIPSTONE_PILLAR, "Dripstone", () -> Items.DRIPSTONE_BLOCK);
+    public static final Item GRANITE_PILLAR = registerPillar(SuCraftBlocks.GRANITE_PILLAR, "Granite", () -> Items.POLISHED_GRANITE);
+    public static final Item TUFF_PILLAR = registerPillar(SuCraftBlocks.TUFF_PILLAR, "Tuff", () -> Items.TUFF);
+    // Not included in initial release
+//    public static final Item RUSTY_BIRCH_LEAVES = registerLeaves(SuCraftBlocks.RUSTY_BIRCH_LEAVES, "Rusty Birch", () -> Items.ACACIA_LEAVES);
+    public static final Item PALE_BIRCH_LEAVES = registerLeaves(SuCraftBlocks.PALE_BIRCH_LEAVES, "Pale Birch", () -> Items.ACACIA_LEAVES);
+    public static final Item RED_OAK_LEAVES = registerLeaves(SuCraftBlocks.RED_OAK_LEAVES, "Red Oak", () -> Items.ACACIA_LEAVES);
+    public static final Item ORANGE_OAK_LEAVES = registerLeaves(SuCraftBlocks.ORANGE_OAK_LEAVES, "Orange Oak", () -> Items.ACACIA_LEAVES);
+    public static final Item RED_MAPLE_LEAVES = registerLeaves(SuCraftBlocks.RED_MAPLE_LEAVES, "Red Maple", () -> Items.ACACIA_LEAVES);
+    public static final Item ORANGE_MAPLE_LEAVES = registerLeaves(SuCraftBlocks.ORANGE_MAPLE_LEAVES, "Orange Maple", () -> Items.ACACIA_LEAVES);
+    public static final Item YELLOW_MAPLE_LEAVES = registerLeaves(SuCraftBlocks.YELLOW_MAPLE_LEAVES, "Yellow Maple", () -> Items.ACACIA_LEAVES);
+    public static final Item DIRT_SLAB = registerSlab(SuCraftBlocks.DIRT_SLAB, "Dirt");
+    public static final Item SNOWY_STONE_BRICK_SLAB = registerSlab(SuCraftBlocks.SNOWY_STONE_BRICK_SLAB, "Snowy Stone Brick");
+    public static final Item DIRTY_STONE_BRICK_SLAB = registerSlab(SuCraftBlocks.DIRTY_STONE_BRICK_SLAB, "Dirty Stone Brick");
+    public static final Item CRACKED_STONE_BRICK_SLAB = registerSlab(SuCraftBlocks.CRACKED_STONE_BRICK_SLAB, "Cracked Stone Brick");
+    public static final Item BLACK_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.BLACK_PLANK_SLAB, "Black");
+    public static final Item BLUE_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.BLUE_PLANK_SLAB, "Blue");
+    public static final Item BROWN_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.BROWN_PLANK_SLAB, "Brown");
+    public static final Item CYAN_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.CYAN_PLANK_SLAB, "Cyan");
+    public static final Item GRAY_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.GRAY_PLANK_SLAB, "Gray");
+    public static final Item GREEN_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.GREEN_PLANK_SLAB, "Green");
+    public static final Item LIGHT_BLUE_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.LIGHT_BLUE_PLANK_SLAB, "Light Blue");
+    public static final Item LIGHT_GRAY_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.LIGHT_GRAY_PLANK_SLAB, "Light Gray");
+    public static final Item LIME_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.LIME_PLANK_SLAB, "Lime");
+    public static final Item MAGENTA_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.MAGENTA_PLANK_SLAB, "Magenta");
+    public static final Item ORANGE_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.ORANGE_PLANK_SLAB, "Orange");
+    public static final Item PINK_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.PINK_PLANK_SLAB, "Pink");
+    public static final Item PURPLE_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.PURPLE_PLANK_SLAB, "Purple");
+    public static final Item RED_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.RED_PLANK_SLAB, "Red");
+    public static final Item WHITE_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.WHITE_PLANK_SLAB, "White");
+    public static final Item YELLOW_PLANK_SLAB = registerPlankSlab(SuCraftBlocks.YELLOW_PLANK_SLAB, "Yellow");
+    public static final Item BLACK_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.BLACK_WOOL_SLAB, "Black");
+    public static final Item BLUE_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.BLUE_WOOL_SLAB, "Blue");
+    public static final Item BROWN_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.BROWN_WOOL_SLAB, "Brown");
+    public static final Item CYAN_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.CYAN_WOOL_SLAB, "Cyan");
+    public static final Item GRAY_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.GRAY_WOOL_SLAB, "Gray");
+    public static final Item GREEN_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.GREEN_WOOL_SLAB, "Green");
+    public static final Item LIGHT_BLUE_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.LIGHT_BLUE_WOOL_SLAB, "Light Blue");
+    public static final Item LIGHT_GRAY_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.LIGHT_GRAY_WOOL_SLAB, "Light Gray");
+    public static final Item LIME_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.LIME_WOOL_SLAB, "Lime");
+    public static final Item MAGENTA_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.MAGENTA_WOOL_SLAB, "Magenta");
+    public static final Item ORANGE_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.ORANGE_WOOL_SLAB, "Orange");
+    public static final Item PINK_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.PINK_WOOL_SLAB, "Pink");
+    public static final Item PURPLE_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.PURPLE_WOOL_SLAB, "Purple");
+    public static final Item RED_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.RED_WOOL_SLAB, "Red");
+    public static final Item WHITE_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.WHITE_WOOL_SLAB, "White");
+    public static final Item YELLOW_WOOL_SLAB = registerWoolSlab(SuCraftBlocks.YELLOW_WOOL_SLAB, "Yellow");
+    public static final Item BLACK_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.BLACK_CONCRETE_SLAB, "Black");
+    public static final Item BLUE_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.BLUE_CONCRETE_SLAB, "Blue");
+    public static final Item BROWN_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.BROWN_CONCRETE_SLAB, "Brown");
+    public static final Item CYAN_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.CYAN_CONCRETE_SLAB, "Cyan");
+    public static final Item GRAY_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.GRAY_CONCRETE_SLAB, "Gray");
+    public static final Item GREEN_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.GREEN_CONCRETE_SLAB, "Green");
+    public static final Item LIGHT_BLUE_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.LIGHT_BLUE_CONCRETE_SLAB, "Light Blue");
+    public static final Item LIGHT_GRAY_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.LIGHT_GRAY_CONCRETE_SLAB, "Light Gray");
+    public static final Item LIME_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.LIME_CONCRETE_SLAB, "Lime");
+    public static final Item MAGENTA_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.MAGENTA_CONCRETE_SLAB, "Magenta");
+    public static final Item ORANGE_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.ORANGE_CONCRETE_SLAB, "Orange");
+    public static final Item PINK_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.PINK_CONCRETE_SLAB, "Pink");
+    public static final Item PURPLE_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.PURPLE_CONCRETE_SLAB, "Purple");
+    public static final Item RED_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.RED_CONCRETE_SLAB, "Red");
+    public static final Item WHITE_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.WHITE_CONCRETE_SLAB, "White");
+    public static final Item YELLOW_CONCRETE_SLAB = registerConcreteSlab(SuCraftBlocks.YELLOW_CONCRETE_SLAB, "Yellow");
+    public static final Item BLACK_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.BLACK_CONCRETE_POWDER_SLAB, "Black");
+    public static final Item BLUE_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.BLUE_CONCRETE_POWDER_SLAB, "Blue");
+    public static final Item BROWN_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.BROWN_CONCRETE_POWDER_SLAB, "Brown");
+    public static final Item CYAN_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.CYAN_CONCRETE_POWDER_SLAB, "Cyan");
+    public static final Item GRAY_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.GRAY_CONCRETE_POWDER_SLAB, "Gray");
+    public static final Item GREEN_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.GREEN_CONCRETE_POWDER_SLAB, "Green");
+    public static final Item LIGHT_BLUE_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.LIGHT_BLUE_CONCRETE_POWDER_SLAB, "Light Blue");
+    public static final Item LIGHT_GRAY_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.LIGHT_GRAY_CONCRETE_POWDER_SLAB, "Light Gray");
+    public static final Item LIME_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.LIME_CONCRETE_POWDER_SLAB, "Lime");
+    public static final Item MAGENTA_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.MAGENTA_CONCRETE_POWDER_SLAB, "Magenta");
+    public static final Item ORANGE_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.ORANGE_CONCRETE_POWDER_SLAB, "Orange");
+    public static final Item PINK_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.PINK_CONCRETE_POWDER_SLAB, "Pink");
+    public static final Item PURPLE_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.PURPLE_CONCRETE_POWDER_SLAB, "Purple");
+    public static final Item RED_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.RED_CONCRETE_POWDER_SLAB, "Red");
+    public static final Item WHITE_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.WHITE_CONCRETE_POWDER_SLAB, "White");
+    public static final Item YELLOW_CONCRETE_POWDER_SLAB = registerConcretePowderSlab(SuCraftBlocks.YELLOW_CONCRETE_POWDER_SLAB, "Yellow");
+    public static final Item BLACK_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.BLACK_TERRACOTTA_SLAB, "Black");
+    public static final Item BLUE_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.BLUE_TERRACOTTA_SLAB, "Blue");
+    public static final Item BROWN_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.BROWN_TERRACOTTA_SLAB, "Brown");
+    public static final Item CYAN_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.CYAN_TERRACOTTA_SLAB, "Cyan");
+    public static final Item GRAY_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.GRAY_TERRACOTTA_SLAB, "Gray");
+    public static final Item GREEN_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.GREEN_TERRACOTTA_SLAB, "Green");
+    public static final Item LIGHT_BLUE_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.LIGHT_BLUE_TERRACOTTA_SLAB, "Light Blue");
+    public static final Item LIGHT_GRAY_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.LIGHT_GRAY_TERRACOTTA_SLAB, "Light Gray");
+    public static final Item LIME_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.LIME_TERRACOTTA_SLAB, "Lime");
+    public static final Item MAGENTA_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.MAGENTA_TERRACOTTA_SLAB, "Magenta");
+    public static final Item ORANGE_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.ORANGE_TERRACOTTA_SLAB, "Orange");
+    public static final Item PINK_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.PINK_TERRACOTTA_SLAB, "Pink");
+    public static final Item PURPLE_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.PURPLE_TERRACOTTA_SLAB, "Purple");
+    public static final Item RED_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.RED_TERRACOTTA_SLAB, "Red");
+    public static final Item WHITE_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.WHITE_TERRACOTTA_SLAB, "White");
+    public static final Item YELLOW_TERRACOTTA_SLAB = registerTerracottaSlab(SuCraftBlocks.YELLOW_TERRACOTTA_SLAB, "Yellow Terracotta");
+    public static final Item COARSE_DIRT_SLAB = registerSlab(SuCraftBlocks.COARSE_DIRT_SLAB, "Coarse Dirt");
+    public static final Item SAND_SLAB = registerSlab(SuCraftBlocks.SAND_SLAB, "Sand");
+    public static final Item RED_SAND_SLAB = registerSlab(SuCraftBlocks.RED_SAND_SLAB, "Red Sand");
+    public static final Item CLAY_SLAB = registerSlab(SuCraftBlocks.CLAY_SLAB, "Clay");
+    public static final Item MUD_SLAB = registerSlab(SuCraftBlocks.MUD_SLAB, "Mud");
+    public static final Item PACKED_MUD_SLAB = registerSlab(SuCraftBlocks.PACKED_MUD_SLAB, "Packed Mud");
+    public static final Item AMETHYST_SLAB = registerSlab(SuCraftBlocks.AMETHYST_SLAB, "Amethyst");
+    public static final Item COAL_SLAB = registerSlab(SuCraftBlocks.COAL_SLAB, "Coal");
+    public static final Item OAK_BOOKSHELF_SLAB = registerBookshelfSlab(SuCraftBlocks.OAK_BOOKSHELF_SLAB, "Oak");
+    public static final Item SPRUCE_BOOKSHELF_SLAB = registerBookshelfSlab(SuCraftBlocks.SPRUCE_BOOKSHELF_SLAB, "Spruce");
+    public static final Item BIRCH_BOOKSHELF_SLAB = registerBookshelfSlab(SuCraftBlocks.BIRCH_BOOKSHELF_SLAB, "Birch");
+    public static final Item JUNGLE_BOOKSHELF_SLAB = registerBookshelfSlab(SuCraftBlocks.JUNGLE_BOOKSHELF_SLAB, "Jungle");
+    public static final Item CALCITE_SLAB = registerSlab(SuCraftBlocks.CALCITE_SLAB, "Calcite");
+    public static final Item DRIPSTONE_SLAB = registerSlab(SuCraftBlocks.DRIPSTONE_SLAB, "Dripstone");
+    public static final Item TUFF_SLAB = registerSlab(SuCraftBlocks.TUFF_SLAB, "Tuff");
+    public static final Item POLISHED_CALCITE_SLAB = registerPolishedSlab(SuCraftBlocks.POLISHED_CALCITE_SLAB, "Calcite");
+    public static final Item POLISHED_DRIPSTONE_SLAB = registerPolishedSlab(SuCraftBlocks.POLISHED_DRIPSTONE_SLAB, "Dripstone");
+    public static final Item POLISHED_TUFF_SLAB = registerPolishedSlab(SuCraftBlocks.POLISHED_TUFF_SLAB, "Tuff");
+    public static final Item ANDESITE_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.ANDESITE_BRICK_SLAB, "Andesite");
+    public static final Item CALCITE_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.CALCITE_BRICK_SLAB, "Calcite");
+    public static final Item DIORITE_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.DIORITE_BRICK_SLAB, "Diorite");
+    public static final Item DRIPSTONE_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.DRIPSTONE_BRICK_SLAB, "Dripstone");
+    public static final Item GRANITE_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.GRANITE_BRICK_SLAB, "Granite");
+    public static final Item TUFF_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.TUFF_BRICK_SLAB, "Tuff");
+    public static final Item ANDESITE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.ANDESITE_PILLAR_SLAB, "Andesite");
+    public static final Item CALCITE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.CALCITE_PILLAR_SLAB, "Calcite");
+    public static final Item DIORITE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.DIORITE_PILLAR_SLAB, "Diorite");
+    public static final Item DRIPSTONE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.DRIPSTONE_PILLAR_SLAB, "Dripstone");
+    public static final Item GRANITE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.GRANITE_PILLAR_SLAB, "Granite");
+    public static final Item TUFF_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.TUFF_PILLAR_SLAB, "Tuff");
+    public static final Item SOUL_SANDSTONE_SLAB = registerSlab(SuCraftBlocks.SOUL_SANDSTONE_SLAB, "Soul Sandstone");
+    public static final Item SANDSTONE_BRICK_SLAB = registerSandstoneBrickSlab(SuCraftBlocks.SANDSTONE_BRICK_SLAB, null);
+    public static final Item RED_SANDSTONE_BRICK_SLAB = registerSandstoneBrickSlab(SuCraftBlocks.RED_SANDSTONE_BRICK_SLAB, "Red");
+    public static final Item SOUL_SANDSTONE_BRICK_SLAB = registerSandstoneBrickSlab(SuCraftBlocks.SOUL_SANDSTONE_BRICK_SLAB, "Soul");
+
+    /**
+     * Based on {@link Items#SMOOTH_SANDSTONE}
+     */
+    public static final Item SMOOTH_SOUL_SANDSTONE = registerBlock(SuCraftBlocks.SMOOTH_SOUL_SANDSTONE, "Smooth Soul Sandstone", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.SOUL_SOIL));
+
+    public static final Item SMOOTH_SOUL_SANDSTONE_SLAB = registerSlab(SuCraftBlocks.SMOOTH_SOUL_SANDSTONE_SLAB, "Smooth Soul Sandstone");
+    public static final Item CUT_SOUL_SANDSTONE_SLAB = registerSlab(SuCraftBlocks.CUT_SOUL_SANDSTONE_SLAB, "Cut Soul Sandstone");
+    public static final Item GRAVEL_SLAB = registerSlab(SuCraftBlocks.GRAVEL_SLAB, "Gravel");
+    public static final Item NETHERRACK_SLAB = registerSlab(SuCraftBlocks.NETHERRACK_SLAB, "Netherrack");
+    public static final Item SOUL_SOIL_SLAB = registerSlab(SuCraftBlocks.SOUL_SOIL_SLAB, "Soul Soil");
+    public static final Item RAW_COPPER_SLAB = registerRawMetalSlab(SuCraftBlocks.RAW_COPPER_SLAB, "Copper");
+    public static final Item RAW_GOLD_SLAB = registerRawMetalSlab(SuCraftBlocks.RAW_GOLD_SLAB, "Gold");
+    public static final Item RAW_IRON_SLAB = registerRawMetalSlab(SuCraftBlocks.RAW_IRON_SLAB, "Iron");
+    public static final Item ANCIENT_DEBRIS_SLAB = registerSlab(SuCraftBlocks.ANCIENT_DEBRIS_SLAB, "Ancient Debris");
+    public static final Item DIRT_BRICK_SLAB = registerSlab(SuCraftBlocks.DIRT_BRICK_SLAB, "Dirt Brick");
+    // Not included in initial release
+//    public static final Item STONE_PILLAR = registerPillar(SuCraftBlocks.STONE_PILLAR, "Stone", () -> Items.STONE);
+//    public static final Item STONE_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.STONE_PILLAR_SLAB, "Stone");
+    public static final Item OAK_LOG_SLAB = registerLogSlab(SuCraftBlocks.OAK_LOG_SLAB, "Oak");
+    public static final Item SPRUCE_LOG_SLAB = registerLogSlab(SuCraftBlocks.SPRUCE_LOG_SLAB, "Spruce");
+    public static final Item BIRCH_LOG_SLAB = registerLogSlab(SuCraftBlocks.BIRCH_LOG_SLAB, "Birch");
+    public static final Item JUNGLE_LOG_SLAB = registerLogSlab(SuCraftBlocks.JUNGLE_LOG_SLAB, "Jungle");
+    public static final Item ACACIA_LOG_SLAB = registerLogSlab(SuCraftBlocks.ACACIA_LOG_SLAB, "Acacia");
+    public static final Item DARK_OAK_LOG_SLAB = registerLogSlab(SuCraftBlocks.DARK_OAK_LOG_SLAB, "Dark Oak");
+    public static final Item WARPED_STEM_SLAB = registerStemSlab(SuCraftBlocks.WARPED_STEM_SLAB, "Warped");
+    public static final Item CRIMSON_STEM_SLAB = registerStemSlab(SuCraftBlocks.CRIMSON_STEM_SLAB, "Crimson");
+    public static final Item MANGROVE_LOG_SLAB = registerLogSlab(SuCraftBlocks.MANGROVE_LOG_SLAB, "Mangrove");
+    public static final Item STRIPPED_OAK_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_OAK_LOG_SLAB, "Oak");
+    public static final Item STRIPPED_SPRUCE_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_SPRUCE_LOG_SLAB, "Spruce");
+    public static final Item STRIPPED_BIRCH_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_BIRCH_LOG_SLAB, "Birch");
+    public static final Item STRIPPED_JUNGLE_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_JUNGLE_LOG_SLAB, "Jungle");
+    public static final Item STRIPPED_ACACIA_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_ACACIA_LOG_SLAB, "Acacia");
+    public static final Item STRIPPED_DARK_OAK_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_DARK_OAK_LOG_SLAB, "Dark Oak");
+    public static final Item STRIPPED_WARPED_STEM_SLAB = registerStrippedStemSlab(SuCraftBlocks.STRIPPED_WARPED_STEM_SLAB, "Warped");
+    public static final Item STRIPPED_CRIMSON_STEM_SLAB = registerStrippedStemSlab(SuCraftBlocks.STRIPPED_CRIMSON_STEM_SLAB, "Crimson");
+    public static final Item STRIPPED_MANGROVE_LOG_SLAB = registerStrippedLogSlab(SuCraftBlocks.STRIPPED_MANGROVE_LOG_SLAB, "Mangrove");
+    public static final Item OAK_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.OAK_WOOD_SLAB, "Oak");
+    public static final Item SPRUCE_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.SPRUCE_WOOD_SLAB, "Spruce");
+    public static final Item BIRCH_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.BIRCH_WOOD_SLAB, "Birch");
+    public static final Item JUNGLE_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.JUNGLE_WOOD_SLAB, "Jungle");
+    public static final Item ACACIA_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.ACACIA_WOOD_SLAB, "Acacia");
+    public static final Item DARK_OAK_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.DARK_OAK_WOOD_SLAB, "Dark Oak");
+    public static final Item WARPED_HYPHAE_SLAB = registerHyphaeSlab(SuCraftBlocks.WARPED_HYPHAE_SLAB, "Warped");
+    public static final Item CRIMSON_HYPHAE_SLAB = registerHyphaeSlab(SuCraftBlocks.CRIMSON_HYPHAE_SLAB, "Crimson");
+    public static final Item MANGROVE_WOOD_SLAB = registerWoodSlab(SuCraftBlocks.MANGROVE_WOOD_SLAB, "Mangrove");
+    public static final Item STRIPPED_OAK_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_OAK_WOOD_SLAB, "Oak");
+    public static final Item STRIPPED_SPRUCE_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_SPRUCE_WOOD_SLAB, "Spruce");
+    public static final Item STRIPPED_BIRCH_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_BIRCH_WOOD_SLAB, "Birch");
+    public static final Item STRIPPED_JUNGLE_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_JUNGLE_WOOD_SLAB, "Jungle");
+    public static final Item STRIPPED_ACACIA_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_ACACIA_WOOD_SLAB, "Acacia");
+    public static final Item STRIPPED_DARK_OAK_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_DARK_OAK_WOOD_SLAB, "Dark Oak");
+    public static final Item STRIPPED_WARPED_HYPHAE_SLAB = registerStrippedHyphaeSlab(SuCraftBlocks.STRIPPED_WARPED_HYPHAE_SLAB, "Warped");
+    public static final Item STRIPPED_CRIMSON_HYPHAE_SLAB = registerStrippedHyphaeSlab(SuCraftBlocks.STRIPPED_CRIMSON_HYPHAE_SLAB, "Crimson");
+    public static final Item STRIPPED_MANGROVE_WOOD_SLAB = registerStrippedWoodSlab(SuCraftBlocks.STRIPPED_MANGROVE_WOOD_SLAB, "Mangrove");
+    public static final Item BONE_SLAB = registerSlab(SuCraftBlocks.BONE_SLAB, "Bone");
+
+    /**
+     * Based on {@link Items#BONE_BLOCK}
+     */
+    public static final Item WITHER_BONE_BLOCK = registerBlock(SuCraftBlocks.WITHER_BONE_BLOCK, "Wither Bone Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.COAL_BLOCK));
+
+    public static final Item WITHER_BONE_SLAB = registerSlab(SuCraftBlocks.WITHER_BONE_SLAB, "Wither Bone");
+    public static final Item BASALT_SLAB = registerSlab(SuCraftBlocks.BASALT_SLAB, "Basalt");
+    public static final Item POLISHED_BASALT_SLAB = registerSlab(SuCraftBlocks.POLISHED_BASALT_SLAB, "Polished Basalt");
+    public static final Item SMOOTH_BASALT_SLAB = registerSlab(SuCraftBlocks.SMOOTH_BASALT_SLAB, "Smooth Basalt");
+
+    /**
+     * Based on {@link Items#COAL_BLOCK}
+     */
+    public static final Item CHARCOAL_BLOCK = registerBlock(SuCraftBlocks.CHARCOAL_BLOCK, "Charcoal Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.COAL_BLOCK));
+
+    public static final Item CHARCOAL_SLAB = registerSlab(SuCraftBlocks.CHARCOAL_SLAB, "Charcoal");
+
+    /**
+     * Based on {@link Items#LIGHT_GRAY_CONCRETE_POWDER}
+     */
+    public static final Item GUNPOWDER_BLOCK = registerBlock(SuCraftBlocks.GUNPOWDER_BLOCK, "Gunpowder Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.LIGHT_GRAY_CONCRETE_POWDER));
+
+    public static final Item GUNPOWDER_SLAB = registerSlab(SuCraftBlocks.GUNPOWDER_SLAB, "Gunpowder");
+    public static final Item PEAT = registerBlock(SuCraftBlocks.PEAT, "Peat", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.COARSE_DIRT));
+    public static final Item SMOULDERING_PEAT = registerBlock(SuCraftBlocks.SMOULDERING_PEAT, "Smouldering Peat", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.COARSE_DIRT));
+    public static final Item PEAT_SLAB = registerSlab(SuCraftBlocks.PEAT_SLAB, "Peat");
+    // Not included in initial release
+//    public static final Item SCULK_SLAB = registerSlab(SuCraftBlocks.SCULK_SLAB, "Sculk");
+    public static final Item CHISELED_QUARTZ_SLAB = registerSlab(SuCraftBlocks.CHISELED_QUARTZ_SLAB, "Chiseled Quartz");
+    public static final Item QUARTZ_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.QUARTZ_PILLAR_SLAB, "Quartz");
+    public static final Item QUARTZ_BRICK_SLAB = registerBrickSlab(SuCraftBlocks.QUARTZ_BRICK_SLAB, "Quartz");
+    // Not included in initial release
+//    public static final Item DRIED_KELP_SLAB = registerSlab(SuCraftBlocks.DRIED_KELP_SLAB, "Dried Kelp");
+    public static final Item PAPER_BLOCK = registerBlock(SuCraftBlocks.PAPER_BLOCK, "Paper Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.WHITE_WOOL));
+    public static final Item PAPER_SLAB = registerSlab(SuCraftBlocks.PAPER_SLAB, "Paper");
+    public static final Item QUARTZ_SPIRAL_MEANDER = registerBlock(SuCraftBlocks.QUARTZ_SPIRAL_MEANDER, "Quartz Meander", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.CHISELED_QUARTZ_BLOCK));
+    public static final Item QUARTZ_SPIRAL_MEANDER_SLAB = registerSlab(SuCraftBlocks.QUARTZ_SPIRAL_MEANDER_SLAB, "Quartz Meander");
+    // Not included in initial release
+//    public static final Item ENDER_PEARL_BLOCK = registerBlock(SuCraftBlocks.ENDER_PEARL_BLOCK, "Ender Pearl Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.WARPED_PLANKS));
+    public static final Item FLINT_BLOCK = registerBlock(SuCraftBlocks.FLINT_BLOCK, "Flint Block", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.DEEPSLATE_TILES));
+    public static final Item FLINT_PILLAR = registerBlock(SuCraftBlocks.FLINT_PILLAR, "Flint Pillar", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.POLISHED_BASALT));
+    public static final Item FLINT_PILLAR_SLAB = registerSlab(SuCraftBlocks.FLINT_PILLAR_SLAB, "Flint Pillar");
+    public static final Item FLINT_TILES = registerBlock(SuCraftBlocks.FLINT_TILES, "Flint Tiles", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(() -> Items.DEEPSLATE_TILES));
+    public static final Item FLINT_TILE_SLAB = registerSlab(SuCraftBlocks.FLINT_TILE_SLAB, "Flint Tile");
+    public static final Item OBSIDIAN_SLAB = registerSlab(SuCraftBlocks.OBSIDIAN_SLAB, "Obsidian");
+    public static final Item CRYING_OBSIDIAN_SLAB = registerSlab(SuCraftBlocks.CRYING_OBSIDIAN_SLAB, "Crying Obsidian");
+    public static final Item GILDED_BLACKSTONE_SLAB = registerSlab(SuCraftBlocks.GILDED_BLACKSTONE_SLAB, "Gilded Blackstone");
+    public static final Item SNOWY_STONE_BRICK_STAIRS = registerStairs(SuCraftBlocks.SNOWY_STONE_BRICK_STAIRS, "Snowy Stone Brick");
+    public static final Item DIRTY_STONE_BRICK_STAIRS = registerStairs(SuCraftBlocks.DIRTY_STONE_BRICK_STAIRS, "Dirty Stone Brick");
+    public static final Item CRACKED_STONE_BRICK_STAIRS = registerStairs(SuCraftBlocks.CRACKED_STONE_BRICK_STAIRS, "Cracked Stone Brick");
+    public static final Item AMETHYST_STAIRS = registerStairs(SuCraftBlocks.AMETHYST_STAIRS, "Amethyst");
+    public static final Item COAL_STAIRS = registerStairs(SuCraftBlocks.COAL_STAIRS, "Coal");
+    public static final Item DRIPSTONE_STAIRS = registerStairs(SuCraftBlocks.DRIPSTONE_STAIRS, "Dripstone");
+    public static final Item DIRT_BRICK_STAIRS = registerStairs(SuCraftBlocks.DIRT_BRICK_STAIRS, "Dirt Brick");
+    public static final Item CHARCOAL_STAIRS = registerStairs(SuCraftBlocks.CHARCOAL_STAIRS, "Charcoal");
+    public static final Item GUNPOWDER_STAIRS = registerStairs(SuCraftBlocks.GUNPOWDER_STAIRS, "Gunpowder");
+    public static final Item PEAT_STAIRS = registerStairs(SuCraftBlocks.PEAT_STAIRS, "Peat");
+    public static final Item FLINT_TILE_STAIRS = registerStairs(SuCraftBlocks.FLINT_TILE_STAIRS, "Flint Tile");
+    public static final Item BLACK_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.BLACK_PLANK_STAIRS, "Black");
+    public static final Item BLUE_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.BLUE_PLANK_STAIRS, "Blue");
+    public static final Item BROWN_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.BROWN_PLANK_STAIRS, "Brown");
+    public static final Item CYAN_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.CYAN_PLANK_STAIRS, "Cyan");
+    public static final Item GRAY_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.GRAY_PLANK_STAIRS, "Gray");
+    public static final Item GREEN_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.GREEN_PLANK_STAIRS, "Green");
+    public static final Item LIGHT_BLUE_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.LIGHT_BLUE_PLANK_STAIRS, "Light Blue");
+    public static final Item LIGHT_GRAY_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.LIGHT_GRAY_PLANK_STAIRS, "Light Gray");
+    public static final Item LIME_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.LIME_PLANK_STAIRS, "Lime");
+    public static final Item MAGENTA_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.MAGENTA_PLANK_STAIRS, "Magenta");
+    public static final Item ORANGE_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.ORANGE_PLANK_STAIRS, "Orange");
+    public static final Item PINK_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.PINK_PLANK_STAIRS, "Pink");
+    public static final Item PURPLE_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.PURPLE_PLANK_STAIRS, "Purple");
+    public static final Item RED_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.RED_PLANK_STAIRS, "Red");
+    public static final Item WHITE_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.WHITE_PLANK_STAIRS, "White");
+    public static final Item YELLOW_PLANK_STAIRS = registerPlankStairs(SuCraftBlocks.YELLOW_PLANK_STAIRS, "Yellow");
+    public static final Item BLACK_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.BLACK_WOOL_STAIRS, "Black");
+    public static final Item BLUE_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.BLUE_WOOL_STAIRS, "Blue");
+    public static final Item BROWN_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.BROWN_WOOL_STAIRS, "Brown");
+    public static final Item CYAN_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.CYAN_WOOL_STAIRS, "Cyan");
+    public static final Item GRAY_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.GRAY_WOOL_STAIRS, "Gray");
+    public static final Item GREEN_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.GREEN_WOOL_STAIRS, "Green");
+    public static final Item LIGHT_BLUE_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.LIGHT_BLUE_WOOL_STAIRS, "Light Blue");
+    public static final Item LIGHT_GRAY_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.LIGHT_GRAY_WOOL_STAIRS, "Light Gray");
+    public static final Item LIME_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.LIME_WOOL_STAIRS, "Lime");
+    public static final Item MAGENTA_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.MAGENTA_WOOL_STAIRS, "Magenta");
+    public static final Item ORANGE_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.ORANGE_WOOL_STAIRS, "Orange");
+    public static final Item PINK_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.PINK_WOOL_STAIRS, "Pink");
+    public static final Item PURPLE_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.PURPLE_WOOL_STAIRS, "Purple");
+    public static final Item RED_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.RED_WOOL_STAIRS, "Red");
+    public static final Item WHITE_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.WHITE_WOOL_STAIRS, "White");
+    public static final Item YELLOW_WOOL_STAIRS = registerWoolStairs(SuCraftBlocks.YELLOW_WOOL_STAIRS, "Yellow");
+    public static final Item BLACK_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.BLACK_CONCRETE_STAIRS, "Black");
+    public static final Item BLUE_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.BLUE_CONCRETE_STAIRS, "Blue");
+    public static final Item BROWN_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.BROWN_CONCRETE_STAIRS, "Brown");
+    public static final Item CYAN_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.CYAN_CONCRETE_STAIRS, "Cyan");
+    public static final Item GRAY_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.GRAY_CONCRETE_STAIRS, "Gray");
+    public static final Item GREEN_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.GREEN_CONCRETE_STAIRS, "Green");
+    public static final Item LIGHT_BLUE_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.LIGHT_BLUE_CONCRETE_STAIRS, "Light Blue");
+    public static final Item LIGHT_GRAY_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.LIGHT_GRAY_CONCRETE_STAIRS, "Light Gray");
+    public static final Item LIME_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.LIME_CONCRETE_STAIRS, "Lime");
+    public static final Item MAGENTA_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.MAGENTA_CONCRETE_STAIRS, "Magenta");
+    public static final Item ORANGE_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.ORANGE_CONCRETE_STAIRS, "Orange");
+    public static final Item PINK_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.PINK_CONCRETE_STAIRS, "Pink");
+    public static final Item PURPLE_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.PURPLE_CONCRETE_STAIRS, "Purple");
+    public static final Item RED_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.RED_CONCRETE_STAIRS, "Red");
+    public static final Item WHITE_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.WHITE_CONCRETE_STAIRS, "White");
+    public static final Item YELLOW_CONCRETE_STAIRS = registerConcreteStairs(SuCraftBlocks.YELLOW_CONCRETE_STAIRS, "Yellow");
+    public static final Item BLACK_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.BLACK_CONCRETE_POWDER_STAIRS, "Black");
+    public static final Item BLUE_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.BLUE_CONCRETE_POWDER_STAIRS, "Blue");
+    public static final Item BROWN_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.BROWN_CONCRETE_POWDER_STAIRS, "Brown");
+    public static final Item CYAN_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.CYAN_CONCRETE_POWDER_STAIRS, "Cyan");
+    public static final Item GRAY_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.GRAY_CONCRETE_POWDER_STAIRS, "Gray");
+    public static final Item GREEN_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.GREEN_CONCRETE_POWDER_STAIRS, "Green");
+    public static final Item LIGHT_BLUE_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.LIGHT_BLUE_CONCRETE_POWDER_STAIRS, "Light Blue");
+    public static final Item LIGHT_GRAY_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.LIGHT_GRAY_CONCRETE_POWDER_STAIRS, "Light Gray");
+    public static final Item LIME_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.LIME_CONCRETE_POWDER_STAIRS, "Lime");
+    public static final Item MAGENTA_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.MAGENTA_CONCRETE_POWDER_STAIRS, "Magenta");
+    public static final Item ORANGE_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.ORANGE_CONCRETE_POWDER_STAIRS, "Orange");
+    public static final Item PINK_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.PINK_CONCRETE_POWDER_STAIRS, "Pink");
+    public static final Item PURPLE_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.PURPLE_CONCRETE_POWDER_STAIRS, "Purple");
+    public static final Item RED_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.RED_CONCRETE_POWDER_STAIRS, "Red");
+    public static final Item WHITE_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.WHITE_CONCRETE_POWDER_STAIRS, "White");
+    public static final Item YELLOW_CONCRETE_POWDER_STAIRS = registerConcretePowderStairs(SuCraftBlocks.YELLOW_CONCRETE_POWDER_STAIRS, "Yellow");
+    public static final Item BLACK_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.BLACK_TERRACOTTA_STAIRS, "Black");
+    public static final Item BLUE_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.BLUE_TERRACOTTA_STAIRS, "Blue");
+    public static final Item BROWN_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.BROWN_TERRACOTTA_STAIRS, "Brown");
+    public static final Item CYAN_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.CYAN_TERRACOTTA_STAIRS, "Cyan");
+    public static final Item GRAY_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.GRAY_TERRACOTTA_STAIRS, "Gray");
+    public static final Item GREEN_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.GREEN_TERRACOTTA_STAIRS, "Green");
+    public static final Item LIGHT_BLUE_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.LIGHT_BLUE_TERRACOTTA_STAIRS, "Light Blue");
+    public static final Item LIGHT_GRAY_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.LIGHT_GRAY_TERRACOTTA_STAIRS, "Light Gray");
+    public static final Item LIME_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.LIME_TERRACOTTA_STAIRS, "Lime");
+    public static final Item MAGENTA_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.MAGENTA_TERRACOTTA_STAIRS, "Magenta");
+    public static final Item ORANGE_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.ORANGE_TERRACOTTA_STAIRS, "Orange");
+    public static final Item PINK_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.PINK_TERRACOTTA_STAIRS, "Pink");
+    public static final Item PURPLE_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.PURPLE_TERRACOTTA_STAIRS, "Purple");
+    public static final Item RED_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.RED_TERRACOTTA_STAIRS, "Red");
+    public static final Item WHITE_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.WHITE_TERRACOTTA_STAIRS, "White");
+    public static final Item YELLOW_TERRACOTTA_STAIRS = registerTerracottaStairs(SuCraftBlocks.YELLOW_TERRACOTTA_STAIRS, "Yellow Terracotta");
+    public static final Item POLISHED_CALCITE_STAIRS = registerPolishedStairs(SuCraftBlocks.POLISHED_CALCITE_STAIRS, "Calcite");
+    public static final Item POLISHED_DRIPSTONE_STAIRS = registerPolishedStairs(SuCraftBlocks.POLISHED_DRIPSTONE_STAIRS, "Dripstone");
+    public static final Item POLISHED_TUFF_STAIRS = registerPolishedStairs(SuCraftBlocks.POLISHED_TUFF_STAIRS, "Tuff");
+    public static final Item ANDESITE_BRICK_STAIRS = registerBrickStairs(SuCraftBlocks.ANDESITE_BRICK_STAIRS, "Andesite");
+    public static final Item CALCITE_BRICK_STAIRS = registerBrickStairs(SuCraftBlocks.CALCITE_BRICK_STAIRS, "Calcite");
+    public static final Item DIORITE_BRICK_STAIRS = registerBrickStairs(SuCraftBlocks.DIORITE_BRICK_STAIRS, "Diorite");
+    public static final Item DRIPSTONE_BRICK_STAIRS = registerBrickStairs(SuCraftBlocks.DRIPSTONE_BRICK_STAIRS, "Dripstone");
+    public static final Item GRANITE_BRICK_STAIRS = registerBrickStairs(SuCraftBlocks.GRANITE_BRICK_STAIRS, "Granite");
+    public static final Item TUFF_BRICK_STAIRS = registerBrickStairs(SuCraftBlocks.TUFF_BRICK_STAIRS, "Tuff");
+    public static final Item QUARTZ_BRICK_STAIRS = registerBrickStairs(SuCraftBlocks.QUARTZ_BRICK_STAIRS, "Quartz");
+    public static final Item SANDSTONE_BRICK_STAIRS = registerSandstoneBrickStairs(SuCraftBlocks.SANDSTONE_BRICK_STAIRS, null);
+    public static final Item RED_SANDSTONE_BRICK_STAIRS = registerSandstoneBrickStairs(SuCraftBlocks.RED_SANDSTONE_BRICK_STAIRS, "Red");
+    public static final Item SOUL_SANDSTONE_BRICK_STAIRS = registerSandstoneBrickStairs(SuCraftBlocks.SOUL_SANDSTONE_BRICK_STAIRS, "Soul");
+    public static final Item RAW_COPPER_STAIRS = registerRawMetalStairs(SuCraftBlocks.RAW_COPPER_STAIRS, "Copper");
+    public static final Item RAW_GOLD_STAIRS = registerRawMetalStairs(SuCraftBlocks.RAW_GOLD_STAIRS, "Gold");
+    public static final Item RAW_IRON_STAIRS = registerRawMetalStairs(SuCraftBlocks.RAW_IRON_STAIRS, "Iron");
+    public static final Item DIRT_STAIRS = registerStairs(SuCraftBlocks.DIRT_STAIRS, "Dirt");
+    public static final Item COARSE_DIRT_STAIRS = registerStairs(SuCraftBlocks.COARSE_DIRT_STAIRS, "Coarse Dirt");
+    public static final Item SAND_STAIRS = registerStairs(SuCraftBlocks.SAND_STAIRS, "Sand");
+    public static final Item RED_SAND_STAIRS = registerStairs(SuCraftBlocks.RED_SAND_STAIRS, "Red Sand");
+    public static final Item CLAY_STAIRS = registerStairs(SuCraftBlocks.CLAY_STAIRS, "Clay");
+    public static final Item MUD_STAIRS = registerStairs(SuCraftBlocks.MUD_STAIRS, "Mud");
+    public static final Item PACKED_MUD_STAIRS = registerStairs(SuCraftBlocks.PACKED_MUD_STAIRS, "Packed Mud");
+    public static final Item CALCITE_STAIRS = registerStairs(SuCraftBlocks.CALCITE_STAIRS, "Calcite");
+    public static final Item TUFF_STAIRS = registerStairs(SuCraftBlocks.TUFF_STAIRS, "Tuff");
+    public static final Item GRAVEL_STAIRS = registerStairs(SuCraftBlocks.GRAVEL_STAIRS, "Gravel");
+    public static final Item NETHERRACK_STAIRS = registerStairs(SuCraftBlocks.NETHERRACK_STAIRS, "Netherrack");
+    public static final Item SOUL_SOIL_STAIRS = registerStairs(SuCraftBlocks.SOUL_SOIL_STAIRS, "Soul Soil");
+    public static final Item SMOOTH_BASALT_STAIRS = registerStairs(SuCraftBlocks.SMOOTH_BASALT_STAIRS, "Smooth Basalt");
+    // Not included in initial release
+//    public static final Item SCULK_STAIRS = registerStairs(SuCraftBlocks.SCULK_STAIRS, "Sculk");
+    public static final Item OBSIDIAN_STAIRS = registerStairs(SuCraftBlocks.OBSIDIAN_STAIRS, "Obsidian");
+    public static final Item CRYING_OBSIDIAN_STAIRS = registerStairs(SuCraftBlocks.CRYING_OBSIDIAN_STAIRS, "Crying Obsidian");
+    public static final Item GILDED_BLACKSTONE_STAIRS = registerStairs(SuCraftBlocks.GILDED_BLACKSTONE_STAIRS, "Gilded Blackstone");
+    public static final Item SOUL_SANDSTONE_STAIRS = registerStairs(SuCraftBlocks.SOUL_SANDSTONE_STAIRS, "Soul Sandstone");
+    public static final Item SMOOTH_SOUL_SANDSTONE_STAIRS = registerStairs(SuCraftBlocks.SMOOTH_SOUL_SANDSTONE_STAIRS, "Smooth Soul Sandstone");
+    public static final Item CUT_SOUL_SANDSTONE_STAIRS = registerStairs(SuCraftBlocks.CUT_SOUL_SANDSTONE_STAIRS, "Cut Soul Sandstone");
+    public static final Item ANCIENT_DEBRIS_STAIRS = registerStairs(SuCraftBlocks.ANCIENT_DEBRIS_STAIRS, "Ancient Debris");
+    public static final Item QUARTZ_SPIRAL_MEANDER_STAIRS = registerStairs(SuCraftBlocks.QUARTZ_SPIRAL_MEANDER_STAIRS, "Quartz Meander");
+    public static final Item CHISELED_QUARTZ_STAIRS = registerStairs(SuCraftBlocks.CHISELED_QUARTZ_STAIRS, "Chiseled Quartz");
+    public static final Item WITHER_BONE_STAIRS = registerStairs(SuCraftBlocks.WITHER_BONE_STAIRS, "Wither Bone");
+    public static final Item PAPER_STAIRS = registerStairs(SuCraftBlocks.PAPER_STAIRS, "Paper");
+    public static final Item FLINT_PILLAR_STAIRS = registerStairs(SuCraftBlocks.FLINT_PILLAR_STAIRS, "Flint Pillar");
+    public static final Item OAK_BOOKSHELF_STAIRS = registerBookshelfStairs(SuCraftBlocks.OAK_BOOKSHELF_STAIRS, "Oak");
+    public static final Item SPRUCE_BOOKSHELF_STAIRS = registerBookshelfStairs(SuCraftBlocks.SPRUCE_BOOKSHELF_STAIRS, "Spruce");
+    public static final Item BIRCH_BOOKSHELF_STAIRS = registerBookshelfStairs(SuCraftBlocks.BIRCH_BOOKSHELF_STAIRS, "Birch");
+    public static final Item JUNGLE_BOOKSHELF_STAIRS = registerBookshelfStairs(SuCraftBlocks.JUNGLE_BOOKSHELF_STAIRS, "Jungle");
+    public static final Item OAK_LOG_STAIRS = registerLogStairs(SuCraftBlocks.OAK_LOG_STAIRS, "Oak");
+    public static final Item SPRUCE_LOG_STAIRS = registerLogStairs(SuCraftBlocks.SPRUCE_LOG_STAIRS, "Spruce");
+    public static final Item BIRCH_LOG_STAIRS = registerLogStairs(SuCraftBlocks.BIRCH_LOG_STAIRS, "Birch");
+    public static final Item JUNGLE_LOG_STAIRS = registerLogStairs(SuCraftBlocks.JUNGLE_LOG_STAIRS, "Jungle");
+    public static final Item ACACIA_LOG_STAIRS = registerLogStairs(SuCraftBlocks.ACACIA_LOG_STAIRS, "Acacia");
+    public static final Item DARK_OAK_LOG_STAIRS = registerLogStairs(SuCraftBlocks.DARK_OAK_LOG_STAIRS, "Dark Oak");
+    public static final Item WARPED_STEM_STAIRS = registerStemStairs(SuCraftBlocks.WARPED_STEM_STAIRS, "Warped");
+    public static final Item CRIMSON_STEM_STAIRS = registerStemStairs(SuCraftBlocks.CRIMSON_STEM_STAIRS, "Crimson");
+    public static final Item MANGROVE_LOG_STAIRS = registerLogStairs(SuCraftBlocks.MANGROVE_LOG_STAIRS, "Mangrove");
+    public static final Item STRIPPED_OAK_LOG_STAIRS = registerStrippedLogStairs(SuCraftBlocks.STRIPPED_OAK_LOG_STAIRS, "Oak");
+    public static final Item STRIPPED_SPRUCE_LOG_STAIRS = registerStrippedLogStairs(SuCraftBlocks.STRIPPED_SPRUCE_LOG_STAIRS, "Spruce");
+    public static final Item STRIPPED_BIRCH_LOG_STAIRS = registerStrippedLogStairs(SuCraftBlocks.STRIPPED_BIRCH_LOG_STAIRS, "Birch");
+    public static final Item STRIPPED_JUNGLE_LOG_STAIRS = registerStrippedLogStairs(SuCraftBlocks.STRIPPED_JUNGLE_LOG_STAIRS, "Jungle");
+    public static final Item STRIPPED_ACACIA_LOG_STAIRS = registerStrippedLogStairs(SuCraftBlocks.STRIPPED_ACACIA_LOG_STAIRS, "Acacia");
+    public static final Item STRIPPED_DARK_OAK_LOG_STAIRS = registerStrippedLogStairs(SuCraftBlocks.STRIPPED_DARK_OAK_LOG_STAIRS, "Dark Oak");
+    public static final Item STRIPPED_WARPED_STEM_STAIRS = registerStrippedStemStairs(SuCraftBlocks.STRIPPED_WARPED_STEM_STAIRS, "Warped");
+    public static final Item STRIPPED_CRIMSON_STEM_STAIRS = registerStrippedStemStairs(SuCraftBlocks.STRIPPED_CRIMSON_STEM_STAIRS, "Crimson");
+    public static final Item STRIPPED_MANGROVE_LOG_STAIRS = registerStrippedLogStairs(SuCraftBlocks.STRIPPED_MANGROVE_LOG_STAIRS, "Mangrove");
+    public static final Item OAK_WOOD_STAIRS = registerWoodStairs(SuCraftBlocks.OAK_WOOD_STAIRS, "Oak");
+    public static final Item SPRUCE_WOOD_STAIRS = registerWoodStairs(SuCraftBlocks.SPRUCE_WOOD_STAIRS, "Spruce");
+    public static final Item BIRCH_WOOD_STAIRS = registerWoodStairs(SuCraftBlocks.BIRCH_WOOD_STAIRS, "Birch");
+    public static final Item JUNGLE_WOOD_STAIRS = registerWoodStairs(SuCraftBlocks.JUNGLE_WOOD_STAIRS, "Jungle");
+    public static final Item ACACIA_WOOD_STAIRS = registerWoodStairs(SuCraftBlocks.ACACIA_WOOD_STAIRS, "Acacia");
+    public static final Item DARK_OAK_WOOD_STAIRS = registerWoodStairs(SuCraftBlocks.DARK_OAK_WOOD_STAIRS, "Dark Oak");
+    public static final Item WARPED_HYPHAE_STAIRS = registerHyphaeStairs(SuCraftBlocks.WARPED_HYPHAE_STAIRS, "Warped");
+    public static final Item CRIMSON_HYPHAE_STAIRS = registerHyphaeStairs(SuCraftBlocks.CRIMSON_HYPHAE_STAIRS, "Crimson");
+    public static final Item MANGROVE_WOOD_STAIRS = registerWoodStairs(SuCraftBlocks.MANGROVE_WOOD_STAIRS, "Mangrove");
+    public static final Item STRIPPED_OAK_WOOD_STAIRS = registerStrippedWoodStairs(SuCraftBlocks.STRIPPED_OAK_WOOD_STAIRS, "Oak");
+    public static final Item STRIPPED_SPRUCE_WOOD_STAIRS = registerStrippedWoodStairs(SuCraftBlocks.STRIPPED_SPRUCE_WOOD_STAIRS, "Spruce");
+    public static final Item STRIPPED_BIRCH_WOOD_STAIRS = registerStrippedWoodStairs(SuCraftBlocks.STRIPPED_BIRCH_WOOD_STAIRS, "Birch");
+    public static final Item STRIPPED_JUNGLE_WOOD_STAIRS = registerStrippedWoodStairs(SuCraftBlocks.STRIPPED_JUNGLE_WOOD_STAIRS, "Jungle");
+    public static final Item STRIPPED_ACACIA_WOOD_STAIRS = registerStrippedWoodStairs(SuCraftBlocks.STRIPPED_ACACIA_WOOD_STAIRS, "Acacia");
+    public static final Item STRIPPED_DARK_OAK_WOOD_STAIRS = registerStrippedWoodStairs(SuCraftBlocks.STRIPPED_DARK_OAK_WOOD_STAIRS, "Dark Oak");
+    public static final Item STRIPPED_WARPED_HYPHAE_STAIRS = registerStrippedHyphaeStairs(SuCraftBlocks.STRIPPED_WARPED_HYPHAE_STAIRS, "Warped");
+    public static final Item STRIPPED_CRIMSON_HYPHAE_STAIRS = registerStrippedHyphaeStairs(SuCraftBlocks.STRIPPED_CRIMSON_HYPHAE_STAIRS, "Crimson");
+    public static final Item STRIPPED_MANGROVE_WOOD_STAIRS = registerStrippedWoodStairs(SuCraftBlocks.STRIPPED_MANGROVE_WOOD_STAIRS, "Mangrove");
+    public static final Item ANDESITE_PILLAR_STAIRS = registerPillarStairs(SuCraftBlocks.ANDESITE_PILLAR_STAIRS, "Andesite");
+    public static final Item CALCITE_PILLAR_STAIRS = registerPillarStairs(SuCraftBlocks.CALCITE_PILLAR_STAIRS, "Calcite");
+    public static final Item DIORITE_PILLAR_STAIRS = registerPillarStairs(SuCraftBlocks.DIORITE_PILLAR_STAIRS, "Diorite");
+    public static final Item DRIPSTONE_PILLAR_STAIRS = registerPillarStairs(SuCraftBlocks.DRIPSTONE_PILLAR_STAIRS, "Dripstone");
+    public static final Item GRANITE_PILLAR_STAIRS = registerPillarStairs(SuCraftBlocks.GRANITE_PILLAR_STAIRS, "Granite");
+    public static final Item TUFF_PILLAR_STAIRS = registerPillarStairs(SuCraftBlocks.TUFF_PILLAR_STAIRS, "Tuff");
+    public static final Item MANGROVE_BOOKSHELF = registerBookshelf(SuCraftBlocks.MANGROVE_BOOKSHELF, "Mangrove", () -> Items.MANGROVE_PLANKS);
+    public static final Item BONE_STAIRS = registerStairs(SuCraftBlocks.BONE_STAIRS, "Bone");
+    public static final Item BASALT_STAIRS = registerStairs(SuCraftBlocks.BASALT_STAIRS, "Basalt");
+    public static final Item POLISHED_BASALT_STAIRS = registerStairs(SuCraftBlocks.POLISHED_BASALT_STAIRS, "Polished Basalt");
+    public static final Item CUT_SANDSTONE_STAIRS = registerStairs(SuCraftBlocks.CUT_SANDSTONE_STAIRS, "Cut Sandstone");
+    public static final Item CUT_RED_SANDSTONE_STAIRS = registerStairs(SuCraftBlocks.CUT_RED_SANDSTONE_STAIRS, "Cut Red Sandstone");
+    public static final Item QUARTZ_PILLAR_STAIRS = registerPillarStairs(SuCraftBlocks.QUARTZ_PILLAR_STAIRS, "Quartz");
+    public static final Item PURPUR_PILLAR_SLAB = registerPillarSlab(SuCraftBlocks.PURPUR_PILLAR_SLAB, "Purpur");
+    public static final Item PURPUR_PILLAR_STAIRS = registerPillarStairs(SuCraftBlocks.PURPUR_PILLAR_STAIRS, "Purpur");
+    public static final Item FLINT_SLAB = registerSlab(SuCraftBlocks.FLINT_SLAB, "Flint");
+    public static final Item FLINT_STAIRS = registerStairs(SuCraftBlocks.FLINT_STAIRS, "Flint");
+    public static final Item IRON_SLAB = registerSlab(SuCraftBlocks.IRON_SLAB, "Iron");
+    public static final Item GOLD_SLAB = registerSlab(SuCraftBlocks.GOLD_SLAB, "Golden");
+    public static final Item DIAMOND_SLAB = registerSlab(SuCraftBlocks.DIAMOND_SLAB, "Diamond");
+    public static final Item EMERALD_SLAB = registerSlab(SuCraftBlocks.EMERALD_SLAB, "Emerald");
+    public static final Item NETHERITE_SLAB = registerSlab(SuCraftBlocks.NETHERITE_SLAB, "Netherite", new Item.Properties().tab(CreativeModeTab.TAB_BUILDING_BLOCKS).fireResistant());
+    public static final Item LAPIS_SLAB = registerSlab(SuCraftBlocks.LAPIS_SLAB, "Lapis Lazuli");
+    public static final Item IRON_STAIRS = registerStairs(SuCraftBlocks.IRON_STAIRS, "Iron");
+    public static final Item GOLD_STAIRS = registerStairs(SuCraftBlocks.GOLD_STAIRS, "Golden");
+    public static final Item DIAMOND_STAIRS = registerStairs(SuCraftBlocks.DIAMOND_STAIRS, "Diamond");
+    public static final Item EMERALD_STAIRS = registerStairs(SuCraftBlocks.EMERALD_STAIRS, "Emerald");
+    public static final Item NETHERITE_STAIRS = registerStairs(SuCraftBlocks.NETHERITE_STAIRS, "Netherite", new Item.Properties().tab(CreativeModeTab.TAB_BUILDING_BLOCKS).fireResistant());
+    public static final Item LAPIS_STAIRS = registerStairs(SuCraftBlocks.LAPIS_STAIRS, "Lapis Lazuli");
+    public static final Item MOSS_SLAB = registerSlab(SuCraftBlocks.MOSS_SLAB, "Moss", CreativeModeTab.TAB_DECORATIONS);
+    public static final Item MOSS_STAIRS = registerStairs(SuCraftBlocks.MOSS_STAIRS, "Moss", CreativeModeTab.TAB_DECORATIONS);
+    public static final Item NETHER_WART_SLAB = registerSlab(SuCraftBlocks.NETHER_WART_SLAB, "Nether Wart", CreativeModeTab.TAB_DECORATIONS);
+    public static final Item NETHER_WART_STAIRS = registerStairs(SuCraftBlocks.NETHER_WART_STAIRS, "Nether Wart", CreativeModeTab.TAB_DECORATIONS);
+    public static final Item WARPED_WART_SLAB = registerSlab(SuCraftBlocks.WARPED_WART_SLAB, "Warped Wart", CreativeModeTab.TAB_DECORATIONS);
+    public static final Item WARPED_WART_STAIRS = registerStairs(SuCraftBlocks.WARPED_WART_STAIRS, "Warped Wart", CreativeModeTab.TAB_DECORATIONS);
+    public static final Item HAY_SLAB = registerSlab(SuCraftBlocks.HAY_SLAB, "Hay");
+    public static final Item HAY_STAIRS = registerStairs(SuCraftBlocks.HAY_STAIRS, "Hay");
+    public static final Item THATCH = registerBlock(SuCraftBlocks.THATCH, "Thatch", CreativeModeTab.TAB_BUILDING_BLOCKS);
+    public static final Item THATCH_SLAB = registerSlab(SuCraftBlocks.THATCH_SLAB, "Thatch");
+    public static final Item THATCH_STAIRS = registerStairs(SuCraftBlocks.THATCH_STAIRS, "Thatch");
+
+    private static @NotNull Item registerBlock(@NotNull Block block, @NotNull String displayName, @NotNull CreativeModeTab group) {
+        return registerBlock(block, displayName, group, null);
+    }
+
+    private static @NotNull Item registerBlock(@NotNull Block block, @NotNull String displayName, @NotNull Item.Properties properties) {
+        return registerBlock(block, displayName, properties, null);
+    }
+
+    private static @NotNull Item registerBlock(@NotNull Block block, @NotNull String displayName, @NotNull CreativeModeTab group, @Nullable Function<ItemReplacementRule.SimpleItemReplacementRule.Builder, ItemReplacementRule.SimpleItemReplacementRule.Builder> replacementRuleFunction) {
+        return registerBlock(block, displayName, new Item.Properties().tab(group), replacementRuleFunction);
+    }
+
+    private static @NotNull Item registerBlock(@NotNull Block block, @NotNull String displayName, @NotNull Item.Properties properties, @Nullable Function<ItemReplacementRule.SimpleItemReplacementRule.Builder, ItemReplacementRule.SimpleItemReplacementRule.Builder> replacementRuleFunction) {
+        Item registeredItem = Items.registerBlock(block, properties);
+        boolean rendersAsEntity = false;
+//        System.out.println("TEMP DEBUG - " + block.id + " is being registered");
+        var blockReplacementRule = block.replacementRule;
+        if (blockReplacementRule != null) {
+            if (blockReplacementRule.hasAsReal(block)) {
+                if (blockReplacementRule.rendersSomeStatesAsEntity()) {
+                    rendersAsEntity = true;
+//                    System.out.println("TEMP DEBUG - " + block.id + " renders as entity");
+                }
+            }
+        }
+        block.customItemForBlock = registeredItem;
+        registeredItem.isVanilla = false;
+        registeredItem.customKey = block.customKey;
+        var replacementRuleBuilder = ItemReplacementRule.simple().withReal(registeredItem).forBlock(block);
+        if (replacementRuleFunction != null) {
+            replacementRuleBuilder = replacementRuleFunction.apply(replacementRuleBuilder);
+        }
+        registeredItem.replacementRule = replacementRuleBuilder.build();
+        var customDisplayNameColor = PaperAdventure.asAdventure(registeredItem.rarity.color);
+        if (rendersAsEntity && RENDERS_AS_ENTITY_DISPLAY_NAME_COLOR != null) {
+            customDisplayNameColor = RENDERS_AS_ENTITY_DISPLAY_NAME_COLOR;
+        }
+        registeredItem.customDisplayName = Component.text(displayName, customDisplayNameColor).decoration(TextDecoration.ITALIC, false);
+//        System.out.println("TEMP DEBUG - " + block.id + " gets custom display name: " + registeredItem.customDisplayName);
+        registeredItem.customDisplayNameJSON = GsonComponentSerializer.gson().serialize(registeredItem.customDisplayName);
+        var customDisplayNameInLoreColor = PaperAdventure.asAdventure(CUSTOM_DISPLAY_NAME_IN_LORE_DEFAULT_COLOR);
+        if (rendersAsEntity && RENDERS_AS_ENTITY_DISPLAY_NAME_IN_LORE_COLOR != null) {
+            customDisplayNameInLoreColor = RENDERS_AS_ENTITY_DISPLAY_NAME_IN_LORE_COLOR;
+        }
+        registeredItem.customDisplayNameInLore = Component.text(displayName, customDisplayNameInLoreColor).decoration(TextDecoration.ITALIC, false);
+        registeredItem.customDisplayNameInLoreJSON = GsonComponentSerializer.gson().serialize(registeredItem.customDisplayNameInLore);
+        // Add crafting recipes
+        for (var customRecipe : block.customRecipes) {
+            registeredItem.withCustomRecipeSupplier(() -> customRecipe.toItemRecipe());
+        }
+        return registeredItem;
+    }
+
+    /**
+     * Based on {@link Items#STONE_BRICKS}
+     */
+    private static @NotNull Item registerStoneBricks(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, typeDisplayName + " Stone Bricks", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#INFESTED_STONE_BRICKS}
+     */
+    private static @NotNull Item registerInfested(@NotNull Block block, @NotNull String uninfestedDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, "Infested " + uninfestedDisplayName, CreativeModeTab.TAB_DECORATIONS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#BOOKSHELF}
+     */
+    private static @NotNull Item registerBookshelf(@NotNull Block block, @NotNull String woodTypeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, woodTypeDisplayName + " Bookshelf", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#OAK_PLANKS}
+     */
+    private static @NotNull Item registerPlanks(@NotNull Block block, @NotNull String descriptionDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, descriptionDisplayName + " Planks", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#STONE_BRICKS}
+     */
+    private static @NotNull Item registerBricks(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, typeDisplayName + " Bricks", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#POLISHED_ANDESITE}
+     */
+    private static @NotNull Item registerPolished(@NotNull Block block, @NotNull String unpolishedDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, "Polished " + unpolishedDisplayName, CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#CHISELED_STONE_BRICKS}
+     */
+    private static @NotNull Item registerChiseledBricks(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, "Chiseled " + typeDisplayName + " Bricks", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#COBBLESTONE}
+     */
+    private static @NotNull Item registerCobblestone(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, typeDisplayName + " Cobblestone", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#QUARTZ_PILLAR}
+     */
+    private static @NotNull Item registerPillar(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, typeDisplayName + " Pillar", CreativeModeTab.TAB_BUILDING_BLOCKS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    /**
+     * Based on {@link Items#BIRCH_LEAVES}
+     */
+    private static @NotNull Item registerLeaves(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Supplier<@NotNull Item> highPingHostSupplier) {
+        return registerBlock(block, typeDisplayName + " Leaves", CreativeModeTab.TAB_DECORATIONS, rule -> rule.withHighPingHost(highPingHostSupplier));
+    }
+
+    private static @NotNull Item registerSlab(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Item.Properties properties) {
+        return registerBlock(block, typeDisplayName + " Slab", properties);
+    }
+
+    private static @NotNull Item registerSlab(@NotNull Block block, @NotNull String typeDisplayName, @NotNull CreativeModeTab group) {
+        return registerSlab(block, typeDisplayName, new Item.Properties().tab(group));
+    }
+
+    /**
+     * Based on {@link Items#OAK_SLAB}
+     */
+    private static @NotNull Item registerSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName, CreativeModeTab.TAB_BUILDING_BLOCKS);
+    }
+
+    private static @NotNull Item registerStairs(@NotNull Block block, @NotNull String typeDisplayName, @NotNull Item.Properties properties) {
+        return registerBlock(block, typeDisplayName + " Stairs", properties);
+    }
+
+    private static @NotNull Item registerStairs(@NotNull Block block, @NotNull String typeDisplayName, @NotNull CreativeModeTab group) {
+        return registerStairs(block, typeDisplayName, new Item.Properties().tab(group));
+    }
+
+    /**
+     * Based on {@link Items#OAK_STAIRS}
+     */
+    private static @NotNull Item registerStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName, CreativeModeTab.TAB_BUILDING_BLOCKS);
+    }
+
+    private static @NotNull Item registerPlankSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Plank");
+    }
+
+    private static @NotNull Item registerPlankStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Plank");
+    }
+
+    private static @NotNull Item registerWoolSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Wool");
+    }
+
+    private static @NotNull Item registerWoolStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Wool");
+    }
+
+    private static @NotNull Item registerConcreteSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Concrete");
+    }
+
+    private static @NotNull Item registerConcreteStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Concrete");
+    }
+
+    private static @NotNull Item registerConcretePowderSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Concrete Powder");
+    }
+
+    private static @NotNull Item registerConcretePowderStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Concrete Powder");
+    }
+
+    private static @NotNull Item registerTerracottaSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Terracotta");
+    }
+
+    private static @NotNull Item registerTerracottaStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Terracotta");
+    }
+
+    private static @NotNull Item registerBookshelfSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Bookshelf");
+    }
+
+    private static @NotNull Item registerBookshelfStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Bookshelf");
+    }
+
+    private static @NotNull Item registerPolishedSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, "Polished " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerPolishedStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, "Polished " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerBrickSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Brick");
+    }
+
+    private static @NotNull Item registerBrickStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Brick");
+    }
+
+    private static @NotNull Item registerPillarSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Pillar");
+    }
+
+    private static @NotNull Item registerPillarStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Pillar");
+    }
+
+    private static @NotNull Item registerSandstoneBrickSlab(@NotNull Block block, @Nullable String typeDisplayName) {
+        return registerBrickSlab(block, (typeDisplayName == null ? "" : typeDisplayName + " ") + "Sandstone");
+    }
+
+    private static @NotNull Item registerSandstoneBrickStairs(@NotNull Block block, @Nullable String typeDisplayName) {
+        return registerBrickStairs(block, (typeDisplayName == null ? "" : typeDisplayName + " ") + "Sandstone");
+    }
+
+    private static @NotNull Item registerRawMetalSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, "Raw " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerRawMetalStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, "Raw " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerLogSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Log");
+    }
+
+    private static @NotNull Item registerLogStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Log");
+    }
+
+    private static @NotNull Item registerStemSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Stem");
+    }
+
+    private static @NotNull Item registerStemStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Stem");
+    }
+
+    private static @NotNull Item registerStrippedLogSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerLogSlab(block, "Stripped " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerStrippedLogStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerLogStairs(block, "Stripped " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerStrippedStemSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStemSlab(block, "Stripped " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerStrippedStemStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStemStairs(block, "Stripped " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerWoodSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Wood");
+    }
+
+    private static @NotNull Item registerWoodStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Wood");
+    }
+
+    private static @NotNull Item registerHyphaeSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerSlab(block, typeDisplayName + " Hyphae");
+    }
+
+    private static @NotNull Item registerHyphaeStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerStairs(block, typeDisplayName + " Hyphae");
+    }
+
+    private static @NotNull Item registerStrippedWoodSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerWoodSlab(block, "Stripped " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerStrippedWoodStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerWoodStairs(block, "Stripped " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerStrippedHyphaeSlab(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerHyphaeSlab(block, "Stripped " + typeDisplayName);
+    }
+
+    private static @NotNull Item registerStrippedHyphaeStairs(@NotNull Block block, @NotNull String typeDisplayName) {
+        return registerHyphaeStairs(block, "Stripped " + typeDisplayName);
+    }
+
+    public static Item bootstrap() {
+        SNOWY_STONE_BRICKS.toString();
+        // Make sure that the item replacement rule for block items for which the block has some hosts that are potentially placed by vanilla items is registered with those vanilla items
+        for (Block block : Registry.BLOCK) {
+            BlockReplacementRule replacementRule = block.replacementRule;
+            if (replacementRule != null) {
+                for (Item item : replacementRule.getHostPlacingItems()) {
+                    item.replacementRule = block.asItem().replacementRule;
+                }
+            }
+        }
+        // Make sure that all item replacement rule late initializations are performed already (so that we know the order in which they are performed, and the order of for example assigning item host custom model data is consistent regardless of whether the resource pack is being newly created - i.e. regardless of whether ItemReplacementRule.addToResourcePack is called
+        // Item replacement rule late initializations that require consistent order between server sessions (within the same resource pack version), such as ItemReplacementRule.getLowPingHost, ItemReplacementRule.getLowPingHostCustomModelData, ItemReplacementRule.getHighPingHost and ItemReplacementRule.getHighPingHostCustomModelData, must never be called before this point
+        for (Item item : Registry.ITEM) {
+            ItemReplacementRule replacementRule = item.replacementRule;
+            if (replacementRule != null) {
+                replacementRule.initializeOrderSensitiveLateInitializations();
+            }
+        }
+        return SNOWY_STONE_BRICKS;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/item/UsedHostCustomModelData.java b/src/main/java/org/sucraft/suki/item/UsedHostCustomModelData.java
new file mode 100644
index 0000000000000000000000000000000000000000..a0942f7214f69938a417cf367a17f53a38452fd9
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/item/UsedHostCustomModelData.java
@@ -0,0 +1,30 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.item;
+
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import net.minecraft.world.item.Item;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class that keeps track of used custom model data in item replacement hosts
+ */
+public final class UsedHostCustomModelData {
+
+    private UsedHostCustomModelData() {}
+
+    private static final @NotNull Object2IntMap<@NotNull Item> lastUsed = new Object2IntOpenHashMap<>(0);
+
+    static {
+        lastUsed.defaultReturnValue(0); // After all, the custom model data 0 is always in use
+    }
+
+    public static int generateUnusedHostCustomModelData(Item host) {
+        int lastUsedCustomModelData = lastUsed.getInt(host);
+        lastUsedCustomModelData++;
+        lastUsed.put(host, lastUsedCustomModelData);
+        return lastUsedCustomModelData;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/json/JsonMerging.java b/src/main/java/org/sucraft/suki/json/JsonMerging.java
new file mode 100644
index 0000000000000000000000000000000000000000..b0b8bb444d998cbba9045a3666fd42db7ca979d2
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/json/JsonMerging.java
@@ -0,0 +1,59 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.json;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Utility class to merge JSON data, with the first provided instance taking precedent over the second one when any conflict arises
+ */
+public final class JsonMerging {
+
+    private JsonMerging() {}
+
+    /**
+     * Returns a new JSON object, the result of merging the two given JSON objects (where the first provided JSON object takes precedence in any conflicts)
+     */
+    public static @NotNull JsonObject merge(@NotNull JsonObject json1, @NotNull JsonObject json2) {
+        JsonObject newJson = json1.deepCopy();
+        mergeIntoObject(newJson, json2);
+        return newJson;
+    }
+
+    /**
+     * Merges the second given JSON object into the first given JSON object (where the first provided JSON object takes precedence in any conflicts)
+     */
+    public static void mergeIntoObject(@NotNull JsonObject json1, @NotNull JsonObject json2) {
+        for (String key : json2.keySet()) {
+            @Nullable JsonElement element2 = json2.get(key);
+            if (element2 != null) {
+                @Nullable JsonElement element1 = json1.get(key);
+                if (element1 == null) {
+                    json1.add(key, element2.deepCopy());
+                } else {
+                    mergeInto(element1, element2);
+                }
+            }
+        }
+    }
+
+    /**
+     * Merges the second given JSON element into the first given JSON element (where the first provided JSON element takes precedence in any conflicts)
+     */
+    public static void mergeInto(@NotNull JsonElement json1, @NotNull JsonElement json2) {
+        if (json1 instanceof JsonArray jsonArray1) {
+            if (json2 instanceof JsonArray jsonArray2) {
+                jsonArray1.addAll(jsonArray2);
+            }
+        } else if (json1 instanceof JsonObject jsonObject1) {
+            if (json2 instanceof JsonObject jsonObject2) {
+                mergeIntoObject(jsonObject1, jsonObject2);
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/protocol/CachableCustomContentReplaceable.java b/src/main/java/org/sucraft/suki/protocol/CachableCustomContentReplaceable.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c26a22141e446e862b54b22687956a7fcbe2fbf
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/protocol/CachableCustomContentReplaceable.java
@@ -0,0 +1,21 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.protocol;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An interface for classes that have custom content that may need to be replaced when being sent to a player
+ */
+public interface CachableCustomContentReplaceable<T extends CachableCustomContentReplaceable<T>> {
+
+    /**
+     * Note: this may not make a full independent copy, merely a copy for the purpose of replacing custom content
+     *
+     * @return A copy of this instances so that it can be modified in-place
+     */
+    @NotNull T copy();
+
+    void replaceCustomContentInPlace(boolean hasResourcePack);
+
+}
diff --git a/src/main/java/org/sucraft/suki/protocol/ReplacedCustomContentCache.java b/src/main/java/org/sucraft/suki/protocol/ReplacedCustomContentCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..8cab318aa758659b4cde72997541cb56f9aa9e2e
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/protocol/ReplacedCustomContentCache.java
@@ -0,0 +1,37 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.protocol;
+
+import javax.annotation.Nullable;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Class to contain a version of an instance that has been modified for players with the resource pack,
+ * and a version for players without the resource pack
+ */
+public class ReplacedCustomContentCache<T extends CachableCustomContentReplaceable<T>> {
+
+    public final @NotNull T original;
+    private @Nullable T withResourcePack;
+    private @Nullable T withoutResourcePack;
+
+    public ReplacedCustomContentCache(@NotNull T original) {
+        this.original = original;
+    }
+
+    public @NotNull T get(boolean hasResourcePack) {
+        if (hasResourcePack) {
+            if (this.withResourcePack == null) {
+                this.withResourcePack = this.original.copy();
+                this.withResourcePack.replaceCustomContentInPlace(true);
+            }
+            return this.withResourcePack;
+        }
+        if (this.withoutResourcePack == null) {
+            this.withoutResourcePack = this.original.copy();
+            this.withoutResourcePack.replaceCustomContentInPlace(false);
+        }
+        return this.withoutResourcePack;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/KeyConstants.java b/src/main/java/org/sucraft/suki/resourcepack/KeyConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..776720f30aea04ec29b78409cb4c8a00dcd3dffd
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/KeyConstants.java
@@ -0,0 +1,124 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class providing the keys of JSON elements in the resource pack format
+ */
+public final class KeyConstants {
+
+    private KeyConstants() {}
+
+    /**
+     * The key for the global pack instance in pack.mcmeta
+     */
+    public static final @NotNull String pack = "pack";
+
+    /**
+     * The resource pack format version
+     */
+    public static final @NotNull String packFormat = "pack_format";
+
+    /**
+     * The description of a resource pack
+     */
+    public static final @NotNull String packDescription = "description";
+
+    /**
+     * The variants of a block (the block states)
+     */
+    public static final @NotNull String variants = "variants";
+
+    /**
+     * The variant key used as block state variant for blocks that have no block states
+     */
+    public static final @NotNull String noVariant = "";
+
+    /**
+     * The model of a variant (block state) of a block, or of a model override
+     */
+    public static final @NotNull String model = "model";
+
+    /**
+     * The parent of an asset
+     */
+    public static final @NotNull String assetParent = "parent";
+
+    /**
+     * The textures of a model
+     */
+    public static final @NotNull String modelTextures = "textures";
+
+    /**
+     * The inner key of textures of a model representing setting all textures
+     */
+    public static final @NotNull String modelTexturesAll = "all";
+
+    /**
+     * The inner key of textures of a model representing setting the fire texture
+     */
+    public static final @NotNull String modelTexturesFire = "fire";
+
+    /**
+     * The inner key of textures of a model representing setting the textures on a column's ends
+     */
+    public static final @NotNull String modelTexturesEnd = "end";
+
+    /**
+     * The inner key of textures of a model representing setting the textures on a column's sides
+     */
+    public static final @NotNull String modelTexturesSide = "side";
+
+    /**
+     * The inner key of textures of a model representing setting the texture on a column's bottom
+     */
+    public static final @NotNull String modelTexturesBottom = "bottom";
+
+    /**
+     * The inner key of textures of a model representing setting the texture on a column's top
+     */
+    public static final @NotNull String modelTexturesTop = "top";
+
+    /**
+     * The overrides of a model
+     */
+    public static final @NotNull String modelOverrides = "overrides";
+
+    /**
+     * The predicate of a model override
+     */
+    public static final @NotNull String overridePredicate = "predicate";
+
+    /**
+     * The key for custom model data
+     */
+    public static final @NotNull String customModelData = "custom_model_data";
+
+    /**
+     * The key for a model display
+     */
+    public static final @NotNull String display = "display";
+
+    /**
+     * The key for model display settings for the head slot
+     */
+    public static final @NotNull String displayHead = "head";
+
+    /**
+     * The key for a translation model display setting
+     */
+    public static final @NotNull String displayTranslation = "translation";
+
+    /**
+     * The key for a scale model display setting
+     */
+    public static final @NotNull String displayScale = "scale";
+
+    /**
+     * The key for a model's elements
+     */
+    public static final @NotNull String elements = "elements";
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/MutableResourcePack.java b/src/main/java/org/sucraft/suki/resourcepack/MutableResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..7500f853d9d54608c2958ed999a96680192f8d71
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/MutableResourcePack.java
@@ -0,0 +1,75 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack;
+
+import org.sucraft.suki.resourcepack.asset.InitializableResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.MutableResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.blockstates.MutableResourcePackBlockStates;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.sucraft.suki.resourcepack.asset.model.MutableResourcePackModel;
+import org.sucraft.suki.resourcepack.asset.texture.MutableResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A mutable {@link ResourcePack}
+ */
+public interface MutableResourcePack extends ResourcePack {
+
+    @NotNull ResourcePackSettings getSettings();
+
+    @Override
+    @NotNull MutableResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException;
+
+    @Override
+    default @Nullable MutableResourcePackAsset getOptionalAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) {
+        return (MutableResourcePackAsset) ResourcePack.super.getOptionalAsset(type, key);
+    }
+
+    @NotNull MutableResourcePackAsset getOrCreateAsset(@NotNull InitializableResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException;
+
+    default <T extends MutableResourcePackAsset> @NotNull T getOrCreateAsset(@NotNull InitializableResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key, @NotNull Class<T> clazz) throws IllegalArgumentException {
+        //noinspection unchecked
+        return (T) this.getOrCreateAsset(type, key);
+    }
+
+    default @NotNull MutableResourcePackBlockStates getBlockStates(@NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.BLOCK_STATES, key, MutableResourcePackBlockStates.class);
+    }
+
+    default @Nullable MutableResourcePackBlockStates getOptionalBlockStates(@NotNull NamespacedKeyWithIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.BLOCK_STATES, key, MutableResourcePackBlockStates.class);
+    }
+
+    default @NotNull MutableResourcePackBlockStates getOrCreateBlockStates(@NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        return this.getOrCreateAsset(ResourcePackAssetType.BLOCK_STATES, key, MutableResourcePackBlockStates.class);
+    }
+
+    default @NotNull MutableResourcePackModel getModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), MutableResourcePackModel.class);
+    }
+
+    default @Nullable MutableResourcePackModel getOptionalModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), MutableResourcePackModel.class);
+    }
+
+    default @NotNull MutableResourcePackModel getOrCreateModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getOrCreateAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), MutableResourcePackModel.class);
+    }
+
+    default @NotNull MutableResourcePackTexture getTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), MutableResourcePackTexture.class);
+    }
+
+    default @Nullable MutableResourcePackTexture getOptionalTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), MutableResourcePackTexture.class);
+    }
+
+    default @NotNull MutableResourcePackTexture getOrCreateTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getOrCreateAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), MutableResourcePackTexture.class);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/PathConstants.java b/src/main/java/org/sucraft/suki/resourcepack/PathConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..ce31dd0cf7d0b1ca857be2dc9485658e6ce73196
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/PathConstants.java
@@ -0,0 +1,114 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack;
+
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class providing the paths of files in the resource pack format
+ */
+public final class PathConstants {
+
+    private PathConstants() {}
+
+    /**
+     * The pack.mcmeta file
+     */
+    public static final class PackMeta {
+
+        public static final @NotNull String name = "pack.mcmeta";
+        public static final @NotNull String pathFromRoot = name;
+
+    }
+
+    /**
+     * The suffix for meta files for files
+     */
+    public static final String metaFileSuffix = ".mcmeta";
+
+    /**
+     * The assets folder
+     */
+    public static final class Assets {
+
+        public static final @NotNull String name = "assets";
+        public static final @NotNull String pathFromRoot = name;
+
+    }
+
+    /**
+     * The blockstates folder
+     */
+    public static final class BlockStates {
+
+        public static final @NotNull String name = "blockstates";
+        public static final @NotNull String pathInNamespaceFolder = name;
+
+    }
+
+    /**
+     * The models folder
+     */
+    public static final class Models {
+
+        public static final @NotNull String name = "models";
+        public static final @NotNull String pathInNamespaceFolder = name;
+
+        /**
+         * The block models folder
+         */
+        public static final class Block {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.BLOCK.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Models.pathInNamespaceFolder + "/" + name;
+
+        }
+
+        /**
+         * The item models folder
+         */
+        public static final class Item {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.ITEM.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Models.pathInNamespaceFolder + "/" + name;
+
+        }
+
+    }
+
+    /**
+     * The textures folder
+     */
+    public static final class Textures {
+
+        public static final @NotNull String name = "textures";
+        public static final @NotNull String pathInNamespaceFolder = name;
+
+        /**
+         * The block textures folder
+         */
+        public static final class Block {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.BLOCK.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Textures.pathInNamespaceFolder + "/" + name;
+
+        }
+
+        /**
+         * The item textures folder
+         */
+        public static final class Item {
+
+            public static final @NotNull String name = ResourcePackAssetIntention.ITEM.prefix;
+            public static final @NotNull String pathInNamespaceFolder = Textures.pathInNamespaceFolder + "/" + name;
+
+        }
+
+    }
+
+    public static @NotNull String getNamespaceFolderPathFromRoot(@NotNull String namespace) {
+        return Assets.pathFromRoot + "/" + namespace;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/ResourcePack.java b/src/main/java/org/sucraft/suki/resourcepack/ResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..71251b67cc9a388c73e2d2d11e01ea295269e027
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/ResourcePack.java
@@ -0,0 +1,75 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack;
+
+import it.unimi.dsi.fastutil.Pair;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.blockstates.ResourcePackBlockStates;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.sucraft.suki.resourcepack.asset.model.ResourcePackModel;
+import org.sucraft.suki.resourcepack.asset.texture.ResourcePackTexture;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.concurrent.Callable;
+import java.util.stream.Stream;
+
+/**
+ * An interface that provides getters to get things out of an existing resource pack, for example one defined by an archive filename, or one currently being built in memory.
+ */
+public interface ResourcePack {
+
+    @NotNull Stream<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> getAllFilesStream() throws IOException;
+
+    @NotNull ResourcePackSettings getSettings();
+
+    @NotNull ResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException;
+
+    default @Nullable ResourcePackAsset getOptionalAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) {
+        try {
+            return this.getAsset(type, key);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    default <T extends ResourcePackAsset> @NotNull T getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key, @NotNull Class<T> clazz) throws IllegalArgumentException {
+        //noinspection unchecked
+        return (T) this.getAsset(type, key);
+    }
+
+    default <T extends ResourcePackAsset> @Nullable T getOptionalAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key, @NotNull Class<T> clazz) {
+        //noinspection unchecked
+        return (T) this.getOptionalAsset(type, key);
+    }
+
+    default @NotNull ResourcePackBlockStates getBlockStates(@NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.BLOCK_STATES, key, ResourcePackBlockStates.class);
+    }
+
+    default @Nullable ResourcePackBlockStates getOptionalBlockStates(@NotNull NamespacedKeyWithIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.BLOCK_STATES, key, ResourcePackBlockStates.class);
+    }
+
+    default @NotNull ResourcePackModel getModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), ResourcePackModel.class);
+    }
+
+    default @Nullable ResourcePackModel getOptionalModel(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.MODEL, key.withIntention(intention), ResourcePackModel.class);
+    }
+
+    default @NotNull ResourcePackTexture getTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) throws IllegalArgumentException {
+        return this.getAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), ResourcePackTexture.class);
+    }
+
+    default @Nullable ResourcePackTexture getOptionalTexture(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        return this.getOptionalAsset(ResourcePackAssetType.TEXTURE, key.withIntention(intention), ResourcePackTexture.class);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/ResourcePackHash.java b/src/main/java/org/sucraft/suki/resourcepack/ResourcePackHash.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a513f8ad9ca04df719b1295dd177b60ff500b09
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/ResourcePackHash.java
@@ -0,0 +1,47 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.math.BigInteger;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+/**
+ * Utility class to compute the SHA-1 hash of the resource pack archive file
+ */
+public final class ResourcePackHash {
+
+    private static final @NotNull String algorithm = "SHA-1";
+
+    private ResourcePackHash() {}
+
+    public static String getHash(@NotNull File resourcePackArchiveFile) {
+        try {
+
+            try {
+                MessageDigest md = MessageDigest.getInstance(algorithm);
+                try (FileInputStream inputStream = new FileInputStream(resourcePackArchiveFile)) {
+                    md.update(inputStream.readAllBytes());
+                    byte[] digest = md.digest();
+                    return toHex(digest);
+                }
+            } catch (NoSuchAlgorithmException e) {
+                throw new IllegalStateException(algorithm + " is not implemented in MessageDigest", e);
+            }
+
+        } catch (Exception e) {
+            throw new RuntimeException("Exception occurred while computing resource pack archive file " + algorithm + " hash", e);
+        }
+    }
+
+    private static String toHex(byte[] bytes) {
+        BigInteger bi = new BigInteger(1, bytes);
+        return String.format("%0" + (bytes.length << 1) + "X", bi);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/ResourcePackSettings.java b/src/main/java/org/sucraft/suki/resourcepack/ResourcePackSettings.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a7f6d701494c637941b1f22c23431d4a8b1a120
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/ResourcePackSettings.java
@@ -0,0 +1,28 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import org.sucraft.suki.resourcepack.sucraft.CreateSuCraftResourcePack;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * The top-level settings of a {@link ResourcePack}
+ */
+public interface ResourcePackSettings {
+
+    @NotNull String getName();
+
+    @NotNull JsonElement getDescription();
+
+    default @NotNull JsonObject createJson() {
+        JsonObject json = new JsonObject();
+        JsonObject packJson = new JsonObject();
+        json.add(KeyConstants.pack, packJson);
+        packJson.addProperty(KeyConstants.packFormat, CreateSuCraftResourcePack.RESOURCE_PACK_FORMAT);
+        packJson.add(KeyConstants.packDescription, getDescription());
+        return json;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/InitializableResourcePackAssetType.java b/src/main/java/org/sucraft/suki/resourcepack/asset/InitializableResourcePackAssetType.java
new file mode 100644
index 0000000000000000000000000000000000000000..9778321194cd723f333c12b7c25afd38a5217970
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/InitializableResourcePackAssetType.java
@@ -0,0 +1,17 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A {@link ResourcePackAssetType} that can be initialized to some empty state
+ */
+public class InitializableResourcePackAssetType extends ResourcePackAssetType {
+
+    protected InitializableResourcePackAssetType(int orderOrdinal, @NotNull String folderPathInNamespaceFolder, @Nullable String defaultFileExtension) {
+        super(orderOrdinal, folderPathInNamespaceFolder, defaultFileExtension);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/MutableResourcePackAsset.java b/src/main/java/org/sucraft/suki/resourcepack/asset/MutableResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..5ad40da6e50145756e9ba6dc6183480c3f9e88a1
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/MutableResourcePackAsset.java
@@ -0,0 +1,41 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ResourcePackAsset}
+ */
+public interface MutableResourcePackAsset extends ResourcePackAsset {
+
+    /**
+     * Note that merging two assets sets the {@link #isDirty} flag if any of the two assets have it set to true
+     */
+    @Override
+    @NotNull MutableResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    /**
+     * Whether this asset would need to be added to a resource pack when written
+     * <br>
+     * This is false when:
+     * <ul>
+     * <li>The asset was created from a default asset and has not been modified</li>
+     * <li>The asset was newly created (not based on a default asset) in an empty state and has not been modified</li>
+     * </ul>
+     * This is true otherwise, for example but not limited to:
+     * <ul>
+     * <li>The asset was created from an included asset</li>
+     * <li>The asset was newly created (not based on a default asset) in a non-empty state</li>
+     * <li>The asset was has modifications since creation that make it non-equal to the default asset, if any</li>
+     * </ul>
+     * Note that this flag may (and will usually) be true if the asset is created from a default asset and then modified in such a way that it ends up being the same as the original again, even though it would be valid (and better) to have it be false
+     */
+    boolean isDirty();
+
+    /**
+     * Sets {@link #isDirty} to true
+     */
+    void setDirty();
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackAsset.java b/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..ba80247d1cbcbeba3bcfae5c9a71231d2f5216f2
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackAsset.java
@@ -0,0 +1,49 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset;
+
+import org.sucraft.suki.resourcepack.ResourcePack;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * An asset (element of some asset type) in a {@link ResourcePack}
+ */
+public interface ResourcePackAsset {
+
+    static @NotNull String getPathInResourcePack(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) {
+        return type.getPathInResourcePack(key);
+    }
+
+    @NotNull ResourcePackAssetType getType();
+
+    /**
+     * This key does not include the asset type folder (such as models) but does include any subfolders that are an intention (such as block)
+     */
+    @NotNull NamespacedKeyWithIntention getKey();
+
+    default @NotNull String getPathInResourcePack() {
+        return getPathInResourcePack(this.getType(), this.getKey());
+    }
+
+    void writeTo(@NotNull OutputStream outputStream) throws IOException;
+
+    default boolean hasMeta() {
+        return false;
+    }
+
+    default void writeMetaTo(@NotNull OutputStream outputStream) throws IOException, UnsupportedOperationException, IllegalStateException {
+        throw new UnsupportedOperationException("This asset (of type " + getClass().getName() + " does not support writeMetaTo");
+    }
+
+    /**
+     * Gets the result of merging this asset with the given one
+     * <br>
+     * In any conflicts, this asset will take precedence over the given one
+     */
+    @NotNull ResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackAssetDataContent.java b/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackAssetDataContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..0f642facb5e348ccdf16034189e1395970694f05
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackAssetDataContent.java
@@ -0,0 +1,5 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset;
+
+public interface ResourcePackAssetDataContent {}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackAssetType.java b/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackAssetType.java
new file mode 100644
index 0000000000000000000000000000000000000000..39cbae2c8d159fed535abf581399624a19d38741
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackAssetType.java
@@ -0,0 +1,56 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset;
+
+import net.minecraft.server.MinecraftServer;
+import org.sucraft.suki.resourcepack.PathConstants;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A type of {@link ResourcePackAsset}
+ */
+public class ResourcePackAssetType {
+
+    public static final @NotNull InitializableResourcePackAssetType BLOCK_STATES = new InitializableResourcePackAssetType(0, PathConstants.BlockStates.pathInNamespaceFolder, ".json");
+    public static final @NotNull InitializableResourcePackAssetType MODEL = new InitializableResourcePackAssetType(1, PathConstants.Models.pathInNamespaceFolder, ".json");
+    public static final @NotNull InitializableResourcePackAssetType TEXTURE = new InitializableResourcePackAssetType(2, PathConstants.Textures.pathInNamespaceFolder, ".png");
+
+    /**
+     * Used for ordering instances of {@link ResourcePackAssetType} (used to attempt to write models as a whole to the resource pack before writing individual textures, to avoid the texture instance being not properly initialized due to being dependent on being initialized by the models that use them)
+     */
+    public final int orderOrdinal;
+    private final @NotNull String folderPathInNamespaceFolder;
+    /**
+     * This extension includes the dot separating the filename from the extension (so this may be an empty string to indicate that this asset type's files have no extension at all)
+     */
+    public final @Nullable String defaultFileExtension;
+
+    protected ResourcePackAssetType(int orderOrdinal, @NotNull String folderName, @Nullable String defaultFileExtension) {
+        this.orderOrdinal = orderOrdinal;
+        this.folderPathInNamespaceFolder = folderName;
+        this.defaultFileExtension = defaultFileExtension;
+    }
+
+    public @NotNull String getFolderPathInNamespaceFolder() {
+        return this.folderPathInNamespaceFolder;
+    }
+
+    public @NotNull String getDefaultFileExtension() throws IllegalStateException {
+        try {
+            return Validate.notNull(this.defaultFileExtension);
+        } catch (NullPointerException e) {
+            throw new IllegalStateException("Called ResourcePackAssetType.getDefaultFileExtension for a type that does not have a default file extension");
+        }
+    }
+
+    public @NotNull String getPathInResourcePack(@NotNull NamespacedKeyWithIntention assetKey) {
+        if (this.defaultFileExtension == null) {
+            throw new IllegalStateException("Called ResourcePackAssetType.getPathInResourcePack while defaultFileExtension was not set: if a type has multiple extensions, this method cannot be used, and ResourcePackAsset.getPathInResourcePack should be overridden as appropriate");
+        }
+        return PathConstants.getNamespaceFolderPathFromRoot(assetKey.namespace()) + "/" + this.getFolderPathInNamespaceFolder() + "/" + assetKey.keyWithIntention() + this.defaultFileExtension;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackIntentionedAssetData.java b/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackIntentionedAssetData.java
new file mode 100644
index 0000000000000000000000000000000000000000..603ddc32755afd6555ee23c6c0734a7548938bfa
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackIntentionedAssetData.java
@@ -0,0 +1,32 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset;
+
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public abstract class ResourcePackIntentionedAssetData {
+
+    protected final @NotNull ResourcePackAssetIntention intention;
+    protected final @NotNull NamespacedKeyWithoutIntention key;
+
+    protected ResourcePackIntentionedAssetData(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key) {
+        this.intention = intention;
+        this.key = key;
+    }
+
+    public @NotNull ResourcePackAssetIntention getIntention() {
+        return this.intention;
+    }
+
+    public @NotNull NamespacedKeyWithoutIntention getKey() {
+        return this.key;
+    }
+
+    public @NotNull NamespacedKeyWithIntention getKeyWithIntention() {
+        return this.key.withIntention(this.intention);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackIntentionedAssetDataByContent.java b/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackIntentionedAssetDataByContent.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7feb9ed05a97b8add701a4d027928c4db19226d
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/ResourcePackIntentionedAssetDataByContent.java
@@ -0,0 +1,22 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset;
+
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.jetbrains.annotations.NotNull;
+
+public abstract class ResourcePackIntentionedAssetDataByContent<T extends ResourcePackAssetDataContent> extends ResourcePackIntentionedAssetData {
+
+    protected final @NotNull T content;
+
+    protected ResourcePackIntentionedAssetDataByContent(@NotNull ResourcePackAssetIntention intention, @NotNull NamespacedKeyWithoutIntention key, @NotNull T content) {
+        super(intention, key);
+        this.content = content;
+    }
+
+    public @NotNull T getContent() {
+        return this.content;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/SimpleResourcePackAsset.java b/src/main/java/org/sucraft/suki/resourcepack/asset/SimpleResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..58e2a4ec35ec6dcf616653bc134f09436039de9d
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/SimpleResourcePackAsset.java
@@ -0,0 +1,44 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset;
+
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Base implementation of {@link MutableResourcePackAsset}
+ */
+public abstract class SimpleResourcePackAsset implements MutableResourcePackAsset {
+
+    private final @NotNull NamespacedKeyWithIntention key;
+
+    private boolean dirty;
+
+    protected SimpleResourcePackAsset(@NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        this.key = key;
+        this.dirty = dirty;
+    }
+
+    protected SimpleResourcePackAsset(@NotNull NamespacedKeyWithIntention key) {
+        this(key, false);
+    }
+
+    @Override
+    public @NotNull NamespacedKeyWithIntention getKey() {
+        return this.key;
+    }
+
+    @Override
+    public boolean isDirty() {
+        return this.dirty;
+    }
+
+    @Override
+    public void setDirty() {
+        this.dirty = true;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/blockstates/ConcreteResourcePackBlockStates.java b/src/main/java/org/sucraft/suki/resourcepack/asset/blockstates/ConcreteResourcePackBlockStates.java
new file mode 100644
index 0000000000000000000000000000000000000000..f0073a29742c384f34a2095f9dac7b90e88e1be7
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/blockstates/ConcreteResourcePackBlockStates.java
@@ -0,0 +1,503 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.blockstates;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import org.sucraft.suki.blockanditemdata.model.ModelParameters;
+import org.sucraft.suki.blockanditemdata.model.ModelWithParameters;
+import org.sucraft.suki.resourcepack.KeyConstants;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.json.SimpleJsonResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.checkerframework.checker.units.qual.N;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Map;
+
+/**
+ * Concrete implementation of {@link MutableResourcePackBlockStates}
+ */
+public class ConcreteResourcePackBlockStates extends SimpleJsonResourcePackAsset<ConcreteResourcePackBlockStates> implements MutableResourcePackBlockStates {
+
+    private boolean setUpFire = false;
+
+    public ConcreteResourcePackBlockStates(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(ConcreteResourcePackBlockStates::new, json, key, dirty);
+    }
+
+    public ConcreteResourcePackBlockStates(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key) {
+        super(ConcreteResourcePackBlockStates::new, json, key);
+    }
+
+    public ConcreteResourcePackBlockStates(@NotNull ResourcePackBlockStates reference) {
+        this(reference.getJsonCopy(), reference.getKey());
+    }
+
+    @Override
+    public @NotNull ResourcePackAssetType getType() {
+        return ResourcePackAssetType.BLOCK_STATES;
+    }
+
+    @Override
+    protected void makeJsonUpToDate(@NotNull JsonObject json) {}
+
+    private @NotNull JsonObject getOrCreateVariantsJson(@NotNull JsonObject json) {
+        @NotNull JsonObject variantsJson;
+        if (json.has(KeyConstants.variants)) {
+            variantsJson = json.getAsJsonObject(KeyConstants.variants);
+        } else {
+            variantsJson = new JsonObject();
+            json.add(KeyConstants.variants, variantsJson);
+        }
+        return variantsJson;
+    }
+
+    @Override
+    public void setModel(@NotNull String variant, @NotNull ModelWithParameters model) {
+        this.updateJsonDirectly(json -> {
+            @NotNull JsonObject variantsJson = this.getOrCreateVariantsJson(json);
+            for (String alreadyExistingVariant : new ArrayList<>(variantsJson.keySet())) {
+                // This check is not perfect because variant properties may be in a different order, may need to improve later
+                if (alreadyExistingVariant.contains(variant)) {
+                    variantsJson.remove(alreadyExistingVariant);
+                }
+            }
+            @NotNull JsonObject variantJson;
+            if (variantsJson.has(variant)) {
+                variantJson = variantsJson.getAsJsonObject(variant);
+            } else {
+                variantJson = new JsonObject();
+                variantsJson.add(variant, variantJson);
+            }
+            variantJson.addProperty(KeyConstants.model, model.model().getKeyWithIntention().toString());
+            if (model.parameters() != null) {
+                for (Map.Entry<String, JsonElement> parameter : model.parameters().getJson().entrySet()) {
+                    variantJson.add(parameter.getKey(), parameter.getValue());
+                }
+            }
+            if (!variant.equals(KeyConstants.noVariant)) {
+                variantsJson.remove(KeyConstants.noVariant);
+            }
+        });
+        this.setDirty();
+//        if (this.getKey().withoutIntention().toString().equals("minecraft:infested_stone_bricks")) {
+//            System.out.println("TEMP DEBUG - now json is: " + this.getJsonCopy().toString());
+//        }
+    }
+
+    @Override
+    public void clearVariants() {
+        this.updateJsonDirectly(json -> {
+            json.add(KeyConstants.variants, new JsonObject());
+        });
+    }
+
+    @Override
+    public void addFireModels(@NotNull BlockState hostState, @NotNull String fireType) {
+        this.replaceJsonDirectly(json -> {
+            if (!setUpFire) {
+                setUpFire = true;
+                // Based on vanilla Minecraft resource file /assets/minecraft/blockstates/fire.json
+                // All parts have an age 0 requirement added (spread over every when condition)
+                // Additionally, the 'all sides' is split from the individual sides, so that only the individual sides use the model with an extra margin (to accommodate fire on the side of blocks rendered using entities)
+                json = JsonParser.parseString("""
+                    {
+                      "multipart": [
+                        {
+                          "apply": [
+                            {
+                              "model": "minecraft:block/fire_floor0"
+                            },
+                            {
+                              "model": "minecraft:block/fire_floor1"
+                            }
+                          ],
+                          "when": {
+                            "east": "false",
+                            "north": "false",
+                            "south": "false",
+                            "up": "false",
+                            "west": "false",
+                            "age": 0
+                          }
+                        },
+                        {
+                          "apply": [
+                            {
+                              "model": "minecraft:block/fire_side0"
+                            },
+                            {
+                              "model": "minecraft:block/fire_side1"
+                            },
+                            {
+                              "model": "minecraft:block/fire_side_alt0"
+                            },
+                            {
+                              "model": "minecraft:block/fire_side_alt1"
+                            }
+                          ],
+                          "when": {
+                            "east": "false",
+                            "north": "false",
+                            "south": "false",
+                            "up": "false",
+                            "west": "false",
+                            "age": 0
+                          }
+                        },
+                        {
+                          "apply": [
+                            {
+                              "model": "minecraft:block/fire_side0",
+                              "y": 90
+                            },
+                            {
+                              "model": "minecraft:block/fire_side1",
+                              "y": 90
+                            },
+                            {
+                              "model": "minecraft:block/fire_side_alt0",
+                              "y": 90
+                            },
+                            {
+                              "model": "minecraft:block/fire_side_alt1",
+                              "y": 90
+                            }
+                          ],
+                          "when": {
+                            "east": "false",
+                            "north": "false",
+                            "south": "false",
+                            "up": "false",
+                            "west": "false",
+                            "age": 0
+                          }
+                        },
+                        {
+                          "apply": [
+                            {
+                              "model": "minecraft:block/fire_side0",
+                              "y": 180
+                            },
+                            {
+                              "model": "minecraft:block/fire_side1",
+                              "y": 180
+                            },
+                            {
+                              "model": "minecraft:block/fire_side_alt0",
+                              "y": 180
+                            },
+                            {
+                              "model": "minecraft:block/fire_side_alt1",
+                              "y": 180
+                            }
+                          ],
+                          "when": {
+                            "east": "false",
+                            "north": "false",
+                            "south": "false",
+                            "up": "false",
+                            "west": "false",
+                            "age": 0
+                          }
+                        },
+                        {
+                          "apply": [
+                            {
+                              "model": "minecraft:block/fire_side0",
+                              "y": 270
+                            },
+                            {
+                              "model": "minecraft:block/fire_side1",
+                              "y": 270
+                            },
+                            {
+                              "model": "minecraft:block/fire_side_alt0",
+                              "y": 270
+                            },
+                            {
+                              "model": "minecraft:block/fire_side_alt1",
+                              "y": 270
+                            }
+                          ],
+                          "when": {
+                            "east": "false",
+                            "north": "false",
+                            "south": "false",
+                            "up": "false",
+                            "west": "false",
+                            "age": 0
+                          }
+                        },
+                        {
+                          "apply": [
+                            {
+                              "model": "sucraft:block/margin_fire_side0"
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side1"
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side_alt0"
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side_alt1"
+                            }
+                          ],
+                          "when": {
+                            "north": "true",
+                            "age": 0
+                          }
+                        },
+                        {
+                          "apply": [
+                            {
+                              "model": "sucraft:block/margin_fire_side0",
+                              "y": 90
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side1",
+                              "y": 90
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side_alt0",
+                              "y": 90
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side_alt1",
+                              "y": 90
+                            }
+                          ],
+                          "when": {
+                            "east": "true",
+                            "age": 0
+                          }
+                        },
+                        {
+                          "apply": [
+                            {
+                              "model": "sucraft:block/margin_fire_side0",
+                              "y": 180
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side1",
+                              "y": 180
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side_alt0",
+                              "y": 180
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side_alt1",
+                              "y": 180
+                            }
+                          ],
+                          "when": {
+                            "south": "true",
+                            "age": 0
+                          }
+                        },
+                        {
+                          "apply": [
+                            {
+                              "model": "sucraft:block/margin_fire_side0",
+                              "y": 270
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side1",
+                              "y": 270
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side_alt0",
+                              "y": 270
+                            },
+                            {
+                              "model": "sucraft:block/margin_fire_side_alt1",
+                              "y": 270
+                            }
+                          ],
+                          "when": {
+                            "west": "true",
+                            "age": 0
+                          }
+                        },
+                        {
+                          "apply": [
+                            {
+                              "model": "minecraft:block/fire_up0"
+                            },
+                            {
+                              "model": "minecraft:block/fire_up1"
+                            },
+                            {
+                              "model": "minecraft:block/fire_up_alt0"
+                            },
+                            {
+                              "model": "minecraft:block/fire_up_alt1"
+                            }
+                          ],
+                          "when": {
+                            "up": "true",
+                            "age": 0
+                          }
+                        }
+                      ]
+                    }""").getAsJsonObject();
+            }
+            @NotNull JsonArray multipart = json.getAsJsonArray("multipart");
+            // Based on vanilla Minecraft resource file /assets/minecraft/blockstates/soul_fire.json
+            // All parts have an added when condition for the right block state
+            multipart.addAll(JsonParser.parseString("""
+                [
+                    {
+                      "apply": [
+                        {
+                          "model": "sucraft:block/%1$s_fire_floor0"
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_floor1"
+                        }
+                      ],
+                      "when": {
+                        "east": "%2$b",
+                        "north": "%3$b",
+                        "south": "%4$b",
+                        "up": "%5$b",
+                        "west": "%6$b",
+                        "age": %7$d
+                      }
+                    },
+                    {
+                      "apply": [
+                        {
+                          "model": "sucraft:block/%1$s_fire_side0"
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side1"
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side_alt0"
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side_alt1"
+                        }
+                      ],
+                      "when": {
+                        "east": "%2$b",
+                        "north": "%3$b",
+                        "south": "%4$b",
+                        "up": "%5$b",
+                        "west": "%6$b",
+                        "age": %7$d
+                      }
+                    },
+                    {
+                      "apply": [
+                        {
+                          "model": "sucraft:block/%1$s_fire_side0",
+                          "y": 90
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side1",
+                          "y": 90
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side_alt0",
+                          "y": 90
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side_alt1",
+                          "y": 90
+                        }
+                      ],
+                      "when": {
+                        "east": "%2$b",
+                        "north": "%3$b",
+                        "south": "%4$b",
+                        "up": "%5$b",
+                        "west": "%6$b",
+                        "age": %7$d
+                      }
+                    },
+                    {
+                      "apply": [
+                        {
+                          "model": "sucraft:block/%1$s_fire_side0",
+                          "y": 180
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side1",
+                          "y": 180
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side_alt0",
+                          "y": 180
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side_alt1",
+                          "y": 180
+                        }
+                      ],
+                      "when": {
+                        "east": "%2$b",
+                        "north": "%3$b",
+                        "south": "%4$b",
+                        "up": "%5$b",
+                        "west": "%6$b",
+                        "age": %7$d
+                      }
+                    },
+                    {
+                      "apply": [
+                        {
+                          "model": "sucraft:block/%1$s_fire_side0",
+                          "y": 270
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side1",
+                          "y": 270
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side_alt0",
+                          "y": 270
+                        },
+                        {
+                          "model": "sucraft:block/%1$s_fire_side_alt1",
+                          "y": 270
+                        }
+                      ],
+                      "when": {
+                        "east": "%2$b",
+                        "north": "%3$b",
+                        "south": "%4$b",
+                        "up": "%5$b",
+                        "west": "%6$b",
+                        "age": %7$d
+                      }
+                    }
+                ]"""
+                .formatted(
+                    fireType,
+                    hostState.getValue(BlockStateProperties.EAST),
+                    hostState.getValue(BlockStateProperties.NORTH),
+                    hostState.getValue(BlockStateProperties.SOUTH),
+                    hostState.getValue(BlockStateProperties.UP),
+                    hostState.getValue(BlockStateProperties.WEST),
+                    hostState.getValue(BlockStateProperties.AGE_15)
+                )).getAsJsonArray()
+            );
+            return json;
+        });
+        this.setDirty();
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/blockstates/MutableResourcePackBlockStates.java b/src/main/java/org/sucraft/suki/resourcepack/asset/blockstates/MutableResourcePackBlockStates.java
new file mode 100644
index 0000000000000000000000000000000000000000..bb68e55fc2a9b1a07fafdc373ddeabe3790bdf19
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/blockstates/MutableResourcePackBlockStates.java
@@ -0,0 +1,66 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.blockstates;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.world.level.block.state.BlockState;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.blockanditemdata.model.ModelWithParameters;
+import org.sucraft.suki.resourcepack.KeyConstants;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.json.MutableJsonResourcePackAsset;
+import org.sucraft.suki.resourcepack.MutableResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+/**
+ * A mutable {@link ResourcePackBlockStates}
+ */
+public interface MutableResourcePackBlockStates extends MutableJsonResourcePackAsset, ResourcePackBlockStates {
+
+    @Override
+    @NotNull MutableResourcePackBlockStates merge(@NotNull ResourcePackAsset other);
+
+    /**
+     * @param pack Because this instance is not aware of the resource pack it is in, this pack must be provided to automatically add the given model to the resource pack
+     * @param overwriteExistingModel Whether to overwrite an existing model in the resource pack (this has to do with the model, not with this {@link MutableResourcePackBlockStates} instance: this instance's model property is always overwritten by this method)
+     */
+    default @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> setModel(@NotNull String variant, @NotNull ModelWithParameters model, @NotNull MutableResourcePack pack, boolean overwriteExistingModel, boolean actuallyAdd) {
+        this.setModel(variant, model);
+        return model.model().addToResourcePack(pack, overwriteExistingModel, actuallyAdd);
+    }
+
+    /**
+     * This does not automatically add the model to the resource pack
+     *
+     * If the variant is not {@link KeyConstants#noVariant}, any existing empty variant will be removed
+     */
+    void setModel(@NotNull String variant, @NotNull ModelWithParameters model);
+
+    default @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> setModel(@NotNull BlockState variant, @NotNull ModelWithParameters model, @NotNull MutableResourcePack pack, boolean overwriteExistingModel, boolean actuallyAdd) {
+        return this.setModel(variant.toVariantString(), model, pack, overwriteExistingModel, actuallyAdd);
+    }
+
+    default void setModel(@NotNull BlockState variant, @NotNull ModelWithParameters model) {
+        this.setModel(variant.toVariantString(), model);
+    }
+
+    default @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> setNoVariantModel(@NotNull ModelWithParameters model, @NotNull MutableResourcePack pack, boolean overwriteExistingModel, boolean actuallyAdd) {
+        return this.setModel(KeyConstants.noVariant, model, pack, overwriteExistingModel, actuallyAdd);
+    }
+
+    default void setNoVariantModel(@NotNull ModelWithParameters model) {
+        this.setModel(KeyConstants.noVariant, model);
+    }
+
+    /**
+     * Removes all entries in the variants JSON object (it will be an empty object afterwards - which is not valid for a variants JSON object, so variant entries must be added afterwards)
+     */
+    void clearVariants();
+
+    void addFireModels(@NotNull BlockState hostState, @NotNull String fireType);
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/blockstates/ResourcePackBlockStates.java b/src/main/java/org/sucraft/suki/resourcepack/asset/blockstates/ResourcePackBlockStates.java
new file mode 100644
index 0000000000000000000000000000000000000000..25f9ef3f384193ffc06b580eedb541af1d03b926
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/blockstates/ResourcePackBlockStates.java
@@ -0,0 +1,18 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.blockstates;
+
+import org.sucraft.suki.resourcepack.asset.json.JsonResourcePackAsset;
+import org.sucraft.suki.resourcepack.ResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An element of 'blockstates' in a {@link ResourcePack}
+ */
+public interface ResourcePackBlockStates extends JsonResourcePackAsset {
+
+    @Override
+    @NotNull ResourcePackBlockStates merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/image/ImageResourcePackAsset.java b/src/main/java/org/sucraft/suki/resourcepack/asset/image/ImageResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..5b4f718b2db9f9770f99fef94fc5ec077644b791
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/image/ImageResourcePackAsset.java
@@ -0,0 +1,20 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.image;
+
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A {@link ResourcePackAsset} that is intended to hold an image (though, it is possible that {@link #hasData} is false, indicating that there is no data stored in this asset instance yet, although eventually, there always must be)
+ * <br>
+ * Note that this does not necessarily store any of the data referenced in memory, an image asset can also simply hold a filename that we assume points to an image
+ */
+public interface ImageResourcePackAsset extends ResourcePackAsset {
+
+    @Override
+    @NotNull ImageResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    boolean hasData();
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/image/MutableImageResourcePackAsset.java b/src/main/java/org/sucraft/suki/resourcepack/asset/image/MutableImageResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..30d1169edfce3597408c1be6ec391bb632e042dd
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/image/MutableImageResourcePackAsset.java
@@ -0,0 +1,17 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.image;
+
+import org.sucraft.suki.resourcepack.asset.MutableResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ImageResourcePackAsset}
+ */
+public interface MutableImageResourcePackAsset extends MutableResourcePackAsset, ImageResourcePackAsset {
+
+    @Override
+    @NotNull MutableImageResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/image/SimpleImageFileResourcePackAsset.java b/src/main/java/org/sucraft/suki/resourcepack/asset/image/SimpleImageFileResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..9fd3a32fd21bffe274520b2de88b71d1250b4b6a
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/image/SimpleImageFileResourcePackAsset.java
@@ -0,0 +1,85 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.image;
+
+import org.sucraft.suki.resourcepack.PathConstants;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.SimpleResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * Base implementation of {@link MutableImageResourcePackAsset} that reference images by a file path (and thus does not support any operations or checks on the content of the image)
+ */
+public abstract class SimpleImageFileResourcePackAsset extends SimpleResourcePackAsset implements MutableImageResourcePackAsset {
+
+    public final boolean existsInIncludedResourcePack;
+    private @Nullable String imageFilePath;
+
+    protected SimpleImageFileResourcePackAsset(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(key, dirty);
+        this.existsInIncludedResourcePack = existsInIncludedResourcePack;
+        this.imageFilePath = imageFilePath;
+    }
+
+    protected SimpleImageFileResourcePackAsset(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key) {
+        super(key);
+        this.existsInIncludedResourcePack = existsInIncludedResourcePack;
+        this.imageFilePath = imageFilePath;
+    }
+
+    @Override
+    public void writeTo(@NotNull OutputStream outputStream) throws IOException {
+        if (this.existsInIncludedResourcePack) {
+            return;
+        }
+        Validate.notNull(this.imageFilePath, "Image file path of simple image file asset " + this.getKey() + " cannot be null when writing to an output stream");
+        try (@NotNull FileInputStream fileInputStream = new FileInputStream(this.imageFilePath)) {
+            outputStream.write(fileInputStream.readAllBytes());
+        }
+    }
+
+    @Override
+    public boolean hasMeta() {
+        return new File(this.imageFilePath + PathConstants.metaFileSuffix).exists();
+    }
+
+    @Override
+    public void writeMetaTo(@NotNull OutputStream outputStream) throws IOException, UnsupportedOperationException, IllegalStateException {
+        File metaFile = new File(this.imageFilePath + PathConstants.metaFileSuffix);
+        if (!metaFile.exists()) {
+            throw new IllegalStateException("Called SimpleImageFileResourcePackAsset.writeMetaTo for an asset that has no meta");
+        }
+        try (@NotNull FileInputStream fileInputStream = new FileInputStream(metaFile)) {
+            outputStream.write(fileInputStream.readAllBytes());
+        }
+    }
+
+    public @NotNull MutableImageResourcePackAsset merge(@NotNull ResourcePackAsset other) {
+        Validate.isInstanceOf(MutableImageResourcePackAsset.class, other);
+        if (this.hasData()) {
+            return this;
+        }
+        return (MutableImageResourcePackAsset) other;
+    }
+
+    @Override
+    public boolean hasData() {
+        return this.existsInIncludedResourcePack || this.imageFilePath != null;
+    }
+
+    public void setImageFilePath(@NotNull String imageFilePath) {
+        if (!imageFilePath.equals(this.imageFilePath)) {
+            this.imageFilePath = imageFilePath;
+            this.setDirty();
+        }
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/intention/NamespacedKeyWithIntention.java b/src/main/java/org/sucraft/suki/resourcepack/asset/intention/NamespacedKeyWithIntention.java
new file mode 100644
index 0000000000000000000000000000000000000000..f7991beef990fa0d082a1ac172db1b3f2227c5da
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/intention/NamespacedKeyWithIntention.java
@@ -0,0 +1,37 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.intention;
+
+import org.jetbrains.annotations.NotNull;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A simple record that represents a {@link NamespacedKey} that includes the intention in the key
+ * <br>
+ * This record just indicates that the intention, if any, was certainly included: if there is no intention for the resource this key represents, the intention can be null
+ */
+public record NamespacedKeyWithIntention(@NotNull String namespace, @Nullable ResourcePackAssetIntention intention, @NotNull String keyWithoutIntention) {
+
+    public @NotNull NamespacedKeyWithoutIntention withoutIntention() {
+        return new NamespacedKeyWithoutIntention(this.namespace, this.keyWithoutIntention);
+    }
+
+    public @NotNull String keyWithIntention() {
+        return this.intention == null ? this.keyWithoutIntention : this.intention.prefix + "/" + this.keyWithoutIntention;
+    }
+
+    public @NotNull NamespacedKeyWithIntention withKeySuffix(@NotNull String suffix) {
+        return new NamespacedKeyWithIntention(this.namespace, this.intention, this.keyWithoutIntention + suffix);
+    }
+
+    public @NotNull NamespacedKeyWithIntention withKeyPrefix(@NotNull String prefix) {
+        return new NamespacedKeyWithIntention(this.namespace, this.intention, prefix + this.keyWithoutIntention);
+    }
+
+    @Override
+    public @NotNull String toString() {
+        return this.namespace + ":" + this.keyWithIntention();
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/intention/NamespacedKeyWithoutIntention.java b/src/main/java/org/sucraft/suki/resourcepack/asset/intention/NamespacedKeyWithoutIntention.java
new file mode 100644
index 0000000000000000000000000000000000000000..43b320a21149ebceb06782a24dab8550d3d9cceb
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/intention/NamespacedKeyWithoutIntention.java
@@ -0,0 +1,61 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.intention;
+
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A simple record that represents a {@link NamespacedKey} that certainly does not include the intention in the key
+ * <br>
+ * This record just indicates that the intention, if any, was certainly excluded: if there is no intention for the resource this key represents, {@link NamespacedKeyWithIntention} should still be used when the potential (but not certainly existing) intention is required
+ */
+public record NamespacedKeyWithoutIntention(@NotNull String namespace, @NotNull String keyWithoutIntention) {
+
+    public @NotNull NamespacedKeyWithIntention withIntention(@NotNull ResourcePackAssetIntention intention) {
+        return new NamespacedKeyWithIntention(this.namespace, intention, this.keyWithoutIntention);
+    }
+
+    public @NotNull NamespacedKeyWithIntention withEmptyIntention() {
+        return new NamespacedKeyWithIntention(this.namespace, null, this.keyWithoutIntention);
+    }
+
+    public @NotNull NamespacedKeyWithoutIntention withKeySuffix(@NotNull String suffix) {
+        return new NamespacedKeyWithoutIntention(this.namespace, this.keyWithoutIntention + suffix);
+    }
+
+    public @NotNull NamespacedKeyWithoutIntention withKeyPrefix(@NotNull String prefix) {
+        return new NamespacedKeyWithoutIntention(this.namespace, prefix + this.keyWithoutIntention);
+    }
+
+    public @NotNull NamespacedKey asBukkit() {
+        return new NamespacedKey(this.namespace, this.keyWithoutIntention);
+    }
+
+    public @NotNull ResourceLocation asMinecraft() {
+        return new ResourceLocation(this.namespace, this.keyWithoutIntention);
+    }
+
+    @Override
+    public @NotNull String toString() {
+        return this.namespace + ":" + this.keyWithoutIntention();
+    }
+
+    public static @NotNull NamespacedKeyWithoutIntention forBukkit(@NotNull NamespacedKey key) {
+        return new NamespacedKeyWithoutIntention(key.getNamespace(), key.getKey());
+    }
+
+    public static @NotNull NamespacedKeyWithoutIntention forMinecraft(@NotNull ResourceLocation resourceLocation) {
+        return new NamespacedKeyWithoutIntention(resourceLocation.getNamespace(), resourceLocation.getPath());
+    }
+
+    public static @NotNull NamespacedKeyWithoutIntention minecraft(@NotNull String keyWithoutIntention) {
+        return new NamespacedKeyWithoutIntention(ResourceLocation.DEFAULT_NAMESPACE, keyWithoutIntention);
+    }
+
+    public static @NotNull NamespacedKeyWithoutIntention sucraft(@NotNull String keyWithoutIntention) {
+        return new NamespacedKeyWithoutIntention(ResourceLocation.SUCRAFT_NAMESPACE, keyWithoutIntention);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/intention/ResourcePackAssetIntention.java b/src/main/java/org/sucraft/suki/resourcepack/asset/intention/ResourcePackAssetIntention.java
new file mode 100644
index 0000000000000000000000000000000000000000..90d8a4da27cf8a8010cf307017f362d451c838bd
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/intention/ResourcePackAssetIntention.java
@@ -0,0 +1,24 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.intention;
+
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * The intention of a {@link ResourcePackAsset}
+ * <br>
+ * Not all asset types use intentions
+ */
+public enum ResourcePackAssetIntention {
+
+    BLOCK("block"),
+    ITEM("item");
+
+    public final @NotNull String prefix;
+
+    ResourcePackAssetIntention(@NotNull String prefix) {
+        this.prefix = prefix;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/json/JsonResourcePackAsset.java b/src/main/java/org/sucraft/suki/resourcepack/asset/json/JsonResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..88c3d768b0662bc9120d71eabed4f83900ce0034
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/json/JsonResourcePackAsset.java
@@ -0,0 +1,21 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.json;
+
+import com.google.gson.JsonObject;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A {@link ResourcePackAsset} with JSON data
+ */
+public interface JsonResourcePackAsset extends ResourcePackAsset {
+
+    @Override
+    @NotNull JsonResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    @NotNull JsonObject getJsonCopy();
+
+    boolean isJsonEmpty();
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/json/MutableJsonResourcePackAsset.java b/src/main/java/org/sucraft/suki/resourcepack/asset/json/MutableJsonResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..43be29717e114434745cebab14d2592f9ddfeea4
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/json/MutableJsonResourcePackAsset.java
@@ -0,0 +1,19 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.json;
+
+import org.sucraft.suki.resourcepack.asset.MutableResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link JsonResourcePackAsset}
+ */
+public interface MutableJsonResourcePackAsset extends MutableResourcePackAsset, JsonResourcePackAsset {
+
+    @Override
+    @NotNull MutableJsonResourcePackAsset merge(@NotNull ResourcePackAsset other);
+
+    void clearJson();
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/json/SimpleJsonResourcePackAsset.java b/src/main/java/org/sucraft/suki/resourcepack/asset/json/SimpleJsonResourcePackAsset.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a4ce43fb5242dcfe02115a0bfede15dc1259815
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/json/SimpleJsonResourcePackAsset.java
@@ -0,0 +1,102 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.json;
+
+import com.google.common.base.Charsets;
+import com.google.gson.JsonObject;
+import org.sucraft.suki.json.JsonMerging;
+import org.sucraft.suki.resourcepack.asset.MutableResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.SimpleResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+/**
+ * Base implementation of {@link MutableJsonResourcePackAsset}
+ */
+public abstract class SimpleJsonResourcePackAsset<T extends SimpleJsonResourcePackAsset<T>> extends SimpleResourcePackAsset implements MutableJsonResourcePackAsset {
+
+    protected interface JsonResourcePackAssetConstructor<T extends SimpleJsonResourcePackAsset<T>> {
+
+        @NotNull T construct(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty);
+
+    }
+
+    private final @NotNull JsonResourcePackAssetConstructor<T> constructor;
+    private @NotNull JsonObject json;
+
+    protected SimpleJsonResourcePackAsset(@NotNull JsonResourcePackAssetConstructor<T> constructor, @NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(key, dirty);
+        this.constructor = constructor;
+        this.json = json;
+    }
+
+    protected SimpleJsonResourcePackAsset(@NotNull JsonResourcePackAssetConstructor<T> constructor, @NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key) {
+        super(key);
+        this.constructor = constructor;
+        this.json = json;
+    }
+
+    protected abstract void makeJsonUpToDate(@NotNull JsonObject json);
+
+    protected void updateJsonDirectly(@NotNull Consumer<@NotNull JsonObject> jsonConsumer) {
+        jsonConsumer.accept(this.json);
+    }
+
+    protected void replaceJsonDirectly(@NotNull Function<@NotNull JsonObject, @NotNull JsonObject> jsonFunction) {
+        this.json = jsonFunction.apply(this.json);
+    }
+
+    protected @NotNull JsonObject getUpToDateJson() {
+        this.makeJsonUpToDate(this.json);
+        return this.json;
+    }
+
+    @Override
+    public void writeTo(@NotNull OutputStream outputStream) throws IOException {
+//        if (this.getKey().withoutIntention().toString().equals("minecraft:infested_stone_bricks")) {
+//            System.out.println("TEMP DEBUG - writing to output stream as: " + this.getJsonCopy().toString());
+//            System.out.println("TEMP DEBUG - up to date makes: " + this.getUpToDateJson().toString());
+//        }
+        outputStream.write(this.getUpToDateJson().toString().getBytes(Charsets.UTF_8));
+    }
+
+    public @NotNull T merge(@NotNull ResourcePackAsset other) {
+        Validate.isTrue(this.getType() == other.getType());
+        @NotNull JsonObject otherJson;
+        if (other instanceof SimpleJsonResourcePackAsset<?> simpleOther) {
+            otherJson = simpleOther.getUpToDateJson();
+        } else {
+            otherJson = ((JsonResourcePackAsset) other).getJsonCopy();
+        }
+        boolean otherDirty;
+        if (other instanceof MutableResourcePackAsset mutableOther) {
+            otherDirty = mutableOther.isDirty();
+        } else {
+            otherDirty = false;
+        }
+        return this.constructor.construct(JsonMerging.merge(this.getUpToDateJson(), otherJson), this.getKey(), this.isDirty() || otherDirty);
+    }
+
+    public @NotNull JsonObject getJsonCopy() {
+        return this.getUpToDateJson().deepCopy();
+    }
+
+    @Override
+    public boolean isJsonEmpty() {
+        return this.getUpToDateJson().keySet().isEmpty();
+    }
+
+    @Override
+    public void clearJson() {
+        this.json = new JsonObject();
+        this.setDirty();
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/model/ConcreteResourcePackModel.java b/src/main/java/org/sucraft/suki/resourcepack/asset/model/ConcreteResourcePackModel.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b4505f7b5824de38a1ec290510df4f76ded4b3d
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/model/ConcreteResourcePackModel.java
@@ -0,0 +1,369 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.model;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import it.unimi.dsi.fastutil.Pair;
+import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
+import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelPosition;
+import org.sucraft.suki.item.ItemReplacementRule;
+import org.sucraft.suki.resourcepack.KeyConstants;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.blockanditemdata.texture.Texture;
+import org.sucraft.suki.resourcepack.asset.json.SimpleJsonResourcePackAsset;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.StreamSupport;
+
+/**
+ * Concrete implementation of {@link MutableResourcePackModel}
+ */
+public class ConcreteResourcePackModel extends SimpleJsonResourcePackAsset<ConcreteResourcePackModel> implements MutableResourcePackModel {
+
+    protected final @NotNull IntSet customModelDataThatWasOverridden = new IntOpenHashSet(0);
+
+    protected @Nullable JsonArray blockEntityElementsYetToSet = null;
+    protected @Nullable Texture allTextureYetToSet = null;
+    protected @Nullable Texture fireTextureYetToSet = null;
+    protected @Nullable Texture endTextureYetToSet = null;
+    protected @Nullable Texture sideTextureYetToSet = null;
+    protected @Nullable Texture bottomTextureYetToSet = null;
+    protected @Nullable Texture topTextureYetToSet = null;
+    protected final @NotNull List<@NotNull Pair<@NotNull Integer, @NotNull Model>> overridesYetToWriteToJson = new ArrayList<>(0);
+    protected boolean modelOverridesMustYetBeSorted = false;
+
+    public ConcreteResourcePackModel(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(ConcreteResourcePackModel::new, json, key, dirty);
+    }
+
+    public ConcreteResourcePackModel(@NotNull JsonObject json, @NotNull NamespacedKeyWithIntention key) {
+        super(ConcreteResourcePackModel::new, json, key);
+    }
+
+    public ConcreteResourcePackModel(@NotNull ResourcePackModel reference) {
+        this(reference.getJsonCopy(), reference.getKey());
+    }
+
+    @Override
+    public @NotNull ResourcePackAssetType getType() {
+        return ResourcePackAssetType.MODEL;
+    }
+
+    @Override
+    protected void makeJsonUpToDate(@NotNull JsonObject json) {
+        if (this.blockEntityElementsYetToSet != null) {
+            this.updateJsonWithBlockEntityElements(json, this.blockEntityElementsYetToSet);
+            this.blockEntityElementsYetToSet = null;
+        }
+        this.updateJsonWithYetToSetTextures(json);
+        this.overridesYetToWriteToJson.forEach(pair -> this.updateJsonWithModelOverride(json, pair.left(), pair.right()));
+        this.overridesYetToWriteToJson.clear();
+        if (this.modelOverridesMustYetBeSorted) {
+            this.updateJsonWithSortedModelOverrides(json);
+            this.modelOverridesMustYetBeSorted = false;
+        }
+    }
+
+    @Override
+    public void setParent(@NotNull Model parent) {
+        this.updateJsonDirectly(json -> {
+            json.addProperty(KeyConstants.assetParent, parent.getKeyWithIntention().toString());
+        });
+        this.setDirty();
+    }
+
+    @Override
+    public void setBlockEntityHeadDisplay(@NotNull BlockEntityModelPosition position) {
+        this.updateJsonDirectly(json -> {
+            @NotNull JsonObject displayJson;
+            if (json.has(KeyConstants.display)) {
+                displayJson = json.getAsJsonObject(KeyConstants.display);
+            } else {
+                displayJson = new JsonObject();
+                json.add(KeyConstants.display, displayJson);
+            }
+            @NotNull JsonObject headJson;
+            if (displayJson.has(KeyConstants.displayHead)) {
+                headJson = displayJson.getAsJsonObject(KeyConstants.displayHead);
+            } else {
+                headJson = new JsonObject();
+                displayJson.add(KeyConstants.displayHead, headJson);
+            }
+            @NotNull JsonArray translationJson = new JsonArray(3);
+            @NotNull JsonArray scaleJson = new JsonArray(3);
+            translationJson.add(position.displayTranslationX);
+            translationJson.add(-30.42555F - BLOCK_ENTITY_ARMOR_STAND_DY * (1.6F * 16));
+            translationJson.add(position.displayTranslationZ);
+            scaleJson.add(-1.6F);
+            scaleJson.add(1.6F);
+            scaleJson.add(-1.6F);
+            headJson.add(KeyConstants.displayTranslation, translationJson);
+            headJson.add(KeyConstants.displayScale, scaleJson);
+        });
+    }
+
+    private void updateJsonWithBlockEntityElements(@NotNull JsonObject json, @NotNull JsonArray elementsJson) {
+        json.add(KeyConstants.elements, elementsJson);
+    }
+
+    @Override
+    public void setBlockEntityElements(@NotNull JsonArray elementsJson) {
+        this.blockEntityElementsYetToSet = elementsJson;
+    }
+
+    private void updateJsonWithYetToSetTextures(@NotNull JsonObject json) {
+        if (this.allTextureYetToSet == null && this.fireTextureYetToSet == null && this.endTextureYetToSet == null && this.sideTextureYetToSet == null && this.bottomTextureYetToSet == null && this.topTextureYetToSet == null) {
+            return;
+        }
+        @NotNull JsonObject texturesJson;
+        if (json.has(KeyConstants.modelTextures)) {
+            texturesJson = json.getAsJsonObject(KeyConstants.modelTextures);
+        } else {
+            texturesJson = new JsonObject();
+            json.add(KeyConstants.modelTextures, texturesJson);
+        }
+        if (this.allTextureYetToSet != null) {
+            texturesJson.addProperty(KeyConstants.modelTexturesAll, this.allTextureYetToSet.getKeyWithIntention().toString());
+            this.allTextureYetToSet = null;
+        }
+        if (this.fireTextureYetToSet != null) {
+            texturesJson.addProperty(KeyConstants.modelTexturesFire, this.fireTextureYetToSet.getKeyWithIntention().toString());
+            this.fireTextureYetToSet = null;
+        }
+        if (this.endTextureYetToSet != null) {
+            texturesJson.addProperty(KeyConstants.modelTexturesEnd, this.endTextureYetToSet.getKeyWithIntention().toString());
+            this.endTextureYetToSet = null;
+        }
+        if (this.sideTextureYetToSet != null) {
+            texturesJson.addProperty(KeyConstants.modelTexturesSide, this.sideTextureYetToSet.getKeyWithIntention().toString());
+            this.sideTextureYetToSet = null;
+        }
+        if (this.bottomTextureYetToSet != null) {
+            texturesJson.addProperty(KeyConstants.modelTexturesBottom, this.bottomTextureYetToSet.getKeyWithIntention().toString());
+            this.bottomTextureYetToSet = null;
+        }
+        if (this.topTextureYetToSet != null) {
+            texturesJson.addProperty(KeyConstants.modelTexturesTop, this.topTextureYetToSet.getKeyWithIntention().toString());
+            this.topTextureYetToSet = null;
+        }
+    }
+
+    @Override
+    public void setAllTextures(@NotNull Texture texture) {
+        this.allTextureYetToSet = texture;
+        this.setDirty();
+    }
+
+    @Override
+    public void setFireTexture(@NotNull Texture texture) {
+        this.fireTextureYetToSet = texture;
+        this.setDirty();
+    }
+
+    @Override
+    public void setColumnTextures(@NotNull Texture endTexture, @NotNull Texture sideTexture) {
+        this.endTextureYetToSet = endTexture;
+        this.sideTextureYetToSet = sideTexture;
+        this.setDirty();
+    }
+
+    @Override
+    public void setBottomTopTextures(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture) {
+        this.bottomTextureYetToSet = bottomTexture;
+        this.sideTextureYetToSet = sideTexture;
+        this.topTextureYetToSet = topTexture;
+        this.setDirty();
+    }
+
+    private void updateJsonWithModelOverride(@NotNull JsonObject json, int customModelData, @NotNull Model overridingModel) {
+        @NotNull JsonArray overridesJson;
+        if (json.has(KeyConstants.modelOverrides)) {
+            overridesJson = json.getAsJsonArray(KeyConstants.modelOverrides);
+        } else {
+            overridesJson = new JsonArray();
+            json.add(KeyConstants.modelOverrides, overridesJson);
+        }
+        // Make sure we try to find an override with the same predicate as that we're trying to create
+        @NotNull JsonObject predicateJson = new JsonObject();
+        predicateJson.addProperty(KeyConstants.customModelData, customModelData);
+        @Nullable JsonObject overrideJson = null;
+        for (JsonElement existingOverrideJson : overridesJson) {
+            if (existingOverrideJson instanceof JsonObject existingOverrideJsonObject) {
+                @Nullable JsonElement existingOverridePredicateJson = existingOverrideJsonObject.get(KeyConstants.overridePredicate);
+                if (existingOverridePredicateJson != null && existingOverridePredicateJson.equals(predicateJson)) {
+                    overrideJson = existingOverrideJsonObject;
+                    break;
+                }
+            }
+        }
+        if (overrideJson == null) {
+            // We need to create a new override because none with the desired predicate existed
+            overrideJson = new JsonObject();
+            overrideJson.add(KeyConstants.overridePredicate, predicateJson);
+            overridesJson.add(overrideJson);
+        }
+        overrideJson.addProperty(KeyConstants.model, overridingModel.getKeyWithIntention().toString());
+    }
+
+    @Override
+    public void addModelOverride(int customModelData, @NotNull Model overridingModel) {
+        this.customModelDataThatWasOverridden.add(customModelData);
+        boolean alreadyReplaced = false;
+        for (int i = 0; i < this.overridesYetToWriteToJson.size(); i++) {
+            if (this.overridesYetToWriteToJson.get(i).left() == customModelData) {
+                this.overridesYetToWriteToJson.set(i, Pair.of(customModelData, overridingModel));
+                alreadyReplaced = true;
+                break;
+            }
+        }
+        if (!alreadyReplaced) {
+            this.overridesYetToWriteToJson.add(Pair.of(customModelData, overridingModel));
+        }
+        this.setDirty();
+    }
+
+    private void updateJsonWithSortedModelOverrides(@NotNull JsonObject json) {
+        if (!json.has(KeyConstants.modelOverrides)) {
+            return;
+        }
+        @NotNull JsonArray overridesJson = json.getAsJsonArray(KeyConstants.modelOverrides);
+        @NotNull JsonArray newOverridesJson = new JsonArray(overridesJson.size());
+        StreamSupport.stream(overridesJson.spliterator(), false).sorted((overrideJson1, overrideJson2) -> {
+            JsonObject overridePredicate1 = ((JsonObject) overrideJson1).getAsJsonObject(KeyConstants.overridePredicate);
+            JsonObject overridePredicate2 = ((JsonObject) overrideJson2).getAsJsonObject(KeyConstants.overridePredicate);
+            int customModelData1 = overridePredicate1.has(KeyConstants.customModelData) ? overridePredicate1.get(KeyConstants.customModelData).getAsInt() : Integer.MAX_VALUE;
+            int customModelData2 = overridePredicate2.has(KeyConstants.customModelData) ? overridePredicate2.get(KeyConstants.customModelData).getAsInt() : Integer.MAX_VALUE;
+            return Integer.compare(customModelData1, customModelData2);
+        }).forEach(newOverridesJson::add);
+        json.add(KeyConstants.modelOverrides, newOverridesJson);
+    }
+
+    private void sortModelOverrides() {
+        this.modelOverridesMustYetBeSorted = true;
+    }
+
+    @Override
+    public void writeTo(@NotNull OutputStream outputStream) throws IOException {
+        this.sortModelOverrides();
+        super.writeTo(outputStream);
+    }
+
+    public void minifyModelOverrides() {
+        boolean[] jsonAlreadyHasModelOverrides = {false};
+        this.updateJsonDirectly(json -> jsonAlreadyHasModelOverrides[0] = json.has(KeyConstants.modelOverrides));
+        if (!(jsonAlreadyHasModelOverrides[0] || !this.overridesYetToWriteToJson.isEmpty())) {
+            return;
+        }
+        Item item = Registry.ITEM.get(this.getKey().withoutIntention().asMinecraft());
+        if (jsonAlreadyHasModelOverrides[0]) {
+
+            // Place all the overrides in the JSON
+            this.getUpToDateJson();
+
+            // Update the JSON directly
+            this.updateJsonDirectly(json -> {
+                @NotNull JsonArray overridesJson = json.getAsJsonArray(KeyConstants.modelOverrides);
+                Object2IntMap<String> minifiedCustomModelDataByModel = new Object2IntOpenHashMap<>(overridesJson.size() * 2);
+                int[] nextMinifiedCustomModelData = {1};
+                IntSet disallowedMinifiedCustomModelData = new IntOpenHashSet(0);
+                for (int i = 0; i < overridesJson.size(); i++) {
+                    JsonObject overrideJson = (JsonObject) overridesJson.get(i);
+                    if (overrideJson.has(KeyConstants.overridePredicate) && overrideJson.has(KeyConstants.model)) {
+                        JsonObject overridePredicate = overrideJson.getAsJsonObject(KeyConstants.overridePredicate);
+                        if (overridePredicate.has(KeyConstants.customModelData)) {
+                            int customModelData = overridePredicate.get(KeyConstants.customModelData).getAsInt();
+                            if (!this.customModelDataThatWasOverridden.contains(customModelData)) {
+                                disallowedMinifiedCustomModelData.add(customModelData);
+                            }
+                        }
+                    }
+                }
+                for (int[] i = {0}; i[0] < overridesJson.size(); i[0]++) {
+                    JsonObject overrideJson = (JsonObject) overridesJson.get(i[0]);
+                    if (overrideJson.has(KeyConstants.overridePredicate) && overrideJson.has(KeyConstants.model)) {
+                        JsonObject overridePredicate = overrideJson.getAsJsonObject(KeyConstants.overridePredicate);
+                        if (overridePredicate.has(KeyConstants.customModelData) && overridePredicate.keySet().size() == 1) {
+                            int customModelData = overridePredicate.get(KeyConstants.customModelData).getAsInt();
+                            if (this.customModelDataThatWasOverridden.contains(customModelData)) {
+                                String model = Validate.notNull(overrideJson.get(KeyConstants.model).getAsString());
+                                minifiedCustomModelDataByModel.compute(model, ($, minifiedCustomModelData) -> {
+                                    if (minifiedCustomModelData == null) {
+                                        while (disallowedMinifiedCustomModelData.contains(nextMinifiedCustomModelData[0])) {
+                                            nextMinifiedCustomModelData[0]++;
+                                        }
+                                        int newMinifiedCustomModelData = nextMinifiedCustomModelData[0];
+                                        nextMinifiedCustomModelData[0]++;
+                                        ItemReplacementRule.addMinifiedCustomModelData(item, customModelData, newMinifiedCustomModelData);
+                                        overridePredicate.addProperty(KeyConstants.customModelData, newMinifiedCustomModelData);
+                                        return newMinifiedCustomModelData;
+                                    }
+                                    ItemReplacementRule.addMinifiedCustomModelData(item, customModelData, minifiedCustomModelData);
+                                    overridesJson.remove(i[0]);
+                                    i[0]--;
+                                    return minifiedCustomModelData;
+                                });
+                            }
+                        }
+                    }
+                }
+            });
+
+        } else {
+            // Update the model overrides yet to add directly
+
+//            if (item.equals(Items.WHEAT)) {
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - Before: " + this.overridesYetToWriteToJson.stream().map(pair -> pair.left() + " -> " + pair.right().getKeyWithIntention()).toList());
+//            }
+
+            Object2IntMap<String> minifiedCustomModelDataByModel = new Object2IntOpenHashMap<>(this.overridesYetToWriteToJson.size() * 2);
+            int[] nextMinifiedCustomModelData = {1};
+            IntSet disallowedMinifiedCustomModelData = new IntOpenHashSet(0);
+            for (int[] i = {0}; i[0] < this.overridesYetToWriteToJson.size(); i[0]++) {
+                var pair = this.overridesYetToWriteToJson.get(i[0]);
+                int customModelData = pair.left();
+                var overridingModel = pair.right();
+                minifiedCustomModelDataByModel.compute(overridingModel.getKeyWithIntention().toString(), ($, minifiedCustomModelData) -> {
+                    if (minifiedCustomModelData == null) {
+                        while (disallowedMinifiedCustomModelData.contains(nextMinifiedCustomModelData[0])) {
+                            nextMinifiedCustomModelData[0]++;
+                        }
+                        int newMinifiedCustomModelData = nextMinifiedCustomModelData[0];
+                        nextMinifiedCustomModelData[0]++;
+                        ItemReplacementRule.addMinifiedCustomModelData(item, customModelData, newMinifiedCustomModelData);
+                        this.overridesYetToWriteToJson.set(i[0], Pair.of(newMinifiedCustomModelData, overridingModel));
+                        return newMinifiedCustomModelData;
+                    }
+                    ItemReplacementRule.addMinifiedCustomModelData(item, customModelData, minifiedCustomModelData);
+                    this.overridesYetToWriteToJson.remove(i[0]);
+                    i[0]--;
+                    return minifiedCustomModelData;
+                });
+            }
+
+//            if (item.equals(Items.WHEAT)) {
+//                MinecraftServer.LOGGER.info("TEMP DEBUG - After: " + this.overridesYetToWriteToJson.stream().map(pair -> pair.left() + " -> " + pair.right().getKeyWithIntention()).toList());
+//            }
+
+        }
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/model/MutableResourcePackModel.java b/src/main/java/org/sucraft/suki/resourcepack/asset/model/MutableResourcePackModel.java
new file mode 100644
index 0000000000000000000000000000000000000000..0e3a9a8eb9e800906b0eb61804e5815ef6aaeb5e
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/model/MutableResourcePackModel.java
@@ -0,0 +1,60 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.model;
+
+import com.google.gson.JsonArray;
+import com.google.gson.JsonObject;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.server.MinecraftServer;
+import org.sucraft.suki.blockanditemdata.model.BlockEntityModelPosition;
+import org.sucraft.suki.blockanditemdata.model.Model;
+import org.sucraft.suki.blockanditemdata.texture.Texture;
+import org.sucraft.suki.resourcepack.MutableResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.json.MutableJsonResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+/**
+ * A mutable {@link ResourcePackModel}
+ */
+public interface MutableResourcePackModel extends MutableJsonResourcePackAsset, ResourcePackModel {
+
+    @Override
+    @NotNull MutableResourcePackModel merge(@NotNull ResourcePackAsset other);
+
+    void setParent(@NotNull Model parent);
+
+    void setBlockEntityHeadDisplay(@NotNull BlockEntityModelPosition position);
+
+    void setBlockEntityElements(@NotNull JsonArray elementsJson);
+
+    void setAllTextures(@NotNull Texture texture);
+
+    void setFireTexture(@NotNull Texture texture);
+
+    void setColumnTextures(@NotNull Texture endTexture, @NotNull Texture sideTexture);
+
+    void setBottomTopTextures(@NotNull Texture bottomTexture, @NotNull Texture sideTexture, @NotNull Texture topTexture);
+
+    /**
+     * @param pack Because this instance is not aware of the resource pack it is in, this pack must be provided to automatically add the given overriding model to the resource pack
+     * @param overwriteExistingOverridingModel Whether to overwrite an existing model in the resource pack (this has to do with the overriding model, not with this model instance: this instance's overrides property is always modified by this method)
+     */
+    default @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> addModelOverride(int customModelData, @NotNull Model overridingModel, @NotNull MutableResourcePack pack, boolean overwriteExistingOverridingModel, boolean actuallyAdd) {
+        if (actuallyAdd) {
+//            MinecraftServer.LOGGER.info("Actually adding model override in " + this.getKey() + " for " + customModelData + " to " + overridingModel.getKeyWithIntention());
+            this.addModelOverride(customModelData, overridingModel);
+        }
+        return overridingModel.addToResourcePack(pack, overwriteExistingOverridingModel, actuallyAdd);
+    }
+
+    /**
+     * This does not automatically add the overriding model to the resource pack
+     */
+    void addModelOverride(int customModelData, @NotNull Model overridingModel);
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/model/ResourcePackModel.java b/src/main/java/org/sucraft/suki/resourcepack/asset/model/ResourcePackModel.java
new file mode 100644
index 0000000000000000000000000000000000000000..9439de0e748512b5bdc6130b533eb1522576e160
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/model/ResourcePackModel.java
@@ -0,0 +1,21 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.model;
+
+import org.sucraft.suki.resourcepack.ResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.json.JsonResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An element of 'models' in a {@link ResourcePack}
+ */
+public interface ResourcePackModel extends JsonResourcePackAsset {
+
+    @Override
+    @NotNull ResourcePackModel merge(@NotNull ResourcePackAsset other);
+
+    float BLOCK_ENTITY_ARMOR_STAND_DY = -0.01F;
+//    short DOUBLE_BLOCK_ENTITY_ARMOR_STAND_DXZ_AS_POS_MOVE_SHORT = 32 * 128;
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/texture/ConcreteResourcePackTexture.java b/src/main/java/org/sucraft/suki/resourcepack/asset/texture/ConcreteResourcePackTexture.java
new file mode 100644
index 0000000000000000000000000000000000000000..6d5129ad15e012517c3fce264a36405ec2ab396a
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/texture/ConcreteResourcePackTexture.java
@@ -0,0 +1,41 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.texture;
+
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.image.SimpleImageFileResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.model.ResourcePackModel;
+import org.apache.commons.lang3.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Concrete implementation of {@link MutableResourcePackTexture}
+ */
+public class ConcreteResourcePackTexture extends SimpleImageFileResourcePackAsset implements MutableResourcePackTexture {
+
+    public ConcreteResourcePackTexture(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key, boolean dirty) {
+        super(existsInIncludedResourcePack, imageFilePath, key, dirty);
+    }
+
+    public ConcreteResourcePackTexture(boolean existsInIncludedResourcePack, @Nullable String imageFilePath, @NotNull NamespacedKeyWithIntention key) {
+        super(existsInIncludedResourcePack, imageFilePath, key);
+    }
+
+    @Override
+    public @NotNull ResourcePackAssetType getType() {
+        return ResourcePackAssetType.TEXTURE;
+    }
+
+    public @NotNull ConcreteResourcePackTexture merge(@NotNull ResourcePackAsset other) {
+        Validate.isInstanceOf(ConcreteResourcePackTexture.class, other);
+        return (ConcreteResourcePackTexture) super.merge(other);
+    }
+
+    public void setBasedOnFileToImport(@NotNull String fileToImport) {
+        this.setImageFilePath(fileToImport);
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/texture/MutableResourcePackTexture.java b/src/main/java/org/sucraft/suki/resourcepack/asset/texture/MutableResourcePackTexture.java
new file mode 100644
index 0000000000000000000000000000000000000000..801acc05edbb7d9b72d78dee722405072e10bd34
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/texture/MutableResourcePackTexture.java
@@ -0,0 +1,19 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.texture;
+
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.image.MutableImageResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A mutable {@link ResourcePackTexture}
+ */
+public interface MutableResourcePackTexture extends MutableImageResourcePackAsset, ResourcePackTexture {
+
+    @Override
+    @NotNull MutableResourcePackTexture merge(@NotNull ResourcePackAsset other);
+
+    void setBasedOnFileToImport(@NotNull String filePath);
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/asset/texture/ResourcePackTexture.java b/src/main/java/org/sucraft/suki/resourcepack/asset/texture/ResourcePackTexture.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e241f1fec1d9cf5c24465b7d085d592d9805be2
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/asset/texture/ResourcePackTexture.java
@@ -0,0 +1,18 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.asset.texture;
+
+import org.sucraft.suki.resourcepack.ResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.image.ImageResourcePackAsset;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An element of 'textures' in a {@link ResourcePack}
+ */
+public interface ResourcePackTexture extends ImageResourcePackAsset {
+
+    @Override
+    @NotNull ResourcePackTexture merge(@NotNull ResourcePackAsset other);
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/httpserver/ResourcePackHTTPServer.java b/src/main/java/org/sucraft/suki/resourcepack/httpserver/ResourcePackHTTPServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..165965debc37a595394cc5a3af5287aa3d114446
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/httpserver/ResourcePackHTTPServer.java
@@ -0,0 +1,142 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.httpserver;
+
+import com.sun.net.httpserver.HttpExchange;
+import com.sun.net.httpserver.HttpServer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServer;
+import org.sucraft.suki.resourcepack.ResourcePackHash;
+import org.sucraft.suki.resourcepack.sucraft.CreateSuCraftResourcePack;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.InetSocketAddress;
+import java.util.Optional;
+import java.util.concurrent.Executors;
+
+/**
+ * A singleton that runs an HTTP server to serve the server resource pack (or multiple variants of it)
+ */
+public final class ResourcePackHTTPServer {
+
+    private static final @NotNull String PROTOCOL = "http";
+    // Modified for easy testing
+    private static final @NotNull String IP = new File("paper_test_server").exists() || new File("sucraft_test_server").exists() ? "89.35.34.254" : "sucraft.org";
+    private static final int PORT = 25454;
+    private static final @NotNull String PATH = "resourcepack-" + CreateSuCraftResourcePack.getOutputFilePathRandomSuffix();
+
+    public static final @NotNull String RESOURCE_PACK_URL = PROTOCOL + "://" + IP + ":" + PORT + "/" + PATH;
+
+    private ResourcePackHTTPServer() {}
+
+    private static @Nullable ResourcePackHTTPServer instance;
+
+    public static @NotNull ResourcePackHTTPServer getInstance() {
+        if (instance == null) {
+            instance = new ResourcePackHTTPServer();
+        }
+        return instance;
+    }
+
+    private boolean isStarted = false;
+    /**
+     * Only null while not initialized yet
+     */
+    private @Nullable HttpServer httpServer = null;
+
+    public void startIfNotStarted() {
+        if (this.isStarted) {
+            return;
+        }
+        try {
+
+            MinecraftServer.LOGGER.info("Attempting to start the resource pack HTTP server on port " + PORT + "...");
+            // Start the HTTP server
+            this.httpServer = HttpServer.create(new InetSocketAddress(PORT), 0);
+            httpServer.createContext("/" + PATH, ResourcePackHTTPServer::handle);
+            httpServer.setExecutor(Executors.newFixedThreadPool(16, runnable -> {
+                Thread newThread = new Thread(runnable);
+                newThread.setPriority(6);
+                return newThread;
+            }));
+            httpServer.start();
+            this.isStarted = true;
+
+            MinecraftServer.LOGGER.info("It appears the resource HTTP server started successfully");
+
+            // Update the server properties in memory to match the resource pack and HTTP server
+            this.updateServerPropertiesInMemory(false);
+
+        } catch (Exception e) {
+            throw new RuntimeException("Exception occurred while starting the resource pack HTTP server", e);
+        } finally {
+            this.httpServer = null;
+        }
+    }
+
+    /**
+     * The whole resource pack is stored in memory, this seems a much better tradeoff than making retrieving it cost I/O operations
+     */
+    private static byte @Nullable [] resourcePackBytes;
+
+    public static void handle(HttpExchange httpExchange) throws IOException {
+        if (resourcePackBytes == null) {
+            resourcePackBytes = new FileInputStream(CreateSuCraftResourcePack.getOutputFile()).readAllBytes();
+        }
+        try {
+            MinecraftServer.LOGGER.info("Received resource pack HTTP request from " + httpExchange.getRemoteAddress().getAddress());
+        } catch (Throwable e) {}
+        httpExchange.sendResponseHeaders(200, resourcePackBytes.length);
+        OutputStream responseBody = httpExchange.getResponseBody();
+        responseBody.write(resourcePackBytes);
+        responseBody.close();
+    }
+
+    private boolean updatedServerPropertiesInMemoryBefore = false;
+
+    public void updateServerPropertiesInMemory(boolean updateEvenIfAlreadyUpdatedBefore) {
+        if (updatedServerPropertiesInMemoryBefore && !updateEvenIfAlreadyUpdatedBefore) {
+            return;
+        }
+        try {
+
+            var server = MinecraftServer.getServer();
+            if (server == null) { // IntelliJ says that this will never be null, but that is false (due to IntelliJ not understanding the static class initialization order in practice)
+                // We cannot update the server properties if the server was not initialized yet
+                return;
+            }
+            var dedicatedServer = (DedicatedServer) server;
+            var serverProperties = dedicatedServer.getProperties();
+            if (serverProperties == null) { // IntelliJ says that this will never be null, but that is false (due to IntelliJ not understanding the static class initialization order in practice)
+                // We cannot update the server properties if the server properties were not initialized yet
+                return;
+            }
+            var outputFile = CreateSuCraftResourcePack.getOutputFile();
+            if (!outputFile.exists()) {
+                // We cannot update the server properties if the resource pack was not written yet
+                return;
+            }
+            String hash = ResourcePackHash.getHash(outputFile);
+            var previousResourcePackInfo = serverProperties.serverResourcePackInfo.orElse(null);
+            boolean isRequired = previousResourcePackInfo != null ? previousResourcePackInfo.isRequired() : false;
+            var prompt = previousResourcePackInfo != null ? previousResourcePackInfo.prompt() : null;
+            serverProperties.serverResourcePackInfo = Optional.of(new MinecraftServer.ServerResourcePackInfo(
+                RESOURCE_PACK_URL,
+                hash,
+                isRequired,
+                prompt
+            ));
+            MinecraftServer.LOGGER.info("Update server resource pack properties: url = '" + RESOURCE_PACK_URL + "', hash = '" + hash + "', isRequired = " + isRequired + ", prompt = '" + prompt + "'");
+            updatedServerPropertiesInMemoryBefore = true;
+
+        } catch (Exception e) {
+            throw new RuntimeException("Exception occurred while updating server properties in memory, for the resource pack", e);
+        }
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/memory/MemoryResourcePack.java b/src/main/java/org/sucraft/suki/resourcepack/memory/MemoryResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..dba1a0b213979bd30055c3d38746409b6a63f6b2
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/memory/MemoryResourcePack.java
@@ -0,0 +1,265 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.memory;
+
+import com.google.common.base.Charsets;
+import com.google.common.collect.ImmutableList;
+import com.google.gson.JsonObject;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.block.Block;
+import org.sucraft.suki.resourcepack.PathConstants;
+import org.sucraft.suki.resourcepack.asset.blockstates.ConcreteResourcePackBlockStates;
+import org.sucraft.suki.resourcepack.asset.image.MutableImageResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.sucraft.suki.resourcepack.asset.model.ConcreteResourcePackModel;
+import org.sucraft.suki.resourcepack.asset.InitializableResourcePackAssetType;
+import org.sucraft.suki.resourcepack.MutableResourcePack;
+import org.sucraft.suki.resourcepack.asset.MutableResourcePackAsset;
+import org.sucraft.suki.resourcepack.ResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.blockstates.ResourcePackBlockStates;
+import org.sucraft.suki.resourcepack.asset.model.ResourcePackModel;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.texture.ConcreteResourcePackTexture;
+import org.sucraft.suki.resourcepack.asset.texture.ResourcePackTexture;
+import org.sucraft.suki.resourcepack.sucraft.CreateSuCraftResourcePack;
+import org.sucraft.suki.util.CollectionPercentageProgress;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.stream.Stream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * A resource pack available in memory. Can be written to a file. May be backed by a default resource pack (such as the Minecraft default resource pack), and may be based on (and always fully include) a list of other resource packs.
+ */
+public class MemoryResourcePack implements MutableResourcePack {
+
+    /**
+     * The resource pack to pull defaults from (that will be included in this resource pack only if they are modified)
+     * <br>
+     * The resource packs with the lowest index are polled for the requested asset first
+     */
+    private final @NotNull List<@NotNull ResourcePack> defaultResourcePacks = new ArrayList<>();
+
+    /**
+     * The resource pack to inherit values from, that will be always be included in this resource pack
+     * <br>
+     * On a merge conflict, the resource pack with the lowest index determines the used value
+     * (of course, unless also overwritten by this resource pack itself, in which case that value becomes the used value)
+     */
+    private final @NotNull List<@NotNull ResourcePack> includedResourcePacks = new ArrayList<>();
+
+    private final @NotNull MemoryResourcePackSettings settings = new MemoryResourcePackSettings(this);
+
+    private final @NotNull Map<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>, @NotNull MutableResourcePackAsset> assets = new HashMap<>(0);
+
+    public MemoryResourcePack() {}
+
+    @Override
+    public @NotNull Stream<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> getAllFilesStream() throws IOException {
+        throw new UnsupportedOperationException("Cannot stream over all files for a resource pack being constructed in memory");
+    }
+
+    public @NotNull List<@NotNull ResourcePack> getDefaultResourcePacks() {
+        return ImmutableList.copyOf(this.defaultResourcePacks);
+    }
+
+    public void addDefaultResourcePack(@NotNull ResourcePack resourcePack) {
+        if (!this.defaultResourcePacks.contains(resourcePack)) {
+            this.defaultResourcePacks.add(resourcePack);
+        }
+    }
+
+    public @NotNull List<@NotNull ResourcePack> getIncludedResourcePacks() {
+        return ImmutableList.copyOf(this.includedResourcePacks);
+    }
+
+    public void addIncludedResourcePack(@NotNull ResourcePack resourcePack) {
+        if (!this.includedResourcePacks.contains(resourcePack)) {
+            this.includedResourcePacks.add(resourcePack);
+        }
+    }
+
+    public void clearAssetsInMemory() {
+        this.assets.clear();
+//        this.assets.values().stream().filter(asset -> !(asset instanceof ResourcePackTexture)).toList().stream().forEach(this.assets::remove);
+    }
+
+    @Override
+    public @NotNull MemoryResourcePackSettings getSettings() {
+        return this.settings;
+    }
+
+    private @NotNull MutableResourcePackAsset getMutable(@NotNull ResourcePackAssetType type, @NotNull ResourcePackAsset asset) {
+        if (asset instanceof MutableResourcePackAsset mutableAsset) {
+            return mutableAsset;
+        }
+        if (type.equals(ResourcePackAssetType.BLOCK_STATES)) {
+            return new ConcreteResourcePackBlockStates((ResourcePackBlockStates) asset);
+        } else if (type.equals(ResourcePackAssetType.MODEL)) {
+            return new ConcreteResourcePackModel((ResourcePackModel) asset);
+        } else if (type.equals(ResourcePackAssetType.TEXTURE)) {
+            // We assume all ResourcePackTexture to have been MutableResourcePackAsset already (as the current only implementation is ConcreteResourcePackTexture)
+            // since there is immediate obvious way to implement a ConcreteResourcePackTexture(ResourcePackTexture reference) constructor
+            throw new UnsupportedOperationException("Not implemented yet: could implement by adding existsInIncludedResourcePack() and getImageFilePath() methods to ResourcePackTexture interface, but that feels wrong for now");
+        } else {
+            throw new IllegalArgumentException("Attempted to create mutable asset for memory resource pack by cloning a given asset, but the type (" + type.getFolderPathInNamespaceFolder() + ") is not a known copiable type");
+        }
+    }
+
+    @Override
+    public @NotNull MutableResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        @Nullable MutableResourcePackAsset foundOrDerivedAsset = this.assets.computeIfAbsent(Pair.of(type, key), namespacedKey -> {
+            // Try creating a merged asset from the included resource packs
+            @Nullable MutableResourcePackAsset derivedAsset = null;
+            for (@NotNull ResourcePack includedResourcePack : this.getIncludedResourcePacks()) {
+                @Nullable ResourcePackAsset includedAsset = includedResourcePack.getOptionalAsset(type, key);
+                if (includedAsset != null) {
+                    if (derivedAsset == null) {
+                        derivedAsset = this.getMutable(type, includedAsset);
+                    } else {
+                        derivedAsset = derivedAsset.merge(includedAsset);
+                    }
+                }
+            }
+            if (derivedAsset != null) {
+                derivedAsset.setDirty();
+                return derivedAsset;
+            }
+            // Try finding the default form of the asset in the default resource packs
+            for (@NotNull ResourcePack defaultResourcePack : this.getDefaultResourcePacks()) {
+                @Nullable ResourcePackAsset defaultAsset = defaultResourcePack.getOptionalAsset(type, key);
+                if (defaultAsset != null) {
+                    derivedAsset = this.getMutable(type, defaultAsset);
+                    // Edit: this is not a correct implementation TODO fix
+//                    if (type.equals(ResourcePackAssetType.TEXTURE) && CreateSuCraftResourcePack.texturesToIncludeForOlderVersionVisibility.contains(key.keyWithoutIntention())) {
+//                        // Include this texture in the resource pack so players with an older client can also see it on custom blocks, specifically including slabs and stairs
+//                        derivedAsset.setDirty();
+//                    }
+                    return derivedAsset;
+                }
+            }
+            // We can't initially derive this asset from any inherited resource packs
+            return null;
+        });
+        if (foundOrDerivedAsset != null) {
+            return foundOrDerivedAsset;
+        }
+        throw new IllegalArgumentException("Attempted to load required asset from memory resource pack, but none was already created or present in inherited resource packs");
+    }
+
+    @Override
+    public @NotNull MutableResourcePackAsset getOrCreateAsset(@NotNull InitializableResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        @Nullable MutableResourcePackAsset existingAsset = this.getOptionalAsset(type, key);
+        if (existingAsset != null) {
+            return existingAsset;
+        }
+        @NotNull MutableResourcePackAsset newAsset;
+        if (type.equals(ResourcePackAssetType.BLOCK_STATES)) {
+            newAsset = new ConcreteResourcePackBlockStates(new JsonObject(), key);
+        } else if (type.equals(ResourcePackAssetType.MODEL)) {
+            newAsset = new ConcreteResourcePackModel(new JsonObject(), key);
+        } else if (type.equals(ResourcePackAssetType.TEXTURE)) {
+            newAsset = new ConcreteResourcePackTexture(false, null, key);
+        } else {
+            throw new IllegalArgumentException("Attempted to create asset for memory resource pack, but the type (" + type.getFolderPathInNamespaceFolder() + ") is not a known initializable type");
+        }
+        this.assets.put(Pair.of(type, key), newAsset);
+        return newAsset;
+    }
+
+    /**
+     * @return All assets in this resource pack, possibly filtered (if not given null) by asset type, key or intention
+     * <br>
+     * Note that the returned assets are not in any particular order
+     */
+    public @NotNull List<@NotNull MutableResourcePackAsset> getAssets(@Nullable ResourcePackAssetType type, @Nullable NamespacedKeyWithIntention key, @Nullable String namespace, @Nullable ResourcePackAssetIntention intention) {
+        return this.assets.values().stream().filter(asset -> (type == null || asset.getType().equals(type)) && (key == null || asset.getKey().equals(key)) && (namespace == null || asset.getKey().namespace().equals(namespace)) && (intention == null || asset.getKey().intention().equals(intention))).toList();
+    }
+
+    public void writeToFile(@NotNull File file) throws IOException {
+        try (@NotNull FileOutputStream fileOutputStream = new FileOutputStream(file)) {
+            try (@NotNull ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream)) {
+                zipOutputStream.setLevel(9);
+                @NotNull Set<@NotNull String> zippedFilePaths = new HashSet<>();
+                // Add the settings
+                {
+                    zippedFilePaths.add(PathConstants.PackMeta.pathFromRoot);
+                    @NotNull ZipEntry zipEntry = new ZipEntry(PathConstants.PackMeta.pathFromRoot);
+                    zipOutputStream.putNextEntry(zipEntry);
+                    zipOutputStream.write(this.getSettings().createJson().toString().getBytes(Charsets.UTF_8));
+                }
+                // Add the cached assets
+                new CollectionPercentageProgress<>("Writing cached assets to resource pack archive file", this.assets.values().stream().filter(assetInMemory -> assetInMemory.isDirty()).toList(), 5)/* {
+
+                    @Override
+                    public void printProgress(int percentage) {
+                        System.gc();
+                        super.printProgress(percentage);
+                    }
+
+                }*/.forEachThrowsException(assetInMemory -> {
+                        @NotNull String path = assetInMemory.getPathInResourcePack();
+                        zippedFilePaths.add(path);
+                        @NotNull ZipEntry zipEntry = new ZipEntry(path);
+                        zipOutputStream.putNextEntry(zipEntry);
+                        assetInMemory.writeTo(zipOutputStream);
+                        if (assetInMemory.hasMeta()) {
+                            @NotNull String metaPath = path + PathConstants.metaFileSuffix;
+                            zippedFilePaths.add(metaPath);
+                            @NotNull ZipEntry metaZipEntry = new ZipEntry(metaPath);
+                            zipOutputStream.putNextEntry(metaZipEntry);
+                            assetInMemory.writeMetaTo(zipOutputStream);
+                        }
+                    });
+                // Add all files from included resource packs that we haven't added yet
+                new CollectionPercentageProgress<>("Writing included resource pack files to resource pack archive file", this.includedResourcePacks.stream().flatMap(pack -> {
+                    try {
+                        return pack.getAllFilesStream();
+                    } catch (Exception e) {
+                        return Stream.empty();
+                    }
+                }).toList(), 5)/* {
+
+                    @Override
+                    public void printProgress(int percentage) {
+                        System.gc();
+                        super.printProgress(percentage);
+                    }
+
+                }*/.forEachThrowsException(includedResourcePackFile -> {
+                        @NotNull String includedFilePath = includedResourcePackFile.left();
+                        if (zippedFilePaths.add(includedFilePath)) {
+                            try (@NotNull InputStream includedFileInputStream = includedResourcePackFile.right().call()) {
+                                zipOutputStream.putNextEntry(new ZipEntry(includedFilePath));
+                                zipOutputStream.write(includedFileInputStream.readAllBytes());
+                            } catch (Exception e) {
+                                if (e instanceof IOException ioE) {
+                                    throw ioE;
+                                }
+                                throw new IOException("An exception occurred while getting input stream for included resource pack file", e);
+                            }
+                        }
+                    });
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/memory/MemoryResourcePackSettings.java b/src/main/java/org/sucraft/suki/resourcepack/memory/MemoryResourcePackSettings.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb174ed6c9052f09de12284a0b51811f7c6fba46
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/memory/MemoryResourcePackSettings.java
@@ -0,0 +1,80 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.memory;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import org.sucraft.suki.resourcepack.ResourcePack;
+import org.sucraft.suki.resourcepack.ResourcePackSettings;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * The top-level settings of a {@link MemoryResourcePack}
+ */
+public class MemoryResourcePackSettings implements ResourcePackSettings {
+
+    private static final @NotNull String DEFAULT_NAME = "Resource pack";
+    private static final @NotNull JsonElement DEFAULT_DESCRIPTION = JsonParser.parseString("[\"A resource pack\"]");
+
+    private final @NotNull MemoryResourcePack pack;
+
+    /**
+     * The name of the resource pack, which is not defined within the resource pack anywhere, but is defined by its filename without the extension
+     * <br>
+     * Note: because the filename of downloaded server resource packs is changed, this value is not relevant for resource packs used as a server resource pack
+     */
+    private @Nullable String name;
+
+    /**
+     * The description of the resource pack, displayed in the resource pack GUI
+     */
+    private @Nullable JsonElement description;
+
+    MemoryResourcePackSettings(@NotNull MemoryResourcePack pack) {
+        this.pack = pack;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        if (this.name == null) {
+            // Get the name from the first included resource pack
+            List<@NotNull ResourcePack> includedResourcePacks = this.pack.getDefaultResourcePacks();
+            if (!includedResourcePacks.isEmpty()) {
+                this.name = includedResourcePacks.get(0).getSettings().getName();
+            }
+            if (this.name == null) {
+                // Use the default name
+                this.name = DEFAULT_NAME;
+            }
+        }
+        return this.name;
+    }
+
+    public void setName(@NotNull String name) {
+        this.name = name;
+    }
+
+    @Override
+    public @NotNull JsonElement getDescription() {
+        if (this.description == null) {
+            // Get the description from the first included resource pack
+            List<@NotNull ResourcePack> includedResourcePacks = this.pack.getDefaultResourcePacks();
+            if (!includedResourcePacks.isEmpty()) {
+                this.description = includedResourcePacks.get(0).getSettings().getDescription();
+            }
+            if (this.description == null) {
+                // Use the default description
+                this.description = DEFAULT_DESCRIPTION;
+            }
+        }
+        return this.description;
+    }
+
+    public void setDescription(@NotNull JsonElement description) {
+        this.description = description;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/readfromarchive/ReadFromArchiveResourcePack.java b/src/main/java/org/sucraft/suki/resourcepack/readfromarchive/ReadFromArchiveResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..f59f6bd6d9b08298da311dc48d5cf6007d02e8f8
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/readfromarchive/ReadFromArchiveResourcePack.java
@@ -0,0 +1,132 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.readfromarchive;
+
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+import it.unimi.dsi.fastutil.Pair;
+import org.sucraft.suki.resourcepack.asset.blockstates.ConcreteResourcePackBlockStates;
+import org.sucraft.suki.resourcepack.asset.model.ConcreteResourcePackModel;
+import org.sucraft.suki.resourcepack.ResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.texture.ConcreteResourcePackTexture;
+import org.apache.commons.lang3.Validate;
+import org.apache.commons.lang3.tuple.ImmutablePair;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.file.Path;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.Callable;
+import java.util.stream.Stream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+/**
+ * Implementation of {@link ResourcePack} based on existing ZIP archive file
+ */
+public class ReadFromArchiveResourcePack implements ResourcePack, Closeable {
+
+    private final @NotNull Path path;
+
+    private @Nullable ZipFile zipFile;
+
+    private final ReadFromArchiveResourcePackSettings settings = new ReadFromArchiveResourcePackSettings(this);
+
+    private final @NotNull Map<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>, @NotNull ResourcePackAsset> assets = new HashMap<>(0);
+
+    public ReadFromArchiveResourcePack(@NotNull Path path) {
+        this.path = path;
+    }
+
+    public ReadFromArchiveResourcePack(@NotNull String path) {
+        this(Path.of(path));
+    }
+
+    @NotNull Path getPath() {
+        return this.path;
+    }
+
+    private @NotNull ZipFile getZipFile() throws IOException {
+        if (this.zipFile == null) {
+            this.zipFile = new ZipFile(this.path.toFile());
+        }
+        return this.zipFile;
+    }
+
+    public void close() throws IOException {
+        if (this.zipFile != null) {
+            this.zipFile.close();
+            this.zipFile = null;
+        }
+    }
+
+    private @NotNull Stream<@NotNull ZipEntry> getZipFileEntriesStream() throws IOException, NullPointerException {
+        return Validate.notNull(this.getZipFile().stream().map(it -> Validate.notNull(it)));
+    }
+
+    private @NotNull ZipEntry getZipFileEntry(@NotNull String path) throws IOException, NullPointerException {
+        return Validate.notNull(this.getZipFile().getEntry(path));
+    }
+
+    private @NotNull InputStream getZipFileEntryInputStream(@NotNull String path) throws IOException, NullPointerException {
+        return Validate.notNull(this.getZipFile().getInputStream(this.getZipFileEntry(path)));
+    }
+
+    @Override
+    public @NotNull Stream<@NotNull Pair<@NotNull String, @NotNull Callable<@NotNull InputStream>>> getAllFilesStream() throws IOException {
+        return this.getZipFileEntriesStream().map(it -> Pair.of(it.getName(), () -> this.getZipFile().getInputStream(it)));
+    }
+
+    @NotNull JsonObject readJsonAsset(@NotNull String path) throws IllegalArgumentException {
+        try {
+            @NotNull InputStream inputStream = this.getZipFileEntryInputStream(path);
+            return Validate.notNull(JsonParser.parseReader(new InputStreamReader(inputStream)).getAsJsonObject());
+        } catch (Exception e) {
+            throw new IllegalArgumentException("Attempted to load required JSON asset at internal path '" + path + "' from resource pack with path '" + this.path + "' but it did not exist", e);
+        }
+    }
+
+    @Nullable JsonObject readOptionalJsonAsset(@NotNull String path) {
+        try {
+            return readJsonAsset(path);
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+    @Override
+    public @NotNull ReadFromArchiveResourcePackSettings getSettings() {
+        return this.settings;
+    }
+
+    @Override
+    public @NotNull ResourcePackAsset getAsset(@NotNull ResourcePackAssetType type, @NotNull NamespacedKeyWithIntention key) throws IllegalArgumentException {
+        @Nullable ResourcePackAsset foundAsset = this.assets.computeIfAbsent(Pair.of(type, key), namespacedKey -> {
+            String path = type.getPathInResourcePack(key);
+            try {
+                this.getZipFileEntry(path);
+            } catch (IOException e) {
+                throw new IllegalArgumentException("Attempted to load required asset at internal path '" + path + "' from resource pack with path '" + this.path + "' but it did not exist", e);
+            }
+            if (type.equals(ResourcePackAssetType.BLOCK_STATES)) {
+                return new ConcreteResourcePackBlockStates(readJsonAsset(type.getPathInResourcePack(key)), key);
+            } else if (type.equals(ResourcePackAssetType.MODEL)) {
+                return new ConcreteResourcePackModel(readJsonAsset(type.getPathInResourcePack(key)), key);
+            } else if (type.equals(ResourcePackAssetType.TEXTURE)) {
+                return new ConcreteResourcePackTexture(true, null, key);
+            } else {
+                throw new IllegalArgumentException("Attempted to read asset from archive resource pack, but the type (" + type.getFolderPathInNamespaceFolder() + ") is not a known readable type");
+            }
+        });
+        return foundAsset;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/readfromarchive/ReadFromArchiveResourcePackSettings.java b/src/main/java/org/sucraft/suki/resourcepack/readfromarchive/ReadFromArchiveResourcePackSettings.java
new file mode 100644
index 0000000000000000000000000000000000000000..1afccf5f8af5d7bd4d40f2701b44a0038f9af9fc
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/readfromarchive/ReadFromArchiveResourcePackSettings.java
@@ -0,0 +1,69 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.readfromarchive;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import org.sucraft.suki.resourcepack.KeyConstants;
+import org.sucraft.suki.resourcepack.PathConstants;
+import org.sucraft.suki.resourcepack.ResourcePackSettings;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * Implementation of {@link ResourcePackSettings} for a {@link ReadFromArchiveResourcePack}
+ */
+public class ReadFromArchiveResourcePackSettings implements ResourcePackSettings {
+
+    private final @NotNull ReadFromArchiveResourcePack pack;
+
+    private @Nullable JsonObject packMetaJson;
+
+    private @Nullable String name;
+
+    private @Nullable JsonElement description;
+
+    ReadFromArchiveResourcePackSettings(@NotNull ReadFromArchiveResourcePack pack) {
+        this.pack = pack;
+    }
+
+    private @NotNull JsonObject getPackMetaJson() {
+        if (this.packMetaJson == null) {
+            this.packMetaJson = this.pack.readJsonAsset(PathConstants.PackMeta.pathFromRoot);
+        }
+        return this.packMetaJson;
+    }
+
+    @Override
+    public @NotNull String getName() {
+        if (this.name == null) {
+            // Read the name from the pack path
+            String filename = this.pack.getPath().getFileName().toString();
+            int dotIndex = filename.lastIndexOf('.');
+            if (dotIndex != -1) {
+                if (dotIndex == 0) {
+                    this.name = "";
+                } else {
+                    this.name = filename.substring(0, dotIndex);
+                }
+            } else {
+                this.name = filename;
+            }
+        }
+        return this.name;
+    }
+
+    @Override
+    public @NotNull JsonElement getDescription() {
+        if (this.description == null) {
+            // Read the description from the archive
+            this.description = this.getPackMetaJson().getAsJsonObject(KeyConstants.pack).get(KeyConstants.packDescription);
+        }
+        return this.description;
+    }
+
+    public void setDescription(@NotNull JsonElement description) {
+        this.description = description;
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/resourcepack/sucraft/CreateSuCraftResourcePack.java b/src/main/java/org/sucraft/suki/resourcepack/sucraft/CreateSuCraftResourcePack.java
new file mode 100644
index 0000000000000000000000000000000000000000..795504ab9905dda84cec72db73bbc654d06db46a
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/resourcepack/sucraft/CreateSuCraftResourcePack.java
@@ -0,0 +1,1447 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.resourcepack.sucraft;
+
+import com.google.common.base.Charsets;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Streams;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.level.block.Block;
+import org.sucraft.suki.block.replacementrule.BlockReplacementRule;
+import org.sucraft.suki.item.ItemReplacementRule;
+import org.sucraft.suki.resourcepack.PathConstants;
+import org.sucraft.suki.resourcepack.ResourcePack;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.ResourcePackAssetType;
+import org.sucraft.suki.resourcepack.asset.image.SimpleImageFileResourcePackAsset;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithIntention;
+import org.sucraft.suki.resourcepack.asset.intention.NamespacedKeyWithoutIntention;
+import org.sucraft.suki.resourcepack.asset.intention.ResourcePackAssetIntention;
+import org.sucraft.suki.resourcepack.asset.model.ConcreteResourcePackModel;
+import org.sucraft.suki.resourcepack.asset.texture.ResourcePackTexture;
+import org.sucraft.suki.resourcepack.memory.MemoryResourcePack;
+import org.sucraft.suki.resourcepack.memory.MemoryResourcePackSettings;
+import org.sucraft.suki.resourcepack.readfromarchive.ReadFromArchiveResourcePack;
+import org.sucraft.suki.util.CollectionPercentageProgress;
+import org.sucraft.suki.util.PercentageProgress;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+/**
+ * Utility class to create and write the server resource pack.
+ */
+public final class CreateSuCraftResourcePack {
+
+    private CreateSuCraftResourcePack() {}
+
+    private static final boolean useRandomResourcePackVersion = false;
+    private static final int currentResourcePackVersion;
+    static {
+        if (useRandomResourcePackVersion) {
+            currentResourcePackVersion = (int) (Math.random() * -2000000000) - 1;
+        } else {
+            currentResourcePackVersion = 206;
+        }
+    }
+
+    private static final String RESOURCE_PACK_FOLDER_PATH = "resourcepack";
+    private static final String OUTPUT_FOLDER_PATH = RESOURCE_PACK_FOLDER_PATH + "/output";
+    private static final String LAST_RESOURCE_PACK_VERSION_FILE_PATH = OUTPUT_FOLDER_PATH + "/last_resource_pack_version.txt";
+    private static final String INPUT_FOLDER_PATH = RESOURCE_PACK_FOLDER_PATH + "/input";
+    public static final String INPUT_TEXTURES_FOLDER_PATH = INPUT_FOLDER_PATH + "/textures";
+    public static final String INHERITED_RESOURCE_PACKS_FOLDER_PATH = INPUT_FOLDER_PATH + "/inheritedpacks";
+    private static final String VANILLA_RESOURCE_PACK_ARCHIVE_PATH = INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/vanilla_client_1.19_only_assets_minecraft.zip";
+
+    public static final int RESOURCE_PACK_FORMAT = 9;
+    private static final String NAME = "SuCraft";
+    private static final JsonElement DESCRIPTION = JsonParser.parseString("[{\"text\":\"\\u2764 Made with love\",\"color\":\"gray\"},{\"text\":\"\\n\"},{\"text\":\"~SuCraft\",\"color\":\"gold\"}]");
+
+    /**
+     * Only null while not initialized
+     */
+    private static @Nullable String outputFilePathRandomSuffix;
+
+    public static @NotNull String getOutputFilePathRandomSuffix() {
+        StringBuilder randomSuffixBuilder = new StringBuilder();
+        Random random = new Random(currentResourcePackVersion * 17 + currentResourcePackVersion * currentResourcePackVersion + 13371 + 17922347);
+        for (int i = 0; i < 10; i++) {
+            int randomCharacter = random.nextInt(62);
+            if (randomCharacter < 26) {
+                randomSuffixBuilder.append((char) (randomCharacter + 'a'));
+            } else if (randomCharacter < 52) {
+                randomSuffixBuilder.append((char) (randomCharacter - 26 + 'A'));
+            } else {
+                randomSuffixBuilder.append((char) (randomCharacter - 52 + '0'));
+            }
+        }
+        return "-" + randomSuffixBuilder;
+    }
+
+    /**
+     * Only null while not initialized
+     */
+    private static @Nullable String outputFilePath;
+
+    public static @NotNull File getOutputFile() throws IOException {
+        if (outputFilePath == null) {
+            @NotNull File folder = new File(OUTPUT_FOLDER_PATH);
+            if (!folder.isDirectory()) {
+                throw new IOException("CreateSuCraftResourcePack.OUTPUT_FOLDER_PATH does not point to a folder");
+            }
+
+            outputFilePath = Path.of(OUTPUT_FOLDER_PATH, NAME + getOutputFilePathRandomSuffix() + ".zip").toString();
+        }
+        return new File(outputFilePath);
+    }
+
+    public static void createAndWrite() {
+
+        MinecraftServer.LOGGER.info("Reading last resource pack version...");
+        File lastResourcePackVersionFile = new File(LAST_RESOURCE_PACK_VERSION_FILE_PATH);
+        boolean shouldWriteResourcePackToArchiveFile = true;
+        if (lastResourcePackVersionFile.exists()) {
+            try (FileInputStream fileInputStream = new FileInputStream(lastResourcePackVersionFile)) {
+                try (BufferedReader reader = new BufferedReader(new InputStreamReader(fileInputStream))) {
+                    int lastResourcePackVersion = Integer.parseInt(reader.readLine());
+                    if (lastResourcePackVersion == currentResourcePackVersion) {
+                        shouldWriteResourcePackToArchiveFile = false;
+                    }
+                }
+            } catch (Exception e) {
+                throw new RuntimeException("Exception occurred while checking last resource pack version", e);
+            }
+        }
+        final boolean finalShouldWriteResourcePackToArchiveFile = shouldWriteResourcePackToArchiveFile;
+
+        MinecraftServer.LOGGER.info("Creating server resource pack...");
+        try {
+
+            // Construct the resource pack
+            MinecraftServer.LOGGER.info("Instantiating resource pack in memory...");
+            @NotNull MemoryResourcePack resourcePack = new MemoryResourcePack();
+
+            try {
+
+                // Add the vanilla JAR as default resource pack
+                resourcePack.addDefaultResourcePack(new ReadFromArchiveResourcePack(VANILLA_RESOURCE_PACK_ARCHIVE_PATH));
+
+                // Add included resource packs
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/SuCraft resource pack logo.zip"));
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/SuCraft splash screen using Optifine.zip"));
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/Fire further from block surfaces.zip"));
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/Alcoholic beverages.zip"));
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/Axolotl buckets using custom model data.zip"));
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/Beta golden apple.zip"));
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/Achievements.zip"));
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/Axolotl buckets using Optifine.zip"));
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/IgnoreSecureChat.zip"));
+                // Disabled because it is quite heavy and not so useful at the moment
+//                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/Tropical fish buckets using Optifine.zip"));
+                resourcePack.addIncludedResourcePack(new ReadFromArchiveResourcePack(INHERITED_RESOURCE_PACKS_FOLDER_PATH + "/Technoblade Pigs.zip"));
+
+                // Set the settings
+                @NotNull MemoryResourcePackSettings settings = resourcePack.getSettings();
+                settings.setName(NAME);
+                settings.setDescription(DESCRIPTION);
+
+                // Add all custom blocks
+                new CollectionPercentageProgress<Block>("Adding custom blocks to resource pack", Registry.BLOCK.stream().filter(block -> block.replacementRule != null).toList(), 10)/* {
+
+                    @Override
+                    public void printProgress(int percentage) {
+                        System.gc();
+                        super.printProgress(percentage);
+                    }
+
+                }*/.forEach(block -> block.replacementRule.addToResourcePack(resourcePack, true));
+
+                // Add all custom items
+                new CollectionPercentageProgress<>("Adding custom items to resource pack", Registry.ITEM.stream().filter(item -> item.replacementRule != null).toList(), 10)/* {
+
+                    @Override
+                    public void printProgress(int percentage) {
+                        System.gc();
+                        super.printProgress(percentage);
+                    }
+
+                }*/.forEach(item -> item.replacementRule.addToResourcePack(resourcePack, true));
+
+                // Minify custom model data
+                MinecraftServer.LOGGER.info("Minifying custom model data...");
+                resourcePack.getAssets(ResourcePackAssetType.MODEL, null, ResourceLocation.DEFAULT_NAMESPACE, ResourcePackAssetIntention.ITEM).forEach(itemModel -> {
+                    if (itemModel instanceof ConcreteResourcePackModel concreteModel) {
+                        concreteModel.minifyModelOverrides();
+                    }
+                });
+
+                // Delete old resource pack files
+                if (shouldWriteResourcePackToArchiveFile) { // Otherwise we deleted the newest one too
+                    MinecraftServer.LOGGER.info("Deleting old resource pack archive files...");
+                    for (File file : new File(OUTPUT_FOLDER_PATH).listFiles()) {
+                        if (file.getName().endsWith(".zip")) {
+                            file.delete();
+                        }
+                    }
+                }
+
+                if (!shouldWriteResourcePackToArchiveFile) {
+                    MinecraftServer.LOGGER.info("Skipping writing resource pack to archive file because it is up-to-date (version " + currentResourcePackVersion + ")");
+                } else {
+                    // Write the resource pack to the output file
+                    resourcePack.writeToFile(getOutputFile());
+                }
+
+//                {
+//                    @Nullable FileOutputStream fileOutputStream = null;
+//                    @Nullable ZipOutputStream zipOutputStream = null;
+//                    @NotNull Set<@NotNull String> zippedFilePaths = new HashSet<>();
+//                    try {
+//
+//                        if (shouldWriteResourcePackToArchiveFile) {
+//                            // Create the output stream
+//                            fileOutputStream = new FileOutputStream(getOutputFile());
+//                            zipOutputStream = new ZipOutputStream(fileOutputStream);
+//                            zipOutputStream.setLevel(9);
+//                        }
+//                        final @Nullable ZipOutputStream finalZipOutputStream = zipOutputStream;
+//
+//                        if (shouldWriteResourcePackToArchiveFile) {
+//                            // Add the settings
+//                            {
+//                                zippedFilePaths.add(PathConstants.PackMeta.pathFromRoot);
+//                                @NotNull ZipEntry zipEntry = new ZipEntry(PathConstants.PackMeta.pathFromRoot);
+//                                zipOutputStream.putNextEntry(zipEntry);
+//                                zipOutputStream.write(resourcePack.getSettings().createJson().toString().getBytes(Charsets.UTF_8));
+//                            }
+//                        }
+//
+//                        // Add the assets
+//                        resourcePack.clearAssetsInMemory();
+//                        new CollectionPercentageProgress<>(shouldWriteResourcePackToArchiveFile ? "Writing assets to resource pack" : "Processing assets", assetLocationsThatWillBeAdded, 1).forEachThrowsException(assetLocation -> {
+//
+//                            {
+//                                @NotNull String path = ResourcePackAsset.getPathInResourcePack(assetLocation.left(), assetLocation.right());
+//                                if (zippedFilePaths.contains(path)) {
+//                                    return;
+//                                }
+//                                if (assetLocation.left().equals(ResourcePackAssetType.TEXTURE)) {
+//                                    var asset = resourcePack.getOptionalAsset(assetLocation.left(), assetLocation.right());
+//                                    if (asset instanceof SimpleImageFileResourcePackAsset imageFileAsset) {
+//                                        if (imageFileAsset.existsInIncludedResourcePack) {
+//                                            return;
+//                                        }
+//                                    }
+//                                }
+//                            }
+//
+//                            MinecraftServer.LOGGER.info("TEMP DEBUG - Processing asset: " + assetLocation.left().getFolderPathInNamespaceFolder() + " , " + assetLocation.right());
+//
+//                            @NotNull List<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> relatedAssets = new ArrayList<>(0);
+//
+//                            var blockReplacementRules = blockReplacementRulesByAssetLocation.get(assetLocation);
+//                            if (blockReplacementRules != null) {
+//                                blockReplacementRules.forEach(rule -> {
+////                                    MinecraftServer.LOGGER.info("TEMP DEBUG - Block replacement rule with real: " + rule.getReal());
+//                                    relatedAssets.addAll(rule.addToResourcePack(resourcePack, true));
+//                                });
+//                            }
+//                            var itemReplacementRules = itemReplacementRulesByAssetLocation.get(assetLocation);
+//                            if (itemReplacementRules != null) {
+//                                itemReplacementRules.forEach(rule -> {
+////                                    MinecraftServer.LOGGER.info("TEMP DEBUG - Item replacement rule with real: " + rule.getReal());
+//                                    relatedAssets.addAll(rule.addToResourcePack(resourcePack, true));
+//                                });
+//                            }
+//
+//                            // Check which related assets were fully included
+//                            @NotNull Stream<@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention>> relatedAssetsThatWereFullyIncluded = relatedAssets.stream().filter(relatedAsset -> {
+//                                var relatedBlockReplacementRules = blockReplacementRulesByAssetLocation.get(relatedAsset);
+//                                if (relatedBlockReplacementRules != null) {
+//                                    if (blockReplacementRules == null || relatedBlockReplacementRules.stream().anyMatch(rule -> !blockReplacementRules.contains(rule))) {
+//                                        return false;
+//                                    }
+//                                }
+//                                var relatedItemReplacementRules = itemReplacementRulesByAssetLocation.get(relatedAsset);
+//                                if (relatedItemReplacementRules != null) {
+//                                    if (itemReplacementRules == null || relatedItemReplacementRules.stream().anyMatch(rule -> !itemReplacementRules.contains(rule))) {
+//                                        return false;
+//                                    }
+//                                }
+//                                return true;
+//                            });
+//
+//                            var asset = resourcePack.getAsset(assetLocation.left(), assetLocation.right());
+//
+//                            // Minify custom model data for vanilla items
+//                            if (asset.getType().equals(ResourcePackAssetType.MODEL) && asset.getKey().namespace().equals(ResourceLocation.DEFAULT_NAMESPACE)) {
+//                                if (asset instanceof ConcreteResourcePackModel concreteModel) {
+//                                    concreteModel.minifyModelOverrides();
+//                                }
+//                            }
+//
+//                            // Write the assets that should be written to file
+//                            if (finalShouldWriteResourcePackToArchiveFile) {
+//                                for (@NotNull Pair<@NotNull ResourcePackAssetType, @NotNull NamespacedKeyWithIntention> assetLocationToWriteToFile : Iterables.concat(Collections.singletonList(assetLocation), Streams.concat(relatedAssets.stream().filter(relatedAsset -> relatedAsset.left().equals(ResourcePackAssetType.TEXTURE) && relatedAsset.right().namespace().equals(ResourceLocation.SUCRAFT_NAMESPACE)), relatedAssetsThatWereFullyIncluded).distinct().toList())) {
+//                                    @NotNull String path = ResourcePackAsset.getPathInResourcePack(assetLocationToWriteToFile.left(), assetLocationToWriteToFile.right());
+//                                    if (zippedFilePaths.add(path)) {
+//                                        var assetToWriteToFile = resourcePack.getAsset(assetLocationToWriteToFile.left(), assetLocationToWriteToFile.right());
+////                                        MinecraftServer.LOGGER.info("TEMP DEBUG - Going to write asset to resource pack: " + assetLocationToWriteToFile.left().getFolderPathInNamespaceFolder() + " , " + assetLocationToWriteToFile.right());
+//                                        @NotNull ZipEntry zipEntry = new ZipEntry(path);
+//                                        finalZipOutputStream.putNextEntry(zipEntry);
+//                                        assetToWriteToFile.writeTo(finalZipOutputStream);
+//                                        if (assetToWriteToFile.hasMeta()) {
+//                                            @NotNull String metaPath = path + PathConstants.metaFileSuffix;
+//                                            zippedFilePaths.add(metaPath);
+//                                            @NotNull ZipEntry metaZipEntry = new ZipEntry(metaPath);
+//                                            finalZipOutputStream.putNextEntry(metaZipEntry);
+//                                            assetToWriteToFile.writeMetaTo(finalZipOutputStream);
+//                                        }
+//                                    }
+//                                }
+//                            }
+//
+//                            resourcePack.clearAssetsInMemory();
+//                            System.gc();
+//                        });
+//
+//                        if (shouldWriteResourcePackToArchiveFile) {
+//
+//                            // Add all files from included resource packs that we haven't added yet
+//                            new CollectionPercentageProgress<>("Writing included resource pack files to resource pack archive file", resourcePack.getIncludedResourcePacks().stream().flatMap(pack -> {
+//                                try {
+//                                    return pack.getAllFilesStream();
+//                                } catch (Exception e) {
+//                                    return Stream.empty();
+//                                }
+//                            }).toList(), 5)
+//                                .forEachThrowsException(includedResourcePackFile -> {
+//                                    @NotNull String includedFilePath = includedResourcePackFile.left();
+//                                    if (zippedFilePaths.add(includedFilePath)) {
+//                                        try (@NotNull InputStream includedFileInputStream = includedResourcePackFile.right().call()) {
+//                                            finalZipOutputStream.putNextEntry(new ZipEntry(includedFilePath));
+//                                            finalZipOutputStream.write(includedFileInputStream.readAllBytes());
+//                                        } catch (Exception e) {
+//                                            if (e instanceof IOException ioE) {
+//                                                throw ioE;
+//                                            }
+//                                            throw new IOException("An exception occurred while getting input stream for included resource pack file", e);
+//                                        }
+//                                    }
+//                                });
+//
+//                        }
+//
+//                    } finally {
+//                        if (zipOutputStream != null) {
+//                            zipOutputStream.close();
+//                        }
+//                        if (fileOutputStream != null) {
+//                            fileOutputStream.close();
+//                        }
+//                    }
+//                }
+
+                if (shouldWriteResourcePackToArchiveFile) {
+                    // Write the resource pack version to the file
+                    MinecraftServer.LOGGER.info("Writing resource pack version to file...");
+                    try (FileOutputStream fileOutputStream = new FileOutputStream(LAST_RESOURCE_PACK_VERSION_FILE_PATH)) {
+                        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fileOutputStream))) {
+                            writer.write(currentResourcePackVersion + "\n");
+                        }
+                    } catch (Exception e) {
+                        throw new RuntimeException("Exception occurred while writing new resource pack version to file", e);
+                    }
+                }
+
+            } finally {
+
+                // Close all opened inherited resource packs
+                MinecraftServer.LOGGER.info("Closing open inherited resource pack files...");
+                for (@NotNull ResourcePack inheritedResourcePack : Iterables.concat(resourcePack.getDefaultResourcePacks(), resourcePack.getIncludedResourcePacks())) {
+                    if (inheritedResourcePack instanceof ReadFromArchiveResourcePack readInheritedResourcePack) {
+                        try {
+                            readInheritedResourcePack.close();
+                        } catch (Exception e) {
+                            MinecraftServer.LOGGER.warn("Exception occurred while closing inherited resource pack read from archive:");
+                            e.printStackTrace();
+                        }
+                    }
+                }
+
+            }
+
+        } catch (Exception e) {
+            throw new RuntimeException("Exception occurred while creating server resource pack", e);
+        }
+
+        System.gc();
+//        try {
+//            Runtime.getRuntime().exec("jcmd org.bukkit.craftbukkit.Main GC.run");
+//        } catch (IOException e) {
+//            MinecraftServer.LOGGER.warn("Exception while calling command line command to force garbage collection after resource pack generation: " + e);
+//        }
+
+    }
+
+    public static Set<String> texturesToIncludeForOlderVersionVisibility = new HashSet<>(0);
+    public static Set<String> modelsToIncludeForOlderVersionVisibility = new HashSet<>(0);
+    static {
+        // Currently, we add all textures and models introduced after 1.16.5, so that users with that version can see all textures
+        String[] minecraftBlockTexturesToInclude = {
+            // 1.16 -> 1.17
+            "small_amethyst_bud",
+            "red_candle",
+            "yellow_candle_lit",
+            "cave_vines_lit",
+            "flowering_azalea_side",
+            "light_blue_candle",
+            "rooted_dirt",
+            "gray_candle",
+            "hanging_roots",
+            "pink_candle_lit",
+            "blue_candle_lit",
+            "amethyst_block",
+            "budding_amethyst",
+            "yellow_candle",
+            "deepslate_bricks",
+            "purple_candle",
+            "sculk_sensor_tendril_active",
+            "big_dripleaf_side",
+            "powder_snow",
+            "light_gray_candle_lit",
+            "spore_blossom_base",
+            "sculk_sensor_tendril_active",
+            "calcite",
+            "azalea_top",
+            "potted_flowering_azalea_bush_plant",
+            "magenta_candle",
+            "deepslate_top",
+            "pointed_dripstone_down_base",
+            "purple_candle_lit",
+            "pointed_dripstone_up_middle",
+            "dripstone_block",
+            "large_amethyst_bud",
+            "glow_item_frame",
+            "candle",
+            "raw_gold_block",
+            "big_dripleaf_tip",
+            "pointed_dripstone_down_middle",
+            "green_candle",
+            "tuff",
+            "chiseled_deepslate",
+            "big_dripleaf_top",
+            "lime_candle_lit",
+            "cave_vines",
+            "small_dripleaf_side",
+            "potted_flowering_azalea_bush_side",
+            "dirt_path_side",
+            "exposed_copper",
+            "white_candle_lit",
+            "brown_candle_lit",
+            "copper_ore",
+            "deepslate_tiles",
+            "raw_copper_block",
+            "green_candle_lit",
+            "flowering_azalea_leaves",
+            "potted_azalea_bush_side",
+            "polished_deepslate",
+            "cracked_deepslate_tiles",
+            "cave_vines_plant",
+            "cave_vines_plant_lit",
+            "deepslate_copper_ore",
+            "cyan_candle",
+            "small_dripleaf_top",
+            "pointed_dripstone_down_tip_merge",
+            "azalea_leaves",
+            "magenta_candle_lit",
+            "azalea_plant",
+            "copper_block",
+            "potted_azalea_bush_top",
+            "amethyst_cluster",
+            "brown_candle",
+            "moss_block",
+            "deepslate_diamond_ore",
+            "spore_blossom",
+            "pointed_dripstone_down_tip",
+            "lime_candle",
+            "potted_flowering_azalea_bush_top",
+            "cracked_deepslate_bricks",
+            "black_candle_lit",
+            "flowering_azalea_top",
+            "oxidized_cut_copper",
+            "deepslate_lapis_ore",
+            "potted_azalea_bush_plant",
+            "pointed_dripstone_down_frustum",
+            "oxidized_copper",
+            "exposed_cut_copper",
+            "pointed_dripstone_up_frustum",
+            "small_dripleaf_stem_bottom",
+            "glow_lichen",
+            "dirt_path_top",
+            "deepslate_redstone_ore",
+            "light_blue_candle_lit",
+            "pointed_dripstone_up_tip",
+            "cut_copper",
+            "orange_candle_lit",
+            "tinted_glass",
+            "big_dripleaf_stem",
+            "blue_candle",
+            "small_dripleaf_stem_top",
+            "sculk_sensor_top",
+            "medium_amethyst_bud",
+            "candle_lit",
+            "sculk_sensor_tendril_inactive",
+            "pink_candle",
+            "raw_iron_block",
+            "cobbled_deepslate",
+            "white_candle",
+            "lightning_rod_on",
+            "light_gray_candle",
+            "gray_candle_lit",
+            "sculk_sensor_bottom",
+            "red_candle_lit",
+            "weathered_copper",
+            "sculk_sensor_side",
+            "black_candle",
+            "lightning_rod",
+            "pointed_dripstone_up_base",
+            "deepslate",
+            "sculk_sensor_tendril_inactive",
+            "smooth_basalt",
+            "deepslate_emerald_ore",
+            "pointed_dripstone_up_tip_merge",
+            "cyan_candle_lit",
+            "deepslate_coal_ore",
+            "azalea_side",
+            "weathered_cut_copper",
+            "orange_candle",
+            "deepslate_iron_ore",
+            "deepslate_gold_ore",
+            // (1.18 added no new block textures)
+            // 1.18 -> 1.19
+            "ochre_froglight_side",
+            "reinforced_deepslate_side",
+            "sculk_catalyst_top_bloom",
+            "ochre_froglight_top",
+            "pearlescent_froglight_top",
+            "mangrove_planks",
+            "verdant_froglight_side",
+            "sculk_vein",
+            "sculk",
+            "packed_mud",
+            "mangrove_roots_top",
+            "sculk_catalyst_top",
+            "muddy_mangrove_roots_side",
+            "sculk_shrieker_can_summon_inner_top",
+            "sculk_catalyst_side",
+            "mud",
+            "mangrove_door_bottom",
+            "sculk_shrieker_side",
+            "sculk_shrieker_bottom",
+            "sculk_shrieker_top",
+            "muddy_mangrove_roots_top",
+            "sculk_catalyst_side_bloom",
+            "reinforced_deepslate_top",
+            "stripped_mangrove_log_top",
+            "verdant_froglight_top",
+            "mangrove_propagule",
+            "mangrove_roots_side",
+            "mangrove_log",
+            "sculk_shrieker_can_summon_inner_top",
+            "mangrove_door_top",
+            "pearlescent_froglight_side",
+            "sculk_catalyst_side_bloom",
+            "mangrove_leaves",
+            "mangrove_log_top",
+            "mud_bricks",
+            "mangrove_trapdoor",
+            "stripped_mangrove_log",
+            "frogspawn",
+            "sculk",
+            "sculk_shrieker_inner_top",
+            "reinforced_deepslate_bottom",
+            "sculk_catalyst_bottom",
+            "sculk_shrieker_inner_top",
+            "sculk_vein",
+            "mangrove_propagule_hanging",
+            "sculk_catalyst_top_bloom"
+        };
+        String[] minecraftItemTexturesToInclude = {
+            // 1.16 -> 1.19
+            "copper_ingot",
+            "recovery_compass_16",
+            "recovery_compass_12",
+            "glow_item_frame",
+            "light_03",
+            "recovery_compass_24",
+            "light_14",
+            "oak_chest_boat",
+            "acacia_chest_boat",
+            "brown_candle",
+            "yellow_candle",
+            "recovery_compass_21",
+            "recovery_compass_26",
+            "recovery_compass_00",
+            "tadpole_bucket",
+            "spyglass_model",
+            "purple_candle",
+            "recovery_compass_06",
+            "mangrove_door",
+            "light_02",
+            "orange_candle",
+            "glow_berries",
+            "recovery_compass_05",
+            "amethyst_shard",
+            "recovery_compass_09",
+            "green_candle",
+            "spruce_chest_boat",
+            "music_disc_otherside",
+            "goat_horn",
+            "blue_candle",
+            "powder_snow_bucket",
+            "glow_ink_sac",
+            "light_00",
+            "mangrove_boat",
+            "candle",
+            "recovery_compass_25",
+            "recovery_compass_20",
+            "recovery_compass_07",
+            "pointed_dripstone",
+            "gray_candle",
+            "recovery_compass_17",
+            "jungle_chest_boat",
+            "raw_gold",
+            "recovery_compass_27",
+            "light",
+            "light_10",
+            "dark_oak_chest_boat",
+            "light_gray_candle",
+            "light_04",
+            "recovery_compass_10",
+            "light_06",
+            "recovery_compass_28",
+            "light_05",
+            "axolotl_bucket",
+            "bundle",
+            "bundle_filled",
+            "echo_shard",
+            "mangrove_chest_boat",
+            "disc_fragment_5",
+            "cyan_candle",
+            "red_candle",
+            "recovery_compass_18",
+            "recovery_compass_19",
+            "recovery_compass_15",
+            "light_11",
+            "light_12",
+            "light_13",
+            "recovery_compass_22",
+            "recovery_compass_01",
+            "recovery_compass_11",
+            "recovery_compass_02",
+            "mangrove_propagule",
+            "recovery_compass_23",
+            "recovery_compass_31",
+            "recovery_compass_14",
+            "recovery_compass_03",
+            "raw_copper",
+            "light_08",
+            "mangrove_sign",
+            "light_09",
+            "light_blue_candle",
+            "music_disc_5",
+            "recovery_compass_08",
+            "birch_chest_boat",
+            "pink_candle",
+            "recovery_compass_29",
+            "recovery_compass_30",
+            "magenta_candle",
+            "spyglass",
+            "black_candle",
+            "recovery_compass_04",
+            "lime_candle",
+            "recovery_compass_13",
+            "light_15",
+            "raw_iron",
+            "light_07",
+            "light_01",
+            "white_candle"
+        };
+        String[] minecraftBlockModelsToInclude = {
+            // 1.16 -> 1.19
+            "raw_gold_block",
+            "cut_copper",
+            "deepslate_tile_wall_side",
+            "small_amethyst_bud",
+            "dirt_path",
+            "candle_cake_lit",
+            "mangrove_leaves",
+            "light_gray_candle_four_candles_lit",
+            "deepslate_brick_slab",
+            "magenta_candle_three_candles",
+            "light_gray_candle_three_candles",
+            "template_item_frame_map",
+            "sculk_mirrored",
+            "packed_mud",
+            "green_candle_cake_lit",
+            "candle_two_candles_lit",
+            "iron_door_bottom_right_open",
+            "deepslate_brick_stairs",
+            "blue_candle_two_candles_lit",
+            "green_candle_cake",
+            "deepslate_tile_slab",
+            "iron_door_top_left",
+            "gray_candle_one_candle",
+            "weathered_cut_copper_slab_top",
+            "potted_mangrove_propagule",
+            "orange_candle_two_candles",
+            "gray_candle_three_candles_lit",
+            "cube_north_west_mirrored_all",
+            "dark_oak_door_bottom_right",
+            "mud_bricks_north_west_mirrored",
+            "exposed_cut_copper",
+            "azalea",
+            "deepslate_redstone_ore",
+            "template_cauldron_full",
+            "lightning_rod",
+            "light_01",
+            "crimson_door_bottom_right_open",
+            "cobbled_deepslate_slab_top",
+            "yellow_candle_four_candles_lit",
+            "mangrove_slab_top",
+            "pointed_dripstone_down_tip",
+            "purple_candle_two_candles_lit",
+            "red_candle_cake_lit",
+            "white_candle_two_candles",
+            "mangrove_propagule",
+            "cracked_deepslate_bricks",
+            "black_candle_four_candles",
+            "template_cauldron_level2",
+            "mangrove_trapdoor_bottom",
+            "stripped_mangrove_log_horizontal",
+            "calcite",
+            "acacia_door_bottom_left_open",
+            "deepslate_gold_ore",
+            "iron_door_bottom_right",
+            "spruce_door_bottom_left_open",
+            "mangrove_door_top_left",
+            "cave_vines_plant_lit",
+            "orange_candle_cake_lit",
+            "orange_candle_four_candles_lit",
+            "lightning_rod_on",
+            "weathered_copper",
+            "cobbled_deepslate",
+            "brown_candle_two_candles_lit",
+            "lime_candle_four_candles",
+            "blue_candle_four_candles_lit",
+            "green_candle_three_candles_lit",
+            "mangrove_button_inventory",
+            "warped_door_top_left_open",
+            "exposed_cut_copper_stairs_inner",
+            "big_dripleaf_stem",
+            "light_00",
+            "cut_copper_stairs_outer",
+            "stripped_mangrove_wood",
+            "orange_candle_three_candles_lit",
+            "water_cauldron_full",
+            "cobbled_deepslate_wall_side_tall",
+            "lime_candle_three_candles",
+            "magenta_candle_two_candles",
+            "dark_oak_door_bottom_right_open",
+            "oak_door_top_right",
+            "spruce_door_top_left_open",
+            "deepslate_brick_stairs_inner",
+            "mangrove_log",
+            "moss_carpet",
+            "budding_amethyst",
+            "deepslate_tile_wall_side_tall",
+            "iron_door_top_left_open",
+            "pearlescent_froglight",
+            "warped_door_top_right_open",
+            "pointed_dripstone_down_middle",
+            "sculk",
+            "polished_deepslate_wall_post",
+            "candle_one_candle",
+            "black_candle_one_candle_lit",
+            "door_bottom_right",
+            "green_candle_two_candles_lit",
+            "gray_candle_two_candles_lit",
+            "lime_candle_two_candles_lit",
+            "weathered_cut_copper_stairs_outer",
+            "magenta_candle_one_candle",
+            "cube_north_west_mirrored",
+            "warped_door_bottom_left",
+            "polished_deepslate_wall_side_tall",
+            "white_candle_four_candles_lit",
+            "amethyst_cluster",
+            "light_blue_candle_cake_lit",
+            "blue_candle_one_candle",
+            "light_10",
+            "light_gray_candle_two_candles",
+            "water_cauldron_level1",
+            "polished_deepslate_slab",
+            "white_candle_two_candles_lit",
+            "brown_candle_three_candles",
+            "white_candle_one_candle_lit",
+            "light_08",
+            "cobbled_deepslate_stairs",
+            "cave_vines",
+            "mud_bricks",
+            "orange_candle_two_candles_lit",
+            "cut_copper_slab_top",
+            "big_dripleaf_full_tilt",
+            "light_06",
+            "magenta_candle_three_candles_lit",
+            "spruce_door_top_left",
+            "green_candle_one_candle",
+            "yellow_candle_two_candles_lit",
+            "small_dripleaf_bottom",
+            "sculk_catalyst_bloom",
+            "cut_copper_stairs",
+            "jungle_door_bottom_right_open",
+            "light_09",
+            "brown_candle_four_candles",
+            "deepslate_tile_wall_post",
+            "cobbled_deepslate_wall_side",
+            "mangrove_fence_gate",
+            "oak_door_bottom_left",
+            "pointed_dripstone_down_tip_merge",
+            "door_top_left",
+            "mangrove_button_pressed",
+            "deepslate_diamond_ore",
+            "light_13",
+            "light_blue_candle_four_candles_lit",
+            "template_potted_azalea_bush",
+            "mud_brick_wall_post",
+            "light_02",
+            "oxidized_cut_copper_slab",
+            "acacia_door_top_right",
+            "cyan_candle_three_candles",
+            "light_07",
+            "candle_four_candles_lit",
+            "oxidized_cut_copper_stairs_outer",
+            "acacia_door_top_left_open",
+            "mangrove_door_top_right_open",
+            "birch_door_top_left",
+            "exposed_cut_copper_slab_top",
+            "orange_candle_cake",
+            "oxidized_cut_copper_slab_top",
+            "spruce_door_top_right_open",
+            "lime_candle_two_candles",
+            "mangrove_door_top_left_open",
+            "weathered_cut_copper_slab",
+            "oak_door_top_left",
+            "sculk_catalyst",
+            "cobbled_deepslate_wall_post",
+            "green_candle_four_candles",
+            "brown_candle_one_candle",
+            "mangrove_wood",
+            "powder_snow",
+            "brown_candle_cake",
+            "black_candle_two_candles",
+            "pointed_dripstone",
+            "black_candle_two_candles_lit",
+            "template_cake_with_candle",
+            "template_two_candles",
+            "red_candle_one_candle_lit",
+            "magenta_candle_cake",
+            "template_item_frame",
+            "white_candle_three_candles",
+            "pointed_dripstone_up_middle",
+            "blue_candle_two_candles",
+            "pink_candle_cake_lit",
+            "mud_brick_slab_top",
+            "deepslate_brick_slab_top",
+            "light_14",
+            "dark_oak_door_top_left",
+            "gray_candle_four_candles_lit",
+            "iron_door_top_right",
+            "pointed_dripstone_up_tip",
+            "magenta_candle_one_candle_lit",
+            "deepslate_brick_wall_side",
+            "mangrove_door_bottom_right_open",
+            "potted_flowering_azalea_bush",
+            "mangrove_fence_gate_open",
+            "white_candle_four_candles",
+            "red_candle_two_candles_lit",
+            "birch_door_bottom_left",
+            "mangrove_fence_gate_wall_open",
+            "spruce_door_bottom_left",
+            "light_11",
+            "deepslate_tiles",
+            "lime_candle_cake_lit",
+            "purple_candle_one_candle",
+            "cyan_candle_four_candles_lit",
+            "pointed_dripstone_down_frustum",
+            "mangrove_door_top_right",
+            "lime_candle_cake",
+            "birch_door_bottom_right",
+            "blue_candle_cake_lit",
+            "weathered_cut_copper",
+            "mangrove_propagule_hanging_3",
+            "tinted_glass",
+            "gray_candle_one_candle_lit",
+            "polished_deepslate_slab_top",
+            "hanging_roots",
+            "exposed_cut_copper_stairs",
+            "spruce_door_bottom_right",
+            "brown_candle_three_candles_lit",
+            "chiseled_deepslate",
+            "purple_candle_three_candles",
+            "flowering_azalea_leaves",
+            "template_three_candles",
+            "mud_brick_stairs_inner",
+            "cyan_candle_one_candle_lit",
+            "powder_snow_cauldron_full",
+            "door_bottom_right_open",
+            "yellow_candle_one_candle",
+            "mangrove_trapdoor_open",
+            "polished_deepslate",
+            "cyan_candle_two_candles_lit",
+            "red_candle_cake",
+            "brown_candle_one_candle_lit",
+            "rooted_dirt",
+            "candle_cake",
+            "light_05",
+            "crimson_door_bottom_left",
+            "oak_door_top_right_open",
+            "pointed_dripstone_up_frustum",
+            "cave_vines_lit",
+            "jungle_door_bottom_left",
+            "dark_oak_door_bottom_left",
+            "crimson_door_bottom_right",
+            "deepslate_iron_ore",
+            "deepslate_brick_wall_side_tall",
+            "spruce_door_top_right",
+            "mangrove_fence_post",
+            "sculk_sensor_active",
+            "lime_candle_three_candles_lit",
+            "black_candle_four_candles_lit",
+            "gray_candle_cake",
+            "deepslate_coal_ore",
+            "lime_candle_one_candle",
+            "magenta_candle_four_candles",
+            "pink_candle_two_candles",
+            "orange_candle_three_candles",
+            "pink_candle_one_candle",
+            "mangrove_stairs",
+            "green_candle_three_candles",
+            "orange_candle_one_candle",
+            "orange_candle_four_candles",
+            "copper_block",
+            "light_blue_candle_three_candles_lit",
+            "deepslate_tile_wall_inventory",
+            "birch_door_top_right_open",
+            "polished_deepslate_wall_side",
+            "yellow_candle_two_candles",
+            "deepslate",
+            "door_bottom_left",
+            "purple_candle_four_candles",
+            "yellow_candle_four_candles",
+            "verdant_froglight_horizontal",
+            "purple_candle_one_candle_lit",
+            "mud_brick_wall_side",
+            "black_candle_cake",
+            "large_amethyst_bud",
+            "amethyst_block",
+            "lime_candle_four_candles_lit",
+            "light_15",
+            "deepslate_mirrored",
+            "light_gray_candle_four_candles",
+            "mangrove_pressure_plate",
+            "white_candle_three_candles_lit",
+            "deepslate_bricks",
+            "cyan_candle_cake",
+            "ochre_froglight_horizontal",
+            "mangrove_door_bottom_left",
+            "lava_cauldron",
+            "iron_door_bottom_left_open",
+            "muddy_mangrove_roots",
+            "yellow_candle_three_candles_lit",
+            "red_candle_four_candles",
+            "light_04",
+            "door_top_left_open",
+            "magenta_candle_four_candles_lit",
+            "white_candle_one_candle",
+            "light_gray_candle_cake_lit",
+            "gray_candle_cake_lit",
+            "mud_brick_wall_side_tall",
+            "yellow_candle_cake_lit",
+            "mangrove_fence_inventory",
+            "light_gray_candle_cake",
+            "polished_deepslate_stairs_inner",
+            "deepslate_emerald_ore",
+            "mangrove_propagule_hanging_2",
+            "blue_candle_cake",
+            "spruce_door_bottom_right_open",
+            "candle_two_candles",
+            "iron_door_top_right_open",
+            "mangrove_door_bottom_left_open",
+            "red_candle_two_candles",
+            "cracked_deepslate_tiles",
+            "pink_candle_four_candles_lit",
+            "cobbled_deepslate_stairs_inner",
+            "magenta_candle_two_candles_lit",
+            "light_blue_candle_cake",
+            "jungle_door_top_left_open",
+            "deepslate_brick_wall_post",
+            "gray_candle_four_candles",
+            "mangrove_button",
+            "black_candle_cake_lit",
+            "mangrove_stairs_inner",
+            "iron_door_bottom_left",
+            "weathered_cut_copper_stairs_inner",
+            "powder_snow_cauldron_level1",
+            "candle_four_candles",
+            "oxidized_cut_copper_stairs_inner",
+            "sculk_shrieker_can_summon",
+            "warped_door_bottom_right_open",
+            "door_bottom_left_open",
+            "door_top_right",
+            "green_candle_one_candle_lit",
+            "mangrove_trapdoor_top",
+            "pointed_dripstone_up_tip_merge",
+            "mangrove_pressure_plate_down",
+            "jungle_door_bottom_right",
+            "pink_candle_one_candle_lit",
+            "ochre_froglight",
+            "exposed_copper",
+            "flowering_azalea",
+            "jungle_door_top_left",
+            "lime_candle_one_candle_lit",
+            "acacia_door_bottom_right_open",
+            "polished_deepslate_stairs",
+            "sculk_shrieker",
+            "blue_candle_one_candle_lit",
+            "brown_candle_cake_lit",
+            "mangrove_fence_side",
+            "template_four_candles",
+            "candle_three_candles_lit",
+            "crimson_door_top_left_open",
+            "mangrove_stairs_outer",
+            "sculk_vein",
+            "exposed_cut_copper_slab",
+            "orange_candle_one_candle_lit",
+            "birch_door_top_left_open",
+            "warped_door_bottom_left_open",
+            "dripstone_block",
+            "cobbled_deepslate_slab",
+            "dark_oak_door_bottom_left_open",
+            "blue_candle_three_candles",
+            "light_12",
+            "tuff",
+            "dark_oak_door_top_right",
+            "door_top_right_open",
+            "mangrove_door_bottom_right",
+            "crimson_door_top_right",
+            "jungle_door_top_right_open",
+            "oak_door_bottom_right",
+            "purple_candle_three_candles_lit",
+            "acacia_door_top_right_open",
+            "spore_blossom",
+            "black_candle_one_candle",
+            "acacia_door_top_left",
+            "mud_brick_stairs_outer",
+            "pink_candle_cake",
+            "light_gray_candle_three_candles_lit",
+            "pearlescent_froglight_horizontal",
+            "birch_door_bottom_right_open",
+            "water_cauldron_level2",
+            "warped_door_top_left",
+            "cyan_candle_four_candles",
+            "mangrove_fence_gate_wall",
+            "oxidized_copper",
+            "birch_door_bottom_left_open",
+            "crimson_door_top_left",
+            "jungle_door_bottom_left_open",
+            "reinforced_deepslate",
+            "candle_one_candle_lit",
+            "black_candle_three_candles",
+            "vine",
+            "red_candle_three_candles",
+            "crimson_door_top_right_open",
+            "blue_candle_four_candles",
+            "oak_door_top_left_open",
+            "moss_block",
+            "deepslate_lapis_ore",
+            "verdant_froglight",
+            "purple_candle_cake",
+            "cut_copper_stairs_inner",
+            "oxidized_cut_copper",
+            "cobbled_deepslate_stairs_outer",
+            "light_gray_candle_one_candle_lit",
+            "white_candle_cake",
+            "white_candle_cake_lit",
+            "blue_candle_three_candles_lit",
+            "polished_deepslate_stairs_outer",
+            "polished_deepslate_wall_inventory",
+            "azalea_leaves",
+            "mangrove_roots",
+            "red_candle_four_candles_lit",
+            "green_candle_two_candles",
+            "mud_brick_slab",
+            "cyan_candle_cake_lit",
+            "mangrove_slab",
+            "pink_candle_four_candles",
+            "magenta_candle_cake_lit",
+            "deepslate_tile_slab_top",
+            "mangrove_log_horizontal",
+            "mangrove_propagule_hanging_4",
+            "deepslate_brick_stairs_outer",
+            "mud",
+            "cyan_candle_two_candles",
+            "oak_door_bottom_right_open",
+            "pink_candle_three_candles_lit",
+            "potted_azalea_bush",
+            "medium_amethyst_bud",
+            "mangrove_propagule_hanging_1",
+            "purple_candle_two_candles",
+            "template_azalea",
+            "green_candle_four_candles_lit",
+            "acacia_door_bottom_right",
+            "exposed_cut_copper_stairs_outer",
+            "pointed_dripstone_down_base",
+            "raw_iron_block",
+            "cube_column_mirrored",
+            "light_blue_candle_two_candles",
+            "purple_candle_four_candles_lit",
+            "big_dripleaf",
+            "brown_candle_four_candles_lit",
+            "dark_oak_door_top_left_open",
+            "yellow_candle_cake",
+            "pink_candle_two_candles_lit",
+            "gray_candle_two_candles",
+            "glow_item_frame_map",
+            "light_blue_candle_three_candles",
+            "deepslate_copper_ore",
+            "cut_copper_slab",
+            "template_cauldron_level1",
+            "birch_door_top_right",
+            "candle_three_candles",
+            "light_blue_candle_one_candle_lit",
+            "glow_lichen",
+            "oak_door_bottom_left_open",
+            "gray_candle_three_candles",
+            "light_gray_candle_one_candle",
+            "small_dripleaf_top",
+            "sculk_sensor_inactive",
+            "light_blue_candle_four_candles",
+            "crimson_door_bottom_left_open",
+            "dark_oak_door_top_right_open",
+            "copper_ore",
+            "purple_candle_cake_lit",
+            "light_gray_candle_two_candles_lit",
+            "stripped_mangrove_log",
+            "red_candle_three_candles_lit",
+            "mud_brick_stairs",
+            "mud_brick_wall_inventory",
+            "deepslate_tile_stairs",
+            "glow_item_frame",
+            "template_sculk_shrieker",
+            "yellow_candle_one_candle_lit",
+            "light_blue_candle_two_candles_lit",
+            "light_blue_candle_one_candle",
+            "light_03",
+            "deepslate_brick_wall_inventory",
+            "cyan_candle_three_candles_lit",
+            "acacia_door_bottom_left",
+            "black_candle_three_candles_lit",
+            "template_candle",
+            "warped_door_top_right",
+            "pink_candle_three_candles",
+            "raw_copper_block",
+            "cave_vines_plant",
+            "sculk_sensor",
+            "cyan_candle_one_candle",
+            "powder_snow_cauldron_level2",
+            "red_candle_one_candle",
+            "brown_candle_two_candles",
+            "mangrove_planks",
+            "deepslate_tile_stairs_outer",
+            "mangrove_sign",
+            "warped_door_bottom_right",
+            "cobbled_deepslate_wall_inventory",
+            "pointed_dripstone_up_base",
+            "deepslate_tile_stairs_inner",
+            "smooth_basalt",
+            "weathered_cut_copper_stairs",
+            "frogspawn",
+            "mangrove_propagule_hanging_0",
+            "jungle_door_top_right",
+            "yellow_candle_three_candles",
+            "big_dripleaf_partial_tilt",
+            "oxidized_cut_copper_stairs"
+        };
+        String[] minecraftItemModelsToInclude = {
+            // 1.16 -> 1.19
+            "recovery_compass_26",
+            "recovery_compass_27",
+            "cut_copper_stairs",
+            "goat_spawn_egg",
+            "allay_spawn_egg",
+            "mangrove_planks",
+            "tadpole_bucket",
+            "deepslate_bricks",
+            "recovery_compass_30",
+            "waxed_oxidized_copper",
+            "recovery_compass_15",
+            "recovery_compass_28",
+            "tadpole_spawn_egg",
+            "mangrove_fence",
+            "copper_ingot",
+            "glow_ink_sac",
+            "oxidized_copper",
+            "stripped_mangrove_wood",
+            "light_14",
+            "raw_iron",
+            "deepslate_brick_slab",
+            "sculk_shrieker",
+            "raw_copper",
+            "waxed_exposed_cut_copper_stairs",
+            "mangrove_propagule",
+            "spruce_chest_boat",
+            "raw_gold_block",
+            "azalea_leaves",
+            "deepslate_brick_wall",
+            "mud_bricks",
+            "glow_lichen",
+            "deepslate_coal_ore",
+            "sculk_sensor",
+            "mangrove_boat",
+            "rooted_dirt",
+            "reinforced_deepslate",
+            "spyglass_in_hand",
+            "polished_deepslate_slab",
+            "recovery_compass_19",
+            "recovery_compass_10",
+            "deepslate_iron_ore",
+            "calcite",
+            "deepslate_tile_stairs",
+            "spyglass",
+            "stripped_mangrove_log",
+            "amethyst_bud",
+            "light_07",
+            "mangrove_pressure_plate",
+            "lime_candle",
+            "sculk_catalyst",
+            "cobbled_deepslate",
+            "recovery_compass",
+            "weathered_cut_copper_stairs",
+            "deepslate_gold_ore",
+            "deepslate_redstone_ore",
+            "music_disc_5",
+            "light_10",
+            "tinted_glass",
+            "recovery_compass_17",
+            "lightning_rod",
+            "copper_ore",
+            "cracked_deepslate_bricks",
+            "light",
+            "recovery_compass_08",
+            "light_gray_candle",
+            "disc_fragment_5",
+            "recovery_compass_18",
+            "exposed_cut_copper_stairs",
+            "light_12",
+            "pink_candle",
+            "infested_deepslate",
+            "azalea",
+            "orange_candle",
+            "brown_candle",
+            "light_01",
+            "polished_deepslate",
+            "mangrove_wood",
+            "gray_candle",
+            "light_15",
+            "warden_spawn_egg",
+            "deepslate_tiles",
+            "recovery_compass_23",
+            "magenta_candle",
+            "sculk",
+            "mangrove_button",
+            "budding_amethyst",
+            "dripstone_block",
+            "echo_shard",
+            "hanging_roots",
+            "waxed_copper_block",
+            "verdant_froglight",
+            "weathered_copper",
+            "waxed_oxidized_cut_copper_stairs",
+            "recovery_compass_01",
+            "recovery_compass_25",
+            "mangrove_leaves",
+            "waxed_weathered_cut_copper_slab",
+            "light_03",
+            "acacia_chest_boat",
+            "polished_deepslate_stairs",
+            "axolotl_bucket",
+            "recovery_compass_14",
+            "blue_candle",
+            "light_06",
+            "dark_oak_chest_boat",
+            "light_09",
+            "bundle_filled",
+            "small_amethyst_bud",
+            "recovery_compass_13",
+            "jungle_chest_boat",
+            "waxed_weathered_cut_copper_stairs",
+            "cobbled_deepslate_stairs",
+            "recovery_compass_12",
+            "oxidized_cut_copper_slab",
+            "recovery_compass_31",
+            "light_11",
+            "exposed_cut_copper",
+            "green_candle",
+            "polished_deepslate_wall",
+            "mangrove_fence_gate",
+            "cracked_deepslate_tiles",
+            "packed_mud",
+            "waxed_weathered_cut_copper",
+            "yellow_candle",
+            "oxidized_cut_copper",
+            "cut_copper",
+            "mangrove_chest_boat",
+            "exposed_copper",
+            "cobbled_deepslate_slab",
+            "waxed_cut_copper_slab",
+            "deepslate_diamond_ore",
+            "recovery_compass_05",
+            "amethyst_shard",
+            "light_08",
+            "deepslate_emerald_ore",
+            "mud_brick_stairs",
+            "cyan_candle",
+            "cut_copper_slab",
+            "purple_candle",
+            "mud_brick_slab",
+            "recovery_compass_24",
+            "mud_brick_wall",
+            "axolotl_spawn_egg",
+            "exposed_cut_copper_slab",
+            "copper_block",
+            "light_00",
+            "glow_berries",
+            "big_dripleaf",
+            "recovery_compass_22",
+            "flowering_azalea_leaves",
+            "powder_snow_bucket",
+            "recovery_compass_07",
+            "light_13",
+            "light_05",
+            "frogspawn",
+            "cobbled_deepslate_wall",
+            "recovery_compass_11",
+            "red_candle",
+            "flowering_azalea",
+            "small_dripleaf",
+            "medium_amethyst_bud",
+            "tooting_goat_horn",
+            "oak_chest_boat",
+            "raw_iron_block",
+            "dirt_path",
+            "recovery_compass_21",
+            "deepslate_brick_stairs",
+            "recovery_compass_06",
+            "mangrove_slab",
+            "deepslate_copper_ore",
+            "candle",
+            "deepslate_lapis_ore",
+            "white_candle",
+            "light_02",
+            "glow_item_frame",
+            "moss_carpet",
+            "waxed_cut_copper_stairs",
+            "pointed_dripstone",
+            "oxidized_cut_copper_stairs",
+            "recovery_compass_03",
+            "weathered_cut_copper_slab",
+            "mangrove_stairs",
+            "raw_gold",
+            "recovery_compass_20",
+            "smooth_basalt",
+            "birch_chest_boat",
+            "ochre_froglight",
+            "mangrove_log",
+            "recovery_compass_29",
+            "waxed_weathered_copper",
+            "mangrove_trapdoor",
+            "recovery_compass_02",
+            "waxed_exposed_cut_copper_slab",
+            "amethyst_block",
+            "waxed_oxidized_cut_copper",
+            "spore_blossom",
+            "mangrove_sign",
+            "waxed_exposed_cut_copper",
+            "light_blue_candle",
+            "waxed_oxidized_cut_copper_slab",
+            "goat_horn",
+            "bundle",
+            "waxed_exposed_copper",
+            "chiseled_deepslate",
+            "mangrove_door",
+            "glow_squid_spawn_egg",
+            "frog_spawn_egg",
+            "tuff",
+            "recovery_compass_00",
+            "moss_block",
+            "recovery_compass_09",
+            "light_04",
+            "deepslate",
+            "pearlescent_froglight",
+            "large_amethyst_bud",
+            "mangrove_roots",
+            "deepslate_tile_wall",
+            "amethyst_cluster",
+            "raw_copper_block",
+            "music_disc_otherside",
+            "sculk_vein",
+            "deepslate_tile_slab",
+            "black_candle",
+            "mud",
+            "muddy_mangrove_roots",
+            "waxed_cut_copper",
+            "recovery_compass_04",
+            "weathered_cut_copper"
+        };
+//        Arrays.stream(minecraftBlockTexturesToInclude).forEach(texture -> texturesToIncludeForOlderVersionVisibility.add(
+//            NamespacedKeyWithoutIntention.minecraft(texture).withIntention(ResourcePackAssetIntention.BLOCK)
+//        ));
+        texturesToIncludeForOlderVersionVisibility.addAll(Arrays.asList(minecraftBlockTexturesToInclude));
+        texturesToIncludeForOlderVersionVisibility.addAll(Arrays.asList(minecraftItemTexturesToInclude));
+        modelsToIncludeForOlderVersionVisibility.addAll(Arrays.asList(minecraftBlockModelsToInclude));
+        modelsToIncludeForOlderVersionVisibility.addAll(Arrays.asList(minecraftItemModelsToInclude));
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/structure/CraftWorldStructurePiece.java b/src/main/java/org/sucraft/suki/structure/CraftWorldStructurePiece.java
index 095b83a7a7bb18392912ba00afd2d59e58a75f80..0e31c424ac9a2e19a3ce242afebad07384a0a56c 100644
--- a/src/main/java/org/sucraft/suki/structure/CraftWorldStructurePiece.java
+++ b/src/main/java/org/sucraft/suki/structure/CraftWorldStructurePiece.java
@@ -66,8 +66,8 @@ public class CraftWorldStructurePiece implements WorldStructurePiece {
             if (tag == null) {
                 this.cachedFullStructureTemplateName = Optional.empty();
             } else {
-                @Nullable String name = tag.getString("Template");
-                if (name != null && name.isBlank()) {
+                @NotNull String name = tag.getString("Template");
+                if (name.isBlank()) {
                     this.cachedFullStructureTemplateName = Optional.empty();
                 } else {
                     this.cachedFullStructureTemplateName = Optional.ofNullable(name);
@@ -115,8 +115,8 @@ public class CraftWorldStructurePiece implements WorldStructurePiece {
                     this.cachedFullPoolElementName = Optional.empty();
                 } else {
                     @NotNull CompoundTag poolElementTag = tag.getCompound("pool_element");
-                    @Nullable String name = poolElementTag.getString("location");
-                    if (name != null && name.isBlank()) {
+                    @NotNull String name = poolElementTag.getString("location");
+                    if (name.isBlank()) {
                         this.cachedFullPoolElementName = Optional.empty();
                     } else {
                         this.cachedFullPoolElementName = Optional.ofNullable(name);
@@ -140,8 +140,8 @@ public class CraftWorldStructurePiece implements WorldStructurePiece {
             if (colonIndex == -1) {
                 this.cachedShortPoolElementName = Optional.of(fullPoolElementName);
             } else {
-                @Nullable String name = fullPoolElementName.substring(colonIndex + 1);
-                if (name != null && name.isBlank()) {
+                @NotNull String name = fullPoolElementName.substring(colonIndex + 1);
+                if (name.isBlank()) {
                     this.cachedShortPoolElementName = Optional.empty();
                 } else {
                     this.cachedShortPoolElementName = Optional.ofNullable(name);
diff --git a/src/main/java/org/sucraft/suki/structure/SuCraftStructureTagsProvider.java b/src/main/java/org/sucraft/suki/structure/SuCraftStructureTagsProvider.java
index fdd3867cf4f8c7d14030a5410f82989040fadf22..daaf9adb34f6df5b8f17b075e1beb857fc250380 100644
--- a/src/main/java/org/sucraft/suki/structure/SuCraftStructureTagsProvider.java
+++ b/src/main/java/org/sucraft/suki/structure/SuCraftStructureTagsProvider.java
@@ -2,12 +2,17 @@
 
 package org.sucraft.suki.structure;
 
+import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.tags.StructureTags;
+import net.minecraft.tags.TagKey;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import org.sucraft.suki.data.SuCraftTagsProvider;
 
+import java.util.List;
+import java.util.Map;
+
 /**
  * Based on {@link net.minecraft.data.tags.StructureTagsProvider}
  */
@@ -18,7 +23,7 @@ public class SuCraftStructureTagsProvider extends SuCraftTagsProvider<Structure>
     }
 
     @Override
-    protected void addTags() {
+    protected void addTags(Map<TagKey<Structure>, List<Holder<Structure>>> existingRegistryTagEntries) {
         MinecraftServer.LOGGER.info("Adding onto existing structure tags...");
         this.tag(StructureTags.EYE_OF_ENDER_LOCATED).add(SuCraftBuiltinStructures.STRONGHOLD_SURFACE);
     }
diff --git a/src/main/java/org/sucraft/suki/util/CollectionPercentageProgress.java b/src/main/java/org/sucraft/suki/util/CollectionPercentageProgress.java
new file mode 100644
index 0000000000000000000000000000000000000000..7795309f9bdc94f24c545805c7aef9d6f8651ebf
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/util/CollectionPercentageProgress.java
@@ -0,0 +1,51 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.util;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.function.Consumer;
+
+/**
+ * A {@link PercentageProgress} for iterating over a collection
+ */
+public class CollectionPercentageProgress<T> extends PercentageProgress {
+
+    protected final @NotNull Collection<T> collection;
+
+    public CollectionPercentageProgress(@NotNull String action, @NotNull Collection<T> collection, int printEveryPercent) {
+        super(action, collection.size(), printEveryPercent);
+        this.collection = collection;
+    }
+
+    public void forEach(@NotNull Consumer<T> action) {
+        this.reset();
+        this.collection.forEach(element -> {
+            this.beforeStep();
+            action.accept(element);
+            this.afterStep();
+        });
+    }
+
+    public <E extends Throwable> void forEachThrowsException(@NotNull ConsumerThrowsException<T, E> action) throws E {
+        try {
+            this.reset();
+            this.collection.forEach(element -> {
+                try {
+                    this.beforeStep();
+                    action.accept(element);
+                    this.afterStep();
+                } catch (Throwable e) {
+                    throw new RuntimeException(e);
+                }
+            });
+        } catch (RuntimeException e) {
+            if (e.getClass().equals(RuntimeException.class)) {
+                throw (E) e.getCause();
+            }
+            throw e;
+        }
+    }
+
+}
diff --git a/src/main/java/org/sucraft/suki/util/ConsumerThrowsException.java b/src/main/java/org/sucraft/suki/util/ConsumerThrowsException.java
new file mode 100644
index 0000000000000000000000000000000000000000..8bfca34446287176e0f308b1cd03f024206c3731
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/util/ConsumerThrowsException.java
@@ -0,0 +1,13 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.util;
+
+/**
+ * A consumer that can throw a specific type of exception
+ */
+@FunctionalInterface
+public interface ConsumerThrowsException<T, E extends Throwable> {
+
+    void accept(T t) throws E;
+
+}
diff --git a/src/main/java/org/sucraft/suki/util/PercentageProgress.java b/src/main/java/org/sucraft/suki/util/PercentageProgress.java
new file mode 100644
index 0000000000000000000000000000000000000000..34549abf504ac7179d8503640dc224eea79db04f
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/util/PercentageProgress.java
@@ -0,0 +1,50 @@
+// Suki - custom blocks and items
+
+package org.sucraft.suki.util;
+
+import net.minecraft.server.MinecraftServer;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Utility class to print progress to console
+ */
+public class PercentageProgress {
+
+    protected final @NotNull String action;
+    protected final int total;
+    protected final int printEveryPercent;
+
+    protected int i;
+
+    protected int lastPrintedPercentage;
+
+    public PercentageProgress(@NotNull String action, int total, int printEveryPercent) {
+        this.action = action;
+        this.total = total;
+        this.printEveryPercent = printEveryPercent;
+        this.reset();
+    }
+
+    public void printProgress(int percentage) {
+        MinecraftServer.LOGGER.info(this.action + "... " + percentage + "% (" + this.i + " / " + this.total + ")");
+    }
+
+    public void beforeStep() {
+        int percentage = (int) Math.floor(this.i * 100.0 / this.total + 0.00001);
+        if ((percentage % this.printEveryPercent == 0 || this.i == this.total) && percentage != this.lastPrintedPercentage) {
+            this.printProgress(percentage);
+            this.lastPrintedPercentage = percentage;
+        }
+    }
+
+    public void afterStep() {
+        this.i++;
+        beforeStep();
+    }
+
+    public void reset() {
+        this.i = 0;
+        this.lastPrintedPercentage = -1;
+    }
+
+}
