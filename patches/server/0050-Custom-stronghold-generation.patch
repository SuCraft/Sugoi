From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Sun, 26 Jun 2022 23:37:34 +0200
Subject: [PATCH] Custom stronghold generation


diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 03bc6298d6b50fe9a321dbf916000109889987be..ab66f41e83ce4f74af03477bc845804c31ba68ca 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -2,26 +2,20 @@ package io.papermc.paper.configuration;
 
 import co.aikar.timings.MinecraftTimings;
 import com.destroystokyo.paper.io.chunk.ChunkTaskManager;
-import com.google.common.graph.Network;
 import io.papermc.paper.configuration.constraint.Constraint;
 import io.papermc.paper.configuration.constraint.Constraints;
 import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.format.NamedTextColor;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ServerboundPlaceRecipePacket;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.world.level.GameType;
 import org.bukkit.Bukkit; // Pufferfish
-import org.bukkit.GameMode;
 import org.checkerframework.checker.nullness.qual.Nullable;
-import org.checkerframework.checker.units.qual.A;
 import org.spongepowered.configurate.objectmapping.ConfigSerializable;
 import org.spongepowered.configurate.objectmapping.meta.Comment;
 import org.spongepowered.configurate.objectmapping.meta.Required;
 import org.spongepowered.configurate.objectmapping.meta.Setting;
 
 import java.util.List;
-import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
 import java.util.logging.Level; // Pufferfish
@@ -40,6 +34,18 @@ public class GlobalConfiguration extends ConfigurationPart {
     @Setting(Configuration.VERSION_FIELD)
     public int version = CURRENT_VERSION;
 
+    // Suki start - custom blocks and items
+
+    public CustomBlocksAndItems customBlocksAndItems;
+
+    public class CustomBlocksAndItems extends ConfigurationPart {
+
+        public int maxPingThatCountsAsLowForCustomBlocks = 300;
+
+    }
+
+    // Suki end - custom blocks and items
+
     public Messages messages;
 
     public class Messages extends ConfigurationPart {
diff --git a/src/main/java/net/minecraft/data/advancements/StoryAdvancements.java b/src/main/java/net/minecraft/data/advancements/StoryAdvancements.java
index 712e249ebe86d9adabf2bb816eea45543061efd3..b11c462c0c76ce15ff7073e0b7f021a0f3649302 100644
--- a/src/main/java/net/minecraft/data/advancements/StoryAdvancements.java
+++ b/src/main/java/net/minecraft/data/advancements/StoryAdvancements.java
@@ -21,6 +21,7 @@ import net.minecraft.world.item.Items;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.levelgen.structure.BuiltinStructures;
+import org.sucraft.suki.structure.SuCraftBuiltinStructures;
 
 public class StoryAdvancements implements Consumer<Consumer<Advancement>> {
     @Override
@@ -39,7 +40,7 @@ public class StoryAdvancements implements Consumer<Consumer<Advancement>> {
         Advancement.Builder.advancement().parent(advancement6).display(Items.DIAMOND_CHESTPLATE, Component.translatable("advancements.story.shiny_gear.title"), Component.translatable("advancements.story.shiny_gear.description"), (ResourceLocation)null, FrameType.TASK, true, true, false).requirements(RequirementsStrategy.OR).addCriterion("diamond_helmet", InventoryChangeTrigger.TriggerInstance.hasItems(Items.DIAMOND_HELMET)).addCriterion("diamond_chestplate", InventoryChangeTrigger.TriggerInstance.hasItems(Items.DIAMOND_CHESTPLATE)).addCriterion("diamond_leggings", InventoryChangeTrigger.TriggerInstance.hasItems(Items.DIAMOND_LEGGINGS)).addCriterion("diamond_boots", InventoryChangeTrigger.TriggerInstance.hasItems(Items.DIAMOND_BOOTS)).save(consumer, "story/shiny_gear");
         Advancement advancement10 = Advancement.Builder.advancement().parent(advancement9).display(Items.FLINT_AND_STEEL, Component.translatable("advancements.story.enter_the_nether.title"), Component.translatable("advancements.story.enter_the_nether.description"), (ResourceLocation)null, FrameType.TASK, true, true, false).addCriterion("entered_nether", ChangeDimensionTrigger.TriggerInstance.changedDimensionTo(Level.NETHER)).save(consumer, "story/enter_the_nether");
         Advancement.Builder.advancement().parent(advancement10).display(Items.GOLDEN_APPLE, Component.translatable("advancements.story.cure_zombie_villager.title"), Component.translatable("advancements.story.cure_zombie_villager.description"), (ResourceLocation)null, FrameType.GOAL, true, true, false).addCriterion("cured_zombie", CuredZombieVillagerTrigger.TriggerInstance.curedZombieVillager()).save(consumer, "story/cure_zombie_villager");
-        Advancement advancement11 = Advancement.Builder.advancement().parent(advancement10).display(Items.ENDER_EYE, Component.translatable("advancements.story.follow_ender_eye.title"), Component.translatable("advancements.story.follow_ender_eye.description"), (ResourceLocation)null, FrameType.TASK, true, true, false).addCriterion("in_stronghold", PlayerTrigger.TriggerInstance.located(LocationPredicate.inStructure(BuiltinStructures.STRONGHOLD))).save(consumer, "story/follow_ender_eye");
+        Advancement advancement11 = Advancement.Builder.advancement().parent(advancement10).display(Items.ENDER_EYE, Component.translatable("advancements.story.follow_ender_eye.title"), Component.translatable("advancements.story.follow_ender_eye.description"), (ResourceLocation)null, FrameType.TASK, true, true, false).requirements(RequirementsStrategy.OR).addCriterion("in_stronghold", PlayerTrigger.TriggerInstance.located(LocationPredicate.inStructure(BuiltinStructures.STRONGHOLD))).addCriterion("in_stronghold_surface", PlayerTrigger.TriggerInstance.located(LocationPredicate.inStructure(SuCraftBuiltinStructures.STRONGHOLD_SURFACE))).save(consumer, "story/follow_ender_eye"); // Suki - custom strongholds - surface strongholds
         Advancement.Builder.advancement().parent(advancement11).display(Blocks.END_STONE, Component.translatable("advancements.story.enter_the_end.title"), Component.translatable("advancements.story.enter_the_end.description"), (ResourceLocation)null, FrameType.TASK, true, true, false).addCriterion("entered_end", ChangeDimensionTrigger.TriggerInstance.changedDimensionTo(Level.END)).save(consumer, "story/enter_the_end");
     }
 }
diff --git a/src/main/java/net/minecraft/data/worldgen/StructureSets.java b/src/main/java/net/minecraft/data/worldgen/StructureSets.java
index ef50bc6a61c074c9b9f6a12dc465d407aec95d19..0dec0e4c698ef57630c949aef71c9d9ee4a89b7d 100644
--- a/src/main/java/net/minecraft/data/worldgen/StructureSets.java
+++ b/src/main/java/net/minecraft/data/worldgen/StructureSets.java
@@ -2,6 +2,8 @@ package net.minecraft.data.worldgen;
 
 import java.util.List;
 import java.util.Optional;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.core.Vec3i;
@@ -15,6 +17,7 @@ import net.minecraft.world.level.levelgen.structure.placement.ConcentricRingsStr
 import net.minecraft.world.level.levelgen.structure.placement.RandomSpreadStructurePlacement;
 import net.minecraft.world.level.levelgen.structure.placement.RandomSpreadType;
 import net.minecraft.world.level.levelgen.structure.placement.StructurePlacement;
+import org.sucraft.suki.structure.SuCraftStructures;
 
 public interface StructureSets {
     Holder<StructureSet> VILLAGES = register(BuiltinStructureSets.VILLAGES, new StructureSet(List.of(StructureSet.entry(Structures.VILLAGE_PLAINS), StructureSet.entry(Structures.VILLAGE_DESERT), StructureSet.entry(Structures.VILLAGE_SAVANNA), StructureSet.entry(Structures.VILLAGE_SNOWY), StructureSet.entry(Structures.VILLAGE_TAIGA)), new RandomSpreadStructurePlacement(34, 8, RandomSpreadType.LINEAR, 10387312)));
@@ -34,7 +37,7 @@ public interface StructureSets {
     Holder<StructureSet> NETHER_COMPLEXES = register(BuiltinStructureSets.NETHER_COMPLEXES, new StructureSet(List.of(StructureSet.entry(Structures.FORTRESS, 2), StructureSet.entry(Structures.BASTION_REMNANT, 3)), new RandomSpreadStructurePlacement(27, 4, RandomSpreadType.LINEAR, 30084232)));
     Holder<StructureSet> NETHER_FOSSILS = register(BuiltinStructureSets.NETHER_FOSSILS, Structures.NETHER_FOSSIL, new RandomSpreadStructurePlacement(2, 1, RandomSpreadType.LINEAR, 14357921));
     Holder<StructureSet> END_CITIES = register(BuiltinStructureSets.END_CITIES, Structures.END_CITY, new RandomSpreadStructurePlacement(20, 11, RandomSpreadType.TRIANGULAR, 10387313));
-    Holder<StructureSet> STRONGHOLDS = register(BuiltinStructureSets.STRONGHOLDS, Structures.STRONGHOLD, new ConcentricRingsStructurePlacement(32, 3, 128, BuiltinRegistries.BIOME.getOrCreateTag(BiomeTags.STRONGHOLD_BIASED_TO)));
+    Holder<StructureSet> STRONGHOLDS = register(BuiltinStructureSets.STRONGHOLDS, new StructureSet(List.of(StructureSet.entry(Structures.STRONGHOLD, 1), StructureSet.entry(SuCraftStructures.STRONGHOLD_SURFACE, 100)), new ConcentricRingsStructurePlacement(32, 3, 128, BuiltinRegistries.BIOME.getOrCreateTag(BiomeTags.STRONGHOLD_BIASED_TO)))); // Suki - custom strongholds - surface strongholds
 
     static Holder<StructureSet> bootstrap(Registry<StructureSet> registry) {
         return registry.holders().iterator().next();
diff --git a/src/main/java/net/minecraft/data/worldgen/Structures.java b/src/main/java/net/minecraft/data/worldgen/Structures.java
index e128dc9d88d0dbac591e79e6fcffff84334d0f34..630e278ca4abc1bc210c2c2fc54f62979e88dcde 100644
--- a/src/main/java/net/minecraft/data/worldgen/Structures.java
+++ b/src/main/java/net/minecraft/data/worldgen/Structures.java
@@ -57,7 +57,7 @@ public class Structures {
     public static final Holder<Structure> SHIPWRECK = register(BuiltinStructures.SHIPWRECK, new ShipwreckStructure(structure(BiomeTags.HAS_SHIPWRECK, TerrainAdjustment.NONE), false));
     public static final Holder<Structure> SHIPWRECK_BEACHED = register(BuiltinStructures.SHIPWRECK_BEACHED, new ShipwreckStructure(structure(BiomeTags.HAS_SHIPWRECK_BEACHED, TerrainAdjustment.NONE), true));
     public static final Holder<Structure> SWAMP_HUT = register(BuiltinStructures.SWAMP_HUT, new SwampHutStructure(structure(BiomeTags.HAS_SWAMP_HUT, Map.of(MobCategory.MONSTER, new StructureSpawnOverride(StructureSpawnOverride.BoundingBoxType.PIECE, WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.WITCH, 1, 1, 1))), MobCategory.CREATURE, new StructureSpawnOverride(StructureSpawnOverride.BoundingBoxType.PIECE, WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.CAT, 1, 1, 1)))), GenerationStep.Decoration.SURFACE_STRUCTURES, TerrainAdjustment.NONE)));
-    public static final Holder<Structure> STRONGHOLD = register(BuiltinStructures.STRONGHOLD, new StrongholdStructure(structure(BiomeTags.HAS_STRONGHOLD, TerrainAdjustment.BURY)));
+    public static final Holder<Structure> STRONGHOLD = register(BuiltinStructures.STRONGHOLD, new StrongholdStructure(structure(BiomeTags.HAS_STRONGHOLD, TerrainAdjustment.BURY), false)); // Suki - custom strongholds - surface strongholds
     public static final Holder<Structure> OCEAN_MONUMENT = register(BuiltinStructures.OCEAN_MONUMENT, new OceanMonumentStructure(structure(BiomeTags.HAS_OCEAN_MONUMENT, Map.of(MobCategory.MONSTER, new StructureSpawnOverride(StructureSpawnOverride.BoundingBoxType.STRUCTURE, WeightedRandomList.create(new MobSpawnSettings.SpawnerData(EntityType.GUARDIAN, 1, 2, 4))), MobCategory.UNDERGROUND_WATER_CREATURE, new StructureSpawnOverride(StructureSpawnOverride.BoundingBoxType.STRUCTURE, MobSpawnSettings.EMPTY_MOB_LIST), MobCategory.AXOLOTLS, new StructureSpawnOverride(StructureSpawnOverride.BoundingBoxType.STRUCTURE, MobSpawnSettings.EMPTY_MOB_LIST)), GenerationStep.Decoration.SURFACE_STRUCTURES, TerrainAdjustment.NONE)));
     public static final Holder<Structure> OCEAN_RUIN_COLD = register(BuiltinStructures.OCEAN_RUIN_COLD, new OceanRuinStructure(structure(BiomeTags.HAS_OCEAN_RUIN_COLD, TerrainAdjustment.NONE), OceanRuinStructure.Type.COLD, 0.3F, 0.9F));
     public static final Holder<Structure> OCEAN_RUIN_WARM = register(BuiltinStructures.OCEAN_RUIN_WARM, new OceanRuinStructure(structure(BiomeTags.HAS_OCEAN_RUIN_WARM, TerrainAdjustment.NONE), OceanRuinStructure.Type.WARM, 0.3F, 0.9F));
diff --git a/src/main/java/net/minecraft/server/ServerAdvancementManager.java b/src/main/java/net/minecraft/server/ServerAdvancementManager.java
index 902f179e4e997829d9f2143ba358dd16d2303829..752e389ad375535274ffb19f2b2306a7f2fc2e5b 100644
--- a/src/main/java/net/minecraft/server/ServerAdvancementManager.java
+++ b/src/main/java/net/minecraft/server/ServerAdvancementManager.java
@@ -13,14 +13,20 @@ import java.util.Map;
 import javax.annotation.Nullable;
 import net.minecraft.advancements.Advancement;
 import net.minecraft.advancements.AdvancementList;
+import net.minecraft.advancements.RequirementsStrategy;
 import net.minecraft.advancements.TreeNodePosition;
 import net.minecraft.advancements.critereon.DeserializationContext;
+import net.minecraft.advancements.critereon.LocationPredicate;
+import net.minecraft.advancements.critereon.PlayerTrigger;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.server.packs.resources.SimpleJsonResourceReloadListener;
 import net.minecraft.util.GsonHelper;
 import net.minecraft.util.profiling.ProfilerFiller;
+import net.minecraft.world.level.levelgen.structure.BuiltinStructures;
 import net.minecraft.world.level.storage.loot.PredicateManager;
+import org.sucraft.suki.structure.SuCraftBuiltinStructures;
+import org.bukkit.Bukkit;
 import org.slf4j.Logger;
 
 public class ServerAdvancementManager extends SimpleJsonResourceReloadListener {
@@ -49,6 +55,17 @@ public class ServerAdvancementManager extends SimpleJsonResourceReloadListener {
                 JsonObject jsonobject = GsonHelper.convertToJsonObject(jsonelement, "advancement");
                 Advancement.Builder advancement_serializedadvancement = Advancement.Builder.fromJson(jsonobject, new DeserializationContext(minecraftkey, this.predicateManager));
 
+                // Suki start - custom strongholds - surface strongholds
+                if (minecraftkey.toString().equals("minecraft:story/follow_ender_eye")) {
+                    advancement_serializedadvancement.getCriteria().clear(); // A bit hacky, but hey, if it works
+                    advancement_serializedadvancement = advancement_serializedadvancement
+                        .requirements(RequirementsStrategy.OR)
+                        .addCriterion("in_stronghold", PlayerTrigger.TriggerInstance.located(LocationPredicate.inStructure(BuiltinStructures.STRONGHOLD)))
+                        .addCriterion("in_stronghold_surface", PlayerTrigger.TriggerInstance.located(LocationPredicate.inStructure(SuCraftBuiltinStructures.STRONGHOLD_SURFACE)))
+                        .requirements(new String[][] {{"in_stronghold", "in_stronghold_surface"}});
+                }
+                // Suki end - custom strongholds - surface strongholds
+
                 map1.put(minecraftkey, advancement_serializedadvancement);
             } catch (Exception exception) {
                 ServerAdvancementManager.LOGGER.error("Parsing error loading custom advancement {}: {}", minecraftkey, exception.getMessage());
diff --git a/src/main/java/net/minecraft/server/level/WorldGenRegion.java b/src/main/java/net/minecraft/server/level/WorldGenRegion.java
index 33f07595a99a94984f221fdf8e436dd3c3b094f5..e4b134039c6a6cae6381c80e78e68a9adee308a1 100644
--- a/src/main/java/net/minecraft/server/level/WorldGenRegion.java
+++ b/src/main/java/net/minecraft/server/level/WorldGenRegion.java
@@ -341,7 +341,7 @@ public class WorldGenRegion implements WorldGenLevel {
         } else {
             // Paper start
             if (!hasSetFarWarned && !wtf.etil.mirai.MiraiConfig.loggerSuppressSetBlockFarChunk) { // Purpur
-            Util.logAndPauseIfInIde("Detected setBlock in a far chunk [" + i + ", " + j + "], pos: " + pos + ", status: " + this.generatingStatus + (this.currentlyGenerating == null ? "" : ", currently generating: " + (String) this.currentlyGenerating.get()));
+            Util.logAndPauseIfInIde("Detected setBlock in a far chunk [" + i + ", " + j + "], pos: " + pos + ", intended center chunk: [" + chunkcoordintpair.x + ", " + chunkcoordintpair.z + "], writeRadiusCutoff: " + this.writeRadiusCutoff + ", status: " + this.generatingStatus + (this.currentlyGenerating == null ? "" : ", currently generating: " + (String) this.currentlyGenerating.get())); // Suki - custom strongholds - debug errors
             hasSetFarWarned = true;
             if (this.getServer() != null && this.getServer().isDebugging()) {
                 io.papermc.paper.util.TraceUtil.dumpTraceForThread("far setBlock call");
diff --git a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
index e6240f891e396d91e31b02fdf3084be77e9d6697..fabee98f1af2b391190f2d43244df09dad4a50c2 100644
--- a/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
+++ b/src/main/java/net/minecraft/world/level/chunk/ChunkStatus.java
@@ -30,6 +30,7 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemp
 public class ChunkStatus {
 
     public static final int MAX_STRUCTURE_DISTANCE = 8;
+    public static final int CHUNK_STATUS_TASK_MARGIN = 8; // Vanilla is 8 // Suki - custom strongholds - bigger strongholds
     private static final EnumSet<Heightmap.Types> PRE_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR_WG, Heightmap.Types.WORLD_SURFACE_WG);
     public static final EnumSet<Heightmap.Types> POST_FEATURES = EnumSet.of(Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE, Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES);
     private static final ChunkStatus.LoadingTask PASSTHROUGH_LOAD_TASK = (chunkstatus, worldserver, structuretemplatemanager, lightenginethreaded, function, ichunkaccess) -> {
@@ -74,12 +75,12 @@ public class ChunkStatus {
 
         return CompletableFuture.completedFuture(Either.left(ichunkaccess));
     });
-    public static final ChunkStatus STRUCTURE_REFERENCES = ChunkStatus.registerSimple("structure_references", ChunkStatus.STRUCTURE_STARTS, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+    public static final ChunkStatus STRUCTURE_REFERENCES = ChunkStatus.registerSimple("structure_references", ChunkStatus.STRUCTURE_STARTS, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> { // Suki - custom strongholds - bigger strongholds
         WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, -1);
 
         chunkgenerator.createReferences(regionlimitedworldaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess);
     });
-    public static final ChunkStatus BIOMES = ChunkStatus.register("biomes", ChunkStatus.STRUCTURE_REFERENCES, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> {
+    public static final ChunkStatus BIOMES = ChunkStatus.register("biomes", ChunkStatus.STRUCTURE_REFERENCES, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> { // Suki - custom strongholds - bigger strongholds
         if (!flag && ichunkaccess.getStatus().isOrAfter(chunkstatus)) {
             return CompletableFuture.completedFuture(Either.left(ichunkaccess));
         } else {
@@ -94,7 +95,7 @@ public class ChunkStatus {
             });
         }
     });
-    public static final ChunkStatus NOISE = ChunkStatus.register("noise", ChunkStatus.BIOMES, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> {
+    public static final ChunkStatus NOISE = ChunkStatus.register("noise", ChunkStatus.BIOMES, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> { // Suki - custom strongholds - bigger strongholds
         if (!flag && ichunkaccess.getStatus().isOrAfter(chunkstatus)) {
             return CompletableFuture.completedFuture(Either.left(ichunkaccess));
         } else {
@@ -119,12 +120,12 @@ public class ChunkStatus {
             });
         }
     });
-    public static final ChunkStatus SURFACE = ChunkStatus.registerSimple("surface", ChunkStatus.NOISE, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+    public static final ChunkStatus SURFACE = ChunkStatus.registerSimple("surface", ChunkStatus.NOISE, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> { // Suki - custom strongholds - bigger strongholds
         WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 0);
 
         chunkgenerator.buildSurface(regionlimitedworldaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), worldserver.getChunkSource().randomState(), ichunkaccess);
     });
-    public static final ChunkStatus CARVERS = ChunkStatus.registerSimple("carvers", ChunkStatus.SURFACE, 8, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+    public static final ChunkStatus CARVERS = ChunkStatus.registerSimple("carvers", ChunkStatus.SURFACE, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.PRE_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> { // Suki - custom strongholds - bigger strongholds
         WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 0);
 
         if (ichunkaccess instanceof ProtoChunk) {
@@ -135,15 +136,15 @@ public class ChunkStatus {
 
         chunkgenerator.applyCarvers(regionlimitedworldaccess, worldserver.getSeed(), worldserver.getChunkSource().randomState(), worldserver.getBiomeManager(), worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess), ichunkaccess, GenerationStep.Carving.AIR);
     });
-    public static final ChunkStatus LIQUID_CARVERS = ChunkStatus.registerSimple("liquid_carvers", ChunkStatus.CARVERS, 8, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> {
+    public static final ChunkStatus LIQUID_CARVERS = ChunkStatus.registerSimple("liquid_carvers", ChunkStatus.CARVERS, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, worldserver, chunkgenerator, list, ichunkaccess) -> { // Suki - custom strongholds - bigger strongholds
     });
-    public static final ChunkStatus FEATURES = ChunkStatus.register("features", ChunkStatus.LIQUID_CARVERS, 8, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> {
+    public static final ChunkStatus FEATURES = ChunkStatus.register("features", ChunkStatus.LIQUID_CARVERS, CHUNK_STATUS_TASK_MARGIN, ChunkStatus.POST_FEATURES, ChunkStatus.ChunkType.PROTOCHUNK, (chunkstatus, executor, worldserver, chunkgenerator, structuretemplatemanager, lightenginethreaded, function, list, ichunkaccess, flag) -> { // Suki start - custom strongholds - bigger strongholds
         ProtoChunk protochunk = (ProtoChunk) ichunkaccess;
 
         protochunk.setLightEngine(lightenginethreaded);
         if (flag || !ichunkaccess.getStatus().isOrAfter(chunkstatus)) {
             Heightmap.primeHeightmaps(ichunkaccess, EnumSet.of(Heightmap.Types.MOTION_BLOCKING, Heightmap.Types.MOTION_BLOCKING_NO_LEAVES, Heightmap.Types.OCEAN_FLOOR, Heightmap.Types.WORLD_SURFACE));
-            WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 1);
+            WorldGenRegion regionlimitedworldaccess = new WorldGenRegion(worldserver, list, chunkstatus, 1); // Default placementRadius is 1 // Suki - custom strongholds - bigger strongholds
 
             chunkgenerator.applyBiomeDecoration(regionlimitedworldaccess, ichunkaccess, worldserver.structureManager().forWorldGenRegion(regionlimitedworldaccess));
             Blender.generateBorderTicks(regionlimitedworldaccess, ichunkaccess);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/StructurePiece.java b/src/main/java/net/minecraft/world/level/levelgen/structure/StructurePiece.java
index 6f062ad8b3a87ad9e943267c538a0ac306cd84a3..a7b12a3bafa22a33b5b5df2e980d82d92d3d4da2 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/StructurePiece.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/StructurePiece.java
@@ -3,15 +3,19 @@ package net.minecraft.world.level.levelgen.structure;
 import com.google.common.collect.ImmutableSet;
 import com.mojang.logging.LogUtils;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
+import java.util.function.Predicate;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Registry;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.NbtOps;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.BlockTags;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.BlockGetter;
 import net.minecraft.world.level.ChunkPos;
@@ -29,6 +33,10 @@ import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.ChestBlockEntity;
 import net.minecraft.world.level.block.entity.DispenserBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
+import net.minecraft.world.level.block.state.properties.Half;
+import net.minecraft.world.level.block.state.properties.SlabType;
+import net.minecraft.world.level.block.state.properties.StairsShape;
 import net.minecraft.world.level.chunk.ChunkGenerator;
 import net.minecraft.world.level.levelgen.Heightmap;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext;
@@ -38,8 +46,6 @@ import org.sucraft.suki.structure.CraftWorldStructure;
 import org.sucraft.suki.structure.CraftWorldStructurePiece;
 import org.apache.commons.lang3.tuple.ImmutableTriple;
 import org.apache.commons.lang3.tuple.Triple;
-import org.apache.logging.log4j.util.TriConsumer;
-import org.bukkit.craftbukkit.CraftWorld;
 import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
@@ -53,7 +59,7 @@ public abstract class StructurePiece {
     private Rotation rotation;
     protected int genDepth;
     private final StructurePieceType type;
-    private static final Set<Block> SHAPE_CHECK_BLOCKS = ImmutableSet.<Block>builder().add(Blocks.NETHER_BRICK_FENCE).add(Blocks.TORCH).add(Blocks.WALL_TORCH).add(Blocks.OAK_FENCE).add(Blocks.SPRUCE_FENCE).add(Blocks.DARK_OAK_FENCE).add(Blocks.ACACIA_FENCE).add(Blocks.BIRCH_FENCE).add(Blocks.JUNGLE_FENCE).add(Blocks.LADDER).add(Blocks.IRON_BARS).build();
+    public static final Set<Block> SHAPE_CHECK_BLOCKS = ImmutableSet.<Block>builder().add(Blocks.NETHER_BRICK_FENCE).add(Blocks.TORCH).add(Blocks.WALL_TORCH).add(Blocks.OAK_FENCE).add(Blocks.SPRUCE_FENCE).add(Blocks.DARK_OAK_FENCE).add(Blocks.ACACIA_FENCE).add(Blocks.BIRCH_FENCE).add(Blocks.JUNGLE_FENCE).add(Blocks.LADDER).add(Blocks.IRON_BARS).build(); // Suki - custom strongholds - surface strongholds
 
     // Suki start - structure API
 
@@ -178,31 +184,300 @@ public abstract class StructurePiece {
         }
     }
 
+    // Suki start - custom strongholds - conditional placements
+
+    public static final Direction[] besideOrAboveDirections = { Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH, Direction.UP };
+
+    public static final Direction[] besideDirections = { Direction.EAST, Direction.WEST, Direction.NORTH, Direction.SOUTH };
+
+    public static boolean countsAsSolid(BlockGetter world, BlockPos pos, Direction inDirection) {
+        return countsAsSolid(world, pos, world.getBlockState(pos), inDirection);
+    }
+
+    public static boolean countsAsSolid(BlockGetter world, BlockPos pos, BlockState block, Direction inDirection) {
+        return !block.isAir() && !block.getMaterial().isLiquid() && block.isFaceSturdy(world, pos, inDirection);
+    }
+
+    public static boolean hasRelativeSolid(BlockGetter world, BlockPos pos, Direction direction) {
+        return countsAsSolid(world, pos.relative(direction), direction.getOpposite());
+    }
+
+    public static boolean hasAnyRelativeSolid(BlockGetter world, BlockPos pos, Direction[] directions) {
+        for (Direction direction : directions) {
+            if (hasRelativeSolid(world, pos, direction)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static boolean anyHasRelativeSolid(BlockGetter world, BlockPos[] poss, Direction direction) {
+        for (BlockPos pos : poss) {
+            if (hasRelativeSolid(world, pos, direction)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static boolean anyHasAnyRelativeSolid(BlockGetter world, BlockPos[] poss, Direction[] directions) {
+        for (BlockPos pos : poss) {
+            if (hasAnyRelativeSolid(world, pos, directions)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public static boolean canBeFilledUpByWaterSourceIfWaterFlowsIn(BlockState state) {
+        return state.isAir() || state.is(BlockTags.BUTTONS) || state.is(Blocks.TORCH) || state.is(Blocks.WALL_TORCH) || state.is(Blocks.LEVER) || state.is(Blocks.COBWEB);
+    }
+
+    public static @Nullable BlockState getRelativeLiquidDefaultBlockState(BlockGetter world, BlockPos pos, Direction direction) {
+        BlockState block = world.getBlockState(pos);
+        Optional<Boolean> blockWaterlogged = block.getOptionalValue(BlockStateProperties.WATERLOGGED);
+        if (!(block.getMaterial().isLiquid() || (blockWaterlogged.isPresent() && blockWaterlogged.get()))) {
+            BlockState relativeBlock = world.getBlockState(pos.relative(direction));
+            Optional<Boolean> relativeBlockWaterlogged = relativeBlock.getOptionalValue(BlockStateProperties.WATERLOGGED);
+            if (relativeBlock.getMaterial().isLiquid() || (relativeBlockWaterlogged.isPresent() && relativeBlockWaterlogged.get())) {
+                if (canBeFilledUpByWaterSourceIfWaterFlowsIn(block)) {
+                    return Blocks.WATER.defaultBlockState();
+                } else if (blockWaterlogged.isPresent()) {
+                    return block.getBlock().withPropertiesOf(block).setValue(BlockStateProperties.WATERLOGGED, true);
+                }
+            }
+        }
+        return null;
+    }
+
+    public static @Nullable BlockState getAnyRelativeLiquidDefaultBlockState(BlockGetter world, BlockPos pos, Direction[] directions) {
+        for (Direction direction : directions) {
+            @Nullable BlockState forDirection = getRelativeLiquidDefaultBlockState(world, pos, direction);
+            if (forDirection != null) {
+                return forDirection;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @param cantReplaceAir If true, the block will not be placed if the existing block is air.
+     * @param cantReplaceLiquid If true, the block will not be placed if the existing block is liquid.
+     * @param requireSolidBelow If true, the block will not be placed if the existing block below is air or liquid.
+     * @param requireSolidBelowOrBeside If true, the block will not be placed if among the existing blocks either below or horizontally besides this block, none are something other than air or liquid.
+     * @param requireSolidAdjacent If true, the block will not be placed if among the existing blocks adjacent to this block in any of the 6 orthogonal directions, none are something other than air or liquid.
+     */
+    protected boolean placeBlockConditionally(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box, boolean cantReplaceAir, boolean cantReplaceLiquid, boolean requireSolidBelow, boolean requireSolidBelowOrBeside, boolean requireSolidAdjacent) {
+
+        BlockPos pos = this.getWorldPos(x, y, z);
+
+        // If the block is air, we can always replace other air
+        if (block.isAir()) {
+            cantReplaceAir = false;
+        }
+
+        // If the block is air or liquid, it does not need any support
+        if (block.isAir() || block.getMaterial().isLiquid()) {
+            requireSolidBelow = false;
+            requireSolidBelowOrBeside = false;
+            requireSolidAdjacent = false;
+        }
+
+        // If we are trying to place air, but there is liquid above or beside, place that liquid type instead
+        if (block.isAir()) {
+            BlockState adjacentLiquidDefaultState = getAnyRelativeLiquidDefaultBlockState(world, pos, besideOrAboveDirections);
+            if (adjacentLiquidDefaultState != null) {
+                block = adjacentLiquidDefaultState;
+            }
+        }
+
+        // If we are trying to place a waterloggable block, and there is water above or beside, place the waterlogged version instead
+        Optional<Boolean> waterlogged = block.getOptionalValue(BlockStateProperties.WATERLOGGED);
+        if (waterlogged.isPresent() && !waterlogged.get()) {
+            BlockState blockAbove = world.getBlockState(pos.above());
+            Optional<Boolean> blockAboveWaterlogged = blockAbove.getOptionalValue(BlockStateProperties.WATERLOGGED);
+            if ((blockAboveWaterlogged.isPresent() && blockAboveWaterlogged.get()) || blockAbove.is(Blocks.WATER)) {
+                block = block.getBlock().withPropertiesOf(block).setValue(BlockStateProperties.WATERLOGGED, true);
+            }
+        }
+
+        // Check for illegal replacement of air
+        if (cantReplaceAir) {
+            if (world.getBlockState(pos).isAir()) {
+                return false;
+            }
+        }
+
+        // Check for illegal replacement of water
+        if (cantReplaceLiquid) {
+            if (world.getBlockState(pos).getMaterial().isLiquid()) {
+                return false;
+            }
+        }
+
+        // Check for missing support from surroundings
+        if (requireSolidBelow || requireSolidBelowOrBeside || requireSolidAdjacent) {
+            if (!hasRelativeSolid(world, pos, Direction.DOWN)) {
+                if (requireSolidBelow) {
+                    return false;
+                }
+                if (!hasAnyRelativeSolid(world, pos, besideDirections)) {
+                    if (requireSolidBelowOrBeside) {
+                        return false;
+                    }
+                    if (!hasRelativeSolid(world, pos, Direction.UP)) {
+                        return false;
+                    }
+                }
+            }
+        }
+
+        // We can place the block
+        return this.placeBlockUnconditionally(world, block, x, y, z, box);
+
+    }
+
+    /**
+     * The same as {@link StructurePiece#placeBlockConditionally(WorldGenLevel, BlockState, int, int, int, BoundingBox, boolean, boolean, boolean, boolean, boolean)},
+     * but requires no adjacent solid blocks.
+     */
+    protected boolean placeBlockConditionally(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box, boolean cantReplaceAir, boolean cantReplaceLiquid) {
+        return this.placeBlockConditionally(world, block, x, y, z, box, cantReplaceAir, cantReplaceLiquid, false, false, false);
+    }
+
+    protected boolean generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, boolean cantReplaceLiquid, boolean requireSolidBelow, boolean requireSolidBelowOrBeside, boolean requireSolidAdjacent, RandomSource random, StructurePiece.BlockSelector randomizer) {
+
+        // Try placing blocks in the box repeatedly
+        boolean changesAtAll = false;
+        int maxCycles = 100;
+        while (maxCycles-->0) {
+            boolean changesThisCycle = false;
+            for (int i = minY; i <= maxY; ++i) {
+                for (int j = minX; j <= maxX; ++j) {
+                    for (int k = minZ; k <= maxZ; ++k) {
+                        if ((!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid())) {
+                            randomizer.next(random, j, i, k, i == minY || i == maxY || j == minX || j == maxX || k == minZ || k == maxZ);
+                            changesThisCycle |= this.placeBlockConditionally(world, randomizer.getNext(), j, i, k, box, cantReplaceAir, cantReplaceLiquid, requireSolidBelow, requireSolidBelowOrBeside, requireSolidAdjacent);
+                        }
+                    }
+                }
+            }
+            changesAtAll |= changesThisCycle;
+            if (!changesThisCycle) {
+                break;
+            }
+        }
+        return changesAtAll;
+    }
+
+    /**
+     * @param cantReplaceAir If true, some block will not be placed if the existing block is air.
+     * @param cantReplaceLiquid If true, some block will not be placed if the existing block is liquid.
+     * @param requireSolidBelow If true, the box as a whole will not be generated if there is no existing block below any block in this box that is air or liquid.
+     * @param requireSolidBelowOrBeside If true, the box as a whole will not be generated if among the existing blocks either below or horizontally besides any block in this box, none are something other than air or liquid.
+     * @param requireSolidAdjacent If true, the box is a whole will not be generated if among the existing blocks adjacent to any block in this box in any of the 6 orthogonal directions, none are something other than air or liquid.
+     */
+    protected boolean generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean cantReplaceLiquid, boolean requireSolidBelow, boolean requireSolidBelowOrBeside, boolean requireSolidAdjacent) {
+
+        // Try placing blocks in the box repeatedly
+        boolean changesAtAll = false;
+        int maxCycles = 100;
+        while (maxCycles-->0) {
+            boolean changesThisCycle = false;
+            for (int i = minY; i <= maxY; ++i) {
+                for (int j = minX; j <= maxX; ++j) {
+                    for (int k = minZ; k <= maxZ; ++k) {
+                        if ((!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid())) {
+                            if (i != minY && i != maxY && j != minX && j != maxX && k != minZ && k != maxZ) {
+                                changesThisCycle |= this.placeBlockConditionally(world, inside, j, i, k, box, cantReplaceAir, cantReplaceLiquid, requireSolidBelow, requireSolidBelowOrBeside, requireSolidAdjacent); // Suki - custom strongholds - surface strongholds
+                            } else {
+                                changesThisCycle |= this.placeBlockConditionally(world, outline, j, i, k, box, cantReplaceAir, cantReplaceLiquid, requireSolidBelow, requireSolidBelowOrBeside, requireSolidAdjacent); // Suki - custom strongholds - surface strongholds
+                            }
+                        }
+                    }
+                }
+            }
+            changesAtAll |= changesThisCycle;
+            if (!changesThisCycle) {
+                break;
+            }
+        }
+        return changesAtAll;
+//
+//        // Check for missing support from surroundings
+//        if (requireSolidBelow || requireSolidBelowOrBeside || requireSolidAdjacent) {
+//            BlockPos[] poss = new BlockPos[(maxY - minY + 1) * (maxX - minX + 1) * (maxZ - minZ + 1)];
+//            int possIndex = 0;
+//            for(int i = minY; i <= maxY; ++i) {
+//                for (int j = minX; j <= maxX; ++j) {
+//                    for (int k = minZ; k <= maxZ; ++k) {
+//                        poss[possIndex] = this.getWorldPos(j, i, k);
+//                        possIndex++;
+//                    }
+//                }
+//            }
+//            if (!anyHasRelativeSolid(world, poss, Direction.DOWN)) {
+//                if (requireSolidBelow) {
+//                    return;
+//                }
+//                if (!anyHasAnyRelativeSolid(world, poss, besideDirections)) {
+//                    if (requireSolidBelowOrBeside) {
+//                        return;
+//                    }
+//                    if (!anyHasRelativeSolid(world, poss, Direction.UP)) {
+//                        return;
+//                    }
+//                }
+//            }
+//        }
+//
+//        // We can generate the box
+//        this.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceLiquid);
+
+    }
+
     protected void placeBlock(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box) {
+        this.placeBlockUnconditionally(world, block, x, y, z, box);
+    }
+    // Suki start - custom strongholds - surface strongholds
+    protected boolean placeBlockUnconditionally(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box) {
         BlockPos blockPos = this.getWorldPos(x, y, z);
         if (box.isInside(blockPos)) {
             if (this.canBeReplaced(world, x, y, z, box)) {
-                if (this.mirror != Mirror.NONE) {
-                    block = block.mirror(this.mirror);
-                }
+                return this.placeBlockUnconditionallyWorldCoordinates(world, block, blockPos, box);
+            }
+        }
+        return false;
+    }
+    protected boolean placeBlockUnconditionallyWorldCoordinates(WorldGenLevel world, BlockState block, BlockPos blockPos, BoundingBox box) {
+        // Suki end - custom strongholds - conditional placements
+        if (box.isInside(blockPos)) {
+            if (this.mirror != Mirror.NONE) {
+                block = block.mirror(this.mirror);
+            }
 
-                if (this.rotation != Rotation.NONE) {
-                    block = block.rotate(this.rotation);
-                }
+            if (this.rotation != Rotation.NONE) {
+                block = block.rotate(this.rotation);
+            }
 
-                world.setBlock(blockPos, block, 2);
-                FluidState fluidState = world.getFluidState(blockPos);
-                if (!fluidState.isEmpty()) {
-                    world.scheduleTick(blockPos, fluidState.getType(), 0);
-                }
+            if (world.getBlockState(blockPos).equals(block)) {
+                return false;
+            }
 
-                if (SHAPE_CHECK_BLOCKS.contains(block.getBlock())) {
-                    world.getChunk(blockPos).markPosForPostprocessing(blockPos);
-                }
+            world.setBlock(blockPos, block, 2);
+            FluidState fluidState = world.getFluidState(blockPos);
+            if (!fluidState.isEmpty()) {
+                world.scheduleTick(blockPos, fluidState.getType(), 0);
+            }
 
+            if (SHAPE_CHECK_BLOCKS.contains(block.getBlock())) {
+                world.getChunk(blockPos).markPosForPostprocessing(blockPos);
             }
+            return true;
         }
+        return false;
     }
+    // Suki end - custom strongholds - surface strongholds
 
     protected boolean canBeReplaced(LevelReader world, int x, int y, int z, BoundingBox box) {
         return true;
@@ -222,6 +497,22 @@ public abstract class StructurePiece {
         }
     }
 
+    // Suki start - custom strongholds - surface strongholds
+
+    protected void generateAirBox(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceLiquid) {
+        for(int i = minY; i <= maxY; ++i) {
+            for(int j = minX; j <= maxX; ++j) {
+                for(int k = minZ; k <= maxZ; ++k) {
+                    if (!cantReplaceLiquid || !this.getBlock(world, j, i, k, bounds).getMaterial().isLiquid()) {
+                        this.placeBlock(world, Blocks.AIR.defaultBlockState(), j, i, k, bounds);
+                    }
+                }
+            }
+        }
+    }
+
+    // Suki end - custom strongholds - surface strongholds
+
     protected void generateAirBox(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {
         for(int i = minY; i <= maxY; ++i) {
             for(int j = minX; j <= maxX; ++j) {
@@ -233,15 +524,35 @@ public abstract class StructurePiece {
 
     }
 
+    // Suki start - custom strongholds - surface strongholds
+
+    protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean cantReplaceLiquid) {
+        for(int i = minY; i <= maxY; ++i) {
+            for(int j = minX; j <= maxX; ++j) {
+                for(int k = minZ; k <= maxZ; ++k) {
+                    if ((!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid())) {
+                        if (i != minY && i != maxY && j != minX && j != maxX && k != minZ && k != maxZ) {
+                            this.placeBlockUnconditionally(world, inside, j, i, k, box); // Suki - custom strongholds - surface strongholds
+                        } else {
+                            this.placeBlockUnconditionally(world, outline, j, i, k, box); // Suki - custom strongholds - surface strongholds
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // Suki end - custom strongholds - surface strongholds
+
     protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir) {
         for(int i = minY; i <= maxY; ++i) {
             for(int j = minX; j <= maxX; ++j) {
                 for(int k = minZ; k <= maxZ; ++k) {
                     if (!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) {
                         if (i != minY && i != maxY && j != minX && j != maxX && k != minZ && k != maxZ) {
-                            this.placeBlock(world, inside, j, i, k, box);
+                            this.placeBlockUnconditionally(world, inside, j, i, k, box); // Suki - custom strongholds - surface strongholds
                         } else {
-                            this.placeBlock(world, outline, j, i, k, box);
+                            this.placeBlockUnconditionally(world, outline, j, i, k, box); // Suki - custom strongholds - surface strongholds
                         }
                     }
                 }
@@ -250,10 +561,35 @@ public abstract class StructurePiece {
 
     }
 
+    // Suki start - custom strongholds - surface strongholds
+
+    protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean cantReplaceLiquid) {
+        this.generateBox(world, box, fillBox.minX(), fillBox.minY(), fillBox.minZ(), fillBox.maxX(), fillBox.maxY(), fillBox.maxZ(), outline, inside, cantReplaceAir, cantReplaceLiquid);
+    }
+
+    // Suki end - custom strongholds - surface strongholds
+
     protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, BlockState outline, BlockState inside, boolean cantReplaceAir) {
         this.generateBox(world, box, fillBox.minX(), fillBox.minY(), fillBox.minZ(), fillBox.maxX(), fillBox.maxY(), fillBox.maxZ(), outline, inside, cantReplaceAir);
     }
 
+    // Suki start - custom strongholds - surface strongholds
+
+    protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        for(int i = minY; i <= maxY; ++i) {
+            for(int j = minX; j <= maxX; ++j) {
+                for(int k = minZ; k <= maxZ; ++k) {
+                    if ((!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid())) {
+                        randomizer.next(random, j, i, k, i == minY || i == maxY || j == minX || j == maxX || k == minZ || k == maxZ);
+                        this.placeBlock(world, randomizer.getNext(), j, i, k, box);
+                    }
+                }
+            }
+        }
+    }
+
+    // Suki end - custom strongholds - surface strongholds
+
     protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
         for(int i = minY; i <= maxY; ++i) {
             for(int j = minX; j <= maxX; ++j) {
@@ -268,10 +604,105 @@ public abstract class StructurePiece {
 
     }
 
+    // Suki start - custom strongholds - surface strongholds
+
+    protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        this.generateBox(world, box, fillBox.minX(), fillBox.minY(), fillBox.minZ(), fillBox.maxX(), fillBox.maxY(), fillBox.maxZ(), cantReplaceAir, cantReplaceLiquid, random, randomizer);
+    }
+
+    // Suki end - custom strongholds - surface strongholds
+
     protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
         this.generateBox(world, box, fillBox.minX(), fillBox.minY(), fillBox.minZ(), fillBox.maxX(), fillBox.maxY(), fillBox.maxZ(), cantReplaceAir, random, randomizer);
     }
 
+    // Suki start - custom strongholds - surface strongholds
+
+    // Suki start - custom strongholds - holes in stronghold parts
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+        var sukiConfig = world.getLevel().sukiConfig().customStrongholds;
+        for(int i = minY; i <= maxY; ++i) {
+            for(int j = minX; j <= maxX; ++j) {
+                for(int k = minZ; k <= maxZ; ++k) {
+                    if ((!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid())) {
+                        randomizer.next(random, j, i, k, i == minY || i == maxY || j == minX || j == maxX || k == minZ || k == maxZ);
+                        BlockState newState = randomizer.getNext();
+                        // If the block is on the floor or ceiling, there is a chance we use a bottom or top slab or stairs
+                        if ((i == minY || i == maxY) && !(j == minX || j == maxX || k == minZ || k == maxZ) && newState.is(BlockTags.STONE_BRICKS)) {
+                            var config = sukiConfig.slabOrStairsSurfaces;
+                            var surfaceConfig = i == minY ? config.floor : config.ceiling;
+                            if (random.nextFloat() < surfaceConfig.chance) {
+                                if (random.nextFloat() < surfaceConfig.slabRatio) {
+                                    newState = Blocks.STONE_BRICK_SLAB.defaultBlockState().setValue(BlockStateProperties.SLAB_TYPE, i == minY ? SlabType.BOTTOM : SlabType.TOP);
+                                } else {
+                                    newState = Blocks.STONE_BRICK_STAIRS.defaultBlockState().setValue(BlockStateProperties.STAIRS_SHAPE, StairsShape.values()[random.nextInt(StairsShape.values().length)]).setValue(BlockStateProperties.HALF, i == minY ? Half.BOTTOM : Half.TOP);
+                                }
+                            }
+                        }
+                        // If the block on top is actually air, there is a chance we use air
+                        if (world.getBlockState(this.getWorldPos(j, i + 1, k)).isAir() && random.nextFloat() < sukiConfig.ceilingBlockHoleChance) {
+                            newState = newAir;
+                        }
+                        // If the block on top is actually water, there is a chance we use water
+                        if (world.getBlockState(this.getWorldPos(j, i + 1, k)).getMaterial().isLiquid() && random.nextFloat() < sukiConfig.ceilingBlockHoleChance) {
+                            newState = Blocks.WATER.defaultBlockState();
+                        }
+                        this.placeBlockUnconditionally(world, newState, j, i, k, box);
+                    }
+                }
+            }
+        }
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+        generateBoxWithPartiallyOpenCeiling(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, false, random, randomizer, newAir);
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox.minX(), fillBox.minY(), fillBox.minZ(), fillBox.maxX(), fillBox.maxY(), fillBox.maxZ(), cantReplaceAir, cantReplaceLiquid, random, randomizer, newAir);
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox, cantReplaceAir, false, random, randomizer, newAir);
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, cantReplaceLiquid, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, boolean cantReplaceLiquid, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox, cantReplaceAir, cantReplaceLiquid, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+    }
+
+    protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+        this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox, cantReplaceAir, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+    }
+
+    // Suki end - custom strongholds - holes in stronghold parts
+
+    protected void generateMaybeBox(WorldGenLevel world, BoundingBox box, RandomSource random, float blockChance, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean cantReplaceLiquid, boolean stayBelowSeaLevel) {
+        for(int i = minY; i <= maxY; ++i) {
+            for(int j = minX; j <= maxX; ++j) {
+                for(int k = minZ; k <= maxZ; ++k) {
+                    if (!(random.nextFloat() > blockChance) && (!cantReplaceAir || !this.getBlock(world, j, i, k, box).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, j, i, k, box).getMaterial().isLiquid()) && (!stayBelowSeaLevel || this.isInterior(world, j, i, k, box))) {
+                        if (i != minY && i != maxY && j != minX && j != maxX && k != minZ && k != maxZ) {
+                            this.placeBlock(world, inside, j, i, k, box);
+                        } else {
+                            this.placeBlock(world, outline, j, i, k, box);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // Suki end - custom strongholds - surface strongholds
+
     protected void generateMaybeBox(WorldGenLevel world, BoundingBox box, RandomSource random, float blockChance, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean stayBelowSeaLevel) {
         for(int i = minY; i <= maxY; ++i) {
             for(int j = minX; j <= maxX; ++j) {
@@ -296,7 +727,9 @@ public abstract class StructurePiece {
 
     }
 
-    protected void generateUpperHalfSphere(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState block, boolean cantReplaceAir) {
+    // Suki start - custom strongholds - surface strongholds
+
+    protected void generateUpperHalfSphere(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState block, boolean cantReplaceAir, boolean cantReplaceLiquid) {
         float f = (float)(maxX - minX + 1);
         float g = (float)(maxY - minY + 1);
         float h = (float)(maxZ - minZ + 1);
@@ -311,7 +744,7 @@ public abstract class StructurePiece {
 
                 for(int o = minZ; o <= maxZ; ++o) {
                     float p = ((float)o - j) / (h * 0.5F);
-                    if (!cantReplaceAir || !this.getBlock(world, m, k, o, bounds).isAir()) {
+                    if ((!cantReplaceAir || !this.getBlock(world, m, k, o, bounds).isAir()) && (!cantReplaceLiquid || !this.getBlock(world, m, k, o, bounds).getMaterial().isLiquid())) {
                         float q = n * n + l * l + p * p;
                         if (q <= 1.05F) {
                             this.placeBlock(world, block, m, k, o, bounds);
@@ -323,6 +756,12 @@ public abstract class StructurePiece {
 
     }
 
+    protected void generateUpperHalfSphere(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState block, boolean cantReplaceAir) {
+        generateUpperHalfSphere(world, bounds, minX, minY, minZ, maxX, maxY, maxZ, block, cantReplaceAir, false);
+    }
+
+    // Suki end - custom strongholds - surface strongholds
+
     protected void fillColumnDown(WorldGenLevel world, BlockState state, int x, int y, int z, BoundingBox box) {
         BlockPos.MutableBlockPos mutableBlockPos = this.getWorldPos(x, y, z);
         if (box.isInside(mutableBlockPos)) {
@@ -342,6 +781,14 @@ public abstract class StructurePiece {
         return this.createChest(world, boundingBox, random, this.getWorldPos(x, y, z), lootTableId, (BlockState)null);
     }
 
+    // Suki start - custom strongholds - surface strongholds
+
+    protected boolean createChest(WorldGenLevel world, BoundingBox boundingBox, RandomSource random, int x, int y, int z, ResourceLocation lootTableId, boolean requireSolidBelow) {
+        return this.createChest(world, boundingBox, random, this.getWorldPos(x, y, z), lootTableId, (BlockState)null, requireSolidBelow);
+    }
+
+    // Suki end - custom strongholds - surface strongholds
+
     public static BlockState reorient(BlockGetter world, BlockPos pos, BlockState state) {
         Direction direction = null;
 
@@ -387,7 +834,13 @@ public abstract class StructurePiece {
     }
 
     protected boolean createChest(ServerLevelAccessor world, BoundingBox boundingBox, RandomSource random, BlockPos pos, ResourceLocation lootTableId, @Nullable BlockState block) {
-        if (boundingBox.isInside(pos) && !world.getBlockState(pos).is(Blocks.CHEST)) {
+        // Suki start - custom strongholds - surface strongholds
+        return this.createChest(world, boundingBox, random, pos, lootTableId, block, false);
+    }
+
+    protected boolean createChest(ServerLevelAccessor world, BoundingBox boundingBox, RandomSource random, BlockPos pos, ResourceLocation lootTableId, @Nullable BlockState block, boolean requireSolidBelow) {
+        if (boundingBox.isInside(pos) && !world.getBlockState(pos).is(Blocks.CHEST) && (!requireSolidBelow || hasRelativeSolid(world, pos, Direction.DOWN))) {
+            // Suki end - custom strongholds - surface strongholds
             if (block == null) {
                 block = reorient(world, pos, Blocks.CHEST.defaultBlockState());
             }
@@ -423,6 +876,65 @@ public abstract class StructurePiece {
         this.boundingBox.move(x, y, z);
     }
 
+    // Suki start - custom strongholds - surface strongholds
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock) {
+        this.replace(world, boundingBox, oldBlock, newBlock, null);
+    }
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock, @Nullable Predicate<Triple<Integer, Integer, Integer>> positionPredicate) {
+        this.replace(world, boundingBox, oldBlock, newBlock, null, 1, positionPredicate);
+    }
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock, @Nullable RandomSource random, double chance) {
+        this.replace(world, boundingBox, oldBlock, newBlock, random, chance, null);
+    }
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock, @Nullable RandomSource random, double chance, @Nullable Predicate<Triple<Integer, Integer, Integer>> positionPredicate) {
+        this.replace(world, boundingBox, oldBlock, newBlock, random, chance, false, false, false, positionPredicate);
+    }
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock, @Nullable RandomSource random, double chance, boolean requireSolidBelow, boolean requireSolidBelowOrBeside, boolean requireSolidAdjacent) {
+        this.replace(world, boundingBox, oldBlock, newBlock, random, chance, requireSolidBelow, requireSolidBelowOrBeside, requireSolidAdjacent, null);
+    }
+
+    public void replace(WorldGenLevel world, BoundingBox boundingBox, Block oldBlock, BlockState newBlock, @Nullable RandomSource random, double chance, boolean requireSolidBelow, boolean requireSolidBelowOrBeside, boolean requireSolidAdjacent, @Nullable Predicate<Triple<Integer, Integer, Integer>> positionPredicate) {
+        for (int x = boundingBox.minX(); x <= boundingBox.maxX(); x++) {
+            for (int y = boundingBox.minY(); y <= boundingBox.maxY(); y++) {
+                for (int z = boundingBox.minZ(); z <= boundingBox.maxZ(); z++) {
+                    if (positionPredicate != null && !positionPredicate.test(new ImmutableTriple<>(x, y, z))) {
+                        continue;
+                    }
+                    BlockPos pos = new BlockPos(x, y, z);
+                    if (world.getBlockState(pos).is(oldBlock)) {
+                        if (random == null || (double) random.nextFloat() < chance) {
+                            boolean hasSupport = true;
+                            // Check for missing support from surroundings
+                            if (requireSolidBelow || requireSolidBelowOrBeside || requireSolidAdjacent) {
+                                if (!hasRelativeSolid(world, pos, Direction.DOWN)) {
+                                    if (requireSolidBelow) {
+                                        hasSupport = false;
+                                    } else if (!hasAnyRelativeSolid(world, pos, besideDirections)) {
+                                        if (requireSolidBelowOrBeside) {
+                                            hasSupport = false;
+                                        } else if (!hasRelativeSolid(world, pos, Direction.UP)) {
+                                            hasSupport = false;
+                                        }
+                                    }
+                                }
+                            }
+                            if (hasSupport) {
+                                this.placeBlockUnconditionallyWorldCoordinates(world, newBlock, pos, boundingBox);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    // Suki end - custom strongholds - surface strongholds
+
     public static BoundingBox createBoundingBox(Stream<StructurePiece> pieces) {
         return BoundingBox.encapsulatingBoxes(pieces.map(StructurePiece::getBoundingBox)::iterator).orElseThrow(() -> {
             return new IllegalStateException("Unable to calculate boundingbox without pieces");
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java
index 0a17765680e28961ac7bf5cb04cf52d8dba86eb0..dd038573e4131caaadb6537b498f3760252f0e89 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdPieces.java
@@ -1,18 +1,26 @@
 package net.minecraft.world.level.levelgen.structure.structures;
 
 import com.google.common.collect.Lists;
+
+import java.util.ArrayList;
 import java.util.List;
-import javax.annotation.Nullable;
+import java.util.Optional;
+
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.tags.BlockTags;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.ServerLevelAccessor;
 import net.minecraft.world.level.StructureManager;
 import net.minecraft.world.level.WorldGenLevel;
+import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.block.ButtonBlock;
+import net.minecraft.world.level.block.CandleBlock;
 import net.minecraft.world.level.block.DoorBlock;
 import net.minecraft.world.level.block.EndPortalFrameBlock;
 import net.minecraft.world.level.block.FenceBlock;
@@ -24,6 +32,7 @@ import net.minecraft.world.level.block.WallTorchBlock;
 import net.minecraft.world.level.block.entity.BlockEntity;
 import net.minecraft.world.level.block.entity.SpawnerBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.block.state.properties.BlockStateProperties;
 import net.minecraft.world.level.block.state.properties.DoubleBlockHalf;
 import net.minecraft.world.level.block.state.properties.SlabType;
 import net.minecraft.world.level.chunk.ChunkGenerator;
@@ -32,30 +41,56 @@ import net.minecraft.world.level.levelgen.structure.StructurePiece;
 import net.minecraft.world.level.levelgen.structure.StructurePieceAccessor;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceSerializationContext;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePieceType;
+import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.level.storage.loot.BuiltInLootTables;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 public class StrongholdPieces {
     private static final int SMALL_DOOR_WIDTH = 3;
     private static final int SMALL_DOOR_HEIGHT = 3;
-    private static final int MAX_DEPTH = 50;
+    // Suki - custom strongholds - strongholds can reach lower
+    private static final int MAX_DEPTH = 60;
+    private static final int MAX_DEPTH_SURFACE = 100;
+    // Suki - custom strongholds - strongholds can reach lower
     private static final int LOWEST_Y_POSITION = 10;
     private static final boolean CHECK_AIR = true;
     public static final int MAGIC_START_Y = 64;
-    private static final StrongholdPieces.PieceWeight[] STRONGHOLD_PIECE_WEIGHTS = new StrongholdPieces.PieceWeight[]{new StrongholdPieces.PieceWeight(StrongholdPieces.Straight.class, 40, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.PrisonHall.class, 5, 5), new StrongholdPieces.PieceWeight(StrongholdPieces.LeftTurn.class, 20, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.RightTurn.class, 20, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.RoomCrossing.class, 10, 6), new StrongholdPieces.PieceWeight(StrongholdPieces.StraightStairsDown.class, 5, 5), new StrongholdPieces.PieceWeight(StrongholdPieces.StairsDown.class, 5, 5), new StrongholdPieces.PieceWeight(StrongholdPieces.FiveCrossing.class, 5, 4), new StrongholdPieces.PieceWeight(StrongholdPieces.ChestCorridor.class, 5, 4), new StrongholdPieces.PieceWeight(StrongholdPieces.Library.class, 10, 2) {
+    // Suki start - custom strongholds - bigger strongholds
+    public static final int MAX_CHAIN_LENGTH = 50; // Default is 50
+    public static final int MAX_PLANAR_DISTANCE = 112; // Default is 112
+    public static final int MINIMUM_LIBRARY_CHAIN_LENGTH = 5; // Default is 4
+    public static final int MINIMUM_PORTAL_ROOM_CHAIN_LENGTH = 6; // Default is 5
+    public static final int MAX_LIBRARY_AMOUNT = 2; // Default is 2
+    // Suki start - custom strongholds - surface strongholds
+    public static final int MAX_CHAIN_LENGTH_SURFACE = 115;
+    public static final int MAX_PLANAR_DISTANCE_SURFACE = 112;
+    public static final int MINIMUM_LIBRARY_CHAIN_LENGTH_SURFACE = 8;
+    public static final int MINIMUM_PORTAL_ROOM_CHAIN_LENGTH_SURFACE = 14;
+    public static final int MAX_LIBRARY_AMOUNT_SURFACE = 3;
+    public static final double DEFAULT_MAX_PLACE_COUNT_SURFACE_FACTOR = 2.5; // 1.0 would mean: no difference between surface and non-surface
+    // Suki end - custom strongholds - surface strongholds
+    // Suki end - custom strongholds - bigger strongholds
+    private static final StrongholdPieces.PieceWeight[] STRONGHOLD_PIECE_WEIGHTS = new StrongholdPieces.PieceWeight[]{new StrongholdPieces.PieceWeight(StrongholdPieces.Straight.class, 40, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.PrisonHall.class, 5, 5), new StrongholdPieces.PieceWeight(StrongholdPieces.LeftTurn.class, 20, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.RightTurn.class, 20, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.RoomCrossing.class, 10, 10, 6, 20), new StrongholdPieces.PieceWeight(StrongholdPieces.StraightStairsDown.class, 5, 10, 5, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.StairsDown.class, 5, 8, 5, 0), new StrongholdPieces.PieceWeight(StrongholdPieces.FiveCrossing.class, 5, 4), new StrongholdPieces.PieceWeight(StrongholdPieces.ChestCorridor.class, 5, 5, 4, 6), new StrongholdPieces.PieceWeight(StrongholdPieces.Library.class, 10, 10, MAX_LIBRARY_AMOUNT, MAX_LIBRARY_AMOUNT_SURFACE) { // Suki - custom strongholds - bigger strongholds, surface strongholds
         @Override
-        public boolean doPlace(int chainLength) {
-            return super.doPlace(chainLength) && chainLength > 4;
+        // Suki start - custom strongholds - surface strongholds, bigger strongholds
+        public boolean doPlace(int chainLength, boolean isSurface) {
+            return super.doPlace(chainLength, isSurface) && chainLength > (isSurface ? MINIMUM_LIBRARY_CHAIN_LENGTH_SURFACE : MINIMUM_LIBRARY_CHAIN_LENGTH);
+            // Suki end - custom strongholds - surface strongholds, bigger strongholds
         }
-    }, new StrongholdPieces.PieceWeight(StrongholdPieces.PortalRoom.class, 20, 1) {
+    }, new StrongholdPieces.PieceWeight(StrongholdPieces.PortalRoom.class, 20, 20, 1, 1) {
         @Override
-        public boolean doPlace(int chainLength) {
-            return super.doPlace(chainLength) && chainLength > 5;
+        // Suki start - custom strongholds - surface strongholds, bigger strongholds
+        public boolean doPlace(int chainLength, boolean isSurface) {
+            return super.doPlace(chainLength, isSurface) && chainLength > (isSurface ? MINIMUM_PORTAL_ROOM_CHAIN_LENGTH_SURFACE : MINIMUM_PORTAL_ROOM_CHAIN_LENGTH);
+            // Suki end - custom strongholds - surface strongholds, bigger strongholds
         }
     }};
     private static List<StrongholdPieces.PieceWeight> currentPieces;
     static Class<? extends StrongholdPieces.StrongholdPiece> imposedPiece;
     private static int totalWeight;
     static final StrongholdPieces.SmoothStoneSelector SMOOTH_STONE_SELECTOR = new StrongholdPieces.SmoothStoneSelector();
+    static final StrongholdPieces.SmoothStoneSelectorOrTemporary SMOOTH_STONE_SELECTOR_OR_TEMPORARY = new StrongholdPieces.SmoothStoneSelectorOrTemporary(); // Suki - custom strongholds - surface strongholds
 
     public static void resetPieces() {
         currentPieces = Lists.newArrayList();
@@ -68,56 +103,60 @@ public class StrongholdPieces {
         imposedPiece = null;
     }
 
-    private static boolean updatePieceWeight() {
+    private static boolean updatePieceWeight(boolean isSurface) { // Suki - custom strongholds - bigger strongholds, surface strongholds
         boolean bl = false;
         totalWeight = 0;
 
         for(StrongholdPieces.PieceWeight pieceWeight : currentPieces) {
-            if (pieceWeight.maxPlaceCount > 0 && pieceWeight.placeCount < pieceWeight.maxPlaceCount) {
+            if (pieceWeight.getEffectiveMaxPlaceCount(isSurface) > 0 && pieceWeight.placeCount < pieceWeight.getEffectiveMaxPlaceCount(isSurface)) { // Suki - custom strongholds - bigger strongholds, surface strongholds
                 bl = true;
             }
 
-            totalWeight += pieceWeight.weight;
+            totalWeight += pieceWeight.getEffectiveWeight(isSurface); // Suki - custom strongholds - bigger strongholds, surface strongholds
         }
 
         return bl;
     }
 
-    private static StrongholdPieces.StrongholdPiece findAndCreatePieceFactory(Class<? extends StrongholdPieces.StrongholdPiece> pieceType, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, @Nullable Direction orientation, int chainLength) {
+    // Suki start - custom strongholds - surface strongholds
+    private static StrongholdPieces.StrongholdPiece findAndCreatePieceFactory(Class<? extends StrongholdPieces.StrongholdPiece> pieceType, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, @Nullable Direction orientation, int chainLength, boolean isSurface) {
         StrongholdPieces.StrongholdPiece strongholdPiece = null;
         if (pieceType == StrongholdPieces.Straight.class) {
-            strongholdPiece = StrongholdPieces.Straight.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.Straight.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.PrisonHall.class) {
-            strongholdPiece = StrongholdPieces.PrisonHall.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.PrisonHall.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.LeftTurn.class) {
-            strongholdPiece = StrongholdPieces.LeftTurn.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.LeftTurn.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.RightTurn.class) {
-            strongholdPiece = StrongholdPieces.RightTurn.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.RightTurn.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.RoomCrossing.class) {
-            strongholdPiece = StrongholdPieces.RoomCrossing.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.RoomCrossing.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.StraightStairsDown.class) {
-            strongholdPiece = StrongholdPieces.StraightStairsDown.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.StraightStairsDown.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.StairsDown.class) {
-            strongholdPiece = StrongholdPieces.StairsDown.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.StairsDown.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.FiveCrossing.class) {
-            strongholdPiece = StrongholdPieces.FiveCrossing.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.FiveCrossing.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.ChestCorridor.class) {
-            strongholdPiece = StrongholdPieces.ChestCorridor.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.ChestCorridor.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.Library.class) {
-            strongholdPiece = StrongholdPieces.Library.createPiece(holder, random, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.Library.createPiece(holder, random, x, y, z, orientation, chainLength, isSurface);
         } else if (pieceType == StrongholdPieces.PortalRoom.class) {
-            strongholdPiece = StrongholdPieces.PortalRoom.createPiece(holder, x, y, z, orientation, chainLength);
+            strongholdPiece = StrongholdPieces.PortalRoom.createPiece(holder, x, y, z, orientation, chainLength, isSurface);
         }
+        // Suki end - custom strongholds - surface strongholds
 
         return strongholdPiece;
     }
 
-    private static StrongholdPieces.StrongholdPiece generatePieceFromSmallDoor(StrongholdPieces.StartPiece start, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
-        if (!updatePieceWeight()) {
+    // Suki start - custom strongholds - surface strongholds
+    private static StrongholdPieces.StrongholdPiece generatePieceFromSmallDoor(StrongholdPieces.StartPiece start, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) {
+        if (!updatePieceWeight(isSurface)) { // Suki - custom strongholds - bigger strongholds
+            // Suki end - custom strongholds - surface strongholds
             return null;
         } else {
             if (imposedPiece != null) {
-                StrongholdPieces.StrongholdPiece strongholdPiece = findAndCreatePieceFactory(imposedPiece, holder, random, x, y, z, orientation, chainLength);
+                StrongholdPieces.StrongholdPiece strongholdPiece = findAndCreatePieceFactory(imposedPiece, holder, random, x, y, z, orientation, chainLength, isSurface); // Suki - custom strongholds - surface strongholds
                 imposedPiece = null;
                 if (strongholdPiece != null) {
                     return strongholdPiece;
@@ -131,17 +170,17 @@ public class StrongholdPieces {
                 int j = random.nextInt(totalWeight);
 
                 for(StrongholdPieces.PieceWeight pieceWeight : currentPieces) {
-                    j -= pieceWeight.weight;
+                    j -= pieceWeight.getEffectiveWeight(isSurface); // Suki - custom strongholds - bigger strongholds, surface strongholds
                     if (j < 0) {
-                        if (!pieceWeight.doPlace(chainLength) || pieceWeight == start.previousPiece) {
+                        if (!pieceWeight.doPlace(chainLength, isSurface) || pieceWeight == start.previousPiece) { // Suki - custom strongholds - surface strongholds, bigger strongholds
                             break;
                         }
 
-                        StrongholdPieces.StrongholdPiece strongholdPiece2 = findAndCreatePieceFactory(pieceWeight.pieceClass, holder, random, x, y, z, orientation, chainLength);
+                        StrongholdPieces.StrongholdPiece strongholdPiece2 = findAndCreatePieceFactory(pieceWeight.pieceClass, holder, random, x, y, z, orientation, chainLength, isSurface); // Suki - custom strongholds - surface strongholds
                         if (strongholdPiece2 != null) {
                             ++pieceWeight.placeCount;
                             start.previousPiece = pieceWeight;
-                            if (!pieceWeight.isValid()) {
+                            if (!pieceWeight.isValid(isSurface)) { // Suki - custom strongholds - surface strongholds, bigger strongholds
                                 currentPieces.remove(pieceWeight);
                             }
 
@@ -152,15 +191,15 @@ public class StrongholdPieces {
             }
 
             BoundingBox boundingBox = StrongholdPieces.FillerCorridor.findPieceBox(holder, random, x, y, z, orientation);
-            return boundingBox != null && boundingBox.minY() > 1 ? new StrongholdPieces.FillerCorridor(chainLength, boundingBox, orientation) : null;
+            return boundingBox != null && boundingBox.minY() > 1 ? new StrongholdPieces.FillerCorridor(chainLength, boundingBox, orientation, isSurface) : null; // Suki - custom strongholds - surface strongholds
         }
     }
 
-    static StructurePiece generateAndAddPiece(StrongholdPieces.StartPiece start, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, @Nullable Direction orientation, int chainLength) {
-        if (chainLength > 50) {
+    static StructurePiece generateAndAddPiece(StrongholdPieces.StartPiece start, StructurePieceAccessor holder, RandomSource random, int x, int y, int z, @Nullable Direction orientation, int chainLength, boolean isSurface) { // Suki - custom strongholds - surface strongholds
+        if (chainLength > (isSurface ? MAX_CHAIN_LENGTH_SURFACE : MAX_CHAIN_LENGTH)) { // Suki - custom strongholds - bigger strongholds
             return null;
-        } else if (Math.abs(x - start.getBoundingBox().minX()) <= 112 && Math.abs(z - start.getBoundingBox().minZ()) <= 112) {
-            StructurePiece structurePiece = generatePieceFromSmallDoor(start, holder, random, x, y, z, orientation, chainLength + 1);
+        } else if (Math.abs(x - start.getBoundingBox().minX()) <= (isSurface ? MAX_PLANAR_DISTANCE_SURFACE : MAX_PLANAR_DISTANCE) && Math.abs(z - start.getBoundingBox().minZ()) <= (isSurface ? MAX_PLANAR_DISTANCE_SURFACE : MAX_PLANAR_DISTANCE)) { // Suki - custom strongholds - bigger strongholds
+            StructurePiece structurePiece = generatePieceFromSmallDoor(start, holder, random, x, y, z, orientation, chainLength + 1, isSurface); // Suki - custom strongholds - surface strongholds
             if (structurePiece != null) {
                 holder.addPiece(structurePiece);
                 start.pendingChildren.add(structurePiece);
@@ -178,8 +217,10 @@ public class StrongholdPieces {
         private static final int DEPTH = 7;
         private boolean hasPlacedChest;
 
-        public ChestCorridor(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_CHEST_CORRIDOR, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public ChestCorridor(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_CHEST_CORRIDOR, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
         }
@@ -200,17 +241,20 @@ public class StrongholdPieces {
             this.generateSmallDoorChildForward((StrongholdPieces.StartPiece)start, holder, random, 1, 1);
         }
 
-        public static StrongholdPieces.ChestCorridor createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainlength) {
+        public static StrongholdPieces.ChestCorridor createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainlength, boolean isSurface) {// Suki - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -1, 0, 5, 5, 7, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.ChestCorridor(chainlength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.ChestCorridor(chainlength, random, boundingBox, orientation, isSurface) : null; // Suki - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 4, 6, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 4, 6, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Suki - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 1, 0);
             this.generateSmallDoor(world, random, chunkBox, StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING, 1, 1, 6);
-            this.generateBox(world, chunkBox, 3, 1, 2, 3, 1, 4, Blocks.STONE_BRICKS.defaultBlockState(), Blocks.STONE_BRICKS.defaultBlockState(), false);
+            this.generateBox(world, chunkBox, 3, 1, 2, 3, 1, 4, Blocks.STONE_BRICKS.defaultBlockState(), Blocks.STONE_BRICKS.defaultBlockState(), this.isSurface); // Suki - custom strongholds - surface strongholds
             this.placeBlock(world, Blocks.STONE_BRICK_SLAB.defaultBlockState(), 3, 1, 1, chunkBox);
             this.placeBlock(world, Blocks.STONE_BRICK_SLAB.defaultBlockState(), 3, 1, 5, chunkBox);
             this.placeBlock(world, Blocks.STONE_BRICK_SLAB.defaultBlockState(), 3, 2, 2, chunkBox);
@@ -231,8 +275,10 @@ public class StrongholdPieces {
     public static class FillerCorridor extends StrongholdPieces.StrongholdPiece {
         private final int steps;
 
-        public FillerCorridor(int chainLength, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_FILLER_CORRIDOR, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public FillerCorridor(int chainLength, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_FILLER_CORRIDOR, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.steps = orientation != Direction.NORTH && orientation != Direction.SOUTH ? boundingBox.getXSpan() : boundingBox.getZSpan();
         }
@@ -269,7 +315,10 @@ public class StrongholdPieces {
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
             for(int i = 0; i < this.steps; ++i) {
                 this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 0, 0, i, chunkBox);
                 this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 1, 0, i, chunkBox);
@@ -304,8 +353,10 @@ public class StrongholdPieces {
         private final boolean rightLow;
         private final boolean rightHigh;
 
-        public FiveCrossing(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_FIVE_CROSSING, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public FiveCrossing(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_FIVE_CROSSING, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
             this.leftLow = random.nextBoolean();
@@ -360,52 +411,59 @@ public class StrongholdPieces {
 
         }
 
-        public static StrongholdPieces.FiveCrossing createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.FiveCrossing createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Suki - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -4, -3, 0, 10, 9, 11, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.FiveCrossing(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.FiveCrossing(chainLength, random, boundingBox, orientation, isSurface) : null; // Suki - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 9, 8, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 9, 8, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY); // Suki - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 4, 3, 0);
             if (this.leftLow) {
-                this.generateBox(world, chunkBox, 0, 3, 1, 0, 5, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 0, 3, 1, 0, 5, 3, SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), this.isSurface); // Suki - custom strongholds - surface strongholds
             }
 
             if (this.rightLow) {
-                this.generateBox(world, chunkBox, 9, 3, 1, 9, 5, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 9, 3, 1, 9, 5, 3, SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), this.isSurface); // Suki - custom strongholds - surface strongholds
             }
 
             if (this.leftHigh) {
-                this.generateBox(world, chunkBox, 0, 5, 7, 0, 7, 9, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 0, 5, 7, 0, 7, 9, SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), this.isSurface); // Suki - custom strongholds - surface strongholds
             }
 
             if (this.rightHigh) {
-                this.generateBox(world, chunkBox, 9, 5, 7, 9, 7, 9, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 9, 5, 7, 9, 7, 9, SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), this.isSurface); // Suki - custom strongholds - surface strongholds
             }
 
-            this.generateBox(world, chunkBox, 5, 1, 10, 7, 3, 10, CAVE_AIR, CAVE_AIR, false);
-            this.generateBox(world, chunkBox, 1, 2, 1, 8, 2, 6, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 4, 1, 5, 4, 4, 9, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 8, 1, 5, 8, 4, 9, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 1, 4, 7, 3, 4, 9, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 1, 3, 5, 3, 3, 6, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 1, 3, 4, 3, 3, 4, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 1, 4, 6, 3, 4, 6, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 5, 1, 7, 7, 1, 8, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 5, 1, 9, 7, 1, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 5, 2, 7, 7, 2, 7, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 4, 5, 7, 4, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 8, 5, 7, 8, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), false);
-            this.generateBox(world, chunkBox, 5, 5, 7, 7, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.DOUBLE), Blocks.SMOOTH_STONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.DOUBLE), false);
+            // Martijn start- custom strongholds - surface strongholds
+            this.generateBox(world, chunkBox, 5, 1, 10, 7, 3, 10, SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), SmoothStoneSelectorOrTemporary.TEMPORARY.defaultBlockState(), this.isSurface);
+            this.generateBoxConditionally(world, chunkBox, 1, 2, 1, 8, 2, 6, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 4, 1, 5, 4, 4, 9, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 8, 1, 5, 8, 4, 9, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 1, 4, 7, 3, 4, 9, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 1, 3, 5, 3, 3, 6, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 1, 3, 4, 3, 3, 4, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 1, 4, 6, 3, 4, 6, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 5, 1, 7, 7, 1, 8, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxConditionally(world, chunkBox, 5, 1, 9, 7, 1, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 5, 2, 7, 7, 2, 7, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 4, 5, 7, 4, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 8, 5, 7, 8, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState(), Blocks.SMOOTH_STONE_SLAB.defaultBlockState());
+            this.generateBoxConditionally(world, chunkBox, 5, 5, 7, 7, 5, 9, Blocks.SMOOTH_STONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.DOUBLE), Blocks.SMOOTH_STONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.DOUBLE));
+            // Suki end - custom strongholds - surface strongholds
             this.placeBlock(world, Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.SOUTH), 6, 5, 6, chunkBox);
         }
     }
 
     public static class LeftTurn extends StrongholdPieces.Turn {
-        public LeftTurn(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_LEFT_TURN, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public LeftTurn(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_LEFT_TURN, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
         }
@@ -425,20 +483,23 @@ public class StrongholdPieces {
 
         }
 
-        public static StrongholdPieces.LeftTurn createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.LeftTurn createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Suki - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -1, 0, 5, 5, 5, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.LeftTurn(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.LeftTurn(chainLength, random, boundingBox, orientation, isSurface) : null; // Suki - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 4, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 4, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Suki - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 1, 0);
             Direction direction = this.getOrientation();
             if (direction != Direction.NORTH && direction != Direction.EAST) {
-                this.generateBox(world, chunkBox, 4, 1, 1, 4, 3, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 4, 1, 1, 4, 3, 3, CAVE_AIR, CAVE_AIR, this.isSurface); // Suki - custom strongholds - surface strongholds
             } else {
-                this.generateBox(world, chunkBox, 0, 1, 1, 0, 3, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 0, 1, 1, 0, 3, 3, CAVE_AIR, CAVE_AIR, this.isSurface); // Suki - custom strongholds - surface strongholds
             }
 
         }
@@ -451,8 +512,10 @@ public class StrongholdPieces {
         protected static final int DEPTH = 15;
         private final boolean isTall;
 
-        public Library(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_LIBRARY, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public Library(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_LIBRARY, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
             this.isTall = boundingBox.getYSpan() > 6;
@@ -469,7 +532,7 @@ public class StrongholdPieces {
             nbt.putBoolean("Tall", this.isTall);
         }
 
-        public static StrongholdPieces.Library createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.Library createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Suki - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -4, -1, 0, 14, 11, 15, orientation);
             if (!isOkBox(boundingBox) || holder.findCollisionPiece(boundingBox) != null) {
                 boundingBox = BoundingBox.orientBox(x, y, z, -4, -1, 0, 14, 6, 15, orientation);
@@ -478,62 +541,67 @@ public class StrongholdPieces {
                 }
             }
 
-            return new StrongholdPieces.Library(chainLength, random, boundingBox, orientation);
+            return new StrongholdPieces.Library(chainLength, random, boundingBox, orientation, isSurface); // Suki - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
             int i = 11;
             if (!this.isTall) {
                 i = 6;
             }
 
-            this.generateBox(world, chunkBox, 0, 0, 0, 13, i - 1, 14, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 13, i - 1, 14, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY); // Suki - custom strongholds - holes in stronghold parts, surface strongholds
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 4, 1, 0);
-            this.generateMaybeBox(world, chunkBox, random, 0.07F, 2, 1, 1, 11, 4, 13, Blocks.COBWEB.defaultBlockState(), Blocks.COBWEB.defaultBlockState(), false, false);
+            this.generateMaybeBox(world, chunkBox, random, 0.07F, 2, 1, 1, 11, 4, 13, Blocks.COBWEB.defaultBlockState(), Blocks.COBWEB.defaultBlockState(), this.isSurface, false); // Suki - custom strongholds - surface strongholds
             int j = 1;
             int k = 12;
 
             for(int l = 1; l <= 13; ++l) {
                 if ((l - 1) % 4 == 0) {
-                    this.generateBox(world, chunkBox, 1, 1, l, 1, 4, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                    this.generateBox(world, chunkBox, 12, 1, l, 12, 4, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
+                    // Suki start - custom strongholds - surface strongholds
+                    this.generateBox(world, chunkBox, 1, 1, l, 1, 4, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                    this.generateBox(world, chunkBox, 12, 1, l, 12, 4, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                    // Suki end - custom strongholds - surface strongholds
                     this.placeBlock(world, Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.EAST), 2, 3, l, chunkBox);
                     this.placeBlock(world, Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.WEST), 11, 3, l, chunkBox);
-                    if (this.isTall) {
-                        this.generateBox(world, chunkBox, 1, 6, l, 1, 9, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                        this.generateBox(world, chunkBox, 12, 6, l, 12, 9, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                    }
                 } else {
-                    this.generateBox(world, chunkBox, 1, 1, l, 1, 4, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                    this.generateBox(world, chunkBox, 12, 1, l, 12, 4, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                    if (this.isTall) {
-                        this.generateBox(world, chunkBox, 1, 6, l, 1, 9, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                        this.generateBox(world, chunkBox, 12, 6, l, 12, 9, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                    }
+                    // Suki start - custom strongholds - surface strongholds
+                    this.generateBoxConditionally(world, chunkBox, 1, 1, l, 1, 4, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                    this.generateBoxConditionally(world, chunkBox, 12, 1, l, 12, 4, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                    // Suki end - custom strongholds - surface strongholds
                 }
             }
 
             for(int m = 3; m < 12; m += 2) {
-                this.generateBox(world, chunkBox, 3, 1, m, 4, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                this.generateBox(world, chunkBox, 6, 1, m, 7, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
-                this.generateBox(world, chunkBox, 9, 1, m, 10, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false);
+                // Suki start - custom strongholds - surface strongholds
+                this.generateBoxConditionally(world, chunkBox, 3, 1, m, 4, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                this.generateBoxConditionally(world, chunkBox, 6, 1, m, 7, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                this.generateBoxConditionally(world, chunkBox, 9, 1, m, 10, 3, m, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                // Suki end - custom strongholds - surface strongholds
             }
 
             if (this.isTall) {
-                this.generateBox(world, chunkBox, 1, 5, 1, 3, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                this.generateBox(world, chunkBox, 10, 5, 1, 12, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                this.generateBox(world, chunkBox, 4, 5, 1, 9, 5, 2, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
-                this.generateBox(world, chunkBox, 4, 5, 12, 9, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), false);
+                // Suki start - custom strongholds - surface strongholds
+                this.generateBox(world, chunkBox, 1, 5, 1, 3, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                this.generateBox(world, chunkBox, 10, 5, 1, 12, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                this.generateBox(world, chunkBox, 4, 5, 1, 9, 5, 2, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                this.generateBox(world, chunkBox, 4, 5, 12, 9, 5, 13, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                // Suki end - custom strongholds - surface strongholds
                 this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 9, 5, 11, chunkBox);
                 this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 8, 5, 11, chunkBox);
                 this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 9, 5, 10, chunkBox);
                 BlockState blockState = Blocks.OAK_FENCE.defaultBlockState().setValue(FenceBlock.WEST, Boolean.valueOf(true)).setValue(FenceBlock.EAST, Boolean.valueOf(true));
                 BlockState blockState2 = Blocks.OAK_FENCE.defaultBlockState().setValue(FenceBlock.NORTH, Boolean.valueOf(true)).setValue(FenceBlock.SOUTH, Boolean.valueOf(true));
-                this.generateBox(world, chunkBox, 3, 6, 3, 3, 6, 11, blockState2, blockState2, false);
-                this.generateBox(world, chunkBox, 10, 6, 3, 10, 6, 9, blockState2, blockState2, false);
-                this.generateBox(world, chunkBox, 4, 6, 2, 9, 6, 2, blockState, blockState, false);
-                this.generateBox(world, chunkBox, 4, 6, 12, 7, 6, 12, blockState, blockState, false);
+                // Suki start - custom strongholds - surface strongholds
+                this.generateBox(world, chunkBox, 3, 6, 3, 3, 6, 11, blockState2, blockState2, this.isSurface);
+                this.generateBox(world, chunkBox, 10, 6, 3, 10, 6, 9, blockState2, blockState2, this.isSurface);
+                this.generateBox(world, chunkBox, 4, 6, 2, 9, 6, 2, blockState, blockState, this.isSurface);
+                this.generateBox(world, chunkBox, 4, 6, 12, 7, 6, 12, blockState, blockState, this.isSurface);
+                // Suki end - custom strongholds - surface strongholds
                 this.placeBlock(world, Blocks.OAK_FENCE.defaultBlockState().setValue(FenceBlock.NORTH, Boolean.valueOf(true)).setValue(FenceBlock.EAST, Boolean.valueOf(true)), 3, 6, 2, chunkBox);
                 this.placeBlock(world, Blocks.OAK_FENCE.defaultBlockState().setValue(FenceBlock.SOUTH, Boolean.valueOf(true)).setValue(FenceBlock.EAST, Boolean.valueOf(true)), 3, 6, 12, chunkBox);
                 this.placeBlock(world, Blocks.OAK_FENCE.defaultBlockState().setValue(FenceBlock.NORTH, Boolean.valueOf(true)).setValue(FenceBlock.WEST, Boolean.valueOf(true)), 10, 6, 2, chunkBox);
@@ -577,6 +645,18 @@ public class StrongholdPieces {
                 this.placeBlock(world, blockState7, 6, 8, 8, chunkBox);
                 this.placeBlock(world, blockState7, 7, 8, 6, chunkBox);
                 this.placeBlock(world, blockState7, 7, 8, 8, chunkBox);
+                // Suki start - custom strongholds - surface strongholds
+                for(int l = 1; l <= 13; ++l) {
+                    if ((l - 1) % 4 == 0) {
+                        this.generateBox(world, chunkBox, 1, 6, l, 1, 9, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                        this.generateBox(world, chunkBox, 12, 6, l, 12, 9, l, Blocks.OAK_PLANKS.defaultBlockState(), Blocks.OAK_PLANKS.defaultBlockState(), this.isSurface);
+                    } else {
+                        // Suki start - custom strongholds - surface strongholds
+                        this.generateBoxConditionally(world, chunkBox, 1, 6, l, 1, 9, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                        this.generateBoxConditionally(world, chunkBox, 12, 6, l, 12, 9, l, Blocks.BOOKSHELF.defaultBlockState(), Blocks.BOOKSHELF.defaultBlockState(), false, false, true, false, false);
+                    }
+                }
+                // Suki end - custom strongholds - surface strongholds
             }
 
             this.createChest(world, chunkBox, random, 3, 3, 5, BuiltInLootTables.STRONGHOLD_LIBRARY);
@@ -586,6 +666,16 @@ public class StrongholdPieces {
             }
 
         }
+
+        // Suki start - custom strongholds - more things
+
+        @Override
+        public boolean areAddedCandlesLit() {
+            return true;
+        }
+
+        // Suki end - custom strongholds - more things
+
     }
 
     static class PieceWeight {
@@ -593,19 +683,43 @@ public class StrongholdPieces {
         public final int weight;
         public int placeCount;
         public final int maxPlaceCount;
+        // Suki start - custom strongholds - surface strongholds, bigger strongholds
+        public final int weightSurface;
+        public final int maxPlaceCountSurface;
 
-        public PieceWeight(Class<? extends StrongholdPieces.StrongholdPiece> pieceType, int weight, int limit) {
+        public int getEffectiveWeight(boolean isSurface) {
+            return isSurface ? weightSurface : weight;
+        }
+
+        public int getEffectiveMaxPlaceCount(boolean isSurface) {
+            return isSurface ? maxPlaceCountSurface : maxPlaceCount;
+        }
+
+        public PieceWeight(Class<? extends StrongholdPieces.StrongholdPiece> pieceType, int weight, int weightSurface, int limit, int limitSurface) {
+            // Suki end - custom strongholds - surface strongholds, bigger strongholds
             this.pieceClass = pieceType;
             this.weight = weight;
             this.maxPlaceCount = limit;
+            // Suki start - custom strongholds - surface strongholds, bigger strongholds
+            this.weightSurface = weightSurface;
+            this.maxPlaceCountSurface = limitSurface;
+            // Suki end - custom strongholds - surface strongholds, bigger strongholds
         }
 
-        public boolean doPlace(int chainLength) {
-            return this.maxPlaceCount == 0 || this.placeCount < this.maxPlaceCount;
+        public PieceWeight(Class<? extends StrongholdPieces.StrongholdPiece> pieceType, int weight, int limit) {
+            this(pieceType, weight, weight, limit, limit == 0 ? 0 : (int) Math.ceil(limit * DEFAULT_MAX_PLACE_COUNT_SURFACE_FACTOR)); // Suki - custom strongholds - surface strongholds, bigger strongholds
+        }
+
+        // Suki start - custom strongholds - surface strongholds, bigger strongholds
+        public boolean doPlace(int chainLength, boolean isSurface) {
+            return this.getEffectiveMaxPlaceCount(isSurface) == 0 || this.placeCount < this.getEffectiveMaxPlaceCount(isSurface);
+            // Suki end - custom strongholds - surface strongholds, bigger strongholds
         }
 
-        public boolean isValid() {
-            return this.maxPlaceCount == 0 || this.placeCount < this.maxPlaceCount;
+        // Suki start - custom strongholds - surface strongholds, bigger strongholds
+        public boolean isValid(boolean isSurface) {
+            return this.getEffectiveMaxPlaceCount(isSurface) == 0 || this.placeCount < this.getEffectiveMaxPlaceCount(isSurface);
+            // Suki end - custom strongholds - surface strongholds, bigger strongholds
         }
     }
 
@@ -615,8 +729,10 @@ public class StrongholdPieces {
         protected static final int DEPTH = 16;
         private boolean hasPlacedSpawner;
 
-        public PortalRoom(int chainLength, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_PORTAL_ROOM, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public PortalRoom(int chainLength, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_PORTAL_ROOM, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
         }
 
@@ -639,14 +755,17 @@ public class StrongholdPieces {
 
         }
 
-        public static StrongholdPieces.PortalRoom createPiece(StructurePieceAccessor holder, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.PortalRoom createPiece(StructurePieceAccessor holder, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) {// Suki - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -4, -1, 0, 11, 8, 16, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.PortalRoom(chainLength, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.PortalRoom(chainLength, boundingBox, orientation, isSurface) : null; // Suki - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 10, 7, 15, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 10, 7, 15, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Suki - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, StrongholdPieces.StrongholdPiece.SmallDoorType.GRATES, 4, 1, 0);
             int i = 6;
             this.generateBox(world, chunkBox, 1, i, 1, 1, i, 14, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
@@ -694,30 +813,32 @@ public class StrongholdPieces {
                 bl &= bls[m];
             }
 
-            this.placeBlock(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[0])), 4, 3, 8, chunkBox);
-            this.placeBlock(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[1])), 5, 3, 8, chunkBox);
-            this.placeBlock(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[2])), 6, 3, 8, chunkBox);
-            this.placeBlock(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[3])), 4, 3, 12, chunkBox);
-            this.placeBlock(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[4])), 5, 3, 12, chunkBox);
-            this.placeBlock(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[5])), 6, 3, 12, chunkBox);
-            this.placeBlock(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[6])), 3, 3, 9, chunkBox);
-            this.placeBlock(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[7])), 3, 3, 10, chunkBox);
-            this.placeBlock(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[8])), 3, 3, 11, chunkBox);
-            this.placeBlock(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[9])), 7, 3, 9, chunkBox);
-            this.placeBlock(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[10])), 7, 3, 10, chunkBox);
-            this.placeBlock(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[11])), 7, 3, 11, chunkBox);
+            // Suki start - custom strongholds - conditional placements
+            this.placeBlockUnconditionally(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[0])), 4, 3, 8, chunkBox);
+            this.placeBlockUnconditionally(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[1])), 5, 3, 8, chunkBox);
+            this.placeBlockUnconditionally(world, blockState4.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[2])), 6, 3, 8, chunkBox);
+            this.placeBlockUnconditionally(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[3])), 4, 3, 12, chunkBox);
+            this.placeBlockUnconditionally(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[4])), 5, 3, 12, chunkBox);
+            this.placeBlockUnconditionally(world, blockState5.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[5])), 6, 3, 12, chunkBox);
+            this.placeBlockUnconditionally(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[6])), 3, 3, 9, chunkBox);
+            this.placeBlockUnconditionally(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[7])), 3, 3, 10, chunkBox);
+            this.placeBlockUnconditionally(world, blockState6.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[8])), 3, 3, 11, chunkBox);
+            this.placeBlockUnconditionally(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[9])), 7, 3, 9, chunkBox);
+            this.placeBlockUnconditionally(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[10])), 7, 3, 10, chunkBox);
+            this.placeBlockUnconditionally(world, blockState7.setValue(EndPortalFrameBlock.HAS_EYE, Boolean.valueOf(bls[11])), 7, 3, 11, chunkBox);
             if (bl) {
                 BlockState blockState8 = Blocks.END_PORTAL.defaultBlockState();
-                this.placeBlock(world, blockState8, 4, 3, 9, chunkBox);
-                this.placeBlock(world, blockState8, 5, 3, 9, chunkBox);
-                this.placeBlock(world, blockState8, 6, 3, 9, chunkBox);
-                this.placeBlock(world, blockState8, 4, 3, 10, chunkBox);
-                this.placeBlock(world, blockState8, 5, 3, 10, chunkBox);
-                this.placeBlock(world, blockState8, 6, 3, 10, chunkBox);
-                this.placeBlock(world, blockState8, 4, 3, 11, chunkBox);
-                this.placeBlock(world, blockState8, 5, 3, 11, chunkBox);
-                this.placeBlock(world, blockState8, 6, 3, 11, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 4, 3, 9, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 5, 3, 9, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 6, 3, 9, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 4, 3, 10, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 5, 3, 10, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 6, 3, 10, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 4, 3, 11, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 5, 3, 11, chunkBox);
+                this.placeBlockUnconditionally(world, blockState8, 6, 3, 11, chunkBox);
             }
+            // Suki end - custom strongholds - conditional placements
 
             if (!this.hasPlacedSpawner) {
                 BlockPos blockPos = this.getWorldPos(5, 3, 6);
@@ -732,6 +853,16 @@ public class StrongholdPieces {
             }
 
         }
+
+        // Suki start - custom strongholds - more things
+
+        @Override
+        public boolean areAddedCandlesLit() {
+            return true;
+        }
+
+        // Suki end - custom strongholds - more things
+
     }
 
     public static class PrisonHall extends StrongholdPieces.StrongholdPiece {
@@ -739,8 +870,10 @@ public class StrongholdPieces {
         protected static final int HEIGHT = 5;
         protected static final int DEPTH = 11;
 
-        public PrisonHall(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_PRISON_HALL, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public PrisonHall(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_PRISON_HALL, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
         }
@@ -754,20 +887,25 @@ public class StrongholdPieces {
             this.generateSmallDoorChildForward((StrongholdPieces.StartPiece)start, holder, random, 1, 1);
         }
 
-        public static StrongholdPieces.PrisonHall createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.PrisonHall createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) {// Suki - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -1, 0, 9, 5, 11, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.PrisonHall(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.PrisonHall(chainLength, random, boundingBox, orientation, isSurface) : null; // Suki - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 8, 4, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 8, 4, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY); // Suki - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 1, 0);
             this.generateBox(world, chunkBox, 1, 1, 10, 3, 3, 10, CAVE_AIR, CAVE_AIR, false);
-            this.generateBox(world, chunkBox, 4, 1, 1, 4, 3, 1, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 4, 1, 3, 4, 3, 3, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 4, 1, 7, 4, 3, 7, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
-            this.generateBox(world, chunkBox, 4, 1, 9, 4, 3, 9, false, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+            // Suki start - custom strongholds - surface strongholds
+            this.generateBoxConditionally(world, chunkBox, 4, 1, 1, 4, 3, 1, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY);
+            this.generateBoxConditionally(world, chunkBox, 4, 1, 3, 4, 3, 3, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY);
+            this.generateBoxConditionally(world, chunkBox, 4, 1, 7, 4, 3, 7, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY);
+            this.generateBoxConditionally(world, chunkBox, 4, 1, 9, 4, 3, 9, random, StrongholdPieces.SMOOTH_STONE_SELECTOR_OR_TEMPORARY);
+            // Suki end - custom strongholds - surface strongholds
 
             for(int i = 1; i <= 3; ++i) {
                 this.placeBlock(world, Blocks.IRON_BARS.defaultBlockState().setValue(IronBarsBlock.NORTH, Boolean.valueOf(true)).setValue(IronBarsBlock.SOUTH, Boolean.valueOf(true)), 4, i, 4, chunkBox);
@@ -790,8 +928,10 @@ public class StrongholdPieces {
     }
 
     public static class RightTurn extends StrongholdPieces.Turn {
-        public RightTurn(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_RIGHT_TURN, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public RightTurn(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_RIGHT_TURN, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
         }
@@ -811,20 +951,23 @@ public class StrongholdPieces {
 
         }
 
-        public static StrongholdPieces.RightTurn createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.RightTurn createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Suki - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -1, 0, 5, 5, 5, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.RightTurn(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.RightTurn(chainLength, random, boundingBox, orientation, isSurface) : null; // Suki - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 4, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 4, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Suki - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 1, 0);
             Direction direction = this.getOrientation();
             if (direction != Direction.NORTH && direction != Direction.EAST) {
-                this.generateBox(world, chunkBox, 0, 1, 1, 0, 3, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 0, 1, 1, 0, 3, 3, CAVE_AIR, CAVE_AIR, this.isSurface); // Suki - custom strongholds - surface strongholds
             } else {
-                this.generateBox(world, chunkBox, 4, 1, 1, 4, 3, 3, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 4, 1, 1, 4, 3, 3, CAVE_AIR, CAVE_AIR, this.isSurface); // Suki - custom strongholds - surface strongholds
             }
 
         }
@@ -836,8 +979,10 @@ public class StrongholdPieces {
         protected static final int DEPTH = 11;
         protected final int type;
 
-        public RoomCrossing(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_ROOM_CROSSING, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public RoomCrossing(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_ROOM_CROSSING, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
             this.type = random.nextInt(5);
@@ -861,18 +1006,23 @@ public class StrongholdPieces {
             this.generateSmallDoorChildRight((StrongholdPieces.StartPiece)start, holder, random, 1, 4);
         }
 
-        public static StrongholdPieces.RoomCrossing createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.RoomCrossing createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Suki - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -4, -1, 0, 11, 7, 11, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.RoomCrossing(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.RoomCrossing(chainLength, random, boundingBox, orientation, isSurface) : null; // Suki - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 10, 6, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            var sukiConfig = world.getLevel().sukiConfig().customStrongholds;
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 10, 6, 10, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Suki - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 4, 1, 0);
-            this.generateBox(world, chunkBox, 4, 1, 10, 6, 3, 10, CAVE_AIR, CAVE_AIR, false);
-            this.generateBox(world, chunkBox, 0, 1, 4, 0, 3, 6, CAVE_AIR, CAVE_AIR, false);
-            this.generateBox(world, chunkBox, 10, 1, 4, 10, 3, 6, CAVE_AIR, CAVE_AIR, false);
+            // Suki start - custom strongholds - surface strongholds
+            this.generateBox(world, chunkBox, 4, 1, 10, 6, 3, 10, CAVE_AIR, CAVE_AIR, this.isSurface);
+            this.generateBox(world, chunkBox, 0, 1, 4, 0, 3, 6, CAVE_AIR, CAVE_AIR, this.isSurface);
+            this.generateBox(world, chunkBox, 10, 1, 4, 10, 3, 6, CAVE_AIR, CAVE_AIR, this.isSurface);
             switch (this.type) {
                 case 0:
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 5, 1, 5, chunkBox);
@@ -902,27 +1052,27 @@ public class StrongholdPieces {
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 5, 1, 5, chunkBox);
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 5, 2, 5, chunkBox);
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 5, 3, 5, chunkBox);
-                    this.placeBlock(world, Blocks.WATER.defaultBlockState(), 5, 4, 5, chunkBox);
+                    this.placeBlock(world, TEMPORARY_WATER.defaultBlockState(), 5, 4, 5, chunkBox); // Suki - custom strongholds - strongholds in water
                     break;
                 case 2:
                     for(int j = 1; j <= 9; ++j) {
-                        this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 1, 3, j, chunkBox);
-                        this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 9, 3, j, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 1, 3, j, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 9, 3, j, chunkBox);
                     }
 
                     for(int k = 1; k <= 9; ++k) {
-                        this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), k, 3, 1, chunkBox);
-                        this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), k, 3, 9, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), k, 3, 1, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), k, 3, 9, chunkBox);
                     }
 
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 1, 4, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 1, 6, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 3, 4, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 3, 6, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 4, 1, 5, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 6, 1, 5, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 4, 3, 5, chunkBox);
-                    this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 6, 3, 5, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 1, 4, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 1, 6, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 3, 4, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 5, 3, 6, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 4, 1, 5, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 6, 1, 5, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 4, 3, 5, chunkBox);
+                    this.placeBlockConditionally(world, Blocks.COBBLESTONE.defaultBlockState(), 6, 3, 5, chunkBox);
 
                     for(int l = 1; l <= 3; ++l) {
                         this.placeBlock(world, Blocks.COBBLESTONE.defaultBlockState(), 4, l, 4, chunkBox);
@@ -934,16 +1084,16 @@ public class StrongholdPieces {
                     this.placeBlock(world, Blocks.TORCH.defaultBlockState(), 5, 3, 5, chunkBox);
 
                     for(int m = 2; m <= 8; ++m) {
-                        this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 2, 3, m, chunkBox);
-                        this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 3, 3, m, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 2, 3, m, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 3, 3, m, chunkBox);
                         if (m <= 3 || m >= 7) {
-                            this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 4, 3, m, chunkBox);
-                            this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 5, 3, m, chunkBox);
-                            this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 6, 3, m, chunkBox);
+                            this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 4, 3, m, chunkBox);
+                            this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 5, 3, m, chunkBox);
+                            this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 6, 3, m, chunkBox);
                         }
 
-                        this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 7, 3, m, chunkBox);
-                        this.placeBlock(world, Blocks.OAK_PLANKS.defaultBlockState(), 8, 3, m, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 7, 3, m, chunkBox);
+                        this.placeBlockConditionally(world, Blocks.OAK_PLANKS.defaultBlockState(), 8, 3, m, chunkBox);
                     }
 
                     BlockState blockState = Blocks.LADDER.defaultBlockState().setValue(LadderBlock.FACING, Direction.WEST);
@@ -951,9 +1101,57 @@ public class StrongholdPieces {
                     this.placeBlock(world, blockState, 9, 2, 3, chunkBox);
                     this.placeBlock(world, blockState, 9, 3, 3, chunkBox);
                     this.createChest(world, chunkBox, random, 3, 4, 8, BuiltInLootTables.STRONGHOLD_CROSSING);
+                    break;
             }
+            // Suki end - custom strongholds - surface strongholds
+
+            // Suki start - custom strongholds - more things
 
+            // Replace some of the floor by water or lava
+            if (random.nextFloat() < sukiConfig.waterAndLavaInCrossings.chance) {
+                BlockState replacement;
+                double blockChance;
+                if (random.nextFloat() < sukiConfig.waterAndLavaInCrossings.waterRatio) {
+                    replacement = Blocks.WATER.defaultBlockState();
+                    blockChance = sukiConfig.waterAndLavaInCrossings.blockChances.water;
+                } else {
+                    replacement = Blocks.LAVA.defaultBlockState();
+                    blockChance = sukiConfig.waterAndLavaInCrossings.blockChances.lava;
+                }
+                for (int x = chunkBox.minX() + 1; x <= chunkBox.maxX() - 1; x++) {
+                    for (int z = chunkBox.minZ() + 1; z <= chunkBox.maxZ() - 1; z++) {
+                        BlockPos pos = new BlockPos(x, chunkBox.minY(), z);
+                        if (random.nextFloat() < blockChance) {
+                            if (world.getBlockState(pos).is(BlockTags.STONE_BRICKS) && world.getBlockState(pos.above()).isAir()) {
+                                placeBlockUnconditionallyWorldCoordinates(world, replacement, pos, boundingBox);
+                            }
+                        }
+                    }
+                }
+            }
+
+            // Suki end - custom strongholds - more things
+
+        }
+
+        // Suki start - custom strongholds - strongholds in water
+
+        public static final Block TEMPORARY_WATER = Blocks.WARPED_WART_BLOCK;
+
+        @Override
+        public void spreadWater(WorldGenLevel world) {
+            BlockPos fountainWaterPos = this.getWorldPos(5, 4, 5);
+            if (world.getBlockState(fountainWaterPos).is(Blocks.WATER)) {
+                this.placeBlockUnconditionally(world, TEMPORARY_WATER.defaultBlockState(), 5, 4, 5, boundingBox);
+            }
+            super.spreadWater(world);
+            if (world.getBlockState(fountainWaterPos).is(TEMPORARY_WATER)) {
+                this.placeBlockUnconditionally(world, Blocks.WATER.defaultBlockState(), 5, 4, 5, boundingBox);
+            }
         }
+
+        // Suki end - custom strongholds - strongholds in water
+
     }
 
     static class SmoothStoneSelector extends StructurePiece.BlockSelector {
@@ -977,21 +1175,49 @@ public class StrongholdPieces {
         }
     }
 
+    // Suki start - custom strongholds - surface strongholds
+    static class SmoothStoneSelectorOrTemporary extends StructurePiece.BlockSelector {
+        public static final Block TEMPORARY = Blocks.LIGHT;
+        @Override
+        public void next(RandomSource random, int x, int y, int z, boolean placeBlock) {
+            if (placeBlock) {
+                float f = random.nextFloat();
+                if (f < 0.2F) {
+                    this.next = Blocks.CRACKED_STONE_BRICKS.defaultBlockState();
+                } else if (f < 0.5F) {
+                    this.next = Blocks.MOSSY_STONE_BRICKS.defaultBlockState();
+                } else if (f < 0.55F) {
+                    this.next = Blocks.INFESTED_STONE_BRICKS.defaultBlockState();
+                } else {
+                    this.next = Blocks.STONE_BRICKS.defaultBlockState();
+                }
+            } else {
+                this.next = TEMPORARY.defaultBlockState();
+            }
+
+        }
+    }
+    // Suki end - custom strongholds - surface strongholds
+
     public static class StairsDown extends StrongholdPieces.StrongholdPiece {
         private static final int WIDTH = 5;
         private static final int HEIGHT = 11;
         private static final int DEPTH = 5;
         private final boolean isSource;
 
-        public StairsDown(StructurePieceType structurePieceType, int chainLength, int x, int z, Direction orientation) {
-            super(structurePieceType, chainLength, makeBoundingBox(x, 64, z, orientation, 5, 11, 5));
+        // Suki start - custom strongholds - surface strongholds
+        public StairsDown(StructurePieceType structurePieceType, int chainLength, int x, int z, Direction orientation, boolean isSurface) {
+            super(structurePieceType, chainLength, makeBoundingBox(x, 64, z, orientation, 5, 11, 5), isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.isSource = true;
             this.setOrientation(orientation);
             this.entryDoor = StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING;
         }
 
-        public StairsDown(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_STAIRS_DOWN, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public StairsDown(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_STAIRS_DOWN, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.isSource = false;
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
@@ -1021,14 +1247,17 @@ public class StrongholdPieces {
             this.generateSmallDoorChildForward((StrongholdPieces.StartPiece)start, holder, random, 1, 1);
         }
 
-        public static StrongholdPieces.StairsDown createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.StairsDown createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Suki - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -7, 0, 5, 11, 5, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.StairsDown(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.StairsDown(chainLength, random, boundingBox, orientation, isSurface) : null; // Suki - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 10, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 10, 4, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Suki - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 7, 0);
             this.generateSmallDoor(world, random, chunkBox, StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING, 1, 1, 4);
             this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 2, 6, 1, chunkBox);
@@ -1057,8 +1286,10 @@ public class StrongholdPieces {
         public StrongholdPieces.PortalRoom portalRoomPiece;
         public final List<StructurePiece> pendingChildren = Lists.newArrayList();
 
-        public StartPiece(RandomSource random, int i, int j) {
-            super(StructurePieceType.STRONGHOLD_START, 0, i, j, getRandomHorizontalDirection(random));
+        // Suki start - custom strongholds - surface strongholds
+        public StartPiece(RandomSource random, int i, int j, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_START, 0, i, j, getRandomHorizontalDirection(random), isSurface);
+            // Suki end - custom strongholds - surface strongholds
         }
 
         public StartPiece(CompoundTag nbt) {
@@ -1078,8 +1309,10 @@ public class StrongholdPieces {
         private final boolean leftChild;
         private final boolean rightChild;
 
-        public Straight(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_STRAIGHT, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public Straight(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_STRAIGHT, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
             this.leftChild = random.nextInt(2) == 0;
@@ -1112,14 +1345,17 @@ public class StrongholdPieces {
 
         }
 
-        public static StrongholdPieces.Straight createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.Straight createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) {
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -1, 0, 5, 5, 7, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.Straight(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.Straight(chainLength, random, boundingBox, orientation, isSurface) : null; // Suki - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 4, 6, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 4, 6, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Suki - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 1, 0);
             this.generateSmallDoor(world, random, chunkBox, StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING, 1, 1, 6);
             BlockState blockState = Blocks.WALL_TORCH.defaultBlockState().setValue(WallTorchBlock.FACING, Direction.EAST);
@@ -1129,11 +1365,11 @@ public class StrongholdPieces {
             this.maybeGenerateBlock(world, chunkBox, random, 0.1F, 1, 2, 5, blockState);
             this.maybeGenerateBlock(world, chunkBox, random, 0.1F, 3, 2, 5, blockState2);
             if (this.leftChild) {
-                this.generateBox(world, chunkBox, 0, 1, 2, 0, 3, 4, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 0, 1, 2, 0, 3, 4, CAVE_AIR, CAVE_AIR, this.isSurface); // Suki - custom strongholds - surface strongholds
             }
 
             if (this.rightChild) {
-                this.generateBox(world, chunkBox, 4, 1, 2, 4, 3, 4, CAVE_AIR, CAVE_AIR, false);
+                this.generateBox(world, chunkBox, 4, 1, 2, 4, 3, 4, CAVE_AIR, CAVE_AIR, this.isSurface); // Suki - custom strongholds - surface strongholds
             }
 
         }
@@ -1144,8 +1380,10 @@ public class StrongholdPieces {
         private static final int HEIGHT = 11;
         private static final int DEPTH = 8;
 
-        public StraightStairsDown(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation) {
-            super(StructurePieceType.STRONGHOLD_STRAIGHT_STAIRS_DOWN, chainLength, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        public StraightStairsDown(int chainLength, RandomSource random, BoundingBox boundingBox, Direction orientation, boolean isSurface) {
+            super(StructurePieceType.STRONGHOLD_STRAIGHT_STAIRS_DOWN, chainLength, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
             this.setOrientation(orientation);
             this.entryDoor = this.randomSmallDoor(random);
         }
@@ -1159,22 +1397,49 @@ public class StrongholdPieces {
             this.generateSmallDoorChildForward((StrongholdPieces.StartPiece)start, holder, random, 1, 1);
         }
 
-        public static StrongholdPieces.StraightStairsDown createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength) {
+        public static StrongholdPieces.StraightStairsDown createPiece(StructurePieceAccessor holder, RandomSource random, int x, int y, int z, Direction orientation, int chainLength, boolean isSurface) { // Suki - custom strongholds - surface strongholds
             BoundingBox boundingBox = BoundingBox.orientBox(x, y, z, -1, -7, 0, 5, 11, 8, orientation);
-            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.StraightStairsDown(chainLength, random, boundingBox, orientation) : null;
+            return isOkBox(boundingBox) && holder.findCollisionPiece(boundingBox) == null ? new StrongholdPieces.StraightStairsDown(chainLength, random, boundingBox, orientation, isSurface) : null; // Suki - custom strongholds - surface strongholds
         }
 
         @Override
-        public void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
-            this.generateBox(world, chunkBox, 0, 0, 0, 4, 10, 7, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR);
+        // Suki start - custom strongholds - surface strongholds
+        public void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            super.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            // Suki end - custom strongholds - surface strongholds
+            this.generateBoxWithPartiallyOpenCeiling(world, chunkBox, 0, 0, 0, 4, 10, 7, true, random, StrongholdPieces.SMOOTH_STONE_SELECTOR); // Suki - custom strongholds - holes in stronghold parts
             this.generateSmallDoor(world, random, chunkBox, this.entryDoor, 1, 7, 0);
             this.generateSmallDoor(world, random, chunkBox, StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING, 1, 1, 7);
-            BlockState blockState = Blocks.COBBLESTONE_STAIRS.defaultBlockState().setValue(StairBlock.FACING, Direction.SOUTH);
+            // Suki start - custom strongholds - stairs have more types
+            BlockState blockStateStairs1 = Blocks.COBBLESTONE_STAIRS.defaultBlockState().setValue(StairBlock.FACING, Direction.SOUTH);
+            BlockState blockStateStairs2 = Blocks.STONE_BRICK_STAIRS.defaultBlockState().setValue(StairBlock.FACING, Direction.SOUTH);
+            BlockState blockStateStairs3 = Blocks.STONE_STAIRS.defaultBlockState().setValue(StairBlock.FACING, Direction.SOUTH);
+            BlockState blockStateStairs4 = Blocks.COBBLESTONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.BOTTOM);
+            BlockState blockStateStairs5 = Blocks.STONE_BRICK_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.BOTTOM);
+            BlockState blockStateStairs6 = Blocks.STONE_SLAB.defaultBlockState().setValue(SlabBlock.TYPE, SlabType.BOTTOM);
+            // Suki end - custom strongholds - stairs have more types
 
             for(int i = 0; i < 6; ++i) {
-                this.placeBlock(world, blockState, 1, 6 - i, 1 + i, chunkBox);
-                this.placeBlock(world, blockState, 2, 6 - i, 1 + i, chunkBox);
-                this.placeBlock(world, blockState, 3, 6 - i, 1 + i, chunkBox);
+                // Suki start - custom strongholds - stairs have more types
+                for (int stairsX = 1; stairsX <= 3; stairsX++) {
+                    float f = random.nextFloat();
+                    BlockState stairsState;
+                    if (f < 0.55F) {
+                        stairsState = blockStateStairs1;
+                    } else if (f < 0.85F) {
+                        stairsState = blockStateStairs2;
+                    } else if (f < 0.9F) {
+                        stairsState = blockStateStairs3;
+                    } else if (f < 0.95F) {
+                        stairsState = blockStateStairs4;
+                    } else if (f < 0.975F) {
+                        stairsState = blockStateStairs5;
+                    } else {
+                        stairsState = blockStateStairs6;
+                    }
+                    this.placeBlock(world, stairsState, stairsX, 6 - i, 1 + i, chunkBox);
+                }
+                // Suki end - custom strongholds - stairs have more types
                 if (i < 5) {
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 1, 5 - i, 1 + i, chunkBox);
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), 2, 5 - i, 1 + i, chunkBox);
@@ -1187,25 +1452,155 @@ public class StrongholdPieces {
 
     abstract static class StrongholdPiece extends StructurePiece {
         protected StrongholdPieces.StrongholdPiece.SmallDoorType entryDoor = StrongholdPieces.StrongholdPiece.SmallDoorType.OPENING;
+        protected boolean isSurface = false; // Suki - custom strongholds - surface strongholds
 
-        protected StrongholdPiece(StructurePieceType type, int length, BoundingBox boundingBox) {
+        protected StrongholdPiece(StructurePieceType type, int length, BoundingBox boundingBox, boolean isSurface) { // Suki - custom strongholds - surface strongholds
             super(type, length, boundingBox);
+            this.isSurface = isSurface; // Suki - custom strongholds - surface strongholds
         }
 
         public StrongholdPiece(StructurePieceType type, CompoundTag nbt) {
             super(type, nbt);
             this.entryDoor = StrongholdPieces.StrongholdPiece.SmallDoorType.valueOf(nbt.getString("EntryDoor"));
+            // Suki start - custom strongholds - surface strongholds
+            if (nbt.contains("IsSurface")) {
+                this.isSurface = nbt.getBoolean("IsSurface");
+            }
+            // Suki end - custom strongholds - surface strongholds
         }
 
         @Override
         protected void addAdditionalSaveData(StructurePieceSerializationContext context, CompoundTag nbt) {
             nbt.putString("EntryDoor", this.entryDoor.name());
+            nbt.putBoolean("IsSurface", this.isSurface); // Suki - custom strongholds - surface strongholds
+        }
+
+        // Suki start - custom strongholds - surface strongholds
+
+        @Override
+        protected void placeBlock(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box) {
+            if (this.isSurface) {
+                this.placeBlockConditionally(world, block, x, y, z, box);
+            } else {
+                super.placeBlock(world, block, x, y, z, box);
+            }
+        }
+
+        protected void placeBlockConditionally(WorldGenLevel world, BlockState block, int x, int y, int z, BoundingBox box) {
+            if (this.isSurface) {
+                this.placeBlockConditionally(world, block, x, y, z, box, false, false, false, false, true);
+            } else {
+                super.placeBlock(world, block, x, y, z, box);
+            }
+        }
+
+        protected void generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean cantReplaceLiquid) {
+            if (this.isSurface) {
+                this.generateBoxConditionally(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceLiquid, false, false, true);
+            } else {
+                super.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceLiquid);
+            }
+        }
+
+        protected void generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir) {
+            this.generateBoxConditionally(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceAir);
+        }
+
+        protected boolean generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, RandomSource random, StructurePiece.BlockSelector randomizer) {
+            // Below is replaced with a dumber version because it seems that otherwise, the server gets stuck in CIRCULAR chunk dependency
+            // ^ Reverted replacement
+            return this.generateBoxConditionally(world, box, minX, minY, minZ, maxX, maxY, maxZ, false, false, false, false, true, random, randomizer);
+//            this.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, this.isSurface, this.isSurface, random, randomizer);
+//            return true; // Meaningless
         }
 
+        protected boolean generateBoxConditionally(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside) {
+            // Below is replaced with a dumber version because it seems that otherwise, the server gets stuck in CIRCULAR chunk dependency
+            // ^ Reverted replacement
+            return this.generateBoxConditionally(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, false, false, false, false, true);
+//            this.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, this.isSurface, this.isSurface);
+//            return true; // Meaningless
+        }
+
+        @Override
+        protected void generateAirBox(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {
+            this.generateAirBox(world, bounds, minX, minY, minZ, maxX, maxY, maxZ, this.isSurface);
+        }
+
+        @Override
+        protected boolean createChest(WorldGenLevel world, BoundingBox boundingBox, RandomSource random, int x, int y, int z, ResourceLocation lootTableId) {
+            return this.createChest(world, boundingBox, random, x, y, z, lootTableId, true);
+        }
+
+        @Override
+        protected boolean createChest(ServerLevelAccessor world, BoundingBox boundingBox, RandomSource random, BlockPos pos, ResourceLocation lootTableId, @Nullable BlockState block) {
+            return this.createChest(world, boundingBox, random, pos, lootTableId, block, true);
+        }
+
+        // Suki end - custom strongholds - surface strongholds
+
+        // Suki start - custom strongholds - strongholds in water
+
+        @Override
+        protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir) {
+            this.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceAir);
+        }
+
+        @Override
+        protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, BlockState outline, BlockState inside, boolean cantReplaceAir) {
+            this.generateBox(world, box, fillBox, outline, inside, cantReplaceAir, cantReplaceAir);
+        }
+
+        @Override
+        protected void generateBox(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+            this.generateBox(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, cantReplaceAir, random, randomizer);
+        }
+
+        @Override
+        protected void generateBox(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+            this.generateBox(world, box, fillBox, cantReplaceAir, cantReplaceAir, random, randomizer);
+        }
+
+        // Suki start - custom strongholds - holes in stronghold parts
+
+        @Override
+        protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+            this.generateBoxWithPartiallyOpenCeiling(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, cantReplaceAir, random, randomizer, newAir);
+        }
+
+        @Override
+        protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer, BlockState newAir) {
+            this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox, cantReplaceAir, cantReplaceAir, random, randomizer, newAir);
+        }
+
+        @Override
+        protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+            this.generateBoxWithPartiallyOpenCeiling(world, box, minX, minY, minZ, maxX, maxY, maxZ, cantReplaceAir, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+        }
+
+        @Override
+        protected void generateBoxWithPartiallyOpenCeiling(WorldGenLevel world, BoundingBox box, BoundingBox fillBox, boolean cantReplaceAir, RandomSource random, StructurePiece.BlockSelector randomizer) {
+            this.generateBoxWithPartiallyOpenCeiling(world, box, fillBox, cantReplaceAir, random, randomizer, Blocks.CAVE_AIR.defaultBlockState());
+        }
+
+        // Suki end - custom strongholds - holes in stronghold parts
+
+        @Override
+        protected void generateMaybeBox(WorldGenLevel world, BoundingBox box, RandomSource random, float blockChance, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState outline, BlockState inside, boolean cantReplaceAir, boolean stayBelowSeaLevel) {
+            this.generateMaybeBox(world, box, random, blockChance, minX, minY, minZ, maxX, maxY, maxZ, outline, inside, cantReplaceAir, cantReplaceAir, stayBelowSeaLevel);
+        }
+
+        @Override
+        protected void generateUpperHalfSphere(WorldGenLevel world, BoundingBox bounds, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, BlockState block, boolean cantReplaceAir) {
+            this.generateUpperHalfSphere(world, bounds, minX, minY, minZ, maxX, maxY, maxZ, block, cantReplaceAir, cantReplaceAir);
+        }
+
+        // Suki end - custom strongholds - strongholds in water
+
         protected void generateSmallDoor(WorldGenLevel world, RandomSource random, BoundingBox boundingBox, StrongholdPieces.StrongholdPiece.SmallDoorType type, int x, int y, int z) {
             switch (type) {
                 case OPENING:
-                    this.generateBox(world, boundingBox, x, y, z, x + 3 - 1, y + 3 - 1, z, CAVE_AIR, CAVE_AIR, false);
+                    this.generateBox(world, boundingBox, x, y, z, x + 3 - 1, y + 3 - 1, z, CAVE_AIR, CAVE_AIR, this.isSurface); // Suki - custom strongholds - surface strongholds
                     break;
                 case WOOD_DOOR:
                     this.placeBlock(world, Blocks.STONE_BRICKS.defaultBlockState(), x, y, z, boundingBox);
@@ -1267,13 +1662,13 @@ public class StrongholdPieces {
             if (direction != null) {
                 switch (direction) {
                     case NORTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, direction, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, direction, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                     case SOUTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, direction, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, direction, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                     case WEST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, direction, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, direction, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                     case EAST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, direction, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, direction, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                 }
             }
 
@@ -1286,13 +1681,13 @@ public class StrongholdPieces {
             if (direction != null) {
                 switch (direction) {
                     case NORTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.WEST, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.WEST, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                     case SOUTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.WEST, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() - 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.WEST, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                     case WEST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, Direction.NORTH, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, Direction.NORTH, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                     case EAST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, Direction.NORTH, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() - 1, Direction.NORTH, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                 }
             }
 
@@ -1305,13 +1700,13 @@ public class StrongholdPieces {
             if (direction != null) {
                 switch (direction) {
                     case NORTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.EAST, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.EAST, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                     case SOUTH:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.EAST, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.maxX() + 1, this.boundingBox.minY() + heightOffset, this.boundingBox.minZ() + leftRightOffset, Direction.EAST, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                     case WEST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, Direction.SOUTH, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, Direction.SOUTH, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                     case EAST:
-                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, Direction.SOUTH, this.getGenDepth());
+                        return StrongholdPieces.generateAndAddPiece(start, holder, random, this.boundingBox.minX() + leftRightOffset, this.boundingBox.minY() + heightOffset, this.boundingBox.maxZ() + 1, Direction.SOUTH, this.getGenDepth(), this.isSurface); // Suki - custom strongholds - surface strongholds
                 }
             }
 
@@ -1328,6 +1723,197 @@ public class StrongholdPieces {
             GRATES,
             IRON_DOOR;
         }
+
+        // Suki start - custom strongholds - surface strongholds
+
+        protected void strongholdPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {}
+
+        @Override
+        public final void postProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            this.strongholdPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+            this.postPostProcess(world, structureAccessor, chunkGenerator, random, chunkBox, chunkPos, pivot);
+        }
+
+        // Suki start - custom strongholds - more things
+
+        public boolean areAddedCandlesLit() {
+            return false;
+        }
+
+        private @NotNull BlockState @Nullable [] addedCandleStates = null;
+
+        public BlockState[] getAddedCandleStates() {
+            if (addedCandleStates == null) {
+                List<BlockState> addedCandleStatesList = new ArrayList<>();
+                for (Block candleBlock : new Block[] {
+                    Blocks.CANDLE, Blocks.CANDLE, Blocks.CANDLE,
+                    Blocks.WHITE_CANDLE,
+                    Blocks.GRAY_CANDLE, Blocks.GRAY_CANDLE,
+                    Blocks.LIGHT_GRAY_CANDLE,
+                    Blocks.BLACK_CANDLE, Blocks.BLACK_CANDLE,
+                    Blocks.BROWN_CANDLE, Blocks.BROWN_CANDLE,
+                    Blocks.GREEN_CANDLE
+                }) {
+                    for (int amount = CandleBlock.MIN_CANDLES; amount <= CandleBlock.MAX_CANDLES; amount++) {
+                        BlockState addedCandleState = candleBlock.defaultBlockState().setValue(BlockStateProperties.WATERLOGGED, false).setValue(BlockStateProperties.LIT, areAddedCandlesLit()).setValue(BlockStateProperties.CANDLES, amount);
+                        for (int timesAdded = 0; timesAdded < (amount == CandleBlock.MIN_CANDLES ? 3 : amount == CandleBlock.MAX_CANDLES ? 1 : 2); timesAdded++) {
+                            addedCandleStatesList.add(addedCandleState);
+                        }
+                    }
+                }
+                addedCandleStates = addedCandleStatesList.toArray(BlockState[]::new);
+            }
+            return addedCandleStates;
+        }
+
+        // Suki end - custom strongholds - more things
+
+        public final void postPostProcess(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox chunkBox, ChunkPos chunkPos, BlockPos pivot) {
+            var sukiConfig = world.getLevel().sukiConfig().customStrongholds;
+            // Replace temporary air-representing blocks by air
+            this.replace(world, chunkBox, SmoothStoneSelectorOrTemporary.TEMPORARY, Blocks.CAVE_AIR.defaultBlockState());
+            // Fix blocks being invalid in their location (for example grass unsupported by a block below)
+            for (int x = this.boundingBox.minX(); x <= this.boundingBox.maxX(); x++) {
+                for (int y = this.boundingBox.minY(); y <= this.boundingBox.maxY() + 4/* should need only 2 but taking 4 as extra margin just in case */; y++) {
+                    for (int z = this.boundingBox.minZ(); z <= this.boundingBox.maxZ(); z++) {
+                        BlockPos pos = new BlockPos(x, y, z);
+                        BlockState block = world.getBlockState(pos);
+                        BlockState newBlock = null;
+                        boolean isUnstableAndMustBeRemoved = false;
+                        if (y <= this.boundingBox.maxY()) {
+                            // Remove single door pieces
+                            if (block.is(BlockTags.DOORS)) {
+                                BlockState blockAbove = world.getBlockState(pos.above());
+                                if (!(world.getBlockState(pos.below()).is(BlockTags.DOORS) || blockAbove.is(BlockTags.DOORS))) {
+                                    Optional<Boolean> waterlogged = block.getOptionalValue(BlockStateProperties.WATERLOGGED);
+                                    Optional<Boolean> waterloggedAbove = blockAbove.getOptionalValue(BlockStateProperties.WATERLOGGED);
+                                    if ((waterlogged.isPresent() && waterlogged.get()) || blockAbove.is(Blocks.WATER) || (waterloggedAbove.isPresent() && waterloggedAbove.get())) {
+                                        newBlock = Blocks.WATER.defaultBlockState();
+                                    } else if (blockAbove.is(Blocks.LAVA)) {
+                                        newBlock = Blocks.LAVA.defaultBlockState();
+                                    } else {
+                                        newBlock = Blocks.CAVE_AIR.defaultBlockState();
+                                    }
+                                }
+                            }
+                        }
+                        // Fix floating grass and similar blocks that rely on a supporting solid block on a specific side
+                        if (block.is(BlockTags.TALL_FLOWERS) || block.is(Blocks.TALL_GRASS) || block.is(Blocks.TALL_SEAGRASS) || block.is(Blocks.LARGE_FERN) || block.is(BlockTags.FLOWERS) || block.is(Blocks.GRASS) || block.is(Blocks.SEAGRASS) || block.is(Blocks.FERN) || block.is(Blocks.KELP_PLANT) || block.is(Blocks.KELP) || block.is(Blocks.RED_MUSHROOM) || block.is(Blocks.BROWN_MUSHROOM) || block.is(Blocks.DEAD_BUSH)) {
+                            if (!StructurePiece.hasRelativeSolid(world, pos, Direction.DOWN)) {
+                                isUnstableAndMustBeRemoved = true;
+                            }
+                        } else if (block.is(Blocks.VINE) || block.is(Blocks.GLOW_LICHEN) || block.is(Blocks.SCULK_VEIN)) {
+                            if (block.getValue(BlockStateProperties.UP) && !StructurePiece.hasRelativeSolid(world, pos, Direction.UP)) {
+                                isUnstableAndMustBeRemoved = true;
+                            } else if (!block.is(Blocks.VINE) && block.getValue(BlockStateProperties.DOWN) && !StructurePiece.hasRelativeSolid(world, pos, Direction.DOWN)) {
+                                isUnstableAndMustBeRemoved = true;
+                            } else if (block.getValue(BlockStateProperties.EAST) && !StructurePiece.hasRelativeSolid(world, pos, Direction.EAST)) {
+                                isUnstableAndMustBeRemoved = true;
+                            } else if (block.getValue(BlockStateProperties.WEST) && !StructurePiece.hasRelativeSolid(world, pos, Direction.WEST)) {
+                                isUnstableAndMustBeRemoved = true;
+                            } else if (block.getValue(BlockStateProperties.NORTH) && !StructurePiece.hasRelativeSolid(world, pos, Direction.NORTH)) {
+                                isUnstableAndMustBeRemoved = true;
+                            } else if (block.getValue(BlockStateProperties.SOUTH) && !StructurePiece.hasRelativeSolid(world, pos, Direction.SOUTH)) {
+                                isUnstableAndMustBeRemoved = true;
+                            }
+                        } else if (block.is(Blocks.LADDER) || block.is(Blocks.WALL_TORCH)) {
+                            if (!StructurePiece.hasRelativeSolid(world, pos, block.getValue(BlockStateProperties.HORIZONTAL_FACING))) {
+                                isUnstableAndMustBeRemoved = true;
+                            }
+                        }
+                        if (isUnstableAndMustBeRemoved) {
+                            BlockState blockAbove = world.getBlockState(pos.above());
+                            Optional<Boolean> waterlogged = block.getOptionalValue(BlockStateProperties.WATERLOGGED);
+                            Optional<Boolean> waterloggedAbove = blockAbove.getOptionalValue(BlockStateProperties.WATERLOGGED);
+                            if ((waterlogged.isPresent() && waterlogged.get()) || blockAbove.is(Blocks.WATER) || (waterloggedAbove.isPresent() && waterloggedAbove.get())) {
+                                newBlock = Blocks.WATER.defaultBlockState();
+                            } else if (blockAbove.is(Blocks.LAVA)) {
+                                newBlock = Blocks.LAVA.defaultBlockState();
+                            } else if (y > boundingBox.maxY()) {
+                                newBlock = Blocks.AIR.defaultBlockState();
+                            } else {
+                                newBlock = Blocks.CAVE_AIR.defaultBlockState();
+                            }
+                        }
+                        // Replace the state if needed
+                        if (newBlock != null) {
+                            world.setBlock(pos, newBlock, 2);
+                            FluidState fluidState = world.getFluidState(pos);
+                            if (!fluidState.isEmpty()) {
+                                world.scheduleTick(pos, fluidState.getType(), 0);
+                            }
+
+                            if (StructurePiece.SHAPE_CHECK_BLOCKS.contains(block.getBlock())) {
+                                world.getChunk(pos).markPosForPostprocessing(pos);
+                            }
+                        }
+                    }
+                }
+            }
+            // Spread water
+            this.spreadWater(world); // Suki - custom strongholds - strongholds in water
+            // Suki start - custom strongholds - more things
+            // Maybe replace some air around the edges with candles
+            BlockState[] addedCandleStates = getAddedCandleStates();
+            var candlesConfig = sukiConfig.addCandles;
+            for (var opportunity : candlesConfig.getOpportunities()) {
+                if (random.nextFloat() < opportunity.chance) {
+                    this.replace(world, boundingBox, Blocks.CAVE_AIR, addedCandleStates[random.nextInt(addedCandleStates.length)], random, opportunity.ratio, true, false, false, pos -> (pos.getLeft() == boundingBox.minX() + 1 || pos.getLeft() == boundingBox.maxX() - 1) && (pos.getRight() == boundingBox.minZ() + 1 || pos.getRight() == boundingBox.maxZ() - 1));
+                    break;
+                }
+            }
+            // Maybe replace some air with cobwebs
+            var cobwebConfig = sukiConfig.moreCobwebs;
+            for (var opportunity : cobwebConfig.getOpportunities()) {
+                if (random.nextFloat() < opportunity.chance) {
+                    this.replace(world, boundingBox, Blocks.CAVE_AIR, Blocks.COBWEB.defaultBlockState(), random, opportunity.ratio, false, false, true);
+                    break;
+                }
+            }
+            // Suki end - custom strongholds - more things
+        }
+
+        // Suki end - custom strongholds - surface strongholds
+
+        // Suki start - custom strongholds - strongholds in water
+
+        public void spreadWater(WorldGenLevel world) {
+            // Spread water horizontally and downwards
+            int maxCycles = 100;
+            while (maxCycles-->0) {
+                boolean changesThisCycle = false;
+                for (int x = this.boundingBox.minX(); x <= this.boundingBox.maxX(); x++) {
+                    for (int y = this.boundingBox.minY(); y <= this.boundingBox.maxY(); y++) {
+                        for (int z = this.boundingBox.minZ(); z <= this.boundingBox.maxZ(); z++) {
+                            BlockPos pos = new BlockPos(x, y, z);
+                            BlockState block = world.getBlockState(pos);
+                            Optional<Boolean> waterlogged = block.getOptionalValue(BlockStateProperties.WATERLOGGED);
+                            if (canBeFilledUpByWaterSourceIfWaterFlowsIn(block) || (waterlogged.isPresent() && !waterlogged.get())) {
+                                BlockState newBlock = getAnyRelativeLiquidDefaultBlockState(world, pos, besideOrAboveDirections);
+                                if (newBlock != null && !newBlock.equals(block)) {
+                                    changesThisCycle = true;
+                                    world.setBlock(pos, newBlock, 2);
+                                    FluidState fluidState = world.getFluidState(pos);
+                                    if (!fluidState.isEmpty()) {
+                                        world.scheduleTick(pos, fluidState.getType(), 0);
+                                    }
+
+                                    if (StructurePiece.SHAPE_CHECK_BLOCKS.contains(block.getBlock())) {
+                                        world.getChunk(pos).markPosForPostprocessing(pos);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                if (!changesThisCycle) {
+                    break;
+                }
+            }
+        }
+
+        // Suki start - custom strongholds - strongholds in water
+
     }
 
     public abstract static class Turn extends StrongholdPieces.StrongholdPiece {
@@ -1335,8 +1921,10 @@ public class StrongholdPieces {
         protected static final int HEIGHT = 5;
         protected static final int DEPTH = 5;
 
-        protected Turn(StructurePieceType type, int length, BoundingBox boundingBox) {
-            super(type, length, boundingBox);
+        // Suki start - custom strongholds - surface strongholds
+        protected Turn(StructurePieceType type, int length, BoundingBox boundingBox, boolean isSurface) {
+            super(type, length, boundingBox, isSurface);
+            // Suki end - custom strongholds - surface strongholds
         }
 
         public Turn(StructurePieceType type, CompoundTag nbt) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdStructure.java b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdStructure.java
index f0bc479d3dfb4df09c61f6bc87f4a124e39c352d..1da54966016969cf20bf71e5946df1e9b33869d5 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdStructure.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/structures/StrongholdStructure.java
@@ -1,36 +1,147 @@
 package net.minecraft.world.level.levelgen.structure.structures;
 
 import com.mojang.serialization.Codec;
+
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
+import java.util.Random;
+
+import com.mojang.serialization.codecs.RecordCodecBuilder;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import io.papermc.paper.world.structure.ConfiguredStructure;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Holder;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.tags.BiomeTags;
+import net.minecraft.util.RandomSource;
+import net.minecraft.util.StringRepresentable;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.LevelHeightAccessor;
+import net.minecraft.world.level.StructureManager;
+import net.minecraft.world.level.WorldGenLevel;
+import net.minecraft.world.level.biome.Biome;
+import net.minecraft.world.level.biome.BiomeSource;
+import net.minecraft.world.level.biome.Biomes;
+import net.minecraft.world.level.chunk.ChunkAccess;
+import net.minecraft.world.level.chunk.ChunkGenerator;
+import net.minecraft.world.level.levelgen.WorldgenRandom;
+import net.minecraft.world.level.levelgen.structure.BoundingBox;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import net.minecraft.world.level.levelgen.structure.StructurePiece;
 import net.minecraft.world.level.levelgen.structure.StructureType;
+import net.minecraft.world.level.levelgen.structure.pieces.PiecesContainer;
 import net.minecraft.world.level.levelgen.structure.pieces.StructurePiecesBuilder;
+import org.sucraft.suki.biome.SuCraftBiomeTags;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.Nullable;
 
 public class StrongholdStructure extends Structure {
-    public static final Codec<StrongholdStructure> CODEC = simpleCodec(StrongholdStructure::new);
 
-    public StrongholdStructure(Structure.StructureSettings config) {
+    // Suki start - custom strongholds - surface strongholds
+
+    public static final Codec<StrongholdStructure> CODEC = RecordCodecBuilder.create(instance ->
+        instance.group(settingsCodec(instance), Codec.BOOL.optionalFieldOf("is_surface").forGetter(structure ->
+            Optional.of(structure.isSurface)
+        )).apply(instance, StrongholdStructure::new)
+    );
+
+    public final boolean isSurface;
+
+    public StrongholdStructure(Structure.StructureSettings config, Optional<Boolean> isSurface) {
+        this(config, isSurface.orElse(false));
+    }
+
+    public StrongholdStructure(Structure.StructureSettings config, boolean isSurface) {
         super(config);
+        this.isSurface = isSurface;
     }
 
+    // Suki end - custom strongholds - surface strongholds
+
     @Override
     public Optional<Structure.GenerationStub> findGenerationPoint(Structure.GenerationContext context) {
         return Optional.of(new Structure.GenerationStub(context.chunkPos().getWorldPosition(), (collector) -> {
-            generatePieces(collector, context);
+            generatePieces(collector, context, this.isSurface); // Suki - custom strongholds - surface strongholds
         }));
     }
 
-    private static void generatePieces(StructurePiecesBuilder collector, Structure.GenerationContext context) {
+    // Suki start - custom strongholds - surface strongholds
+
+    public static @Nullable Holder<Biome> getBiomeDuringGeneration(Structure.GenerationContext context, BlockPos blockPos) {
+        try {
+            return context.biomeSource().getNoiseBiome(blockPos.getX(), blockPos.getY(), blockPos.getZ(), context.randomState().sampler());
+        } catch (Exception e) {}
+        return null;
+    }
+
+    public static @Nullable Holder<Biome> getBiomeDuringGeneration(Structure.GenerationContext context) {
+        Holder<Biome> biome = null;
+        try {
+            return getBiomeDuringGeneration(context, context.chunkPos().getMiddleBlockPosition(context.chunkGenerator().getSeaLevel()));
+        } catch (Exception e) {}
+        return null;
+    }
+
+    // Suki end - custom strongholds - surface strongholds
+
+    private static void generatePieces(StructurePiecesBuilder collector, Structure.GenerationContext context, boolean isSurface) { // Suki - custom strongholds - surface strongholds
         int i = 0;
 
+        // Suki start - custom strongholds - surface strongholds
+        var sukiConfig = context.heightAccessor() instanceof Level ? ((Level) context.heightAccessor()).sukiConfig().customStrongholds : null;
+        if (sukiConfig == null) {
+            Bukkit.getLogger().severe("Could not get Suki world configuration while generating a stronghold");
+        }
+
+        // We determine a possible block amount to vertically raise the stronghold by
+        // (or null if we do not move this stronghold to the surface)
+        Integer potentialExtraIncreasedY = 0;
+        RandomSource surfaceStrongholdRandom = context.random().fork();
+        if (sukiConfig != null && isSurface/*surfaceStrongholdRandom.nextDouble() < sukiConfig.customStrongholds.moveToSurfaceChance*/) {
+            @Nullable Holder<Biome> biome = getBiomeDuringGeneration(context);
+            // Only move strongholds to the surface in some biomes (particularly excluding otherworldly or watery biomes)
+            if (biome != null) {
+                if (!(biome.is(BiomeTags.IS_BEACH) || biome.is(BiomeTags.IS_OCEAN) || biome.is(BiomeTags.IS_DEEP_OCEAN) || biome.is(BiomeTags.IS_NETHER) || biome.is(BiomeTags.IS_END) || biome.is(BiomeTags.HAS_SHIPWRECK) || biome.is(BiomeTags.HAS_SHIPWRECK_BEACHED) || biome.is(BiomeTags.HAS_OCEAN_MONUMENT) || biome.is(BiomeTags.HAS_OCEAN_RUIN_COLD) || biome.is(BiomeTags.HAS_OCEAN_RUIN_WARM) || biome.is(BiomeTags.HAS_RUINED_PORTAL_OCEAN) || biome.is(BiomeTags.IS_RIVER))) {
+                    // Potentially move the stronghold vertically up some extra
+                    potentialExtraIncreasedY = sukiConfig.potentialExtraIncreasedY.all;
+                    if (biome.is(Biomes.BADLANDS) || biome.is(Biomes.ERODED_BADLANDS) || biome.is(Biomes.WOODED_BADLANDS)) {
+                        potentialExtraIncreasedY = Math.max(potentialExtraIncreasedY, sukiConfig.potentialExtraIncreasedY.badlands);
+                    }
+                    if (biome.is(Biomes.SAVANNA_PLATEAU)) {
+                        potentialExtraIncreasedY = Math.max(potentialExtraIncreasedY, sukiConfig.potentialExtraIncreasedY.plateau);
+                    }
+                    if (biome.is(Biomes.WINDSWEPT_FOREST) || biome.is(Biomes.WINDSWEPT_HILLS) || biome.is(Biomes.WINDSWEPT_GRAVELLY_HILLS) || biome.is(Biomes.WINDSWEPT_SAVANNA)) {
+                        potentialExtraIncreasedY = Math.max(potentialExtraIncreasedY, sukiConfig.potentialExtraIncreasedY.windswept);
+                    }
+                    if (biome.is(BiomeTags.IS_MOUNTAIN)) {
+                        potentialExtraIncreasedY = Math.max(potentialExtraIncreasedY, sukiConfig.potentialExtraIncreasedY.mountain);
+                    }
+                    if (biome.is(BiomeTags.IS_HILL)) {
+                        potentialExtraIncreasedY = Math.max(potentialExtraIncreasedY, sukiConfig.potentialExtraIncreasedY.hill);
+                    }
+                }
+            }
+        }
+
+        // Suki end - custom strongholds - surface strongholds
+
+        final int minYDifferenceBetweenPortalRoomAndStartPiece = sukiConfig == null ? 0 : context.random().nextIntBetweenInclusive(
+            sukiConfig.minimumPortalRoomYDifference.min,
+            sukiConfig.minimumPortalRoomYDifference.max
+        );
+
         StrongholdPieces.StartPiece startPiece;
-        do {
+        // Suki start - custom strongholds - surface strongholds
+        int maxCyclesBeforeAllowEndPortalInWrongBiome = 1000;
+        int maxCyclesBeforeAllowHighEndPortal = 2000;
+        for (int cycle = 0;; cycle++) {
+            // Suki end - custom strongholds - surface strongholds
             collector.clear();
             context.random().setLargeFeatureSeed(context.seed() + (long)(i++), context.chunkPos().x, context.chunkPos().z);
             StrongholdPieces.resetPieces();
-            startPiece = new StrongholdPieces.StartPiece(context.random(), context.chunkPos().getBlockX(2), context.chunkPos().getBlockZ(2));
+            startPiece = new StrongholdPieces.StartPiece(context.random(), context.chunkPos().getBlockX(2), context.chunkPos().getBlockZ(2), isSurface);
             collector.addPiece(startPiece);
             startPiece.addChildren(startPiece, collector, context.random());
             List<StructurePiece> list = startPiece.pendingChildren;
@@ -41,13 +152,120 @@ public class StrongholdStructure extends Structure {
                 structurePiece.addChildren(startPiece, collector, context.random());
             }
 
+            // Suki start - custom strongholds - bigger strongholds
+            if (collector.isEmpty()) {
+                Bukkit.getLogger().info("Failed a stronghold generation (isSurface = " + isSurface + "): pieces empty");
+                continue;
+            } else if (startPiece.portalRoomPiece == null) {
+                Bukkit.getLogger().info("Failed a stronghold generation (isSurface = " + isSurface + "): no end portal");
+                continue;
+                // Suki start - custom strongholds - surface strongholds
+            } else if (cycle < maxCyclesBeforeAllowHighEndPortal && isSurface && startPiece.portalRoomPiece.getBoundingBox().getCenter().getY() >= startPiece.getBoundingBox().getCenter().getY() - minYDifferenceBetweenPortalRoomAndStartPiece) {
+                Bukkit.getLogger().info("Failed a stronghold generation (isSurface = " + isSurface + "): end portal not low enough");
+                continue;
+            }
+            boolean isPortalRoomValidBiome;
+            if (isSurface) {
+                boolean[] areAllPortalRoomCornersValidBiome = {true}; // Use an array so we can modify it inside the lambda function below
+                final StrongholdPieces.StartPiece finalStartPiece = startPiece;
+                final BoundingBox portalRoomBoundingBox = startPiece.portalRoomPiece.getBoundingBox();
+                portalRoomBoundingBox.forAllCorners(cornerPos -> {
+                    if (!areAllPortalRoomCornersValidBiome[0]) { // Skip the other corners if we already know another corner is in an invalid biome
+                        return;
+                    }
+                    @Nullable Holder<Biome> biome = getBiomeDuringGeneration(context, cornerPos);
+                    if (biome == null) {
+                        return; // We don't know, and we probably won't ever find out, so we just have to assume it will be fine
+                    }
+                    if (!biome.is(SuCraftBiomeTags.HAS_STRONGHOLD_SURFACE)) {
+                        areAllPortalRoomCornersValidBiome[0] = false;
+                    }
+                });
+                isPortalRoomValidBiome = areAllPortalRoomCornersValidBiome[0];
+//                if (isPortalRoomValidBiome) {
+//                    if (context.heightAccessor() instanceof ChunkAccess chunkAccess) {
+//                        int waterAmount = 0;
+//                        for (int x = portalRoomBoundingBox.minX(); x <= portalRoomBoundingBox.maxX(); x++) {
+//                            for (int z = portalRoomBoundingBox.minZ(); z <= portalRoomBoundingBox.maxZ(); z++) {
+//                                chunkAccess.getBlockState(x, 61, z)
+//                            }
+//                        }
+//                    }
+//                }
+            } else {
+                isPortalRoomValidBiome = true;
+            }
+            if (!isPortalRoomValidBiome) {
+                if (cycle < maxCyclesBeforeAllowEndPortalInWrongBiome) {
+                    Bukkit.getLogger().info("Failed a stronghold generation (isSurface = " + isSurface + "): end portal not in right biome");
+                    continue;
+                }
+                potentialExtraIncreasedY = null; // Move the stronghold down after all
+            }
+            break;
+        }
+        // Suki end - custom strongholds - bigger strongholds
+
+        // Suki start - custom strongholds - surface strongholds
+
+        if (sukiConfig != null && isSurface && potentialExtraIncreasedY != null) {
+            int standardDecreasedY = sukiConfig.decreasedY.always;
+            int potentialExtraDecreasedY = sukiConfig.decreasedY.potentialExtra;
+            int extraIncreasedY = surfaceStrongholdRandom.nextInt(potentialExtraIncreasedY + 1) - standardDecreasedY - surfaceStrongholdRandom.nextInt(potentialExtraDecreasedY + 1);
+            Bukkit.getLogger().info("To create more surface strongholds, vertically offsetting stronghold at block " + context.chunkPos().getBlockX(2) + " , " + context.chunkPos().getBlockZ(2) + " by " + extraIncreasedY + " and not moving it downwards on purpose");
+            collector.offsetPiecesVertically(extraIncreasedY);
+        } else {
             collector.moveBelowSeaLevel(context.chunkGenerator().getSeaLevel(), context.chunkGenerator().getMinY(), context.random(), 10);
-        } while(collector.isEmpty() || startPiece.portalRoomPiece == null);
+        }
+
+        // Suki end - custom strongholds - surface strongholds
 
     }
 
+    // Suki start - custom strongholds - surface strongholds
+
     @Override
     public StructureType<?> type() {
         return StructureType.STRONGHOLD;
     }
+
+    public static enum Type implements StringRepresentable {
+        WARM("is_surface"),
+        COLD("cold");
+
+        public static final Codec<OceanRuinStructure.Type> CODEC = StringRepresentable.fromEnum(OceanRuinStructure.Type::values);
+        private final String name;
+
+        private Type(String name) {
+            this.name = name;
+        }
+
+        public String getName() {
+            return this.name;
+        }
+
+        @Override
+        public String getSerializedName() {
+            return this.name;
+        }
+    }
+
+    // Suki end - custom strongholds - surface strongholds
+
+    // Suki start - custom strongholds - strongholds in water
+
+    @Override
+    public void afterPlace(WorldGenLevel world, StructureManager structureAccessor, ChunkGenerator chunkGenerator, RandomSource random, BoundingBox box, ChunkPos chunkPos, PiecesContainer pieces) {
+        super.afterPlace(world, structureAccessor, chunkGenerator, random, box, chunkPos, pieces);
+        pieces.pieces().forEach(piece -> {
+            if (piece instanceof StrongholdPieces.StrongholdPiece strongholdPiece) {
+                if (piece.getBoundingBox().intersects(box)) {
+                    strongholdPiece.spreadWater(world);
+                }
+            }
+        });
+    }
+
+    // Suki end - custom strongholds - strongholds in water
+
 }
diff --git a/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTags.java b/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTags.java
index ab02c2e31c42add6360e88bd5ed7e3aafabb8671..0bbcd5eef9ffa27547ce8e7adee430288fd27e73 100644
--- a/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTags.java
+++ b/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTags.java
@@ -12,6 +12,8 @@ import net.minecraft.world.level.biome.Biome;
  */
 public class SuCraftBiomeTags {
 
+    public static final TagKey<Biome> HAS_STRONGHOLD_SURFACE = create("has_structure/stronghold_surface"); // Suki - custom strongholds - surface strongholds
+
     private static TagKey<Biome> create(String id) {
         return TagKey.create(Registry.BIOME_REGISTRY, ResourceLocation.sucraft(id));
     }
diff --git a/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTagsProvider.java b/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTagsProvider.java
index 186e426e5d41e38b3f40ba6e160f13655b99e7db..df2bccc465bdc0fd16ca7c8a5353891a576633ae 100644
--- a/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTagsProvider.java
+++ b/src/main/java/org/sucraft/suki/biome/SuCraftBiomeTagsProvider.java
@@ -3,8 +3,10 @@
 package org.sucraft.suki.biome;
 
 import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.world.level.biome.Biome;
 import org.sucraft.suki.data.SuCraftTagsProvider;
+import net.minecraft.world.level.biome.Biomes;
 
 /**
  * Based on {@link net.minecraft.data.tags.BiomeTagsProvider}
@@ -16,6 +18,9 @@ public class SuCraftBiomeTagsProvider extends SuCraftTagsProvider<Biome> {
     }
 
     @Override
-    protected void addTags() {}
+    protected void addTags() {
+        MinecraftServer.LOGGER.info("Adding custom biome tags...");
+        this.tag(SuCraftBiomeTags.HAS_STRONGHOLD_SURFACE).add(Biomes.PLAINS).add(Biomes.SUNFLOWER_PLAINS).add(Biomes.SNOWY_PLAINS).add(Biomes.ICE_SPIKES).add(Biomes.DESERT).add(Biomes.FOREST).add(Biomes.FLOWER_FOREST).add(Biomes.BIRCH_FOREST).add(Biomes.DARK_FOREST).add(Biomes.OLD_GROWTH_BIRCH_FOREST).add(Biomes.OLD_GROWTH_PINE_TAIGA).add(Biomes.OLD_GROWTH_SPRUCE_TAIGA).add(Biomes.TAIGA).add(Biomes.SNOWY_TAIGA).add(Biomes.SAVANNA).add(Biomes.SAVANNA_PLATEAU).add(Biomes.WINDSWEPT_HILLS).add(Biomes.WINDSWEPT_GRAVELLY_HILLS).add(Biomes.WINDSWEPT_FOREST).add(Biomes.WINDSWEPT_SAVANNA).add(Biomes.JUNGLE).add(Biomes.SPARSE_JUNGLE).add(Biomes.BAMBOO_JUNGLE).add(Biomes.BADLANDS).add(Biomes.ERODED_BADLANDS).add(Biomes.WOODED_BADLANDS).add(Biomes.MEADOW).add(Biomes.GROVE).add(Biomes.SNOWY_SLOPES).add(Biomes.FROZEN_PEAKS).add(Biomes.JAGGED_PEAKS).add(Biomes.STONY_PEAKS).add(Biomes.MUSHROOM_FIELDS); // Suki - custom strongholds - surface strongholds
+    }
 
 }
diff --git a/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java b/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
index 982e2936376ed973b2bfd601cc3348cbe1e8908b..230d899f10503cc521e241728f5c4db8e6352b66 100644
--- a/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
+++ b/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
@@ -602,4 +602,139 @@ public class SukiWorldConfiguration extends ConfigurationPart {
 
     // Suki end - limit packets per tick
 
+    // Suki start - custom strongholds
+
+    public CustomStrongholds customStrongholds;
+
+    public class CustomStrongholds extends ConfigurationPart {
+
+        public PotentialExtraIncreasedY potentialExtraIncreasedY;
+
+        public class PotentialExtraIncreasedY extends ConfigurationPart {
+
+            public int badlands = 0;
+            public int plateau = 0;
+            public int windswept = 0;
+            public int mountain = 0;
+            public int hill = 0;
+            public int all = 0;
+
+        }
+
+        public DecreasedY decreasedY;
+
+        public class DecreasedY extends ConfigurationPart {
+
+            public int always = 0;
+            public int potentialExtra = 0;
+
+        }
+
+        public MinimumPortalRoomYDifference minimumPortalRoomYDifference;
+
+        public class MinimumPortalRoomYDifference extends ConfigurationPart {
+
+            public int min = 0;
+            public int max = 0;
+
+        }
+
+        public double ceilingBlockHoleChance = 0;
+
+        public SlabOrStairsSurfaces slabOrStairsSurfaces;
+
+        public class SlabOrStairsSurfaces extends ConfigurationPart {
+
+            public Floor floor;
+            public Ceiling ceiling;
+
+            public class Floor extends FloorOrCeiling {}
+
+            public class Ceiling extends FloorOrCeiling {}
+
+            public abstract class FloorOrCeiling extends ConfigurationPart {
+
+                public double chance = 0;
+                public double slabRatio = 0.5;
+
+            }
+
+        }
+
+        public WaterAndLavaInCrossings waterAndLavaInCrossings;
+
+        public class WaterAndLavaInCrossings extends ConfigurationPart {
+
+            public double chance = 0;
+            public double waterRatio = 0.5;
+
+            public BlockChances blockChances;
+
+            public class BlockChances extends ConfigurationPart {
+
+                public double water = 0;
+                public double lava = 0;
+
+            }
+
+        }
+
+        public MoreCobwebs moreCobwebs;
+
+        public class MoreCobwebs extends ConfigurationPart {
+
+            public FirstOpportunity firstOpportunity;
+            public SecondOpportunity secondOpportunity;
+            public ThirdOpportunity thirdOpportunity;
+
+            public class FirstOpportunity extends Opportunity {}
+
+            public class SecondOpportunity extends Opportunity {}
+
+            public class ThirdOpportunity extends Opportunity {}
+
+            public abstract class Opportunity extends ConfigurationPart {
+
+                public double chance = 0;
+                public double ratio = 0;
+
+            }
+
+            public Opportunity[] getOpportunities() {
+                return new Opportunity[] { firstOpportunity, secondOpportunity, thirdOpportunity };
+            }
+
+        }
+
+        public AddCandles addCandles;
+
+        public class AddCandles extends ConfigurationPart {
+
+            public FirstOpportunity firstOpportunity;
+            public SecondOpportunity secondOpportunity;
+            public ThirdOpportunity thirdOpportunity;
+
+            public class FirstOpportunity extends Opportunity {}
+
+            public class SecondOpportunity extends Opportunity {}
+
+            public class ThirdOpportunity extends Opportunity {}
+
+            public abstract class Opportunity extends ConfigurationPart {
+
+                public double chance = 0;
+                public double ratio = 0;
+
+            }
+
+            public Opportunity[] getOpportunities() {
+                return new Opportunity[] { firstOpportunity, secondOpportunity, thirdOpportunity };
+            }
+
+        }
+
+    }
+
+    // Suki end - custom strongholds
+
 }
diff --git a/src/main/java/org/sucraft/suki/structure/SuCraftBuiltinStructures.java b/src/main/java/org/sucraft/suki/structure/SuCraftBuiltinStructures.java
index c3652f47082b5b26c828d79acddfe4f4ea325664..80e18b24bd3062065866a4af9451e041a81ea5a3 100644
--- a/src/main/java/org/sucraft/suki/structure/SuCraftBuiltinStructures.java
+++ b/src/main/java/org/sucraft/suki/structure/SuCraftBuiltinStructures.java
@@ -12,6 +12,8 @@ import net.minecraft.world.level.levelgen.structure.Structure;
  */
 public interface SuCraftBuiltinStructures {
 
+    ResourceKey<Structure> STRONGHOLD_SURFACE = createKey("stronghold_surface"); // Suki - custom strongholds - surface strongholds
+
     private static ResourceKey<Structure> createKey(String id) {
         return ResourceKey.create(Registry.STRUCTURE_REGISTRY, ResourceLocation.sucraft(id));
     }
diff --git a/src/main/java/org/sucraft/suki/structure/SuCraftStructureTagsProvider.java b/src/main/java/org/sucraft/suki/structure/SuCraftStructureTagsProvider.java
index 2a7b0db070bd61a43340d100d123c7b4ccd1ad25..fdd3867cf4f8c7d14030a5410f82989040fadf22 100644
--- a/src/main/java/org/sucraft/suki/structure/SuCraftStructureTagsProvider.java
+++ b/src/main/java/org/sucraft/suki/structure/SuCraftStructureTagsProvider.java
@@ -3,6 +3,8 @@
 package org.sucraft.suki.structure;
 
 import net.minecraft.core.Registry;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.tags.StructureTags;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import org.sucraft.suki.data.SuCraftTagsProvider;
 
@@ -16,6 +18,9 @@ public class SuCraftStructureTagsProvider extends SuCraftTagsProvider<Structure>
     }
 
     @Override
-    protected void addTags() {}
+    protected void addTags() {
+        MinecraftServer.LOGGER.info("Adding onto existing structure tags...");
+        this.tag(StructureTags.EYE_OF_ENDER_LOCATED).add(SuCraftBuiltinStructures.STRONGHOLD_SURFACE);
+    }
 
 }
diff --git a/src/main/java/org/sucraft/suki/structure/SuCraftStructures.java b/src/main/java/org/sucraft/suki/structure/SuCraftStructures.java
index 1a7997c5ff8716956477d3bc9728958da245d213..cd3f575120d4523a216ef73a0fadfbee3172b203 100644
--- a/src/main/java/org/sucraft/suki/structure/SuCraftStructures.java
+++ b/src/main/java/org/sucraft/suki/structure/SuCraftStructures.java
@@ -14,6 +14,8 @@ import net.minecraft.world.level.levelgen.GenerationStep;
 import net.minecraft.world.level.levelgen.structure.Structure;
 import net.minecraft.world.level.levelgen.structure.StructureSpawnOverride;
 import net.minecraft.world.level.levelgen.structure.TerrainAdjustment;
+import net.minecraft.world.level.levelgen.structure.structures.StrongholdStructure;
+import org.sucraft.suki.biome.SuCraftBiomeTags;
 
 import java.util.Map;
 
@@ -22,8 +24,10 @@ import java.util.Map;
  */
 public class SuCraftStructures {
 
+    public static final Holder<Structure> STRONGHOLD_SURFACE = register(SuCraftBuiltinStructures.STRONGHOLD_SURFACE, new StrongholdStructure(structure(SuCraftBiomeTags.HAS_STRONGHOLD_SURFACE, TerrainAdjustment.NONE), true));
+
     public static Holder<? extends Structure> bootstrap(Registry<Structure> registry) {
-       return null; // TODO fil with first structure added
+       return STRONGHOLD_SURFACE;
     }
 
     public static Structure.StructureSettings structure(TagKey<Biome> biomeTag, Map<MobCategory, StructureSpawnOverride> spawns, GenerationStep.Decoration featureStep, TerrainAdjustment terrainAdaptation) {
